1
00:00:00,000 --> 00:00:02,520
All right, should we do this?

2
00:00:02,520 --> 00:00:03,880
Good morning.

3
00:00:03,880 --> 00:00:06,520
How's everybody doing?

4
00:00:06,520 --> 00:00:07,680
Awesome.

5
00:00:07,680 --> 00:00:09,520
A few quick housekeeping tasks.

6
00:00:09,520 --> 00:00:11,360
If you have a device that makes noise,

7
00:00:11,360 --> 00:00:14,840
please make it so it doesn't make noise.

8
00:00:14,840 --> 00:00:16,920
Please hold your questions till the end of the talk.

9
00:00:16,920 --> 00:00:19,760
If there's time, we will take questions then.

10
00:00:19,760 --> 00:00:23,760
And if not, catch these guys afterwards.

11
00:00:23,760 --> 00:00:26,560
So please welcome Moses Schwartz and Andy Cullen.

12
00:00:26,560 --> 00:00:29,560
They'll be giving the talk, A Snake in the Bits,

13
00:00:29,560 --> 00:00:32,560
Security Automation with Python.

14
00:00:32,560 --> 00:00:41,360
Thanks, everyone.

15
00:00:41,360 --> 00:00:42,480
Thank you for being here.

16
00:00:42,480 --> 00:00:45,720
Thanks to all the volunteers and organizers.

17
00:00:45,720 --> 00:00:47,160
Super excited to be here.

18
00:00:47,160 --> 00:00:47,960
So I'm Moses.

19
00:00:47,960 --> 00:00:49,840
This is my coworker, Andy.

20
00:00:49,840 --> 00:00:53,520
We've also got Jonathan from our team watching us here.

21
00:00:53,520 --> 00:00:57,760
We work at Box on the security automation team,

22
00:00:57,760 --> 00:01:02,880
which means we basically write software and manage

23
00:01:02,880 --> 00:01:05,760
infrastructure that supports our incident response team,

24
00:01:05,760 --> 00:01:09,600
our application security team, and even going and building

25
00:01:09,600 --> 00:01:12,240
stuff for compliance and other groups that are all

26
00:01:12,240 --> 00:01:14,240
under that security umbrella.

27
00:01:14,240 --> 00:01:16,240
So we're going to talk about kind of a DIY approach

28
00:01:16,240 --> 00:01:20,480
to building automations to support these teams in Python.

29
00:01:20,480 --> 00:01:23,320
This isn't a talk about what Box does,

30
00:01:23,320 --> 00:01:24,920
rather it's a general introduction.

31
00:01:24,920 --> 00:01:27,280
But there are a lot of parallels with how we've actually built

32
00:01:27,280 --> 00:01:30,360
out our infrastructure.

33
00:01:30,360 --> 00:01:32,880
So one of the first things that's really important

34
00:01:32,880 --> 00:01:36,400
to understand is sort of what the infrastructure looks

35
00:01:36,400 --> 00:01:39,480
like for an incident response or like a security monitoring

36
00:01:39,480 --> 00:01:41,760
team like your SOC.

37
00:01:41,760 --> 00:01:44,960
So essentially, you've got all of these things

38
00:01:44,960 --> 00:01:47,840
that are creating logs, whether they're individuals' laptops

39
00:01:47,840 --> 00:01:51,720
or your servers or network hardware, things like that.

40
00:01:51,720 --> 00:01:53,920
And so you need to feed all of those logs into some sort

41
00:01:53,960 --> 00:01:57,680
of centralized aggregation system.

42
00:01:57,680 --> 00:01:59,920
From there, most of those systems

43
00:01:59,920 --> 00:02:02,080
will allow you to build some kind of alert.

44
00:02:02,080 --> 00:02:04,600
When an alert triggers, you'll create a ticket.

45
00:02:04,600 --> 00:02:06,400
And then you've got some analysts

46
00:02:06,400 --> 00:02:08,800
that has to take a look at that ticket.

47
00:02:08,800 --> 00:02:11,400
And so a big part of an analyst's job

48
00:02:11,400 --> 00:02:14,960
before you automate things is opening up browser tabs,

49
00:02:14,960 --> 00:02:17,280
copying data from the ticket, pasting it

50
00:02:17,280 --> 00:02:20,240
into these web-based tools, getting information back,

51
00:02:20,240 --> 00:02:21,680
putting in the ticket.

52
00:02:21,680 --> 00:02:23,800
Lots of just kind of repetitive back and forth there.

53
00:02:24,760 --> 00:02:26,480
As engineers, we see this and we're like, oh, we

54
00:02:26,480 --> 00:02:29,120
can do something about that.

55
00:02:29,120 --> 00:02:31,280
However, we have to start at the beginning.

56
00:02:31,280 --> 00:02:33,280
Splunk is a really popular example

57
00:02:33,280 --> 00:02:37,320
of a log aggregation system that'll let you create alerts.

58
00:02:37,320 --> 00:02:42,840
So just super briefly, you start out with a search.

59
00:02:42,840 --> 00:02:46,240
And the search criteria will then go through the logs

60
00:02:46,240 --> 00:02:49,720
and return you any relevant log information.

61
00:02:49,720 --> 00:02:52,080
And from there, we can develop an alert.

62
00:02:52,080 --> 00:02:57,680
So Splunk lets you take your search, put it into an alert.

63
00:02:57,680 --> 00:03:01,920
You set up a timing.

64
00:03:01,920 --> 00:03:05,120
In this case, it's a cron-style time.

65
00:03:05,120 --> 00:03:07,120
It's going to run every 15 minutes.

66
00:03:07,120 --> 00:03:08,920
And then we set a 15-minute look back.

67
00:03:08,920 --> 00:03:11,880
So it only looks at the last 15 minutes of logs

68
00:03:11,880 --> 00:03:14,880
to determine if it should trigger an alert.

69
00:03:14,880 --> 00:03:16,920
And that's really important, because otherwise, you're

70
00:03:16,920 --> 00:03:18,080
going to get duplicate alerts.

71
00:03:18,920 --> 00:03:20,400
So then after you have the alert,

72
00:03:20,400 --> 00:03:22,400
you need to actually do something with the data

73
00:03:22,400 --> 00:03:23,960
that it surfaces, right?

74
00:03:23,960 --> 00:03:28,360
So a really popular way to handle the next step

75
00:03:28,360 --> 00:03:32,600
is to send a post request out to some API that then does

76
00:03:32,600 --> 00:03:35,160
ticketing or enrichment or whatever you need it to do.

77
00:03:35,160 --> 00:03:38,480
So in this case, it's going to this sketchy Digital Ocean IP

78
00:03:38,480 --> 00:03:44,040
address that we use for our demo purposes.

79
00:03:44,040 --> 00:03:47,640
And so it just sends a webhook to the post request.

80
00:03:47,800 --> 00:03:52,840
It sends a webhook to this API that we've set up.

81
00:03:52,840 --> 00:03:56,280
So we're going to jump right into writing the code

82
00:03:56,280 --> 00:03:59,040
to actually receive that webhook.

83
00:03:59,040 --> 00:04:01,160
So we're going to start just by writing a bit of code.

84
00:04:01,160 --> 00:04:04,720
We're going to use Flask, super popular micro framework

85
00:04:04,720 --> 00:04:08,240
for building web apps, super commonly used for APIs

86
00:04:08,240 --> 00:04:10,280
and similar use cases.

87
00:04:10,280 --> 00:04:12,760
We're going to import Flask, instantiate it.

88
00:04:12,760 --> 00:04:14,260
And the first thing we're going to do

89
00:04:14,300 --> 00:04:18,060
is set up a status or health check endpoint.

90
00:04:18,060 --> 00:04:20,860
That's super useful, because first off,

91
00:04:20,860 --> 00:04:22,400
we can stop right there, run that,

92
00:04:22,400 --> 00:04:24,220
and that's like our hello world to make sure we actually

93
00:04:24,220 --> 00:04:25,540
did this thing right.

94
00:04:25,540 --> 00:04:27,340
Later on, that's going to be super helpful

95
00:04:27,340 --> 00:04:29,980
because we can check that endpoint after we say,

96
00:04:29,980 --> 00:04:32,860
push an update to make sure things are back up and running.

97
00:04:32,860 --> 00:04:35,420
And that makes it super easy to integrate into status

98
00:04:35,420 --> 00:04:37,980
monitoring systems where they'll basically

99
00:04:37,980 --> 00:04:41,060
do a heartbeat kind of thing, send a request to this endpoint

100
00:04:41,060 --> 00:04:44,700
periodically, and let you know if your service goes down.

101
00:04:44,700 --> 00:04:47,700
Then we're going to jump into the code to write this Splunk

102
00:04:47,700 --> 00:04:49,300
webhook receiver.

103
00:04:49,300 --> 00:04:52,100
So in there, we're going to just go into the Flask request

104
00:04:52,100 --> 00:04:55,140
object and grab the JSON payload.

105
00:04:55,140 --> 00:04:58,420
And right now, we're just going to write that out

106
00:04:58,420 --> 00:04:59,720
into a JSON file.

107
00:04:59,720 --> 00:05:01,420
That bit of code is not going to persist

108
00:05:01,420 --> 00:05:03,380
to the end of the example.

109
00:05:03,380 --> 00:05:04,900
But I want to kind of give insight

110
00:05:04,900 --> 00:05:07,980
into how we go about developing these things.

111
00:05:07,980 --> 00:05:10,540
So I'm going to jump right up onto that server.

112
00:05:10,540 --> 00:05:14,340
It is sshn run python automation server.py.

113
00:05:14,340 --> 00:05:17,740
This is going to spin it up in Flask's development server.

114
00:05:17,740 --> 00:05:20,060
And it's just going to sit there listening,

115
00:05:20,060 --> 00:05:24,220
waiting until we receive that Splunk webhook.

116
00:05:24,220 --> 00:05:26,440
Now, if you're doing this in practice,

117
00:05:26,440 --> 00:05:28,540
you're probably going to want to make Splunk fire

118
00:05:28,540 --> 00:05:29,820
that alert every minute or so.

119
00:05:29,820 --> 00:05:33,980
You really don't want to wait 15 minutes to test your code.

120
00:05:33,980 --> 00:05:35,740
But when we finally do get it, it's

121
00:05:35,740 --> 00:05:38,820
going to print out basically a log entry to the screen.

122
00:05:38,820 --> 00:05:41,740
We will have received this webhook.

123
00:05:41,740 --> 00:05:44,460
And then I'm just going to Control-C out and print

124
00:05:44,460 --> 00:05:46,420
the first few lines from that JSON file

125
00:05:46,420 --> 00:05:48,700
so we can see what Splunk is sending us.

126
00:05:48,700 --> 00:05:52,860
And in there, we've got a search name, some metadata, the owner.

127
00:05:52,860 --> 00:05:56,060
And then we've got the raw results.

128
00:05:56,060 --> 00:05:59,020
So I'm going to take a brief detour.

129
00:05:59,020 --> 00:06:01,420
Before we go back to automation server.py

130
00:06:01,420 --> 00:06:03,060
and add more functionality, we're

131
00:06:03,060 --> 00:06:06,940
going to start needing to use usernames and passwords

132
00:06:06,940 --> 00:06:08,780
and other configuration things.

133
00:06:08,820 --> 00:06:11,700
So a quick and dirty way to keep that stuff out of our code base

134
00:06:11,700 --> 00:06:13,580
without going all into secrets management

135
00:06:13,580 --> 00:06:16,420
is just to have something like a settings.py file

136
00:06:16,420 --> 00:06:19,500
that you don't check in with your repo.

137
00:06:19,500 --> 00:06:20,900
So in the next few slides, you'll

138
00:06:20,900 --> 00:06:22,900
see settings.username and things like that.

139
00:06:22,900 --> 00:06:26,300
That's what it's referring to.

140
00:06:26,300 --> 00:06:29,900
So back to that automation server code.

141
00:06:29,900 --> 00:06:32,420
Here, we are going to go write a new function

142
00:06:32,420 --> 00:06:35,820
to create a JIRA issue.

143
00:06:35,820 --> 00:06:37,540
That's going to be our ticketing system.

144
00:06:37,540 --> 00:06:41,900
We're just going to use Atlassian's SDK.

145
00:06:41,900 --> 00:06:42,980
Connect to JIRA.

146
00:06:42,980 --> 00:06:45,260
You just need a URL, username, password.

147
00:06:45,260 --> 00:06:47,540
And then it's literally one line,

148
00:06:47,540 --> 00:06:50,420
although broken up to be readable, to create an issue.

149
00:06:50,420 --> 00:06:52,580
Just specify project.

150
00:06:52,580 --> 00:06:56,420
Name what we want the summary or ticket name to be.

151
00:06:56,420 --> 00:07:00,380
And then we're going to dump the entire JSON result

152
00:07:00,380 --> 00:07:03,100
into the description field.

153
00:07:03,100 --> 00:07:08,860
So we can now go back into our Digital Ocean Droplet,

154
00:07:08,860 --> 00:07:10,860
start up this new code, and just let

155
00:07:10,860 --> 00:07:13,780
it sit until we get the next Splunk webhook.

156
00:07:13,780 --> 00:07:16,460
When that fires, we're right away going

157
00:07:16,460 --> 00:07:19,700
to go reach out to JIRA and create a ticket.

158
00:07:19,700 --> 00:07:21,700
This almost starts to be kind of cool.

159
00:07:21,700 --> 00:07:22,780
We at least have a ticket.

160
00:07:22,780 --> 00:07:24,380
We've got some information there.

161
00:07:24,380 --> 00:07:27,500
But it's an ugly raw JSON blob.

162
00:07:27,500 --> 00:07:29,700
This is actually kind of the default state

163
00:07:29,700 --> 00:07:33,180
for a lot of SOCs and incident response teams

164
00:07:33,180 --> 00:07:35,260
before they start doing automation.

165
00:07:35,260 --> 00:07:37,740
They create a ticket based on an email or a webhook

166
00:07:37,740 --> 00:07:38,300
or something.

167
00:07:38,300 --> 00:07:41,580
And it really just has that raw information.

168
00:07:41,580 --> 00:07:45,660
But we can do something to make that a little bit more useful.

169
00:07:45,660 --> 00:07:48,940
So I'm actually going to go into the JIRA configuration

170
00:07:48,940 --> 00:07:50,700
and set up a webhook that's going to fire

171
00:07:50,700 --> 00:07:52,820
when those tickets are created.

172
00:07:52,820 --> 00:07:54,420
So we're going to come up with a name.

173
00:07:54,420 --> 00:07:56,020
We're going to call this a mock scan alert,

174
00:07:56,020 --> 00:07:59,740
because the faked up beta we're using was called mock scan.

175
00:07:59,740 --> 00:08:01,620
And we're going to give it a URL.

176
00:08:01,620 --> 00:08:05,180
Again, we've got our IP address and super verbose name,

177
00:08:05,180 --> 00:08:08,020
JIRA mock scan created webhook.

178
00:08:08,020 --> 00:08:09,420
And then down at the bottom, we're

179
00:08:09,420 --> 00:08:13,620
going to specify a JQL or JIRA query language, I think,

180
00:08:13,620 --> 00:08:17,060
query to let it know what kinds of tickets

181
00:08:17,060 --> 00:08:18,660
we want this webhook to fire on.

182
00:08:18,660 --> 00:08:20,500
So you can actually filter based on anything

183
00:08:20,500 --> 00:08:22,340
that you can search for in JIRA.

184
00:08:22,340 --> 00:08:24,100
If you scroll down further on the page,

185
00:08:24,100 --> 00:08:28,020
you can also choose to fire webhooks on ticket creation

186
00:08:28,020 --> 00:08:30,420
or closing or other cases.

187
00:08:30,420 --> 00:08:34,020
But right now, we're going to focus on just creation.

188
00:08:34,020 --> 00:08:37,420
So once that's set up, the next time Spunk fires a webhook

189
00:08:37,420 --> 00:08:39,540
and we create a ticket, JIRA is going

190
00:08:39,540 --> 00:08:43,620
to reach back out to our automation server

191
00:08:43,620 --> 00:08:47,660
and try to call that endpoint.

192
00:08:47,660 --> 00:08:50,060
So we've got to write code for that now.

193
00:08:50,060 --> 00:08:53,220
Going to add a, first off, a new function,

194
00:08:53,220 --> 00:08:54,820
this JIRA comment function.

195
00:08:54,820 --> 00:08:56,900
It's really similar to the ticket creation one.

196
00:08:56,900 --> 00:08:58,540
I'm just going to connect to JIRA,

197
00:08:58,540 --> 00:09:01,260
grab the issue based on the key, and then we're

198
00:09:01,260 --> 00:09:02,340
going to add a comment.

199
00:09:02,340 --> 00:09:04,880
And that's basically just to take string and post it

200
00:09:04,880 --> 00:09:06,020
in there.

201
00:09:06,020 --> 00:09:09,060
Then we're going to write the endpoint to actually handle

202
00:09:09,060 --> 00:09:12,580
that webhook, calling this mock scan created.

203
00:09:12,580 --> 00:09:14,620
We specify the route up above.

204
00:09:14,620 --> 00:09:17,260
Say we're expecting a post call.

205
00:09:17,260 --> 00:09:19,620
And then again, we're going to pull the JSON out

206
00:09:19,620 --> 00:09:25,700
of that request object and then do a bit of ugly JSON parsing.

207
00:09:25,700 --> 00:09:27,860
We could have simplified this maybe,

208
00:09:27,860 --> 00:09:30,780
but ended up deciding not to because dealing

209
00:09:30,780 --> 00:09:34,260
with ugly JSON blobs is like half of the job

210
00:09:34,260 --> 00:09:36,060
that we do day to day.

211
00:09:36,060 --> 00:09:39,700
So we're going to pull out the results that

212
00:09:39,700 --> 00:09:41,180
was in that description field.

213
00:09:41,180 --> 00:09:43,340
And that was actually JSON that we wrote in there.

214
00:09:43,340 --> 00:09:44,780
So it's double encoded.

215
00:09:44,780 --> 00:09:46,940
We've got to load that JSON again.

216
00:09:46,940 --> 00:09:49,180
But finally, we can pull out a few fields.

217
00:09:49,180 --> 00:09:51,940
We're just going to grab a user, an MD5.

218
00:09:51,940 --> 00:09:54,420
And then we can go call our JIRA comment function

219
00:09:54,420 --> 00:09:57,460
and comment on that ticket with that information extracted

220
00:09:57,460 --> 00:09:59,380
from the JSON.

221
00:09:59,380 --> 00:10:01,540
That's not a whole lot more useful

222
00:10:01,540 --> 00:10:04,460
than just having it in that JSON.

223
00:10:04,460 --> 00:10:07,740
But if we were to go and do a lookup,

224
00:10:07,740 --> 00:10:11,100
say take that username and look them up in Active Directory,

225
00:10:11,100 --> 00:10:13,100
then that starts to be useful.

226
00:10:13,100 --> 00:10:16,580
So to do that, we're going to write another script.

227
00:10:16,580 --> 00:10:20,540
And this is not tied to Flask or the rest of the application

228
00:10:20,540 --> 00:10:21,040
at all.

229
00:10:21,040 --> 00:10:25,300
This is just plain Python using the LDAP3 module.

230
00:10:25,300 --> 00:10:27,500
We're going to write a little function to search Active

231
00:10:27,500 --> 00:10:30,940
Directory, given a username, and just return a dictionary that

232
00:10:30,940 --> 00:10:33,460
has the results.

233
00:10:33,460 --> 00:10:37,260
So this is what this looks like when you look at my username.

234
00:10:37,260 --> 00:10:40,780
And then we can go back to our automation server

235
00:10:40,780 --> 00:10:44,820
and set up a new function that's going

236
00:10:44,820 --> 00:10:48,300
to go call our new script, that function in it,

237
00:10:48,300 --> 00:10:52,060
do a bit of string formatting, pull out the fields

238
00:10:52,060 --> 00:10:54,700
that we think are most interesting,

239
00:10:54,700 --> 00:10:56,300
format a comment string.

240
00:10:56,300 --> 00:10:59,020
And then we're just going to call that JIRA comment function

241
00:10:59,020 --> 00:11:00,060
again.

242
00:11:00,060 --> 00:11:02,180
And that'll post that information.

243
00:11:02,180 --> 00:11:05,580
Then in our mock scan created endpoint,

244
00:11:05,580 --> 00:11:08,060
we just have to add a call to that function.

245
00:11:08,060 --> 00:11:12,540
Now when the webhook from JIRA fires,

246
00:11:12,540 --> 00:11:13,660
it'll be handled in here.

247
00:11:13,660 --> 00:11:16,660
We'll do that lookup, and we'll post the user's information

248
00:11:16,660 --> 00:11:17,740
straight to the ticket.

249
00:11:20,620 --> 00:11:24,860
We can do the exact same thing with the MD5 hash that we had.

250
00:11:24,860 --> 00:11:27,380
We can go look it up in VirusTotal.

251
00:11:27,380 --> 00:11:32,260
It's a really popular service that basically runs

252
00:11:32,260 --> 00:11:34,740
a whole bunch of virus scanners against files

253
00:11:34,740 --> 00:11:36,240
and puts everything into a database.

254
00:11:36,240 --> 00:11:39,340
And you can query it and say, given either this file

255
00:11:39,340 --> 00:11:42,740
that you uploaded or this hash, what do the virus scanners say?

256
00:11:42,780 --> 00:11:45,140
This is the hash for an empty file.

257
00:11:45,140 --> 00:11:49,740
So it's actually got zero positives out of 60 scanners.

258
00:11:49,740 --> 00:11:52,740
And we've also got a permalink to take you to their web page

259
00:11:52,740 --> 00:11:54,420
where you can view more details.

260
00:11:54,420 --> 00:11:56,700
Those are the most useful fields.

261
00:11:56,700 --> 00:11:59,820
So the code to actually call VirusTotal here

262
00:11:59,820 --> 00:12:01,340
was pretty much copied and pasted

263
00:12:01,340 --> 00:12:03,300
out of their public documentation.

264
00:12:03,300 --> 00:12:07,500
It's really quick, just a little get request,

265
00:12:07,500 --> 00:12:11,540
and then we're going to return that JSON.

266
00:12:11,540 --> 00:12:14,220
Now, to integrate this into our automation server code,

267
00:12:14,220 --> 00:12:15,860
we're just going to go back in there,

268
00:12:15,860 --> 00:12:18,580
do the exact same thing we just did for Active Directory.

269
00:12:18,580 --> 00:12:22,180
We'll write a new function to do the comment formatting.

270
00:12:22,180 --> 00:12:27,380
We'll call VirusTotal, pull out the useful fields

271
00:12:27,380 --> 00:12:30,940
and put them into a string, and call that gira-comment function

272
00:12:30,940 --> 00:12:31,780
again.

273
00:12:31,780 --> 00:12:34,900
Then we'll put that VirusTotal fileskin enrichment function

274
00:12:34,900 --> 00:12:37,100
call right after the Active Directory lookup.

275
00:12:37,100 --> 00:12:38,980
And that's pretty much all it takes.

276
00:12:38,980 --> 00:12:42,100
The next time we have a ticket created,

277
00:12:42,100 --> 00:12:43,900
it will get all of that information

278
00:12:43,900 --> 00:12:47,260
extracted and posted.

279
00:12:47,260 --> 00:12:49,300
So if you look again at this graphic

280
00:12:49,300 --> 00:12:53,420
that we showed at the beginning, our SOC analyst,

281
00:12:53,420 --> 00:12:56,740
Freddie Mercury there, looks at a ticket,

282
00:12:56,740 --> 00:13:00,160
copies and pastes usernames and hashes into other systems,

283
00:13:00,160 --> 00:13:03,380
and then makes his decision as to whether this is malicious

284
00:13:03,380 --> 00:13:05,540
or what he has to do.

285
00:13:05,540 --> 00:13:10,580
Now, things are looking up a little bit more for him.

286
00:13:10,580 --> 00:13:13,580
We have all this information automatically

287
00:13:13,580 --> 00:13:14,820
posted to the ticket.

288
00:13:14,820 --> 00:13:16,580
And to recap, the way it works, because it's

289
00:13:16,580 --> 00:13:19,700
kind of a weird cycle of webhooks,

290
00:13:19,700 --> 00:13:21,900
Splunkfire is a webhook to our automation server.

291
00:13:21,900 --> 00:13:23,980
We create a ticket.

292
00:13:23,980 --> 00:13:26,260
When the ticket's created, gira calls a webhook back

293
00:13:26,260 --> 00:13:27,820
to our automation server, and then we

294
00:13:27,820 --> 00:13:31,480
start doing these enrichments and add information right there.

295
00:13:31,480 --> 00:13:35,140
And this is actually a really simple but also really cool

296
00:13:35,140 --> 00:13:39,900
model, because now we can run any arbitrary code we want

297
00:13:39,900 --> 00:13:41,660
when a ticket is created.

298
00:13:41,660 --> 00:13:45,140
So anything that you can write a program to do,

299
00:13:45,140 --> 00:13:48,980
we can kick off automatically when a ticket comes in.

300
00:13:48,980 --> 00:13:52,620
There's some low-hanging fruit that is really easy stuff

301
00:13:52,620 --> 00:13:56,020
to do in an IT or security ops group.

302
00:13:56,020 --> 00:13:57,440
A lot of the time, the first thing

303
00:13:57,440 --> 00:13:59,220
you do when you open or close a ticket

304
00:13:59,220 --> 00:14:02,720
is spend a minute going and setting appropriate fields

305
00:14:02,720 --> 00:14:05,880
for the ticket type so that your metrics look good.

306
00:14:05,880 --> 00:14:08,200
That stuff is super easy to automate.

307
00:14:08,200 --> 00:14:10,240
We could also go a little more in-depth.

308
00:14:10,240 --> 00:14:14,000
We could run another Splunk search and post the results.

309
00:14:14,000 --> 00:14:16,760
You could even do something like kicking off an Ansible playbook

310
00:14:16,760 --> 00:14:18,880
if you wanted to do something a lot more complex

311
00:14:18,880 --> 00:14:22,080
and build up workflows.

312
00:14:22,080 --> 00:14:25,160
And really, anything that has an API

313
00:14:25,160 --> 00:14:28,680
or any kind of programmatic interface we could do.

314
00:14:28,680 --> 00:14:31,280
I've been looking for use cases to actually get

315
00:14:31,280 --> 00:14:35,440
a Roomba to do something when we have a certain ticket type.

316
00:14:35,440 --> 00:14:36,280
That's the dream.

317
00:14:40,800 --> 00:14:43,520
So now that we've started building this automation

318
00:14:43,520 --> 00:14:45,600
server and all of its endpoints, we

319
00:14:45,600 --> 00:14:48,600
need to start thinking about how is it going to scale?

320
00:14:48,600 --> 00:14:51,160
What's the future of it?

321
00:14:51,160 --> 00:14:53,720
When you have two endpoints, fine.

322
00:14:53,720 --> 00:14:58,320
But when you're starting to write 10, 20, 100, 200,

323
00:14:58,320 --> 00:15:00,840
you start to see a lot of the same patterns being repeated

324
00:15:01,080 --> 00:15:04,000
in all of your Flask endpoint code.

325
00:15:04,000 --> 00:15:06,840
So as developers, we want to make our jobs easier, too.

326
00:15:06,840 --> 00:15:08,600
We want some sort of framework or middleware

327
00:15:08,600 --> 00:15:11,000
that does this for us.

328
00:15:11,000 --> 00:15:13,460
We're probably going to want authentication on everything.

329
00:15:13,460 --> 00:15:15,000
We obviously want uniform logging

330
00:15:15,000 --> 00:15:17,040
so that we know if our automations aren't working

331
00:15:17,040 --> 00:15:19,000
properly.

332
00:15:19,000 --> 00:15:21,760
Input validation is like the biggest boilerplate ever

333
00:15:21,760 --> 00:15:24,320
when it comes to building APIs, because you

334
00:15:24,320 --> 00:15:26,760
want to make sure that if somebody gives you bad data,

335
00:15:26,760 --> 00:15:30,040
you tell them about it instead of just breaking.

336
00:15:30,040 --> 00:15:31,500
In terms of breaking, you also don't

337
00:15:31,500 --> 00:15:35,320
want to send a stack trace back to your API client.

338
00:15:35,320 --> 00:15:37,640
You might expose sensitive information.

339
00:15:37,640 --> 00:15:40,600
It's just generally not very useful to the average API user.

340
00:15:43,340 --> 00:15:44,080
Things like that.

341
00:15:44,080 --> 00:15:47,200
So how can we improve this?

342
00:15:47,200 --> 00:15:49,320
Well, probably the easiest way is just

343
00:15:49,320 --> 00:15:53,520
go get an open source plugin for Flask.

344
00:15:53,520 --> 00:15:56,120
In this instance, we used Flask REST+,

345
00:15:56,120 --> 00:16:00,080
which is pretty well known.

346
00:16:00,080 --> 00:16:05,600
And it's also built to function very similarly to Flask.

347
00:16:05,600 --> 00:16:08,760
So as you can see, we're still building a Flask app.

348
00:16:08,760 --> 00:16:12,720
Then we just pass that into the REST+, API objects.

349
00:16:12,720 --> 00:16:17,000
And you still set up your routes just like you did with Flask,

350
00:16:17,000 --> 00:16:18,960
except now you're operating on classes.

351
00:16:18,960 --> 00:16:20,620
And those classes define functions

352
00:16:20,620 --> 00:16:23,860
that directly correlate to the HTTP method

353
00:16:23,860 --> 00:16:28,340
that you're making available, so a get or a post.

354
00:16:28,340 --> 00:16:30,580
But as you can see, we still have essentially

355
00:16:30,580 --> 00:16:34,700
the same meat and potatoes code within the endpoint itself.

356
00:16:37,780 --> 00:16:39,780
So this gives you, we'll get into it,

357
00:16:39,780 --> 00:16:42,180
but it gives you nice error messages.

358
00:16:42,180 --> 00:16:44,440
But one of the things that's really cool that it does

359
00:16:44,440 --> 00:16:47,260
is it automatically generates Swagger documentation

360
00:16:47,260 --> 00:16:51,660
or a Swagger specification for your endpoint.

361
00:16:51,680 --> 00:16:54,840
For those that aren't familiar, Swagger or OpenAPI

362
00:16:54,840 --> 00:16:59,700
is a JSON or a YAML definition of an API.

363
00:16:59,700 --> 00:17:01,540
And a lot of people will write that spec

364
00:17:01,540 --> 00:17:04,260
and then use generators to generate their code.

365
00:17:04,260 --> 00:17:06,060
This goes the other way, and you write code,

366
00:17:06,060 --> 00:17:09,440
and it generates the spec for you, which is really awesome.

367
00:17:09,440 --> 00:17:12,400
Because there are JavaScript libraries called,

368
00:17:12,400 --> 00:17:15,580
or a library that I know of called Swagger UI, which

369
00:17:15,580 --> 00:17:20,360
will ingest that specification and build you a cool website.

370
00:17:20,360 --> 00:17:21,780
And this is great, because now you

371
00:17:21,780 --> 00:17:24,560
don't have to build some other documentation.

372
00:17:24,560 --> 00:17:27,760
You have documentation that is built for you

373
00:17:27,760 --> 00:17:28,680
based on your code.

374
00:17:31,600 --> 00:17:33,460
And if you're being a good developer

375
00:17:33,460 --> 00:17:35,880
and writing doc strings for all of your functions,

376
00:17:35,880 --> 00:17:38,280
those get pulled into the specification too.

377
00:17:38,280 --> 00:17:40,200
So your code documentation is literally

378
00:17:40,200 --> 00:17:44,760
documenting your endpoint for you, which is awesome.

379
00:17:44,760 --> 00:17:46,880
It also allows you to interact with your API

380
00:17:46,880 --> 00:17:47,680
through the browser.

381
00:17:47,680 --> 00:17:51,600
You can actually drop down those endpoints

382
00:17:51,600 --> 00:17:53,440
and send test data to your endpoint,

383
00:17:53,440 --> 00:17:56,040
and it'll actually send it, show you their curl requests

384
00:17:56,040 --> 00:17:58,640
to do the same thing on your command line, which

385
00:17:58,640 --> 00:18:01,480
is pretty awesome.

386
00:18:01,480 --> 00:18:04,520
So one of the things we mentioned that we wanted to use

387
00:18:04,520 --> 00:18:10,560
to elevate our RESTful API is we want to do input validation.

388
00:18:10,560 --> 00:18:15,320
And that's something that's built right into Flask REST+.

389
00:18:15,320 --> 00:18:17,880
So you can see here we've added a section of code

390
00:18:17,880 --> 00:18:22,480
to our endpoint that is defining the API model.

391
00:18:22,480 --> 00:18:23,880
And so in this case, we're saying

392
00:18:23,880 --> 00:18:26,920
that we have a search name, and it needs to be a string,

393
00:18:26,920 --> 00:18:29,000
and we have a result that is just

394
00:18:29,000 --> 00:18:32,240
going to be a raw JSON blob.

395
00:18:32,240 --> 00:18:37,320
So what this will do then is if we get data

396
00:18:37,320 --> 00:18:39,320
and those fields don't exist, it'll

397
00:18:39,320 --> 00:18:42,180
return a useful error message to the user,

398
00:18:42,180 --> 00:18:44,760
and we don't have to worry about it in our code at all.

399
00:18:44,760 --> 00:18:49,880
Our code knows that once we get to the actual post function,

400
00:18:49,880 --> 00:18:51,960
we're going to have those fields in our result.

401
00:18:57,760 --> 00:18:59,400
So we mentioned the swagger docs.

402
00:18:59,400 --> 00:19:01,900
Another cool thing about defining those models

403
00:19:01,900 --> 00:19:05,360
is it informs our documentation as well.

404
00:19:05,360 --> 00:19:09,240
Because we've told the code what we expect as input,

405
00:19:09,240 --> 00:19:11,480
now we get documentation that says, hey,

406
00:19:11,480 --> 00:19:13,440
this is what you need to send to the endpoint

407
00:19:13,440 --> 00:19:16,680
if you want to get good results.

408
00:19:16,680 --> 00:19:19,120
So it's just this great back and forth

409
00:19:19,120 --> 00:19:23,040
of informing the documentation from the code

410
00:19:23,040 --> 00:19:25,120
so we don't have to go write the documentation

411
00:19:25,120 --> 00:19:28,160
and make sure it's all still up to date when we make changes

412
00:19:28,160 --> 00:19:31,520
and all of that fun developer stuff.

413
00:19:34,040 --> 00:19:35,960
So we keep talking about these error messages.

414
00:19:35,960 --> 00:19:38,360
So this is just a brief example.

415
00:19:38,360 --> 00:19:43,320
Our first curl request there is when we were just using Flask.

416
00:19:43,320 --> 00:19:45,760
And so you get back that awful 500 error

417
00:19:45,760 --> 00:19:47,800
when you request something that's not there,

418
00:19:47,800 --> 00:19:50,760
or there's an internal server error, your code breaks.

419
00:19:50,760 --> 00:19:53,880
And for an end user, that's not helpful.

420
00:19:53,880 --> 00:19:55,800
If you're calling your API programmatically,

421
00:19:55,800 --> 00:19:58,560
that's not helpful.

422
00:19:58,560 --> 00:20:00,560
It might be helpful if you were in a browser, maybe,

423
00:20:00,560 --> 00:20:04,400
but still not helpful at all.

424
00:20:04,400 --> 00:20:07,320
So the same thing with Flask or S+,

425
00:20:07,320 --> 00:20:11,200
you get a nice JSON message with internal server error.

426
00:20:11,200 --> 00:20:13,720
Still not necessarily helpful to the end user,

427
00:20:13,720 --> 00:20:17,960
but it's something that they could parse very easily.

428
00:20:17,960 --> 00:20:20,440
And then as we mentioned with the input output validation

429
00:20:20,440 --> 00:20:24,200
stuff, you can see at the bottom there,

430
00:20:24,200 --> 00:20:29,640
they called the webhook and their input was incorrect.

431
00:20:29,640 --> 00:20:32,960
And they got a verbose error message telling them

432
00:20:32,960 --> 00:20:35,840
that you can't send us a none type for this.

433
00:20:35,840 --> 00:20:38,760
So that's the off the shelf solution.

434
00:20:38,760 --> 00:20:41,320
But as developers, a lot of times, we're like, oh,

435
00:20:41,320 --> 00:20:43,840
let's build a framework, right?

436
00:20:43,840 --> 00:20:46,440
And sort of in our defense, we started

437
00:20:46,440 --> 00:20:48,960
building this around the same time that Flask or S+,

438
00:20:48,960 --> 00:20:50,200
initially came out.

439
00:20:50,200 --> 00:20:53,560
So we weren't necessarily reinventing the wheel,

440
00:20:53,560 --> 00:20:56,280
but maybe a little bit.

441
00:20:56,280 --> 00:21:01,320
So we built a framework that we called Funnel.

442
00:21:01,320 --> 00:21:04,840
And we built a little bit of a little bit of a little bit

443
00:21:04,840 --> 00:21:08,960
called Funnel, because it's putting things into Flask.

444
00:21:08,960 --> 00:21:12,360
And developers are super clever.

445
00:21:12,360 --> 00:21:14,400
And we are working on getting it open sourced.

446
00:21:14,400 --> 00:21:17,760
It's just there's a lot of hoops to jump through for that.

447
00:21:17,760 --> 00:21:19,640
But it does a lot of the same things

448
00:21:19,640 --> 00:21:24,000
that Flask or S+, just in a slightly different way.

449
00:21:24,000 --> 00:21:27,480
You still define the allowed HTTP methods.

450
00:21:27,480 --> 00:21:31,640
It's all based on an endpoint class.

451
00:21:31,640 --> 00:21:36,040
You then have attribute classes for inputs and outputs.

452
00:21:36,040 --> 00:21:37,800
You define them the same way.

453
00:21:37,800 --> 00:21:41,680
There's built-ins for strings and integers and all of that,

454
00:21:41,680 --> 00:21:43,440
as well as base classes for doing

455
00:21:43,440 --> 00:21:48,200
like regex-based types, enum-based types, dates,

456
00:21:48,200 --> 00:21:51,200
all those sorts of things.

457
00:21:51,200 --> 00:21:53,160
We also do output validation, which

458
00:21:53,160 --> 00:21:56,920
can be nice because it'll strip off additional fields so that

459
00:21:56,920 --> 00:21:59,380
you're not returning a bunch of data

460
00:21:59,380 --> 00:22:04,100
that you might not want to.

461
00:22:04,100 --> 00:22:05,900
Of course, standardizes the logging.

462
00:22:05,900 --> 00:22:07,480
But one of the big things we wanted

463
00:22:07,480 --> 00:22:11,260
was a code-defined API, as I kind of alluded to before.

464
00:22:11,260 --> 00:22:12,020
We're developers.

465
00:22:12,020 --> 00:22:13,820
We don't want to write a JSON spec all day.

466
00:22:13,820 --> 00:22:17,940
We'd rather write a class and have it generate that for us.

467
00:22:17,940 --> 00:22:26,300
And so much like REST+, Funnel will generate you the open API

468
00:22:26,300 --> 00:22:27,220
spec.

469
00:22:27,220 --> 00:22:30,300
And then you can ingest it with Swagger UI or some

470
00:22:30,300 --> 00:22:35,540
of the other open source tools that process those specs.

471
00:22:35,540 --> 00:22:40,420
Also does all the exception masking, as well, which is nice.

472
00:22:40,420 --> 00:22:41,920
And so really the main difference for us

473
00:22:41,920 --> 00:22:43,820
is we don't use decorators.

474
00:22:43,820 --> 00:22:46,700
If you see at the bottom there with the register function,

475
00:22:46,700 --> 00:22:50,660
that's how we map routes to classes.

476
00:22:50,660 --> 00:22:53,700
And then the before and after, I guess

477
00:22:53,700 --> 00:22:54,900
most people can probably see it.

478
00:22:54,900 --> 00:22:57,180
It's kind of near the bottom and dark.

479
00:22:57,180 --> 00:23:00,940
But it allows you to specify a list of plugins.

480
00:23:00,940 --> 00:23:02,540
So for instance, in this example,

481
00:23:02,540 --> 00:23:05,580
there is an auth function listed there

482
00:23:05,580 --> 00:23:08,740
to do authentication in the before plugins.

483
00:23:08,740 --> 00:23:10,200
The after plugins are cool, too.

484
00:23:10,200 --> 00:23:13,420
If you're dealing with potentially sensitive data,

485
00:23:13,420 --> 00:23:15,660
you might want to scrub out credit card numbers

486
00:23:15,660 --> 00:23:19,340
or social security numbers or anything like that.

487
00:23:19,340 --> 00:23:21,740
And those plugins get the full request object

488
00:23:21,740 --> 00:23:25,980
so they can make determinations based

489
00:23:25,980 --> 00:23:27,540
on anything in the request.

490
00:23:27,540 --> 00:23:30,020
And then if they throw exceptions or anything like that,

491
00:23:30,020 --> 00:23:31,860
it just kills it and doesn't give data back.

492
00:23:37,860 --> 00:23:40,520
So when you actually go to build one of these things

493
00:23:40,520 --> 00:23:43,780
and get it deployed to really support a team,

494
00:23:43,780 --> 00:23:46,240
first thing you're going to have to do or deal with

495
00:23:46,240 --> 00:23:48,340
is Murphy's law.

496
00:23:48,340 --> 00:23:49,900
Everything is going to break.

497
00:23:49,900 --> 00:23:54,500
You're going to have ephemeral errors, all kinds of things.

498
00:23:54,500 --> 00:23:56,660
And so we wanted to just talk a little bit about some

499
00:23:56,660 --> 00:23:59,900
of our tips for keeping things manageable.

500
00:23:59,900 --> 00:24:01,900
First off, I always like to remind everyone

501
00:24:01,900 --> 00:24:03,900
that maintaining state is hard.

502
00:24:03,900 --> 00:24:07,380
Some people see a problem and they think, I need a database.

503
00:24:07,380 --> 00:24:08,900
I'd argue that now they got two problems.

504
00:24:11,820 --> 00:24:13,420
I mean, a database are definitely

505
00:24:13,420 --> 00:24:14,700
the right approach for a lot of things

506
00:24:14,700 --> 00:24:15,980
where you need to maintain data.

507
00:24:15,980 --> 00:24:17,860
But if you don't, if you could do something

508
00:24:17,860 --> 00:24:20,180
completely stateless, why would you also

509
00:24:20,180 --> 00:24:23,940
want to manage database migrations on top of code

510
00:24:23,940 --> 00:24:25,260
updates?

511
00:24:25,260 --> 00:24:28,120
And if you thought, I don't need a database,

512
00:24:28,120 --> 00:24:30,340
but I can just go write some stuff to a local file

513
00:24:30,340 --> 00:24:33,780
or something, well, that's how you get race conditions.

514
00:24:33,780 --> 00:24:35,540
So anything that can be totally stateless

515
00:24:35,540 --> 00:24:38,220
is just so much easier than if you need

516
00:24:38,220 --> 00:24:42,380
to maintain anything externally.

517
00:24:42,380 --> 00:24:45,500
Errors pop up for pretty much no reason at all,

518
00:24:45,500 --> 00:24:49,340
like network hiccups that are just completely unexplainable

519
00:24:49,340 --> 00:24:51,340
happen an alarming amount of time.

520
00:24:51,340 --> 00:24:53,500
It's really amazing the baseline level of errors

521
00:24:53,500 --> 00:24:55,460
of stuff on the internet.

522
00:24:55,460 --> 00:24:58,600
Just adding a little wait and retry decorator

523
00:24:58,600 --> 00:25:01,660
to your functions eliminates so many errors.

524
00:25:01,660 --> 00:25:04,380
I always highly recommend everyone do that.

525
00:25:04,380 --> 00:25:07,180
And then speaking of that, in our code,

526
00:25:07,180 --> 00:25:10,040
we called our Active Directory lookup followed

527
00:25:10,040 --> 00:25:11,740
by our VirusTotal lookup.

528
00:25:11,740 --> 00:25:14,400
If we couldn't reach that Active Directory server for any reason

529
00:25:15,080 --> 00:25:17,160
the whole thing would just throw an exception and die,

530
00:25:17,160 --> 00:25:19,400
and we would never call out to VirusTotal.

531
00:25:19,400 --> 00:25:23,240
So really, if you're doing all of these various enrichments,

532
00:25:23,240 --> 00:25:25,480
you want them to be asynchronous and run

533
00:25:25,480 --> 00:25:28,520
separately from each other.

534
00:25:28,520 --> 00:25:32,000
So you could set up separate Jira webhooks for each one.

535
00:25:32,000 --> 00:25:33,800
That kind of makes sense, but might end up

536
00:25:33,800 --> 00:25:35,920
being a lot of stuff to manage.

537
00:25:35,920 --> 00:25:41,160
Or we could go into Python and use Celery and RabbitMQ.

538
00:25:41,160 --> 00:25:44,280
Or AsyncIO, I think, might be really neat

539
00:25:44,280 --> 00:25:49,200
if you're willing to commit all in and do AsyncIO everywhere.

540
00:25:49,200 --> 00:25:51,320
There are also a lot of DevOps tools that are basically

541
00:25:51,320 --> 00:25:55,320
built for exactly this, like StackStorm, Jenkins, Rundeck.

542
00:25:55,320 --> 00:25:57,320
And that's one of the big points we want to make.

543
00:25:57,320 --> 00:26:00,400
Like, you can repurpose a lot of these DevOps tools,

544
00:26:00,400 --> 00:26:02,320
even though they aren't marketed for security,

545
00:26:02,320 --> 00:26:04,240
and they work really, really well.

546
00:26:04,240 --> 00:26:06,400
If you're a cloud native, you could do something

547
00:26:06,400 --> 00:26:09,200
like AWS Lambda.

548
00:26:09,200 --> 00:26:11,360
Or if you've got piles of money, you

549
00:26:11,440 --> 00:26:14,760
can also buy some of these commercial security automation

550
00:26:14,760 --> 00:26:18,160
platforms called SOAR.

551
00:26:18,160 --> 00:26:20,480
And they have similar functionality.

552
00:26:20,480 --> 00:26:23,640
They actually have similar functionality all around.

553
00:26:23,640 --> 00:26:27,400
But you can also write your own code to interoperate with them.

554
00:26:27,400 --> 00:26:30,000
But at the end of the day, getting something up and running

555
00:26:30,000 --> 00:26:34,320
and then iterating is always, always the best way to go.

556
00:26:34,320 --> 00:26:35,360
Done is better than perfect.

557
00:26:35,360 --> 00:26:41,360
So we'd like you to have a few takeaways from this talk.

558
00:26:41,360 --> 00:26:45,520
Basically, first off, security automation is not magic.

559
00:26:45,520 --> 00:26:49,520
It really is a series of webhooks and Python glue.

560
00:26:49,520 --> 00:26:52,400
And that's true for the code we just showed you.

561
00:26:52,400 --> 00:26:54,760
It's true for all of the commercial platforms.

562
00:26:54,760 --> 00:26:58,960
It's really just how you tie these systems together

563
00:26:58,960 --> 00:27:00,360
a lot of the time.

564
00:27:00,360 --> 00:27:02,360
So I'm going to go ahead and show you

565
00:27:02,360 --> 00:27:06,320
these systems together a lot of the time.

566
00:27:06,320 --> 00:27:08,120
But if you've actually implemented something

567
00:27:08,120 --> 00:27:11,120
like this, if you're automating tasks for a team,

568
00:27:11,120 --> 00:27:13,800
start counting the number of times those endpoints are

569
00:27:13,800 --> 00:27:14,800
called.

570
00:27:14,800 --> 00:27:17,880
And assign a number of minutes to each one,

571
00:27:17,880 --> 00:27:21,560
minutes saved that it would have taken to do the lookup manually.

572
00:27:21,560 --> 00:27:25,040
And add those all up to see what kind of real impact

573
00:27:25,040 --> 00:27:26,080
you're having.

574
00:27:26,080 --> 00:27:29,300
This little graphic is similar to something

575
00:27:29,300 --> 00:27:32,200
that our team actually sends out every week to management

576
00:27:32,200 --> 00:27:35,880
and other teams saying, here's how many calls we got.

577
00:27:35,880 --> 00:27:38,640
Here's how many hours we estimate we saved.

578
00:27:38,640 --> 00:27:42,800
We make it green because management likes colors.

579
00:27:42,800 --> 00:27:45,440
And if they care to take that and multiply

580
00:27:45,440 --> 00:27:47,800
by an average hourly rate, then that

581
00:27:47,800 --> 00:27:51,000
can directly correlate to amount of dollars

582
00:27:51,000 --> 00:27:55,800
saved, which is a pretty powerful proposition.

583
00:27:55,800 --> 00:27:57,880
We've been talking about security

584
00:27:57,880 --> 00:28:00,160
because that's what we do specifically.

585
00:28:00,160 --> 00:28:02,240
But most of what we talked about could

586
00:28:02,240 --> 00:28:07,160
apply to any kind of IT or development workflow that's

587
00:28:07,160 --> 00:28:09,360
oriented around tickets.

588
00:28:09,360 --> 00:28:11,000
Even if you're just purely development,

589
00:28:11,000 --> 00:28:12,900
one thing that we've been setting up

590
00:28:12,900 --> 00:28:16,200
is GitHub webhooks so that when we make a pull request,

591
00:28:16,200 --> 00:28:18,520
we also create a code review ticket, things like that.

592
00:28:23,640 --> 00:28:26,600
So these automations are not like a thing

593
00:28:26,600 --> 00:28:29,120
that you can build once and then forget about.

594
00:28:29,120 --> 00:28:31,680
And you also can't replace people.

595
00:28:31,680 --> 00:28:34,320
It's not like a factory where we are

596
00:28:34,320 --> 00:28:36,840
trying to automate and completely take over

597
00:28:36,840 --> 00:28:38,400
a human's job.

598
00:28:38,400 --> 00:28:44,040
In this space where we have security analysts, IT analysts,

599
00:28:44,040 --> 00:28:47,280
developers, we're just trying to eliminate the busy work that

600
00:28:47,280 --> 00:28:49,240
takes up their time so that they can actually

601
00:28:49,240 --> 00:28:53,760
spend their time doing security or doing development.

602
00:28:53,760 --> 00:28:57,440
And there's a lot of low-hanging fruit.

603
00:28:58,240 --> 00:29:01,040
Filling out ticket fields, adding links to that pull

604
00:29:01,040 --> 00:29:02,600
request, that kind of thing.

605
00:29:02,600 --> 00:29:03,800
It's super easy to do.

606
00:29:03,800 --> 00:29:05,200
And it really adds a lot of value.

607
00:29:09,160 --> 00:29:13,960
And then at the end, I just want to make a pitch for basically

608
00:29:13,960 --> 00:29:15,040
our job.

609
00:29:15,040 --> 00:29:18,240
Security automation is a super neat field to be in.

610
00:29:18,240 --> 00:29:20,400
I wouldn't want to be anywhere else.

611
00:29:20,400 --> 00:29:23,200
Our job is working with the rest of the team.

612
00:29:23,200 --> 00:29:25,000
They're our customers.

613
00:29:25,000 --> 00:29:26,400
But they're also sitting next to us.

614
00:29:26,400 --> 00:29:27,560
We write code for them.

615
00:29:27,560 --> 00:29:28,640
We develop software.

616
00:29:28,640 --> 00:29:31,960
They can use it the next day, get us immediate feedback.

617
00:29:31,960 --> 00:29:34,560
It's a really cool kind of hybrid of software development

618
00:29:34,560 --> 00:29:36,960
and other operations work.

619
00:29:36,960 --> 00:29:39,600
If anyone is a developer and wants to get into security,

620
00:29:39,600 --> 00:29:42,080
it's also a really cool niche to look at.

621
00:29:42,080 --> 00:29:43,560
Next time you're looking at jobs,

622
00:29:43,560 --> 00:29:46,360
consider those security engineer positions.

623
00:29:46,360 --> 00:29:48,920
A lot of them actually have a really heavy development

624
00:29:48,920 --> 00:29:51,000
component.

625
00:29:51,000 --> 00:29:55,800
And by the way, like everyone else, we are hiring.

626
00:29:55,840 --> 00:29:57,520
So that is everything.

627
00:29:57,520 --> 00:29:58,880
And I think we are at time.

628
00:29:58,880 --> 00:30:00,840
So thank you, everyone, for your attention.

629
00:30:00,840 --> 00:30:02,480
Thanks a lot.

