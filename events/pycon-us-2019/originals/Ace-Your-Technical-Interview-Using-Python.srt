1
00:00:00,000 --> 00:00:10,800
Hello everyone. Hello everyone. Next up is Erin Allard who is a platform support

2
00:00:10,800 --> 00:00:15,520
engineer at Heroku and will be presenting a technical interview using

3
00:00:15,520 --> 00:00:17,880
Python.

4
00:00:21,880 --> 00:00:27,880
Hi thanks so much for coming I'm Erin. I see some friendly faces in the audience

5
00:00:27,880 --> 00:00:32,200
so thanks very much for being here. Without further ado let's talk about

6
00:00:32,200 --> 00:00:35,880
technical interviewing with Python. If you'd like to follow along with the

7
00:00:35,880 --> 00:00:43,000
slides there's a bit.ly link there for you. So is this talk for you? Probably.

8
00:00:43,000 --> 00:00:47,920
It's geared more towards candidates who are going to be interviewing less

9
00:00:47,920 --> 00:00:52,440
towards interviewers but if you're an interviewer there will still probably be

10
00:00:52,440 --> 00:00:57,200
things from the talk you can take away. So if you're a kind of candidate who's

11
00:00:57,200 --> 00:01:01,480
rendering oh my god what should I study or how can I feel more confident because

12
00:01:01,480 --> 00:01:06,560
I feel really nervous or how can I do all of this interview stuff using Python

13
00:01:06,560 --> 00:01:12,760
I will answer a lot of these questions in the talk. In the next 25 minutes we'll

14
00:01:12,760 --> 00:01:17,120
talk about briefly the overview of what a technical interview process looks like

15
00:01:17,120 --> 00:01:22,000
all the steps, some personal qualities and non-technical skills that hiring

16
00:01:22,000 --> 00:01:26,400
managers are going to be looking for when they interview candidates. Importantly

17
00:01:26,400 --> 00:01:30,120
probably why most of you are here the computer science concepts that you

18
00:01:30,120 --> 00:01:34,080
should probably know and how to implement them in Python. And finally I'll

19
00:01:34,080 --> 00:01:38,440
wrap up with some general advice about mindset and how to stay positive because

20
00:01:38,440 --> 00:01:45,560
let's admit interviewing sucks it's emotionally very draining. All of that to

21
00:01:45,560 --> 00:01:50,280
say this is going to be a whirlwind of things you should probably study. There

22
00:01:50,280 --> 00:01:54,200
will probably be things up here that you don't think should be and maybe things

23
00:01:54,240 --> 00:01:58,040
you think should be up here that aren't. There's a lot of different ways to

24
00:01:58,040 --> 00:02:03,240
approach interviewing. I'd love to hear your ideas if they're missing so feel

25
00:02:03,240 --> 00:02:08,200
free to send me an email I'll give you my email address at the end. So that's me

26
00:02:08,200 --> 00:02:13,920
as of this past Monday I am on the Heroku support team as a platform support

27
00:02:13,920 --> 00:02:18,960
engineer. Prior to that I spent just over a year at a company called Numerator

28
00:02:18,960 --> 00:02:25,840
building out their Django SAS product for which is was their flagship product

29
00:02:25,840 --> 00:02:30,160
and I'm also a LinkedIn learning instructor. I have three courses up right

30
00:02:30,160 --> 00:02:34,480
now all relating to technical interviewing using Python. I'll link to

31
00:02:34,480 --> 00:02:40,440
two of them later on in the slides as they relate to the material here. I am a

32
00:02:40,440 --> 00:02:44,320
software engineer from a non-traditional background. I actually studied economics

33
00:02:44,360 --> 00:02:49,080
in college and then later went to Hackbrite Academy in San Francisco and I

34
00:02:49,080 --> 00:02:53,360
continue to be involved there and do a lot of mentoring of folks who are also

35
00:02:53,360 --> 00:02:58,280
trying to transition careers and so a lot of that experience has colored this

36
00:02:58,280 --> 00:03:04,080
presentation. This is also my first time speaking at PyCon so again thank you

37
00:03:04,080 --> 00:03:07,080
very much for coming.

38
00:03:07,080 --> 00:03:18,760
Okay so this is a crossword puzzle obviously. I want to give you just a few

39
00:03:18,760 --> 00:03:23,760
seconds. Can anyone think of why this crossword might be important?

40
00:03:23,760 --> 00:03:36,960
Okay I'll tell you. So this crossword appeared in January of 1942 in the Daily

41
00:03:36,960 --> 00:03:43,400
Telegraph newspaper which is published in Britain and I am cheekily and only

42
00:03:43,400 --> 00:03:48,720
half-jokingly going to propose that this was the first technical interview in the

43
00:03:48,720 --> 00:03:53,000
history of computer science and the reason I say that is that this crossword

44
00:03:53,000 --> 00:03:58,960
puzzle was the one that folks from Bletchley Park used to sort of initially

45
00:03:58,960 --> 00:04:03,200
try to find cryptanalysts and people who are good at problem-solving to come join

46
00:04:03,200 --> 00:04:07,600
their efforts to crack the enigma code. I watched the imitation game last night

47
00:04:07,600 --> 00:04:12,320
for like the fifth time and realized how well this fit in with my talk and so

48
00:04:12,320 --> 00:04:17,480
added it at the last minute. We've really come a long way since technical

49
00:04:17,480 --> 00:04:21,160
interviews like this and I put this here just to remind you to keep it in

50
00:04:21,160 --> 00:04:25,640
perspective. We're going to talk about some very technical things but really it

51
00:04:25,640 --> 00:04:31,640
goes back to things that a crossword puzzle are fundamentally trying to help

52
00:04:31,640 --> 00:04:36,520
those Bletchley Park people find which is can you solve problems? Can you

53
00:04:36,520 --> 00:04:43,680
recognize patterns? Can you stick with a thing until you finish it? So a brief

54
00:04:43,680 --> 00:04:47,400
overview of the technical interview process in case some of you haven't yet

55
00:04:47,440 --> 00:04:52,440
had a technical interview. It usually starts with a recruiter phone screen. I

56
00:04:52,440 --> 00:04:57,720
call this a pulse check. The recruiter will talk to you for 20 or 30 minutes

57
00:04:57,720 --> 00:05:02,160
and ask you all the general questions like why are you applying for the role?

58
00:05:02,160 --> 00:05:06,120
What do you know about the company? What have you been up to for the last year or

59
00:05:06,120 --> 00:05:11,640
two? And if that goes well, you know, if you can convince them that it's fun to

60
00:05:11,640 --> 00:05:15,640
talk to you for 20 minutes, they'll move you on to the next step which is

61
00:05:15,680 --> 00:05:20,520
typically a technical phone screen with an engineer. And I forgot to mention that

62
00:05:20,520 --> 00:05:24,520
there will of course be some variation in all of these steps across companies.

63
00:05:24,520 --> 00:05:30,640
But typically this is the flow. The technical phone screen with an engineer

64
00:05:30,640 --> 00:05:35,840
might or might not have a web collaborative coding component but

65
00:05:35,840 --> 00:05:41,080
typically it's 30 to 60 minutes and they'll ask you questions maybe about

66
00:05:41,080 --> 00:05:45,600
your preferred programming language. They may kind of poke at your knowledge

67
00:05:45,600 --> 00:05:49,480
about different concepts within that language. And then depending on the role

68
00:05:49,480 --> 00:05:53,960
they may ask you some domain specific questions. If you're applying for a back

69
00:05:53,960 --> 00:05:59,120
end Django role, they may ask you some questions about Django, things like that.

70
00:05:59,120 --> 00:06:03,200
If this call goes well, typically the next step is something called a take home

71
00:06:03,200 --> 00:06:08,720
assessment which is a mini self-contained project that the recruiter will probably

72
00:06:08,760 --> 00:06:14,320
email you some instructions for. And it's your job over the next two to seven days

73
00:06:14,320 --> 00:06:20,760
to put together some response or solution to whatever the prompt is. There is a bit

74
00:06:20,760 --> 00:06:26,760
of debate about whether or not these are effective or fair. Some companies

75
00:06:26,760 --> 00:06:30,760
unfortunately use them to get a little free labor out of people which is not

76
00:06:30,760 --> 00:06:35,960
right. But when done well and when structured well, companies can get a good

77
00:06:36,000 --> 00:06:42,880
sense of how a candidate might fit in on a team in terms of skill. And the last step

78
00:06:42,880 --> 00:06:46,760
is usually the on-site interviews. This is the part that I always get really

79
00:06:46,760 --> 00:06:51,800
nervous about. Typically there are at least four hours you meet anywhere from

80
00:06:51,800 --> 00:06:57,280
three to ten people, most of whom will be on your team. And a lot of the interviews

81
00:06:57,280 --> 00:07:01,200
are technical in nature, meaning you're white boarding or pair programming and

82
00:07:01,200 --> 00:07:05,920
I'll explain what those are in a minute. Also a lot of behavioral questions where

83
00:07:05,920 --> 00:07:09,400
people will ask you things you've probably heard before like what would you

84
00:07:09,400 --> 00:07:16,120
do if or how do you approach conflict, those kinds of things. White boarding, you

85
00:07:16,120 --> 00:07:19,760
may know, is when you and your interviewer are standing in front of a big

86
00:07:19,760 --> 00:07:24,520
white board instead of a computer screen and working through what is usually a

87
00:07:24,520 --> 00:07:29,120
coding problem, writing it out. Pair programming is when you're doing

88
00:07:29,120 --> 00:07:34,600
effectively the same thing, working together on a problem but actually coding.

89
00:07:34,600 --> 00:07:38,440
Pros and cons to both, won't get into the disagreements about which of those are

90
00:07:38,440 --> 00:07:44,480
better but there's a lot of conversation about that online. So let's move into the

91
00:07:44,480 --> 00:07:49,000
skills part. First I want to talk about the non-technical skills. People often

92
00:07:49,000 --> 00:07:52,480
call these soft skills. I don't like to call them soft skills because

93
00:07:52,480 --> 00:07:57,240
non-technical skills are hard for some people. Interpersonal stuff can be really

94
00:07:57,240 --> 00:08:03,560
hard but it really matters. And the first one of those is problem-solving. And we

95
00:08:03,560 --> 00:08:07,400
hear this phrase a lot as software engineers. Everyone wants to work with

96
00:08:07,400 --> 00:08:12,800
people who are great problem solvers. And to me the phrase problem solver is a

97
00:08:12,800 --> 00:08:18,800
shorthand for a much longer description. To me it means using what you already

98
00:08:18,800 --> 00:08:25,120
know to solve a specific problem that might not be well defined. And for those

99
00:08:25,120 --> 00:08:28,360
of you with a little more experience you know that this happens all the time in

100
00:08:28,360 --> 00:08:32,840
your work. So this is a skill that your interviewers are going to be screening

101
00:08:32,840 --> 00:08:38,880
for. Another non-technical skill that has been really important in my career

102
00:08:38,880 --> 00:08:43,240
growth is the ability to ask good questions. And I've linked here to a blog

103
00:08:43,240 --> 00:08:48,360
article by Julia Evans called How to Ask Good Questions. This is a fantastic

104
00:08:48,360 --> 00:08:53,240
article. I mention it anytime I'm talking to anyone who's early in

105
00:08:53,240 --> 00:08:58,080
their career or going through the interview process. The main thing that

106
00:08:58,280 --> 00:09:03,640
I've pulled out of it is a framework around how to structure a question so

107
00:09:03,640 --> 00:09:08,080
that it's most useful to you and most useful to the person you're asking it of.

108
00:09:08,080 --> 00:09:13,520
And that is something like this. I'm trying to do this thing but this other

109
00:09:13,520 --> 00:09:18,760
thing is happening. I already tried X and Y. Can you point me in the right

110
00:09:18,760 --> 00:09:23,880
direction? For me when I use this format it's really effective because I am able

111
00:09:24,040 --> 00:09:29,200
to show that I've already tried doing something on my own. It didn't work and so

112
00:09:29,200 --> 00:09:33,640
I tried other things. I can set a baseline level of knowledge for the

113
00:09:33,640 --> 00:09:40,000
person who I'm asking and then I make a specific ask for help. I do also want to

114
00:09:40,000 --> 00:09:44,720
add here that asking a good question should be asked of the right person. And

115
00:09:44,720 --> 00:09:50,400
for me the right person is usually who knows the most about this topic, who is

116
00:09:50,400 --> 00:09:55,800
also the least busy. Typically you'd, well actually nevermind, I was gonna start

117
00:09:55,800 --> 00:10:01,120
talking about slack but I'm not gonna go down that rabbit hole. The third

118
00:10:01,120 --> 00:10:04,960
non-technical skill that I wanted to highlight is about understanding

119
00:10:04,960 --> 00:10:10,320
assumptions. And this goes for both code and people. You know we're probably very

120
00:10:10,320 --> 00:10:14,640
familiar with both actually but when you kind of combine them in the context of a

121
00:10:14,640 --> 00:10:18,600
software engineering team we can talk about it a little more differently. We

122
00:10:18,600 --> 00:10:24,240
know about understanding assumptions about a problem but I kind of go a level

123
00:10:24,240 --> 00:10:30,440
deeper when I talk about understanding assumptions. I think about what things

124
00:10:30,440 --> 00:10:35,840
about this problem do I think are facts that I haven't actually taken the time

125
00:10:35,840 --> 00:10:43,840
to prove or ask about. And within that could also be things like bias or

126
00:10:43,880 --> 00:10:50,480
expectations. So when hiring managers are interviewing candidates this is something

127
00:10:50,480 --> 00:10:55,600
that they may be looking for. Same goes with people right. A hiring manager may be

128
00:10:55,600 --> 00:11:00,880
very interested to know if a candidate can you know kind of get inside their own

129
00:11:00,880 --> 00:11:05,120
mind and make fewer assumptions about their colleagues through the use of

130
00:11:05,120 --> 00:11:11,040
asking good questions. An example would be, hey when you said this in a meeting I

131
00:11:11,400 --> 00:11:15,520
wasn't quite sure how you meant that. Could you explain a little more? Checking

132
00:11:15,520 --> 00:11:22,640
assumptions about people helps your team run more smoothly. So now we'll move on to

133
00:11:22,640 --> 00:11:28,520
the code part. Code obviously matters a lot in a technical interview. And I wanted

134
00:11:28,520 --> 00:11:33,880
to start us off by talking about collections. So when I think about approaching

135
00:11:33,880 --> 00:11:38,480
a coding challenge for example I like to keep in mind what are all of the tools

136
00:11:38,480 --> 00:11:44,240
that I have in programming that can help me solve a problem. And in my mind

137
00:11:44,240 --> 00:11:48,680
collections are the most powerful tool because they help me store and organize

138
00:11:48,680 --> 00:11:55,720
data. These would be tuples, lists, dictionaries and sets. I'm purposefully

139
00:11:55,720 --> 00:12:00,000
not going into syntax or methods or things like that because I know you can

140
00:12:00,000 --> 00:12:04,080
all go check the documentation. But knowing these like the back of your hand

141
00:12:04,080 --> 00:12:08,160
will save you so much time in coding challenges. If you can immediately

142
00:12:08,160 --> 00:12:14,160
recognize which one of these collections to use when, that'll save you time. If you

143
00:12:14,160 --> 00:12:18,480
can memorize a few very helpful methods that are associated with each of these

144
00:12:18,480 --> 00:12:24,200
collections that can save you a lot of time. For example with dictionaries if

145
00:12:24,200 --> 00:12:29,600
you can remember oh there's a keys of values and an items method or iter items

146
00:12:29,680 --> 00:12:32,680
method that can save you a lot of time.

147
00:12:36,680 --> 00:12:43,320
And this is a link to the Python 3 documentation. So time complexity in my

148
00:12:43,320 --> 00:12:48,040
experience comes up pretty much at the end of every coding challenge. Like

149
00:12:48,040 --> 00:12:52,040
probably many of you I was baffled by this at first I like to think that I'm a

150
00:12:52,040 --> 00:12:57,160
lot better at it now. But basically time complexity is referring to the amount of

151
00:12:57,160 --> 00:13:01,480
time it takes to run an algorithm and the worst-case scenario compared to the

152
00:13:01,480 --> 00:13:05,920
size of the input. And there's a link here in case you need a refresher this

153
00:13:05,920 --> 00:13:10,800
goes to a free code camp blog post. Probably most of you have seen this

154
00:13:10,800 --> 00:13:17,320
ubiquitous chart here showing all of the various time complexities. This I do want

155
00:13:17,320 --> 00:13:22,540
to note is on a logarithmic scale so o of log in is that red line that you see

156
00:13:22,540 --> 00:13:26,880
all the way down on the x-axis. And the important thing to pull from this chart

157
00:13:26,880 --> 00:13:31,800
here is that the closer the line is to the x-axis the more optimal the runtime.

158
00:13:31,800 --> 00:13:37,320
You really want to stay away from runtimes that are closer to the y-axis.

159
00:13:37,320 --> 00:13:42,920
The most common runtimes that have come up in my experience as someone who's

160
00:13:42,920 --> 00:13:47,520
early in my career when I do coding challenges for interviews are these four.

161
00:13:47,520 --> 00:13:54,080
So constant time which is o of 1, linear time which is o of n, log n which we

162
00:13:54,080 --> 00:13:59,800
just talked about that often comes up with binary search and o of n squared.

163
00:13:59,800 --> 00:14:03,560
We don't have time to go into what all of these mean and how you get them but again

164
00:14:03,560 --> 00:14:07,440
check out that link that I provided on the first slide if you need a refresher.

165
00:14:07,440 --> 00:14:13,120
There are actually a few more as well so it would be good to know how those work

166
00:14:13,120 --> 00:14:17,640
but these are the ones that I come across most commonly.

167
00:14:17,680 --> 00:14:24,000
Okay, recursion. How many of you have ever been afraid of recursion?

168
00:14:24,000 --> 00:14:29,320
Yes, me too. I put off learning about it for a very long time.

169
00:14:29,320 --> 00:14:35,680
Recursion is at its core an elegant method of solving a problem where the solution

170
00:14:35,680 --> 00:14:42,240
depends on solutions to smaller occurrences of that same problem.

171
00:14:42,240 --> 00:14:47,280
And recursion when you write a recursive function it has to have two components,

172
00:14:47,320 --> 00:14:50,040
a base case and progress.

173
00:14:50,040 --> 00:14:54,760
And the base case just means how will I know when I'm done recursing or how will my

174
00:14:54,760 --> 00:14:58,480
function know when it can stop calling itself.

175
00:14:58,480 --> 00:15:05,600
And the progress portion is to continually reduce the problem until you get down to the base case.

176
00:15:05,600 --> 00:15:11,960
Al Swigart who spoke at North Bay Python last year did a fantastic talk on recursion.

177
00:15:11,960 --> 00:15:17,080
I wish I had listened or watched this talk three years ago when I was just getting started.

178
00:15:17,120 --> 00:15:20,360
I really, really encourage you to watch it.

179
00:15:20,360 --> 00:15:23,640
Again, you'll have access to these slides with the bit.ly link.

180
00:15:23,640 --> 00:15:27,160
So click on this link. It's 20 or 30 minutes.

181
00:15:27,160 --> 00:15:41,120
And he just does a really good job of breaking it down and also high five Al for a really fantastic talk title about recursion.

182
00:15:41,120 --> 00:15:46,760
Object oriented programming just comes up all the time in interviews because Python is an object

183
00:15:46,760 --> 00:15:52,680
oriented language and classes and objects are absolutely everywhere in production code,

184
00:15:52,680 --> 00:15:57,240
at least from my experience and from most of the folks who I've coached.

185
00:15:57,240 --> 00:16:01,920
I've again linked to an external resource here. This one's from real python dot com.

186
00:16:01,920 --> 00:16:07,440
If you need an OOP refresher I highly recommend checking out that resource.

187
00:16:07,440 --> 00:16:13,920
Really at its core you need to know about defining classes and attributes and knowing the difference between class

188
00:16:13,920 --> 00:16:15,920
attributes and method attributes.

189
00:16:20,160 --> 00:16:24,200
And likewise knowing the difference between class methods and instance methods.

190
00:16:26,400 --> 00:16:34,840
And if OOP comes up in an interview you are also most likely going to be asked but why do we like OOP?

191
00:16:34,840 --> 00:16:39,160
And your answers should include each of these three keywords.

192
00:16:39,160 --> 00:16:43,560
Encapsulation inheritance and polymorphism.

193
00:16:43,600 --> 00:16:48,920
Again we're not going to go into great detail here but that link I provided at the beginning is a good resource.

194
00:16:48,920 --> 00:16:53,160
So I really really recommend knowing how to talk about each of these three things.

195
00:16:56,080 --> 00:16:58,320
Data structures and algorithms.

196
00:16:58,320 --> 00:17:05,320
There's a free book available online called Problem Solving with Algorithms and Data Structures Using Python.

197
00:17:05,320 --> 00:17:13,440
I shortened that in the rest of these slides to PSADS up and it's written by Brad Miller and David Ranham.

198
00:17:13,480 --> 00:17:15,800
I highly highly highly recommend this book.

199
00:17:15,800 --> 00:17:19,400
I'm going to be linking to it on almost every slide from here on out.

200
00:17:19,400 --> 00:17:24,400
I won't be telling you that I've linked to the slide you can at this point read it for yourself.

201
00:17:24,400 --> 00:17:29,680
But all of the data structures and algorithms that I'm going to present in the next 10 minutes are in that book.

202
00:17:29,680 --> 00:17:37,840
So while we don't have time to go over the Python code in this talk all of the Python code is there waiting for you.

203
00:17:37,880 --> 00:17:40,400
So first we'll start with the linear data structures.

204
00:17:40,400 --> 00:17:46,680
Stacks which you can think of like a stack of pancakes in the sense that it's last in first out.

205
00:17:46,680 --> 00:17:51,840
So whatever pancake we put on top of the stack last is going to be the first one we're going to take off to eat.

206
00:17:52,800 --> 00:17:58,320
You can add and remove items or pancakes from a pancake stack in constant time.

207
00:17:59,520 --> 00:18:04,800
And it preserves the order of items it preserves the order in which we cook those pancakes.

208
00:18:05,200 --> 00:18:12,480
In my experience with these data structures you're commonly asked to just implement like a vanilla version of them.

209
00:18:12,480 --> 00:18:15,120
Sometimes you're asked to then manipulate them.

210
00:18:15,120 --> 00:18:21,360
But knowing at a base level how to code them and how they all work is really really helpful.

211
00:18:21,360 --> 00:18:26,800
We also have the concept of queues which you can think of as a line in the grocery store if you're waiting to check out.

212
00:18:27,520 --> 00:18:34,400
First in first out meaning the first person in the line is going to be the first person to check out.

213
00:18:34,400 --> 00:18:38,400
You can add items to the back of the queue in constant time.

214
00:18:38,400 --> 00:18:44,000
But it's linear time while you wait your turn to get out of the queue and buy your groceries.

215
00:18:44,000 --> 00:18:47,440
And queues also preserve the order of items.

216
00:18:47,440 --> 00:18:51,920
Another linear data structure are called linked lists.

217
00:18:52,160 --> 00:18:56,080
We differentiate between singly linked and doubly linked lists.

218
00:18:56,080 --> 00:19:02,720
And linked lists are represented by a Python class which we typically call a node.

219
00:19:02,720 --> 00:19:06,960
And we are able to make those nodes kind of point to each other in memory.

220
00:19:06,960 --> 00:19:10,480
And that's how we represent this list structure.

221
00:19:10,480 --> 00:19:15,280
In a singly linked list you can only move through the nodes in one direction.

222
00:19:15,360 --> 00:19:23,120
But in a doubly linked list each node can keep track of what the node after it is and what the node before it is.

223
00:19:23,120 --> 00:19:25,840
These two data structures are actually very similar.

224
00:19:25,840 --> 00:19:27,920
There's a lot of overlap in the code.

225
00:19:27,920 --> 00:19:31,840
So while it may feel overwhelming, okay there's like two different types of this.

226
00:19:31,840 --> 00:19:34,400
I'm going to have to learn two different data structures.

227
00:19:34,400 --> 00:19:35,920
The code is pretty similar.

228
00:19:38,480 --> 00:19:45,040
I did mention that I'd share the link to my linked and learning courses which are all or these two are about Python data structures.

229
00:19:45,040 --> 00:19:50,880
So if you need a much more in-depth treatment of stacks, queues and linked lists you can check these out.

230
00:19:50,880 --> 00:19:57,040
Again you'll have access to this link in the slides and this will get you a free trial for those courses.

231
00:19:59,040 --> 00:20:01,040
Nonlinear data structures.

232
00:20:01,040 --> 00:20:03,040
So trees.

233
00:20:03,040 --> 00:20:08,000
Binary search trees which are a subtype of a regular tree.

234
00:20:08,000 --> 00:20:12,080
And graphs like social networks for example.

235
00:20:12,080 --> 00:20:14,080
And hash maps.

236
00:20:14,480 --> 00:20:18,240
You can think of Python dictionaries as very much like hash maps.

237
00:20:18,240 --> 00:20:27,840
And so if you're asked questions about these in particular hash maps what you're being asked about essentially is how do dictionaries work.

238
00:20:28,800 --> 00:20:32,480
So knowing about these nonlinear data structures is important.

239
00:20:32,480 --> 00:20:37,760
I'd say at a high level know what they are, what they do and what they're useful for.

240
00:20:37,760 --> 00:20:43,520
In my experience I have not had any coding challenges and interviews come up yet about these.

241
00:20:43,520 --> 00:20:53,360
But again I'm early in my career so if you're more mid-level probably the expectation is that you would have a higher understanding than someone with my level of experience would have.

242
00:20:53,360 --> 00:20:57,360
And all the code for these is in that book I mentioned.

243
00:20:57,360 --> 00:20:59,360
Sorting algorithms.

244
00:20:59,360 --> 00:21:04,320
These are commonly used to assess foundational computer science knowledge.

245
00:21:04,320 --> 00:21:09,360
There's quite a debate around should we even ask about data structures?

246
00:21:09,360 --> 00:21:13,360
Should we even ask about sorting algorithms and searching algorithms?

247
00:21:13,360 --> 00:21:15,360
I think it really depends on the role.

248
00:21:15,360 --> 00:21:26,960
So they're in this talk because I think they are important although it may be your experience that you go quite a few years of interviews without having to be asked about any of these things.

249
00:21:26,960 --> 00:21:33,120
So it just depends on how the company approaches their interview process and what they value when they're looking for candidates.

250
00:21:33,120 --> 00:21:36,400
So I'll highlight three sorting algorithms here.

251
00:21:36,400 --> 00:21:38,400
There are actually a lot more.

252
00:21:38,400 --> 00:21:41,520
These three to me felt like a pretty good place to start.

253
00:21:41,600 --> 00:21:48,080
The first one is insertion sort which is a pretty simple algorithm that does not have very good runtime.

254
00:21:48,080 --> 00:21:50,080
O of n squared.

255
00:21:50,080 --> 00:21:55,920
This type of sorting is best on shorter lists or lists that are already sorted.

256
00:21:55,920 --> 00:21:57,920
Here's a diagram.

257
00:21:57,920 --> 00:21:59,920
You can see a little bit about how it works.

258
00:21:59,920 --> 00:22:05,760
The next one is merge sort which has a much better runtime.

259
00:22:05,760 --> 00:22:08,560
It looks a little quite a bit more complicated.

260
00:22:08,560 --> 00:22:10,560
There's a lot more boxes on that screen.

261
00:22:10,800 --> 00:22:16,640
But really what it does is it breaks a list down into the smallest individual component which is an item.

262
00:22:16,640 --> 00:22:23,920
And then it reassembles those items in ordered pairs until it eventually reassembles a sorted list.

263
00:22:25,760 --> 00:22:35,040
And the third one I wanted to highlight is quick sort which is a really efficient general purpose sorting algorithm that's commonly used.

264
00:22:35,040 --> 00:22:39,760
So again in my experience it has been enough to know how these work.

265
00:22:39,760 --> 00:22:46,640
I have not been asked to code them or implement them yet although it is my intention to dig into that more.

266
00:22:47,600 --> 00:22:50,960
And then finally we'll wrap up with searching algorithms.

267
00:22:51,920 --> 00:22:55,840
Linear or binary search. I love this one. It's one of my favorites. It's just really cool.

268
00:22:56,400 --> 00:23:03,040
I love the idea that every time you do an operation you're reducing the universe of possibilities by half.

269
00:23:03,600 --> 00:23:08,240
And that's why this is very efficient. O of log n.

270
00:23:09,200 --> 00:23:18,480
We can also search through binary search trees. So the binary search of trees is done most effectively on binary trees.

271
00:23:20,160 --> 00:23:24,160
And then we can do breadth first search and depth first search.

272
00:23:24,160 --> 00:23:32,720
So I'll go through each of these. And breadth first search you're going through each hierarchical level of the tree before moving on to the next one.

273
00:23:32,880 --> 00:23:38,640
So in this example we start at the root node which is labeled one and then we go down to the next level.

274
00:23:38,640 --> 00:23:43,040
And then you can see two three and four and then five and six and so on.

275
00:23:44,000 --> 00:23:50,800
And you can contrast that with depth first which is where you go all the way down as far as you can go a leg of a tree.

276
00:23:50,800 --> 00:23:57,280
Once you reach the bottom you go back up to the most recently visited node and then back down again as far as you can go.

277
00:23:57,280 --> 00:24:00,320
And you keep doing that until you've visited the whole tree.

278
00:24:01,040 --> 00:24:06,240
There are kind of guidelines around when you might want to use one of these methods over the other.

279
00:24:06,880 --> 00:24:12,320
We won't get into that here but there is some science around choosing which one to use in which situation.

280
00:24:14,480 --> 00:24:21,360
So that's it for the really specific you know data structure and algorithm stuff that you should probably know.

281
00:24:21,360 --> 00:24:29,360
Let's talk a little bit about coding challenges. My approach to coding challenges has always been quality over quantity.

282
00:24:29,440 --> 00:24:35,600
I think it's really easy to tell yourself oh just just 10 more challenges and then I'll be ready to interview.

283
00:24:36,400 --> 00:24:44,320
Or the other thing I've seen happen is people will just continually do coding challenges that that they can do that they can finish.

284
00:24:44,320 --> 00:24:48,800
And they don't go on to ones that are more complex.

285
00:24:48,800 --> 00:24:57,120
So a myth that I have seen a lot is this idea that I need to spend all of my time doing coding challenges.

286
00:24:57,120 --> 00:25:01,760
Since I won't get an offer unless I can solve them perfectly during a whiteboarding session.

287
00:25:03,360 --> 00:25:11,120
So reality number one is that just studying coding challenges alone is is not sufficient.

288
00:25:11,120 --> 00:25:17,600
Studying coding challenges is necessary but if you combine that with also studying other computer science concepts.

289
00:25:17,600 --> 00:25:22,720
Ultimately what you're doing over the long run is learning how to approach a variety of problems.

290
00:25:22,800 --> 00:25:28,080
And since you never know what's going to pop up in an interview the more types of problems you have seen.

291
00:25:28,880 --> 00:25:32,560
The more likely it is that something will trigger your memory when you're in an interview.

292
00:25:34,160 --> 00:25:38,960
The other reality is that you can get offers even if you don't finish a coding challenge.

293
00:25:39,600 --> 00:25:42,320
And the reason is that well there's many reasons.

294
00:25:42,320 --> 00:25:48,400
Sometimes the hiring manager might purposefully and knowingly give you a coding challenge that's too hard for you.

295
00:25:48,400 --> 00:25:53,760
Because they want to see how far you get or they want to test how you handle frustration.

296
00:25:53,760 --> 00:25:58,560
Or they may want to suss out how good you are at asking questions when you get stuck.

297
00:26:00,240 --> 00:26:04,000
In a situation like that where you're not able to finish a coding challenge.

298
00:26:04,000 --> 00:26:10,240
You can still get an offer but you have to demonstrate a lot of the other skills that we talked about earlier in this talk.

299
00:26:10,880 --> 00:26:17,440
The more non-technical skills because it's often a balance of comparing technical skill to.

300
00:26:17,920 --> 00:26:19,280
Who you are as a human being.

301
00:26:22,000 --> 00:26:25,280
There are lots of ways to practice what I call interview Python.

302
00:26:25,280 --> 00:26:29,600
Which is a Python that you would type to fill out a coding challenge.

303
00:26:29,600 --> 00:26:37,680
And I make this distinction because at least to me coding challenge Python feels a lot different than production Python.

304
00:26:37,680 --> 00:26:40,400
That I was writing you know over the last year.

305
00:26:40,400 --> 00:26:46,800
So I've linked to a number of different websites and platforms you can go to interactively solve coding challenges.

306
00:26:47,440 --> 00:26:49,680
And then there's also good old pen and paper.

307
00:26:49,680 --> 00:26:52,240
Or if you have a little mini whiteboard at home.

308
00:26:52,240 --> 00:26:58,880
You know the physical act of writing things out can also really help solidify concepts in your mind.

309
00:27:01,600 --> 00:27:06,720
So I recommend that you do work on coding challenges that actually challenge you.

310
00:27:06,720 --> 00:27:10,320
And don't get into this rut of only doing ones that feel comfortable.

311
00:27:11,040 --> 00:27:15,040
And then use the internet when those coding challenges cause you to get stuck.

312
00:27:16,000 --> 00:27:20,480
I would also encourage you as you're choosing which coding challenges to do.

313
00:27:20,480 --> 00:27:24,240
To be realistic about what your interviewer might be expecting from you.

314
00:27:25,120 --> 00:27:30,720
If this is your very first role out of a boot camp or out of a computer science program at college.

315
00:27:30,720 --> 00:27:33,760
And you're going for a junior level role.

316
00:27:33,760 --> 00:27:38,400
Your interviewer probably is not expecting you to know machine learning algorithms.

317
00:27:38,400 --> 00:27:42,400
Unless it's like a junior machine learning role.

318
00:27:42,400 --> 00:27:47,280
In which case you probably shouldn't spend your time studying those algorithms for your interview.

319
00:27:47,280 --> 00:27:51,760
You might be much better served studying a different set of coding challenges.

320
00:27:54,480 --> 00:27:55,840
So we're coming to a close.

321
00:27:55,840 --> 00:27:59,280
I wanted to provide some final thoughts around mindset.

322
00:28:01,120 --> 00:28:03,680
Failure and rejection are part of the process.

323
00:28:03,680 --> 00:28:07,680
I think this is something that we have probably all heard from people who love us.

324
00:28:07,680 --> 00:28:11,600
As they have watched us struggle through the interview process.

325
00:28:13,360 --> 00:28:17,200
It sounds great but for me it has been so hard to absorb.

326
00:28:18,240 --> 00:28:24,640
But I guess a bit of progress that I was finally able to make for myself is that okay fine.

327
00:28:24,640 --> 00:28:27,760
If it is part of the process I'm going to have to deal with it anyway.

328
00:28:27,760 --> 00:28:30,080
I would rather deal with it upfront.

329
00:28:30,080 --> 00:28:34,960
And incorporate what I learned from that rejection into my next interview.

330
00:28:34,960 --> 00:28:38,720
And incrementally make my interviews more and more successful.

331
00:28:38,720 --> 00:28:40,160
Until I finally get an offer.

332
00:28:40,800 --> 00:28:44,960
So I'm kind of going to twist this a little bit and say yes.

333
00:28:44,960 --> 00:28:48,080
Because it's part of the process I would encourage you to front load it.

334
00:28:48,800 --> 00:28:50,560
Apply for jobs before you're ready.

335
00:28:50,560 --> 00:28:52,960
Get as many phone screens as you can.

336
00:28:52,960 --> 00:28:54,080
Fail and fail and fail.

337
00:28:54,080 --> 00:28:58,480
And just recycle everything you learned from those failures into your next interview.

338
00:28:58,480 --> 00:28:59,360
And your next interview.

339
00:29:01,440 --> 00:29:02,240
Next one.

340
00:29:02,240 --> 00:29:03,120
I love this one.

341
00:29:03,920 --> 00:29:05,200
I made this one up myself.

342
00:29:06,240 --> 00:29:09,120
You don't need every company to want to hire you.

343
00:29:09,120 --> 00:29:12,240
It feels good if every company wants to hire you.

344
00:29:13,600 --> 00:29:18,560
Maybe for a small sliver of people every company does want to hire them.

345
00:29:18,560 --> 00:29:21,440
But most of us don't fall into that category.

346
00:29:21,440 --> 00:29:26,640
You only need one company to want to hire you to get a new job.

347
00:29:26,640 --> 00:29:28,320
And hopefully it's the right company.

348
00:29:29,440 --> 00:29:34,560
But if that is true you don't need to beat yourself up if a company decides not to move

349
00:29:34,560 --> 00:29:35,600
forward with you.

350
00:29:35,600 --> 00:29:40,320
It just means that they for whatever reason were not the right company at that time.

351
00:29:43,200 --> 00:29:47,280
So I want to bring it back to the crossword puzzle from 1942.

352
00:29:48,320 --> 00:29:53,920
Just to remind you that we have come a long way and while it may feel really overwhelming

353
00:29:53,920 --> 00:29:59,040
to think about studying data structures and algorithms and knowing all of these collection

354
00:29:59,040 --> 00:30:02,000
types and having to also remember to be a good human.

355
00:30:03,360 --> 00:30:08,880
It boils down to these essential things around problem solving and recognizing patterns

356
00:30:10,240 --> 00:30:11,120
and being curious.

357
00:30:13,360 --> 00:30:14,640
And also you got this.

358
00:30:15,280 --> 00:30:16,320
Go forth.

359
00:30:16,320 --> 00:30:17,120
Interview.

360
00:30:17,120 --> 00:30:18,240
Get offers.

361
00:30:18,240 --> 00:30:19,200
Accept offers.

362
00:30:20,160 --> 00:30:21,680
There's my email address.

363
00:30:21,680 --> 00:30:24,800
If you didn't get the slide link at the beginning you're welcome to email me.

364
00:30:24,800 --> 00:30:25,840
I can send you the link.

365
00:30:26,560 --> 00:30:30,560
Feel free to reach out and share any successes you might have.

366
00:30:30,560 --> 00:30:32,080
And again thank you for coming.

367
00:30:32,080 --> 00:30:41,280
I really appreciate it.

