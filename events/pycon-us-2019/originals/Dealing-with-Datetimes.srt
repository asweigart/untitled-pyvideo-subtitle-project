1
00:00:00,000 --> 00:00:15,480
Hopefully you all have maybe got some of these.

2
00:00:15,480 --> 00:00:18,920
I've never used these before, so I'm just going to try it out.

3
00:00:18,920 --> 00:00:25,120
The idea with these is if you need help, put up a little red thing.

4
00:00:25,120 --> 00:00:27,720
If you're good, put up a green one.

5
00:00:27,720 --> 00:00:33,440
There's a lot of people and I don't have any mentors to help out, so I can't guarantee

6
00:00:33,440 --> 00:00:37,160
that I'm going to be able to spend too much time with anybody.

7
00:00:37,160 --> 00:00:46,400
Ideally, if you finish early and someone else is struggling next to you, we could try and

8
00:00:46,400 --> 00:00:53,080
help each other, but I will try and respond to the stickies.

9
00:00:53,080 --> 00:00:54,720
I guess we'll get started.

10
00:00:54,720 --> 00:00:57,520
If you haven't already, please load up the binder link.

11
00:00:57,520 --> 00:01:03,680
Show of hands, who has already loaded the binder link?

12
00:01:03,680 --> 00:01:04,680
Let's do it the other way around.

13
00:01:04,680 --> 00:01:08,200
Who has not loaded the binder link?

14
00:01:08,200 --> 00:01:13,760
Of those, who is having trouble loading it?

15
00:01:13,760 --> 00:01:15,320
Who is having trouble with it?

16
00:01:15,320 --> 00:01:17,760
No one yet?

17
00:01:17,760 --> 00:01:23,080
Let's just assume that it's going to be okay and by the time we actually need it, the last

18
00:01:23,560 --> 00:01:24,560
stragglers will be fine.

19
00:01:24,560 --> 00:01:25,560
All right, great.

20
00:01:25,560 --> 00:01:38,240
I'm just going to start quickly with just a little overview of how this material is structured.

21
00:01:38,240 --> 00:01:43,000
On the repo link, actually, and in the binder, there's a lot more material than we're going

22
00:01:43,000 --> 00:01:46,400
to cover in this tutorial.

23
00:01:46,400 --> 00:01:51,000
I can pretend that it's because I wanted to give you guys extra material that you could

24
00:01:51,080 --> 00:01:54,640
but it's really because I don't know how long it takes to go through material.

25
00:01:54,640 --> 00:01:59,800
I just wrote twice as much as can be covered in three hours.

26
00:01:59,800 --> 00:02:01,880
There's plenty of extra bonus material.

27
00:02:01,880 --> 00:02:05,000
That may mean that we're going to be skipping some workbooks and some exercises are going

28
00:02:05,000 --> 00:02:08,760
to be just bonus exercises, but no worries.

29
00:02:08,760 --> 00:02:14,000
The material is also written to be done well.

30
00:02:14,000 --> 00:02:16,320
It works well in a self-paced manner.

31
00:02:16,320 --> 00:02:22,120
If you go through later, if you missed something today, or if you were like, oh, I really wanted

32
00:02:22,120 --> 00:02:27,440
to learn this particular thing, you should be able to just go into the binder link, into

33
00:02:27,440 --> 00:02:35,560
the materials and read what I've written and work through the exercises.

34
00:02:35,560 --> 00:02:40,160
The things that we are going to be covering are three things.

35
00:02:40,160 --> 00:02:44,120
The two big ones are going to be time zones and recurring events because those are kind

36
00:02:44,120 --> 00:02:50,200
of complicated and we'll have a little light fare, which is working with the serializing

37
00:02:50,200 --> 00:02:52,600
and deserializing date times.

38
00:02:52,600 --> 00:02:59,360
Unfortunately, the way it works out is that the fun exercises come at the end, so I'm

39
00:02:59,360 --> 00:03:04,960
going to try and make sure that we get to those more fun exercises by the time, with

40
00:03:04,960 --> 00:03:09,040
enough time for us to actually spend a good amount of time on them.

41
00:03:09,760 --> 00:03:15,360
It's going to be a mix of lectures and exercises, and it starts out a little lecture heavy and

42
00:03:15,360 --> 00:03:20,720
ends up a little exercise heavy.

43
00:03:20,720 --> 00:03:25,920
Before we do any of that, I just wanted to get us all on the same page about date times

44
00:03:25,920 --> 00:03:32,040
because when I've done this in the past, people have said that...

45
00:03:32,040 --> 00:03:36,720
Actually a little background about me, which is that for the past four or five years, I'm

46
00:03:36,760 --> 00:03:42,240
afraid to calculate it because then I'll realize how old I am and then that death comes for

47
00:03:42,240 --> 00:03:45,240
us all.

48
00:03:45,240 --> 00:03:49,560
But for the past four or five years, I've been maintaining the library DateUtil, which

49
00:03:49,560 --> 00:03:53,480
is a date time library, does parsing, time zones, things like that.

50
00:03:53,480 --> 00:03:56,520
We'll use it a lot in this material.

51
00:03:56,520 --> 00:04:00,960
But what that also means is that I've been kind of steeped in the world of date times

52
00:04:01,200 --> 00:04:08,200
and I have no problem talking about calendrical arithmetic and all kinds of other obscure

53
00:04:09,200 --> 00:04:10,360
date time terminology.

54
00:04:10,360 --> 00:04:17,360
So if I kind of use unfamiliar terminology or a concept that you're not familiar with,

55
00:04:19,000 --> 00:04:23,720
feel free to stop me and ask because I actually don't know, I don't remember which things

56
00:04:23,720 --> 00:04:27,600
that I learned while doing this and which things I can assume to become a knowledge.

57
00:04:27,600 --> 00:04:34,160
So feel free to stop me because there's a lot of details involved.

58
00:04:34,160 --> 00:04:39,000
But I know there are a couple of things that people have in the past had trouble with.

59
00:04:39,000 --> 00:04:41,560
I just want to establish the terminology.

60
00:04:41,560 --> 00:04:47,120
So the first thing, a very critical notion is the difference between absolute and civil

61
00:04:47,120 --> 00:04:48,880
times.

62
00:04:48,880 --> 00:04:52,160
And I don't know that there's a great standard terminology for this.

63
00:04:52,160 --> 00:04:53,800
So I call it absolute and civil times.

64
00:04:54,000 --> 00:04:56,480
Sometimes you can call it timestamps and wall times.

65
00:04:56,480 --> 00:05:00,300
But absolute times are a specific moment in time.

66
00:05:00,300 --> 00:05:07,000
So 15 minutes ago, 20 years ago, one minute after the beginning of the eunuchs epoch,

67
00:05:07,000 --> 00:05:11,240
those are all absolute times or timestamps.

68
00:05:11,240 --> 00:05:18,240
Civil times are kind of a related concept but what they are is the time it says on the

69
00:05:18,240 --> 00:05:19,160
wall.

70
00:05:19,520 --> 00:05:26,720
So civil times are not necessarily, they don't necessarily reflect how much time is elapsed

71
00:05:26,720 --> 00:05:28,280
between two events or anything.

72
00:05:28,280 --> 00:05:32,560
They're really more what a human would expect the time to be.

73
00:05:32,560 --> 00:05:38,680
So if we're going to have a meeting at noon and then all of a sudden the meaning of noon

74
00:05:38,680 --> 00:05:43,600
changes because like daylight saving time gets cancelled with two days notice.

75
00:05:43,600 --> 00:05:47,680
We're not going to start having that meeting at 11 o'clock because we agreed that our meeting

76
00:05:47,760 --> 00:05:49,760
is in 75 hours.

77
00:05:49,760 --> 00:05:53,000
We're going to have our meeting at noon because we're humans and we get to work at 9 and we

78
00:05:53,000 --> 00:05:55,200
have our meetings at noon.

79
00:05:55,200 --> 00:05:57,920
So I guess maybe people go to lunch at noon.

80
00:05:57,920 --> 00:05:59,840
I'm sorry, I'm actually not a human.

81
00:05:59,840 --> 00:06:01,020
I'm more of like a robot.

82
00:06:01,020 --> 00:06:05,840
So I don't really understand lunch and human breakfast.

83
00:06:05,840 --> 00:06:10,100
So with absolute times, they're usually the right choice for things in the past.

84
00:06:10,100 --> 00:06:13,540
So like logs, logging events.

85
00:06:13,540 --> 00:06:17,980
Sometimes they're used for things in the future like astronomical events or like chemical

86
00:06:17,980 --> 00:06:22,260
processes things that don't that where you care about the elapsed time.

87
00:06:22,260 --> 00:06:25,180
Civil times are usually the right choice for things in the future.

88
00:06:25,180 --> 00:06:30,100
So like meetings, events, alarms, things where what really matters is that you get there

89
00:06:30,100 --> 00:06:34,580
when everyone agrees that it's noon, not when a certain amount of time has passed.

90
00:06:34,580 --> 00:06:38,420
With absolute times, you can store them as UTC or as a fixed offset.

91
00:06:38,420 --> 00:06:42,260
And with civil times, you generally want to store the local time and sometimes you want

92
00:06:42,260 --> 00:06:43,580
to store the time zone that it's in.

93
00:06:43,580 --> 00:06:44,580
It depends.

94
00:06:44,580 --> 00:06:45,580
Okay.

95
00:06:45,580 --> 00:06:54,660
So with regards to and this is the slides a little bit with regards to so now that we've

96
00:06:54,660 --> 00:06:59,860
established that I'm going to talk about the Python's representation of daytimes.

97
00:06:59,860 --> 00:07:02,820
So Python has a standard library module called daytime.

98
00:07:02,820 --> 00:07:07,900
There's a class in there called daytime that represents a given daytime.

99
00:07:07,900 --> 00:07:08,900
Daytimes are immutable.

100
00:07:08,900 --> 00:07:14,060
So that means that if you try and assign one if you try and change the values of a daytime,

101
00:07:14,060 --> 00:07:15,060
it will not work.

102
00:07:15,060 --> 00:07:19,260
You know, this is useful when you so that you can use them in as the keys for a dictionary

103
00:07:19,260 --> 00:07:21,220
or something like that.

104
00:07:21,220 --> 00:07:24,980
But what that means is instead of if you want to get basically the same daytime but with

105
00:07:24,980 --> 00:07:27,780
something changed, you need to construct a new daytime.

106
00:07:27,780 --> 00:07:30,140
There's a convenience method for that called replace.

107
00:07:30,140 --> 00:07:35,420
So if you you can pass it any number of the keyword arguments that would be passed to

108
00:07:35,420 --> 00:07:36,420
the constructor.

109
00:07:36,420 --> 00:07:40,420
And that's essentially the same thing as saying give me the constructor for this daytime but

110
00:07:40,420 --> 00:07:43,100
with some of the arguments replaced with this.

111
00:07:43,100 --> 00:07:46,460
And this will construct a brand new daytime.

112
00:07:46,460 --> 00:07:50,180
So then there's also a time delta time.

113
00:07:50,180 --> 00:07:53,580
So normally if you think about if you have two integers and you subtract one integer

114
00:07:53,580 --> 00:07:55,380
from another, you get an integer back.

115
00:07:55,380 --> 00:08:00,340
And if you have two floats and you subtract two, you know, one float from another or add

116
00:08:00,340 --> 00:08:04,500
two floats together, you get another float.

117
00:08:04,500 --> 00:08:09,380
These are different in that the class that represents a difference in daytimes is not

118
00:08:09,380 --> 00:08:10,380
a daytime.

119
00:08:10,380 --> 00:08:11,380
It's some elapsed time.

120
00:08:11,380 --> 00:08:13,140
It's time delta.

121
00:08:13,140 --> 00:08:16,580
This represents the difference in the like wall times.

122
00:08:16,580 --> 00:08:18,980
It does not represent a difference in the elapsed time.

123
00:08:18,980 --> 00:08:22,020
So these are this is a difference in civil times basically.

124
00:08:22,020 --> 00:08:26,500
So we can look at that by saying, all right, here is November 2nd at noon.

125
00:08:26,500 --> 00:08:31,780
If I add 24 hours to that, what I get is November 3rd at noon, even though the daylight saving

126
00:08:32,020 --> 00:08:39,500
time has ended and now the UTC offset has changed.

127
00:08:39,500 --> 00:08:43,980
If I convert these both to UTC and then subtract one from the other, instead of getting 24

128
00:08:43,980 --> 00:08:47,140
hours, I get 25 hours, right?

129
00:08:47,140 --> 00:08:49,820
So that's just something to know.

130
00:08:49,820 --> 00:08:53,380
There's a whole workbook in here that we're not going to cover that covers some of the

131
00:08:53,380 --> 00:08:58,020
more complex aspects of arithmetic semantics.

132
00:08:58,020 --> 00:09:02,900
But I just wanted to get just the baseline settled there.

133
00:09:02,900 --> 00:09:06,620
And then another big thing is aware versus naive daytimes.

134
00:09:06,620 --> 00:09:10,380
So a naive daytime, that's just what it's called, is when it has no time zone information.

135
00:09:10,380 --> 00:09:13,700
So the time zone is set to none or it's not specified.

136
00:09:13,700 --> 00:09:17,900
And that just represents a daytime, basically local time.

137
00:09:17,900 --> 00:09:20,140
You can consider it local system time.

138
00:09:20,140 --> 00:09:22,780
You could also consider it an abstract daytime, right?

139
00:09:22,780 --> 00:09:28,500
You're just trying to do calendrical arithmetic.

140
00:09:28,500 --> 00:09:33,580
Basically if you want to know, November 4th is always more than November 5th in the abstract,

141
00:09:33,580 --> 00:09:37,340
even if there's some weird time zone where that's not the case.

142
00:09:37,340 --> 00:09:42,480
And then an aware daytime is one where you've attached a TZ info to it, right?

143
00:09:42,480 --> 00:09:48,080
So this is a daytime that is aware that it is in Eastern time.

144
00:09:48,080 --> 00:09:52,300
And we'll have a whole section on time zones where I go into all the implications of that.

145
00:09:52,980 --> 00:09:54,500
Okay, great.

146
00:09:54,500 --> 00:10:00,300
So now that that is covered, do we have any questions?

147
00:10:03,060 --> 00:10:04,060
Okay, great.

148
00:10:04,060 --> 00:10:09,140
So we're all on the same page and we will open up the first workbook.

149
00:10:09,140 --> 00:10:17,700
So the workbooks, if you've loaded a JupyterLab, I want to make sure this is in presentation mode.

150
00:10:17,900 --> 00:10:25,340
And all right, show of hands, who is having trouble seeing if I do this and like that?

151
00:10:25,340 --> 00:10:27,220
Is anyone having trouble seeing it?

152
00:10:27,220 --> 00:10:29,740
Okay, so a little bit bigger then.

153
00:10:29,740 --> 00:10:30,740
How about now?

154
00:10:30,740 --> 00:10:31,740
Anyone having trouble?

155
00:10:31,740 --> 00:10:36,620
Sure, does anyone in the back know how to do that?

156
00:10:36,620 --> 00:10:37,620
Or is this?

157
00:10:37,620 --> 00:10:41,980
All right, I'm just going to start pressing switches and let's just find out.

158
00:10:41,980 --> 00:10:42,980
No?

159
00:10:42,980 --> 00:10:46,460
I think I heard a fire alarm.

160
00:10:47,460 --> 00:10:49,220
Is that good?

161
00:10:49,220 --> 00:10:52,220
All right, great.

162
00:10:52,220 --> 00:10:56,740
Okay, so all right, now show of hands, anyone having trouble seeing this?

163
00:10:56,740 --> 00:11:00,700
Yes, the binder is here.

164
00:11:00,700 --> 00:11:06,500
Okay, so if you have the binder loaded up, you should see here, it probably started you

165
00:11:06,500 --> 00:11:08,980
in materials or it started you here.

166
00:11:08,980 --> 00:11:15,580
So you go into materials and then 01-time underscore zones and then load up the first

167
00:11:15,580 --> 00:11:18,620
workbook which is called Python underscore time zones.

168
00:11:18,620 --> 00:11:21,140
Okay, great.

169
00:11:21,140 --> 00:11:24,260
So now we'll start on working with time zones.

170
00:11:24,260 --> 00:11:29,460
And the first thing I want to address here is that sometimes what you'll hear from people

171
00:11:29,460 --> 00:11:33,700
is like, oh, I don't like to deal with time zones, I just convert everything to UTC as

172
00:11:33,700 --> 00:11:37,620
soon as I get it and then I work with that and it makes everything super easy, right?

173
00:11:37,620 --> 00:11:39,620
This is a fairly common refrain.

174
00:11:39,620 --> 00:11:45,540
It's probably a refrain that may be that may jive with your experience if you're like a

175
00:11:45,540 --> 00:11:49,420
Python admin or something who actually works with absolute times all the time.

176
00:11:49,420 --> 00:11:53,980
But if you're, say, working in like business where you care about market closes and actual

177
00:11:53,980 --> 00:11:58,220
human times or some kind of recurring events, you'll find that that is not actually the

178
00:11:58,220 --> 00:12:03,180
greatest advice because so for example, here, I've constructed an R rule and we'll spend

179
00:12:03,180 --> 00:12:06,540
more time on that later, but this is a recurring rule and what it's going to do is it's going

180
00:12:07,540 --> 00:12:17,580
times during the weekday at five o'clock in New York and that's basically market time

181
00:12:17,580 --> 00:12:21,460
for like market close time for like the New York Stock Exchange, right?

182
00:12:21,460 --> 00:12:25,980
So if I just look at this, you can see it says five o'clock on each of these days and

183
00:12:25,980 --> 00:12:31,860
at some point it switches from being standard time to daylight saving time, right?

184
00:12:31,860 --> 00:12:34,260
And that was just a smooth experience.

185
00:12:34,260 --> 00:12:39,260
Now, if I wanted to just use UTC, what we would get is something where here I'm just

186
00:12:39,260 --> 00:12:41,860
going to convert all those day times we just generated into UTC.

187
00:12:41,860 --> 00:12:47,100
You can see at some point, the market close time stops being at 10 o'clock and it starts

188
00:12:47,100 --> 00:12:48,820
being at like nine o'clock, right?

189
00:12:48,820 --> 00:12:53,700
So if you wanted to just use UTC, you'd have to kind of know what the rules are for that

190
00:12:53,700 --> 00:13:00,540
and then figure out all the kind of aspects of that and there is actually something that

191
00:13:00,540 --> 00:13:04,180
does figure out all those rules and that's the time zone objects.

192
00:13:04,180 --> 00:13:09,520
So unfortunately, as with far too many things with day times, there's not really simple

193
00:13:09,520 --> 00:13:10,520
rules.

194
00:13:10,520 --> 00:13:14,100
I'm not going to be able to just say like here's a little slogan that you can go and

195
00:13:14,100 --> 00:13:16,100
you will be a master of day times.

196
00:13:16,100 --> 00:13:20,660
What's going to happen is I'm going to say, oh, it depends on your use case and, you know,

197
00:13:20,660 --> 00:13:23,780
do really good job testing, I guess.

198
00:13:23,780 --> 00:13:27,900
But hopefully I can give you some ideas of what to look for and how to understand this

199
00:13:27,900 --> 00:13:33,060
problem so that you can identify when you need to understand the shades of meaning between

200
00:13:33,060 --> 00:13:34,060
things.

201
00:13:34,940 --> 00:13:41,340
In Python, the TZInfo class is an abstract base class and all the concrete implementations,

202
00:13:41,340 --> 00:13:46,020
they implement at least these three methods, TZName, UTCOffset and DST.

203
00:13:46,020 --> 00:13:54,700
I'm not going to go into too much detail about exactly what they do, but basically the TZName

204
00:13:54,700 --> 00:13:59,620
tells you what the localized name is at the time that you request it.

205
00:13:59,860 --> 00:14:07,260
UTCOffset is the offset and then DST is actually the difference between standard time and the

206
00:14:07,260 --> 00:14:08,820
current offset.

207
00:14:08,820 --> 00:14:12,940
I would say if you ever find yourself trying to use this DST method, you're probably doing

208
00:14:12,940 --> 00:14:14,300
something wrong.

209
00:14:14,300 --> 00:14:20,100
This concept is not universal enough that I think you can rely on it for all time zones

210
00:14:20,100 --> 00:14:25,140
and you can almost always get away with saying like I don't care whether it's daylight saving

211
00:14:25,140 --> 00:14:26,140
time or not.

212
00:14:26,140 --> 00:14:30,060
I just care about what the name is and what the offset is.

213
00:14:30,060 --> 00:14:38,300
But you'll notice that these all take DT as a parameter, right, and DT meaning daytime.

214
00:14:38,300 --> 00:14:45,420
That's because what happens is if you, what these are is they represent a mapping from

215
00:14:45,420 --> 00:14:51,620
the local time to the absolute time, right, or to the information that you, the information,

216
00:14:51,620 --> 00:14:54,720
the time zone information that applies at that time.

217
00:14:54,720 --> 00:14:59,280
So here I'm going to show you, I have this little function and this function, all it

218
00:14:59,280 --> 00:15:04,160
does is it invokes TZName, UTCOffset, and DST.

219
00:15:04,160 --> 00:15:06,800
And you'll notice that I'm actually invoking these on the daytime.

220
00:15:06,800 --> 00:15:12,800
That's because the TZName, the TZInfo methods are invoked by the daytime itself.

221
00:15:12,800 --> 00:15:16,840
So you only have to know that they're on the TZInfo if you're implementing a TZInfo and

222
00:15:16,840 --> 00:15:20,560
you should probably not be implementing a TZInfo.

223
00:15:20,560 --> 00:15:22,680
So here I just have this thing.

224
00:15:22,680 --> 00:15:27,480
It's going to invoke them, it's going to print these out and I'm going to create a single

225
00:15:27,480 --> 00:15:28,480
time zone object.

226
00:15:28,480 --> 00:15:35,080
This is like, represents Eastern time and I'm using DateUtils TZ module for that.

227
00:15:35,080 --> 00:15:40,560
And then I create a daytime that's in the standard time zone and if I execute that, you can see

228
00:15:40,560 --> 00:15:45,480
that it says Eastern standard time, right, that's what applied on March 1st.

229
00:15:45,480 --> 00:15:47,600
Minus five, no daylight saving time.

230
00:15:47,600 --> 00:15:54,320
And then if I attach the exact same TZInfo to a daytime one month later, which is in

231
00:15:54,320 --> 00:15:56,880
daylight saving time, the offsets change, right?

232
00:15:56,880 --> 00:16:02,960
So this is something to note is that generally you're attaching the exact same Python object

233
00:16:02,960 --> 00:16:09,760
to more than one daytime and these map and it's just a lazily implemented mapping to

234
00:16:09,760 --> 00:16:11,160
get the time zone offsets.

235
00:16:11,160 --> 00:16:13,940
All right, so I have this example.

236
00:16:13,940 --> 00:16:18,100
This was originally an exercise but to be honest, I really don't want to be encouraging

237
00:16:18,100 --> 00:16:24,180
people to be implementing their own time zone classes just because really the answer is

238
00:16:24,180 --> 00:16:27,120
like use a third party time zone provider.

239
00:16:27,120 --> 00:16:37,100
But I can show you how it works which is like def tzname self dt return utc def utc offset

240
00:16:37,320 --> 00:16:41,120
self dt return time delta zero.

241
00:16:41,120 --> 00:16:49,400
I don't know if I imported time delta so I'm going to say from daytime import time delta.

242
00:16:49,400 --> 00:16:54,020
And then I'm going to do def dst self dt.

243
00:16:54,020 --> 00:16:57,340
So this is one thing that you should, that may be worth knowing.

244
00:16:57,340 --> 00:17:02,240
So reasonably speaking, you could return time delta zero here as well because it's always

245
00:17:02,240 --> 00:17:06,200
zero but sometimes for these fixed offsets and in the standard library they do this,

246
00:17:06,300 --> 00:17:11,420
you return none and I think that's useful for certain third party libraries if they

247
00:17:11,420 --> 00:17:15,660
want to detect whether something is a fixed offset or whether it has rules that just aren't

248
00:17:15,660 --> 00:17:17,280
in effect.

249
00:17:17,280 --> 00:17:22,740
I don't rely on it because I don't know that people consistently know about that but there

250
00:17:22,740 --> 00:17:23,740
we go.

251
00:17:23,740 --> 00:17:27,040
That's our UTC thing and these tests, I don't know, that's not a great visual spectacle

252
00:17:27,040 --> 00:17:32,580
but behind the scenes I tested it against the standard library tzinfo.

253
00:17:33,120 --> 00:17:37,720
Okay, so let's get into something a little meatier which is what you probably should

254
00:17:37,720 --> 00:17:42,400
be doing which is working with third party time zone providers.

255
00:17:42,400 --> 00:17:49,280
So there's a little more complexity than we would hope because of historical reasons but

256
00:17:49,280 --> 00:17:53,480
I'm just going to go through, I'm going to be talking about dateutil which is the library

257
00:17:53,480 --> 00:17:56,200
I maintain is also the best library.

258
00:17:56,200 --> 00:18:00,200
That's a completely objective opinion.

259
00:18:00,260 --> 00:18:04,020
And I'm also going to be talking about PyTz which is a legacy module that you should never

260
00:18:04,020 --> 00:18:10,380
use but no honestly it served its purpose very well and there's probably a lot of code

261
00:18:10,380 --> 00:18:15,740
out there that is working perfectly fine that's using PyTz and it is a little dangerous so

262
00:18:15,740 --> 00:18:19,980
you may, I'm just going to try and go through a couple of edge cases so if you see something

263
00:18:19,980 --> 00:18:22,260
like this in production you can fix it.

264
00:18:22,260 --> 00:18:24,720
Okay, so we'll start with our eastern time zone again.

265
00:18:24,720 --> 00:18:31,580
You can see that if I attach it to this date time we have our standard thing, this is 2

266
00:18:31,580 --> 00:18:34,140
o'clock eastern daylight time, right?

267
00:18:34,140 --> 00:18:40,140
So the way I've used this is I've taken the eastern object and I just attached it to the

268
00:18:40,140 --> 00:18:45,220
date time by passing it to the tzinfo argument of the constructor.

269
00:18:45,220 --> 00:18:48,260
I'm not sure if you can pass this positionally, I never do it though.

270
00:18:48,280 --> 00:18:54,960
I always pass this as a keyword argument just, I don't know, it makes things a little clear

271
00:18:54,960 --> 00:18:58,680
just because there's so many positional arguments for date times.

272
00:18:58,680 --> 00:19:05,000
So if I have this thing that I've constructed, if I want to reinterpret this as being in

273
00:19:05,000 --> 00:19:06,000
another time zone, right?

274
00:19:06,000 --> 00:19:09,440
So say we have some meeting that's in New York and then everyone from the meeting all

275
00:19:09,440 --> 00:19:14,120
goes to San Francisco all at the same time and so the meeting is still at 2 o'clock but

276
00:19:14,120 --> 00:19:15,840
we need to just shift the time zone.

277
00:19:15,940 --> 00:19:21,940
I'm just going to use dt.replace, oh and I accidentally pressed capital Z there, and

278
00:19:21,940 --> 00:19:29,420
you can see now here I have 2 o'clock UTC minus 4, the second one is UTC minus 7.

279
00:19:29,420 --> 00:19:33,060
If I want to reinterpret the original meeting, right, so for example in the original meeting

280
00:19:33,060 --> 00:19:36,860
everyone was in New York, maybe instead of everyone moving to San Francisco, someone

281
00:19:36,860 --> 00:19:41,020
from the San Francisco office is now calling in and so we want to know what time they should

282
00:19:41,020 --> 00:19:45,260
call in and the answer is 11 o'clock and we got that from using as time zone.

283
00:19:45,280 --> 00:19:51,960
So replace is saying, just reinterpret this, as time zone is saying kind of do a unit conversion,

284
00:19:51,960 --> 00:19:56,320
give me the same absolute time but represented in a different local time.

285
00:19:56,320 --> 00:20:02,680
Okay, so with PyTZ if you use as time zone it works exactly as expected and in general

286
00:20:02,680 --> 00:20:06,320
PyTZ works well with these methods where you're taking something where you know the absolute

287
00:20:06,320 --> 00:20:09,480
time and converting it to another absolute time.

288
00:20:09,480 --> 00:20:13,760
But if you use a constructor or the replace method which is equivalent, it actually fails

289
00:20:13,780 --> 00:20:14,780
horribly.

290
00:20:14,780 --> 00:20:20,540
So if you notice now what I've done is I've tried to put this in Los Angeles time but

291
00:20:20,540 --> 00:20:24,660
instead of getting what we were expecting up here which is Pacific Daylight Time we're

292
00:20:24,660 --> 00:20:30,880
getting this thing called LMT and its offset is 7 hours and 53 minutes or 7.88 hours so

293
00:20:30,880 --> 00:20:33,900
that's obviously weird, right?

294
00:20:33,900 --> 00:20:43,540
The reason for this is that PyTZ does not use the standard Python time zone model and

295
00:20:43,560 --> 00:20:47,480
I think it's a little beyond scope of this talk to explain exactly why that is but I

296
00:20:47,480 --> 00:20:50,280
do have a blog post on that.

297
00:20:50,280 --> 00:20:54,240
Needless to say it was a good idea at the time and it is no longer really applicable

298
00:20:54,240 --> 00:20:58,840
but what that means is that you can't just attach PyTZ zones either with replace or with

299
00:20:58,840 --> 00:21:02,840
the constructor, what you need to do is you need to call localize on the zone itself because

300
00:21:02,840 --> 00:21:10,520
what PyTZ does is instead of acting as a mapping it just is a factory for static mapping objects,

301
00:21:10,620 --> 00:21:16,100
it's just like when I made that UTC and I hard coded what the TZ name is for all the

302
00:21:16,100 --> 00:21:23,420
date times, PyTZ does that for everything and it decides which offset to attach when

303
00:21:23,420 --> 00:21:25,540
you call localize on the date time.

304
00:21:25,540 --> 00:21:32,180
So here if I use localize and actually I'm just going to change this to Los Angeles so

305
00:21:32,180 --> 00:21:36,740
if I call Los Angeles now we get what we were expecting if we're using localize instead

306
00:21:36,740 --> 00:21:39,140
of just using the constructor.

307
00:21:39,140 --> 00:21:44,420
The same thing will happen if you use arithmetic because if you add 180 days or 6 months or

308
00:21:44,420 --> 00:21:48,840
something what that's basically doing is it calculates what the new date time is and then

309
00:21:48,840 --> 00:21:53,220
attaches the same time zone object to the result.

310
00:21:53,220 --> 00:21:57,200
So what that means is that for date util it works fine because if we add 6 months now

311
00:21:57,200 --> 00:22:01,200
we're in standard time.

312
00:22:01,200 --> 00:22:02,200
Now we're in standard time.

313
00:22:02,200 --> 00:22:08,340
Now I have to change this back.

314
00:22:08,340 --> 00:22:13,700
So now we're in standard time 6 months later but with PyTZ because the same it's hard coded

315
00:22:13,700 --> 00:22:19,860
and doesn't actually pay attention to the date time argument then what that means is

316
00:22:19,860 --> 00:22:24,060
that you're going to see EDT even though this never existed, it was never Eastern Daylight

317
00:22:24,060 --> 00:22:26,380
Time in February.

318
00:22:26,380 --> 00:22:30,460
To fix that you have to call the normalize method which will give you what you would

319
00:22:30,460 --> 00:22:36,480
expect by calling normalize on the result.

320
00:22:36,480 --> 00:22:43,560
So generally my advice is if you see something using PyTZ see if you can use date util instead

321
00:22:43,560 --> 00:22:48,800
and if not you just have to be aware of making sure that you're very diligent about using

322
00:22:48,800 --> 00:22:52,240
localize and normalize.

323
00:22:52,240 --> 00:22:56,800
There are also alternate constructors not the main constructor so there's datetime.now

324
00:22:56,800 --> 00:22:59,440
and datetime.fromTimeStamp.

325
00:22:59,440 --> 00:23:05,440
Both of these take a TZ argument so if you call datetime.now or datetime.fromTimeStamp

326
00:23:05,440 --> 00:23:08,640
both of these are going to take basically an absolute time.

327
00:23:08,640 --> 00:23:13,800
Right now is an absolute time, it's a specific moment in time and they're going to represent

328
00:23:13,800 --> 00:23:16,600
that in your local system time.

329
00:23:16,600 --> 00:23:21,760
Time stamps are also an absolute time, they're Unix epoch times or whatever so they're always

330
00:23:21,760 --> 00:23:25,900
denoted in, they're just numbers, this number of seconds after the Unix epoch so that's

331
00:23:25,900 --> 00:23:27,280
also an absolute time.

332
00:23:27,280 --> 00:23:33,520
Both of these will give you naive datetimes that are represented in the system local time

333
00:23:33,680 --> 00:23:39,480
so the result of this from time stamp will depend on what system you're on.

334
00:23:39,480 --> 00:23:46,640
So here it's 20-20-1-1 I think on the binder because this is running on my laptop which

335
00:23:46,640 --> 00:23:47,880
is set to eastern time.

336
00:23:47,880 --> 00:23:52,020
On the binder this will probably give you a different result like 10 o'clock or something

337
00:23:52,020 --> 00:23:54,640
like that.

338
00:23:54,640 --> 00:24:02,880
So I generally prefer if possible to attach a time zone to it unless you really just want

339
00:24:02,880 --> 00:24:08,440
the local system time that's fine but you can attach a system time to it and it will

340
00:24:08,440 --> 00:24:12,120
work just fine with PyTZ and with datetil.

341
00:24:12,120 --> 00:24:19,400
So here if I take from time zone and I want it in eastern time in both cases I'll get

342
00:24:19,400 --> 00:24:24,480
I'm not sure why those are different.

343
00:24:24,480 --> 00:24:25,480
It doesn't really matter.

344
00:24:25,480 --> 00:24:32,840
What I said is true so I think I may have done something funky here but in any case

345
00:24:33,120 --> 00:24:38,560
you'll see that this is the local time that corresponds to that absolute time in that

346
00:24:38,560 --> 00:24:39,560
time zone.

347
00:24:39,560 --> 00:24:45,640
So generally speaking if you want the local time like now in UTC use datetime.now and

348
00:24:45,640 --> 00:24:52,200
then pass tz equals tz UTC or whatever UTC object you're using.

349
00:24:52,200 --> 00:24:57,520
There are these sort of semi-deprecated methods in the standard library UTC now and UTC from

350
00:24:58,520 --> 00:25:05,520
which will give you a naive local time that is basically the same as passing UTC to the

351
00:25:05,520 --> 00:25:13,520
tz argument and then removing the time zone but honestly I don't recommend using these

352
00:25:13,520 --> 00:25:19,840
because there are other parts of Python that treat naive time zones as local times and

353
00:25:19,840 --> 00:25:20,960
it will cause confusion.

354
00:25:20,960 --> 00:25:28,160
So generally if you want the local time in UTC use the tz argument.

355
00:25:28,160 --> 00:25:37,040
So this brings us to our first argument and I'm sorry that I talked for so long.

356
00:25:37,040 --> 00:25:41,520
And here we're going to work on getting the current time in multiple time zones.

357
00:25:41,520 --> 00:25:47,640
So let's practice using time zones by implementing this function and this function is going to

358
00:25:47,640 --> 00:25:52,480
take as an argument a list of strings and you can pass to get time zones from those

359
00:25:52,480 --> 00:26:03,480
strings if you have from datetale import tz you can do say tokyo equals tz dot get tz

360
00:26:03,480 --> 00:26:09,640
this is the best way to get a time zone from a string.

361
00:26:10,640 --> 00:26:17,640
And that will give you the time zone that you want.

362
00:26:17,640 --> 00:26:24,160
So here just implement this function and what we'd like to do is we'd like to see the current

363
00:26:24,160 --> 00:26:30,960
time printed in all the time zones that are in the list and you'll note that these are

364
00:26:30,960 --> 00:26:36,640
all the exact same time they're not like milliseconds or microseconds after each other that's because

365
00:26:36,640 --> 00:26:41,320
I only use datetime.now one time if you call datetime.now like five times you'll get slightly

366
00:26:41,320 --> 00:26:44,200
different times because it has microsecond precision.

367
00:26:44,200 --> 00:26:50,280
So yeah so go ahead try and implement that and try and use exactly one thing.

368
00:26:50,280 --> 00:26:54,880
If you're having trouble getting started put up one of the red post-its I'll give you a

369
00:26:54,880 --> 00:26:55,880
couple minutes.

370
00:26:55,880 --> 00:26:59,800
Let's take like 10 or 15 minutes for this.

371
00:26:59,800 --> 00:27:03,840
Oh and when you're done put up the green one.

372
00:27:03,840 --> 00:27:10,280
If I start seeing a lot of green in five minutes then we can just move on.

373
00:28:03,840 --> 00:28:12,200
Okay.

374
00:28:33,840 --> 00:28:35,900
you

375
00:29:03,840 --> 00:29:06,900
you

376
00:29:33,840 --> 00:29:36,900
you

377
00:30:03,840 --> 00:30:06,900
you

378
00:30:33,840 --> 00:30:36,900
you

379
00:31:03,840 --> 00:31:06,900
you

380
00:31:33,840 --> 00:31:36,900
you

381
00:32:03,840 --> 00:32:06,900
you

382
00:32:33,840 --> 00:32:36,900
you

383
00:33:03,840 --> 00:33:06,900
you

384
00:33:33,840 --> 00:33:35,900
you

385
00:34:03,840 --> 00:34:05,900
you

386
00:34:08,840 --> 00:34:14,500
anyone else having trouble okay

387
00:34:33,840 --> 00:34:35,900
you

388
00:34:41,840 --> 00:34:46,840
if you're still working feel free to continue working or I can I'm just

389
00:34:46,840 --> 00:34:54,840
going to run through it real quick do a live code and then you know if you want

390
00:34:54,840 --> 00:35:00,040
to try and if you're having problems still and you want to try and see how I

391
00:35:00,040 --> 00:35:03,000
did it hopefully this will help okay so I'm going to show you how I would do

392
00:35:03,000 --> 00:35:07,000
this there's like basically a bunch of slightly different ways that are we'll

393
00:35:07,000 --> 00:35:13,080
all have the same effect so the first thing I'm going to do is I don't really

394
00:35:13,080 --> 00:35:16,600
want to worry about the edge cases with the lists and stuff so I'm just going

395
00:35:16,600 --> 00:35:22,320
to say from date time import time zone I could use it also I could also use date

396
00:35:22,320 --> 00:35:26,080
utils UTC but I'm just going to show you this because then you'll know that it

397
00:35:26,080 --> 00:35:31,880
exists and then I'm going to say dt equals date time dot now time zone dot

398
00:35:31,880 --> 00:35:38,040
UTC that'll get me the daytime in UTC this could be any aware daytime I just

399
00:35:38,040 --> 00:35:47,720
picked UTC because it's a nice reference time and then we'll say for TZS in TZ

400
00:35:47,720 --> 00:36:06,640
list DT say DTL equals DT dot as time zone TZ dot get TZ TZS print DTL and

401
00:36:06,640 --> 00:36:13,560
then there we go oh and if I wanted to have this thing I have to have some more

402
00:36:13,560 --> 00:36:19,960
complicated formatter right so I do something like TZS colon I'm not going to

403
00:36:19,960 --> 00:36:23,640
bother with the other part where it gets them all aligned to the right at the

404
00:36:23,640 --> 00:36:28,960
same time but that is in the answers oh there's also answers for all of these as

405
00:36:28,960 --> 00:36:34,240
well like it's in a Python file that's sibling to the to the exercises forgot

406
00:36:34,240 --> 00:36:39,320
to mention them okay great so does anyone have any questions so far on just

407
00:36:39,320 --> 00:36:47,000
working with time zones by TZ versus date util anything like that time zone

408
00:36:47,000 --> 00:36:53,800
dot UTC is a time zone object which is a subclass of TZ info time zone and time

409
00:36:53,800 --> 00:36:58,360
zone time zone dot UTC is a singleton it's a single instance of time zone

410
00:36:58,360 --> 00:37:04,080
which is fixed offsets and that was added in Python 3.2 so if you use Python

411
00:37:04,080 --> 00:37:08,800
2.7 you you won't be able to use this time zone dot UTC but all of that stuff

412
00:37:08,800 --> 00:37:14,360
is in date util so if you use TZ dot UTC which is another UTC singleton that will

413
00:37:14,360 --> 00:37:20,160
work just as well okay any other questions

414
00:37:24,160 --> 00:37:33,280
yeah is this visible now it's all right even bigger well you should oh yeah here

415
00:37:33,280 --> 00:37:38,240
we go so yeah also pretty I don't know if I did exactly the same thing but I

416
00:37:38,240 --> 00:37:43,680
probably did a much more correct version of it in the in this sibling directory

417
00:37:43,680 --> 00:37:48,560
so if you go to TZ answers you can you can see what you know how I implemented

418
00:37:48,560 --> 00:37:55,160
it there if you if you're having trouble reading the screen okay all right so I'm

419
00:37:55,160 --> 00:38:00,560
gonna move on to the next case which is this is our first interesting edge case

420
00:38:00,560 --> 00:38:08,600
which is ambiguous and imaginary times so obviously and you're always talking

421
00:38:08,600 --> 00:38:13,440
at the water cooler like oh did you see that ambiguous time like so ambiguous

422
00:38:13,440 --> 00:38:19,360
and then they'll be like yeah at least it wasn't imaginary right am I right okay

423
00:38:19,360 --> 00:38:26,060
so but no obviously this is not water cooler gossip this is this is a specific

424
00:38:26,060 --> 00:38:34,180
daytime terminology so an ambiguous time is when you have in a given zone two

425
00:38:34,180 --> 00:38:38,780
different absolute times that map to the same local wall time right so this will

426
00:38:38,780 --> 00:38:44,020
happen anytime you set your clocks back so here I guess it was like Halloween

427
00:38:44,020 --> 00:38:51,020
2004 was I guess a Sunday so the way it worked was that at two o'clock so first

428
00:38:51,020 --> 00:38:57,220
it was 130 and then it was 149 and then it was one o'clock right and the only

429
00:38:57,220 --> 00:39:01,300
difference was Eastern one is Eastern daylight time the other is Eastern

430
00:39:01,300 --> 00:39:05,260
standard time for a long time Python could just literally not handle this

431
00:39:05,260 --> 00:39:10,500
because there was no as we talked about before the TZ info is a mapping from

432
00:39:10,500 --> 00:39:15,180
wall times the naive portion of the daytime to the information that applies

433
00:39:15,180 --> 00:39:20,260
at that time right but these daytime are actually distinguished only by the

434
00:39:20,260 --> 00:39:26,860
offset information so the the only it needs to be an input to the function but

435
00:39:26,860 --> 00:39:29,620
it's also the output that you're trying to calculate so there was just no way to

436
00:39:29,620 --> 00:39:34,260
express this you couldn't round trip anything like this this is in fact why

437
00:39:34,260 --> 00:39:40,980
pi tz has its weird interface because it can handle this but in Python 3.6 pep

438
00:39:40,980 --> 00:39:47,680
495 was accepted and what that does is it introduces a fold attribute to

439
00:39:48,280 --> 00:39:54,080
so what it does is it just adds fold if you set fold equal to one if you set

440
00:39:54,080 --> 00:39:59,240
fold equal if folded defaults to zero if it's zero then it just represents the

441
00:39:59,240 --> 00:40:03,520
first occurrence of the daytime if it's one it represents the second occurrence

442
00:40:03,520 --> 00:40:09,600
of the daytime and zero and one of the only valid options so now we have this

443
00:40:09,600 --> 00:40:16,880
solved and detail can handle this one but of course there's only ever using

444
00:40:16,880 --> 00:40:29,320
Python 3.6 or greater but there is a there is a backport for this so in detail

445
00:40:29,320 --> 00:40:35,240
here I guess what I'm oh so I'll tell I'll talk about the backport in a second

446
00:40:35,240 --> 00:40:41,040
sorry right so if you're dealing with these ambiguous times as time zone will

447
00:40:41,040 --> 00:40:45,560
just always work both for date util and pi tz right because again this is

448
00:40:45,560 --> 00:40:50,120
another one of those situations where this is another one of those situations

449
00:40:50,120 --> 00:40:57,080
where having an existing having an existing absolute time makes these much

450
00:40:57,080 --> 00:41:00,800
easier right so pi tz is always able to calculate the right offset given an

451
00:41:00,800 --> 00:41:05,960
existing absolute time using and date util is always able to calculate what

452
00:41:05,960 --> 00:41:09,920
fold should be given an absolute time because it knows how to do the mapping

453
00:41:09,920 --> 00:41:16,080
pi tz obviously also knows how to do this if you have a sort of naive time if

454
00:41:16,080 --> 00:41:19,800
you're doing replace or wall time or something and you need backwards

455
00:41:19,800 --> 00:41:25,800
compatibility for Python 2 detail also provides an in fold method so what this

456
00:41:25,800 --> 00:41:31,680
does is that on Python 3 it just is like replace fold equals 1 with a little bit

457
00:41:31,680 --> 00:41:38,040
of logic to not do any replacement if the fold is already 1 right but on Python

458
00:41:38,040 --> 00:41:45,160
2 what this does is that if the fold needs to be set to 1 then it will give

459
00:41:45,160 --> 00:41:51,200
you a backport like a backported object which is called date time with fold and

460
00:41:51,200 --> 00:41:55,960
that just adds fold back into the into date time generally speaking you don't

461
00:41:55,960 --> 00:42:00,840
like print these the wrappers of these things but essentially in any case that

462
00:42:00,840 --> 00:42:05,280
I've ever seen you can just use tz dot in fold for all backwards compatible

463
00:42:05,280 --> 00:42:10,000
cases and then when you go to Python 3 only you just replace it with just

464
00:42:10,000 --> 00:42:18,360
regular fold equals 1 okay so that's one side of the story right which is sort of

465
00:42:18,360 --> 00:42:22,360
working with it if you already know that something is ambiguous and you want to

466
00:42:22,360 --> 00:42:30,320
choose one or the other if you want to detect ambiguous times detail will will

467
00:42:30,320 --> 00:42:35,800
has a function for that generally speaking if you just want to always

468
00:42:35,800 --> 00:42:42,280
default to STD you can just pass fold right so if you just pass fold equals 1

469
00:42:42,280 --> 00:42:49,280
then the fold is actually ignored in any case where it's not ambiguous so you

470
00:42:49,280 --> 00:42:52,400
don't really have to know this information too much the one time that

471
00:42:52,400 --> 00:42:56,760
you would want to like call this function is if you have a situation

472
00:42:57,080 --> 00:43:02,720
where you as the developer don't actually know what you want the user to

473
00:43:02,720 --> 00:43:06,320
do or something right so it's actually an ambiguous case and you're saying this

474
00:43:06,320 --> 00:43:11,640
is out of scope or I need to query for for what to do in this case I need a you

475
00:43:11,640 --> 00:43:15,520
know I need a policy or something so you would do something like raise an

476
00:43:15,520 --> 00:43:19,640
exception if if there's an ambiguous case or maybe you just log it right you

477
00:43:19,640 --> 00:43:24,520
say this was an ambiguous case I defaulted to the daylight saving time and

478
00:43:24,600 --> 00:43:28,640
yeah if you just set fold equals one it'll always it'll always it'll just

479
00:43:28,640 --> 00:43:33,120
ignore it if you're not ambiguous okay so the next step is thinking about

480
00:43:33,120 --> 00:43:39,640
imaginary times so the conjugate of ambiguous times where there's two wall

481
00:43:39,640 --> 00:43:46,840
times that have the same nominal value is imaginary times when a nominal wall

482
00:43:46,840 --> 00:43:51,320
clock never even exists in a zone so I mean for some examples you could say

483
00:43:51,320 --> 00:43:56,040
like that example where pi tz was attaching EDT to something in February

484
00:43:56,040 --> 00:43:59,480
that is a kind of ambiguous time or a kind of imaginary time but the more

485
00:43:59,480 --> 00:44:04,360
common one is when there's a gap because you've you're switching your clocks

486
00:44:04,360 --> 00:44:10,480
forward so in this case here it was you know in March of 2004 it was what it was

487
00:44:10,480 --> 00:44:16,940
159 and then it was three o'clock right so nothing about Python will stop you

488
00:44:16,940 --> 00:44:22,700
from constructing an imaginary time right because Python is very lazy about

489
00:44:22,700 --> 00:44:26,260
its time zone handling you only get that information if you need it so if I go

490
00:44:26,260 --> 00:44:32,900
through and I just add one hour or or just do a replace you can see it'll

491
00:44:32,900 --> 00:44:40,060
happily construct imaginary times that's why that detail has this tz dot daytime

492
00:44:40,060 --> 00:44:44,300
exists function so you can check if it exists and then do something with it

493
00:44:44,300 --> 00:44:47,180
whatever you want to do with it right if it doesn't if the time zone doesn't if

494
00:44:47,180 --> 00:44:52,220
the daytime doesn't exist in that time zone you can you know make your choice

495
00:44:52,220 --> 00:44:57,620
there's also this thing called resolve imaginary that I added and that

496
00:44:57,620 --> 00:45:02,540
essentially just skips you forward so if I think you know a lot of times this is

497
00:45:02,540 --> 00:45:06,420
what you want so you're going one you're adding one hour at a time and then

498
00:45:06,420 --> 00:45:10,660
there's a gap right and if you fall into the gap a lot of times you're just like

499
00:45:11,620 --> 00:45:20,940
instead of going from you know from 1 30 to 2 30 just go 130 to 330 but if that

500
00:45:20,940 --> 00:45:26,540
gap is some other weird amount of time that's you can't always just add an hour

501
00:45:26,540 --> 00:45:34,020
so resolve imaginary handles that so here's a case where in Kirboss in like

502
00:45:34,020 --> 00:45:38,180
1994 they wanted to switch which side of the international dateline they were on

503
00:45:38,180 --> 00:45:45,020
so there was just a missing day and I think I guess the missing day was all of

504
00:45:45,020 --> 00:45:49,860
December 31st so it was like December 30th and then the next day was January

505
00:45:49,860 --> 00:45:56,620
1st so an interesting story about this this was in my test suite in date detail

506
00:45:56,620 --> 00:46:00,900
and then someone was like digging through the like South Pacific news

507
00:46:00,900 --> 00:46:05,700
newspapers or whatever and they're like you know in the time zone database this

508
00:46:05,700 --> 00:46:08,980
is saying that January 1st was skipped but in the newspapers it says that

509
00:46:08,980 --> 00:46:13,260
December 31st was the one that was skipped and then they're like oh that

510
00:46:13,260 --> 00:46:16,940
was our mistake and then they updated it and now I have this weird check which is

511
00:46:16,940 --> 00:46:20,020
like oh is this imaginary well maybe a little check if the other one's

512
00:46:20,020 --> 00:46:24,780
imaginary so even like the past is sometimes the mappings in the past are

513
00:46:24,780 --> 00:46:31,900
sometimes not super stable okay so again I recommend using date

514
00:46:31,900 --> 00:46:37,500
detail but if you have to use pi tz I'm going to just give you the information

515
00:46:37,500 --> 00:46:43,180
that you need to understand it so with pi tz they use the localize function and

516
00:46:43,180 --> 00:46:49,100
if you localize something it defaults to the if you localize an ambiguous

517
00:46:49,100 --> 00:47:00,780
daytime it will default to the to the the standard side which was what the

518
00:47:00,780 --> 00:47:08,660
Python standard library originally said to do if you want to get the first

519
00:47:08,660 --> 00:47:14,140
occurrence or the daylight saving time side you pass to localize is underscore

520
00:47:14,140 --> 00:47:18,940
DST equals true and I think that's ignored if it's not ambiguous so here

521
00:47:18,940 --> 00:47:24,180
if I want to localize these you can pass is DST equals false or nothing and it'll

522
00:47:24,180 --> 00:47:28,980
give you the standard side passes DST equals true and it will give you the

523
00:47:28,980 --> 00:47:34,220
daylight saving time side but if you want to detect ambiguous times then you

524
00:47:34,220 --> 00:47:39,660
pass is DST equals none and what it'll do is it will throw this ambiguous time

525
00:47:39,660 --> 00:47:46,620
error so if you want to recreate the date detail version of the daytime

526
00:47:46,620 --> 00:47:54,860
underscore ambiguous then you would just do this try catch for imaginary times pi

527
00:47:54,860 --> 00:48:01,820
tz will happily create a an imaginary daytime and then it'll just assign it

528
00:48:01,820 --> 00:48:07,180
like an offset based on what you say for is DST which again I think defaults to

529
00:48:07,180 --> 00:48:15,940
false and if you pass and if you pass it none then it will raise this pi tz dot

530
00:48:15,940 --> 00:48:23,340
non-existent time error so basically you can get you know other than the fact

531
00:48:23,340 --> 00:48:29,100
that pi tz uses weird localized method they have they have a method to handle

532
00:48:29,100 --> 00:48:32,660
everything you can do with the date util with pi tz though again I don't

533
00:48:32,660 --> 00:48:39,500
necessarily recommend it so here's another exercise which is hopefully we

534
00:48:39,500 --> 00:48:45,300
have yeah I think we have time for this what I'd like you to do is say that you

535
00:48:45,300 --> 00:48:49,540
have some system you can you can see where my bias is here right let's

536
00:48:49,540 --> 00:48:52,780
imagine that you have some system and we're gonna call it a legacy system

537
00:48:53,180 --> 00:48:58,060
that's using pi tz and someone's like well we have all this behavior based

538
00:48:58,060 --> 00:49:03,300
around pi tz's localized stuff and you say well you know what I am a big

539
00:49:03,300 --> 00:49:06,820
proponent of date util so what I'd like to do is I would like to write this

540
00:49:06,820 --> 00:49:10,020
compatibility function for you it's going to be called localized and it

541
00:49:10,020 --> 00:49:15,460
basically does exactly what pi tz is localized does it takes a daytime a tz

542
00:49:15,460 --> 00:49:22,700
info and then is DST and it recreates pi tz's functionality about raising errors

543
00:49:23,100 --> 00:49:26,300
this is something you may actually legitimately want anyway in terms of

544
00:49:26,300 --> 00:49:32,660
again you know if you want the is DST equals non behavior okay so let's take

545
00:49:32,660 --> 00:49:40,140
15 minutes for that again put up the the red if you have a problem and the green

546
00:49:40,140 --> 00:49:42,140
if you're done and I'll come around

547
00:50:52,700 --> 00:50:54,760
you

548
00:51:52,700 --> 00:51:55,760
you

549
00:52:22,700 --> 00:52:25,760
you

550
00:52:52,700 --> 00:52:55,760
you

551
00:53:22,700 --> 00:53:25,760
you

552
00:53:52,700 --> 00:53:55,760
you

553
00:54:22,700 --> 00:54:25,760
you

554
00:54:52,700 --> 00:54:55,760
you

555
00:55:22,700 --> 00:55:25,760
you

556
00:55:52,700 --> 00:55:55,760
you

557
00:56:22,700 --> 00:56:25,760
you

558
00:56:52,700 --> 00:56:55,760
you

559
00:57:22,700 --> 00:57:24,760
you

560
00:57:41,700 --> 00:57:46,940
behavior of pi tz that I neglected to mention but I actually am testing for is

561
00:57:47,940 --> 00:57:54,640
localized can only be used on naive time zones and normalized can only be used on

562
00:57:54,640 --> 00:57:59,820
aware time zones so you may have implemented this and then it's like

563
00:57:59,820 --> 00:58:05,180
you're not raising value error just note that that's because if if we're

564
00:58:05,180 --> 00:58:10,180
actually trying to build a pi tz style exactly localizer then it wants you to

565
00:58:10,180 --> 00:58:17,820
raise value error if you get a time zone if you get a daytime with a tz info

566
00:58:17,820 --> 00:58:24,380
attached so if the tz info is not none so was that clear is anyone unclear on

567
00:58:24,380 --> 00:58:29,860
that okay so

568
00:58:29,860 --> 00:58:43,740
unless you're naive maybe I'm maybe yeah sorry yeah localized tz info has to be

569
00:58:43,740 --> 00:58:50,420
none normalized tz info cannot be none so you're to me that's like localized

570
00:58:50,420 --> 00:58:56,340
normalizes is the same as localized except for aware date times so let's just

571
00:58:56,340 --> 00:59:00,140
focus on localized localized has to be called on naive date times if you call

572
00:59:00,140 --> 00:59:05,980
it on a on an aware date time then it will raise an error

573
00:59:26,340 --> 00:59:29,380
you

574
00:59:56,340 --> 00:59:59,400
you

575
01:00:26,340 --> 01:00:29,400
you

576
01:00:56,340 --> 01:00:59,400
you

577
01:01:26,340 --> 01:01:29,400
you

578
01:01:56,340 --> 01:01:59,400
you

579
01:02:26,340 --> 01:02:29,400
you

580
01:02:56,340 --> 01:02:59,400
you

581
01:03:26,340 --> 01:03:28,400
you

582
01:03:33,340 --> 01:03:39,860
feel free sorry I keep messing with this microphone after this please do send me

583
01:03:39,860 --> 01:03:44,180
feedback because I realized that some of these am error messages are probably

584
01:03:44,180 --> 01:03:49,260
ambiguous I could probably do better so I'm very much looking forward to

585
01:03:49,260 --> 01:03:56,820
adjusting this tutorial for future people so just saying that by the way I

586
01:03:56,820 --> 01:04:00,940
think we're at 15 minutes do we have one more question let's take one more

587
01:04:00,940 --> 01:04:06,860
minute how many how many people are have something that works even a little bit

588
01:04:06,860 --> 01:04:13,660
just like a couple okay I'll give you like one or two more minutes

589
01:04:19,260 --> 01:04:22,320
you

590
01:04:49,260 --> 01:04:51,320
you

591
01:05:03,180 --> 01:05:05,240
you

592
01:05:05,240 --> 01:05:20,960
Okay, so it's been 15 minutes. How many people finished? Show of hands. Like one. Okay. All

593
01:05:20,960 --> 01:05:25,720
right. Well, I'm just going to go through it. Just, and I realize now, all right, how

594
01:05:25,720 --> 01:05:32,920
many people were like 70% done? All right. And how many people were like 50% done? And

595
01:05:32,920 --> 01:05:37,560
how many people just didn't know how to start? Okay. Yeah, that's what the red sticky is

596
01:05:37,560 --> 01:05:44,640
for, guys. Like, I'm surprised, given that there's 50 people, I'm surprised at how little

597
01:05:44,640 --> 01:05:50,000
I've had to, like, walk around. So feel free to, you know, I hope I don't regret saying

598
01:05:50,000 --> 01:05:54,880
that, but feel free to, like, make extra use of that red sticky. Because I want everyone

599
01:05:54,880 --> 01:05:58,560
to get something out of this for sure. All right. So I'm just going to show you how I

600
01:05:58,560 --> 01:06:07,400
would do it. It's that, but I'll say, okay, so the first thing I'm going to handle is

601
01:06:07,400 --> 01:06:13,600
I'll check the case that we, the edge case that we mentioned about the value error. So

602
01:06:13,600 --> 01:06:27,120
if dt.tzinfo is not none, raise value error, localize can only be used with time zone,

603
01:06:27,120 --> 01:06:34,840
time zones. And, you know, I really hope no one hears on the Unicode standards committee

604
01:06:34,840 --> 01:06:39,720
because I did not use the dioresis in naive. I'm just, I'm so sorry about that. I just

605
01:06:39,720 --> 01:06:47,160
don't know how to type it. So then what I'm going to do is I'll handle the isDST. So there's

606
01:06:47,160 --> 01:06:52,800
two ways you can do this. One, you can just set the fold one way or the other, and it'll

607
01:06:52,800 --> 01:06:56,560
just, it will work. So I'll show you how to do that. I'll show you that way, right, which

608
01:06:56,560 --> 01:07:05,640
is just to say dt.fold equals int. I mean, you don't really have to do the int part,

609
01:07:05,640 --> 01:07:14,200
but not isDST. I'm not sure if the semantics of this are exactly right because I suppose

610
01:07:14,200 --> 01:07:18,720
there are possibilities, there's possibilities where you're like in Ireland, this might cause

611
01:07:18,720 --> 01:07:24,560
some problem. This might be slightly different, but those are very hard to detect. But they're

612
01:07:24,560 --> 01:07:29,840
not in the test suite either way. But just to note that the fold has an inverted sense

613
01:07:29,840 --> 01:07:34,620
of isDST because the standard, usually you're going from daylight saving time to standard

614
01:07:34,620 --> 01:07:38,720
time when you're setting your clocks back. So that means standard time is the second

615
01:07:38,720 --> 01:07:49,800
occurrence, which means fold should be one. And then we'll say if, oh wait, actually first

616
01:07:50,800 --> 01:07:58,800
I have to say if isDST is none, we'll say, now this is the case where we have to throw

617
01:07:58,800 --> 01:08:11,800
an error. So we'll say try, actually we'll say if tz.datetime.ambiguous dt.replace, oh

618
01:08:11,800 --> 01:08:24,800
wait, I can just do this. Raise, oh and also I can't do that. I'm sorry. Raise, ambiguous

619
01:08:24,800 --> 01:08:42,800
time error. Okay. And then I'll say lf tz.datetime. sorry, datetime underscore ambiguous. I don't

620
01:08:42,800 --> 01:08:52,800
know why I thought this should be datetime exists and not datetime imaginary. Dt tzi

621
01:08:52,800 --> 01:09:14,800
is nonexistent time error. Dt does not exist in tzi. And then finally we'll say fold equals,

622
01:09:14,800 --> 01:09:37,800
actually I'll say fold equals zero. Else fold here. And then finally I do dt.replace tzinfo

623
01:09:37,800 --> 01:09:46,800
equals tzi.fold equals fold. And we're going to return that. And let's check the tests.

624
01:09:46,800 --> 01:09:56,800
And it passes all the tests. Another way to do this would be instead of setting, here

625
01:09:56,800 --> 01:10:05,800
I'm just setting the fold like indiscriminately, which means that if I do like localize datetime.now

626
01:10:05,800 --> 01:10:16,800
tz.get tz America New York, then it's going to set fold equals one even though this is

627
01:10:16,800 --> 01:10:23,800
not an ambiguous time. So if I want to fix that, I can say, I mean, fixed. It doesn't

628
01:10:23,800 --> 01:10:36,800
really matter. But if I say if tz.datetime ambiguous dt tzi, that'll still pass all

629
01:10:36,800 --> 01:10:45,800
the tests. And when I localize it, it won't have the fold. So there we go. And that works.

630
01:10:45,800 --> 01:10:52,800
Great. So I'm going to, at this point, I'm going to skip the last two workbooks. The

631
01:10:52,800 --> 01:10:57,800
first one is about handling local times. You should be able to read through it. And

632
01:10:57,800 --> 01:11:04,300
it's fine. One thing I will note is if you go through this, if you go through this locally

633
01:11:04,300 --> 01:11:08,800
and you don't have time zone information, some of these demos won't work. Like I noticed

634
01:11:08,800 --> 01:11:13,800
the demos didn't quite work when I tried it on the binder originally and I had to install

635
01:11:13,800 --> 01:11:18,800
the tz.data. Windows, it will definitely not work because it turns out that this is something

636
01:11:18,800 --> 01:11:24,800
you may want to know. If you change the system time zone during the course of a Python run,

637
01:11:24,800 --> 01:11:31,800
like say if you wanted to demonstrate what it looks like to do some Python things that

638
01:11:31,800 --> 01:11:36,800
take place in different locales on Windows, it will just not do it. Like you have to restart

639
01:11:36,800 --> 01:11:42,800
Python to get the new local time zone information. And there's pretty much no way around that.

640
01:11:42,800 --> 01:11:49,800
You can get different local time zone information if you use datetil.tz.tzwinlocal. But I was

641
01:11:49,800 --> 01:11:55,800
trying to demonstrate something else. So go ahead and work through these two. Probably

642
01:11:55,800 --> 01:12:02,800
do the local time one on the binder if you're on Windows. And frankly, I haven't tested

643
01:12:02,800 --> 01:12:05,800
any of this on Windows, so it might all be broken.

644
01:12:13,800 --> 01:12:20,800
Yes. I mean, there's datetil.tz.tzwinlocal, which actually queries the registry whenever

645
01:12:20,800 --> 01:12:26,800
you construct it. And the registry will get updated. You have to call this tzset function

646
01:12:26,800 --> 01:12:33,800
in time in order to get datetil.tzlocal to work. So generally speaking, try not to change

647
01:12:33,800 --> 01:12:38,800
your local time zone while a Python run is happening. It doesn't happen too often. But

648
01:12:38,800 --> 01:12:41,800
yeah, there's a lot of edge cases around that.

649
01:12:42,800 --> 01:12:48,800
Okay. All right. Let's see. All right. So I think the break is probably at 3 o'clock.

650
01:12:48,800 --> 01:12:54,800
So we're going to go through the serializing and deserializing. So you can go, if you're

651
01:12:54,800 --> 01:12:59,800
in the time zone one, just go up one level to materials and then go down one level to

652
01:12:59,800 --> 01:13:06,800
02-serializing underscore deserializing. And we'll open the first workbook. We may not

653
01:13:06,800 --> 01:13:10,800
get to the other workbooks, but at least the first workbook is a good start.

654
01:13:12,800 --> 01:13:15,800
So yes.

655
01:13:15,800 --> 01:13:39,800
Yeah. So not is DST. Fold has the opposite sense of is DST because, well, I mean, they

656
01:13:39,800 --> 01:13:44,800
just map to different concepts. So is DST is like, are you on the daily saving time

657
01:13:44,800 --> 01:13:49,800
side? But there are other situations that could cause folds. So for example, like Portugal

658
01:13:49,800 --> 01:13:59,800
at one point canceled the saving time and they wanted to do it with a minimum of problems.

659
01:13:59,800 --> 01:14:05,800
So what they did was they just waited until daylight saving time or they shifted their

660
01:14:05,800 --> 01:14:10,800
base offset. So they shifted their base offset. So instead of being UTC plus two during standard

661
01:14:10,800 --> 01:14:15,800
time, they switched to being like UTC plus one or UTC plus three. I forget which one.

662
01:14:15,800 --> 01:14:19,800
And they were, I think they were also canceling daylight saving time or maybe not. I don't

663
01:14:19,800 --> 01:14:20,800
know. But they.

664
01:14:30,800 --> 01:14:37,800
Oh, no, it's going to be true, false or none. Yeah. Yeah. So like if you were going to write

665
01:14:37,800 --> 01:14:44,800
this, it would be, yeah, sorry. I misunderstood that. It would be like bull and then none

666
01:14:44,800 --> 01:14:52,800
or something or optional or actually. And I think this would have to be. Yeah. So false

667
01:14:52,800 --> 01:15:00,800
means choose standard time if it's an option. True means choose daily saving time if it's

668
01:15:00,800 --> 01:15:06,800
an option and none means throw an error if you're uncertain. So that's exactly what

669
01:15:06,800 --> 01:15:13,800
Pytz does. You can see it up here, right? Where here true does one thing, false is the

670
01:15:13,800 --> 01:15:22,800
default. It does another thing. And then none throws errors. Yeah. Okay. So any other questions

671
01:15:22,800 --> 01:15:35,800
on this? Okay. Great. All right. Let's jump to workbook one strings. All right. So, no,

672
01:15:35,800 --> 01:16:02,800
go for it. Yes. Is DSC kind of has the inverse sense of false. I mean, yeah. Yeah, they

673
01:16:02,800 --> 01:16:09,800
are. But I cast it to int. I mean, you don't like you don't have to. Oh, yeah. If you pass

674
01:16:09,800 --> 01:16:14,800
true or false, it will just get cast to int like automatically. I think I mean, you could

675
01:16:14,800 --> 01:16:19,800
I'm not even sure you may be able to pass the string zero or one. I don't I don't I

676
01:16:19,800 --> 01:16:25,800
don't know. Yeah. The reason why it's zero or one I think is because the underlying representation

677
01:16:25,800 --> 01:16:32,800
if you add just an unsigned character instead of like a Boolean, it wouldn't make the times

678
01:16:32,800 --> 01:16:38,800
take up any more space because of the alignment the padding for alignment in the C structure.

679
01:16:38,800 --> 01:16:43,800
So like I think they were like very specific that the only valid values are not like Python

680
01:16:43,800 --> 01:16:54,800
objects. They're like zero or one. Yeah. Okay. Cool. So let's jump into serializing and deserializing

681
01:16:54,800 --> 01:17:00,800
date times. And then I think there's well, we can stop for a break at three o'clock. I think

682
01:17:00,800 --> 01:17:05,800
that's also when there's going to be like tea and stuff outside. Okay. So serializing and

683
01:17:05,800 --> 01:17:10,800
deserializing date times. So I have a couple workbooks on here. The second two are probably

684
01:17:10,800 --> 01:17:16,800
going to have to be just do self-paced. But this is a fairly common operation that you're going

685
01:17:16,800 --> 01:17:20,800
to do, right? Because you need to represent your date times in some format that's either going to

686
01:17:20,800 --> 01:17:25,800
be independent of programming language or you're going to have to transmit it to something that

687
01:17:25,800 --> 01:17:32,800
you really shouldn't be transmitting like Python binary objects or maybe you're just sort of

688
01:17:32,800 --> 01:17:37,800
serializing it by writing it to a log file that a human being is going to read. Generally speaking,

689
01:17:37,800 --> 01:17:42,800
if a human is going to read it, you're going to want to use some sort of a string representation

690
01:17:42,800 --> 01:17:49,800
that's unambiguous and compact. If no human is going to read it, we would jump to workbook two

691
01:17:49,800 --> 01:17:54,800
and probably just represent it as like a number because that can be easier. And then workbook

692
01:17:54,800 --> 01:18:05,800
three, I don't have time to go into it, but I deal with JSON because JSON, as with many other

693
01:18:05,800 --> 01:18:11,800
programming language and such, including Python, frankly, don't treat date times as a kind of

694
01:18:11,800 --> 01:18:17,800
first class type. You know, they're not primitive types, but they're so common that it causes a

695
01:18:17,800 --> 01:18:23,800
lot of problems when people just have to create all their own different standard ways to represent

696
01:18:23,800 --> 01:18:29,800
them. And so the JSON standard does not have any way to represent date times. So you just have to

697
01:18:29,800 --> 01:18:34,800
represent it as a string and then have a schema that says this is a date time, convert it from a

698
01:18:34,800 --> 01:18:40,800
date time, or you have to have some sort of self-describing superset of JSON where it's like,

699
01:18:40,800 --> 01:18:46,800
oh, if I have a little curly bracket and it says object and then date time and then string or

700
01:18:46,800 --> 01:18:53,800
whatever. So the last one at least lets you add hooks for JSON, but you have to work out all the

701
01:18:53,800 --> 01:18:58,800
stuff that goes around that because it's not standardized. YAML, on the other hand, does

702
01:18:58,800 --> 01:19:06,800
standardize date times but has other problems. Okay. So, oh, and one other thing I'd like to note

703
01:19:06,800 --> 01:19:11,800
before I go on to this deserializing and serializing of strings is the difference between what I'm

704
01:19:11,800 --> 01:19:17,800
calling deserializing and parsing. So deserializing does involve a parse because it involves taking a

705
01:19:17,800 --> 01:19:23,800
string and then turning it into the actual core values and turning that into a date time object.

706
01:19:23,800 --> 01:19:29,800
But that's really a subset of all parsing tasks, right? Because a lot of times when you think of

707
01:19:29,800 --> 01:19:33,800
parsing, you're thinking of things like maybe parsing user input, right, where they're going to be

708
01:19:33,800 --> 01:19:39,800
typing a date time as a string and it might be in one of 16 million different formats or someone

709
01:19:39,800 --> 01:19:45,800
from the business team gives you an Excel spreadsheet and they've got a column with half the

710
01:19:45,800 --> 01:19:51,800
date times are like year, year, year, slash month, month, slash day, day, and then the other half are

711
01:19:51,800 --> 01:19:57,800
like year, year, dash month, month, dash day, day, or some other weird thing like that. And you as a

712
01:19:57,800 --> 01:20:03,800
programmer are not able to be like, well, I really only support this one format, right, because you

713
01:20:03,800 --> 01:20:08,800
don't control what your users do. And if you make that mistake, you're going to be making the same

714
01:20:08,800 --> 01:20:14,800
mistake as whatever programmer is making it so that someone named John Null is unable to get on

715
01:20:14,800 --> 01:20:20,800
airplanes, right? Oh, John Null, that's just some fake thing. It's probably test data. Let's just

716
01:20:20,800 --> 01:20:26,800
throw it away. You don't get to choose how people are going to give you their date time formats

717
01:20:26,800 --> 01:20:32,800
necessarily, and you also don't get to choose what people's names are going to be. But when you're

718
01:20:32,800 --> 01:20:38,800
deserializing, and that's why I was very specific about that's what we're going to cover here,

719
01:20:38,800 --> 01:20:44,800
that's because it's either you're reading it from a serialization format, which is standardized,

720
01:20:44,800 --> 01:20:50,800
right, so you're saying part of the standard is that we use ISO 8601, which itself is actually quite

721
01:20:50,800 --> 01:20:56,800
ambiguous. And then, or it's maybe something you generated yourself, right, so it's like you're

722
01:20:56,800 --> 01:21:02,800
writing some sort of microservice kind of operation, and you just have some interchange format, and

723
01:21:02,800 --> 01:21:08,800
maybe you want to be able to read the data in packet captures or something, so you want it to be

724
01:21:08,800 --> 01:21:14,800
strings, but you don't have to worry about arbitrary date times because you're controlling both sides.

725
01:21:14,800 --> 01:21:18,800
So we're going to be talking about the latter case, the case where you control both formats, but, you

726
01:21:18,800 --> 01:21:24,800
know, this is a refrain I go to a lot with date time, and with a lot of things, honestly. It depends

727
01:21:24,800 --> 01:21:30,800
on your use case, and try and be careful about not mistaking one use case for another.

728
01:21:30,800 --> 01:21:36,800
Okay, so when you're going for a string format, you want something that's going to be unambiguous,

729
01:21:36,800 --> 01:21:41,800
something that's going to be easy to parse, preferably fast, and ideally fairly compact, right, you don't

730
01:21:41,800 --> 01:21:49,800
want it to take up a huge amount of space. So probably there's two ways to do this. One, you can use

731
01:21:49,800 --> 01:21:55,800
strf time, and in that case, it will be, as long as you know what the format is, the format string

732
01:21:55,800 --> 01:21:59,800
you choose, it will be unambiguous, but it may not be unambiguous to people who don't know what that

733
01:21:59,800 --> 01:22:07,800
string is. If you use iso format, which does a very specific subset of iso 8601, though it's also

734
01:22:07,800 --> 01:22:16,800
able to generate a superset of iso 8601, so, yeah, things are complicated. There is an easy way to

735
01:22:16,800 --> 01:22:24,800
invert iso format, and then there's, and mostly people looking at iso 8601 day times, they will just

736
01:22:24,800 --> 01:22:30,800
be able to look at it and say, that's what this is, right. It's unambiguous that it goes year, month,

737
01:22:30,800 --> 01:22:38,800
day, because, you know, the only middle Indian people are like the Americans, and we usually

738
01:22:38,800 --> 01:22:48,800
represent it day, wait, day, month, day, year, yeah. Sorry. I mean, yeah, I'm Canadian. I didn't just

739
01:22:48,800 --> 01:23:00,800
say TZ a million times. Canadians say Zed. Sorry. Anyway, yeah, so we have this datetime.iso format.

740
01:23:00,800 --> 01:23:07,800
It has two arguments, sep, which specifies what the separator between the date portion and the time

741
01:23:07,800 --> 01:23:13,800
portion is going to be. It defaults to T, which is what the standard says you should do. And then

742
01:23:13,800 --> 01:23:19,800
time spec, which determines the amount of truncation. And you can tell that I was putting off

743
01:23:19,800 --> 01:23:25,800
writing the rest of this talk because I spent like an inordinate amount of time making this ASCII

744
01:23:25,800 --> 01:23:34,800
diagram. So we're just going to bask in that for like a couple seconds. Look at this. Yeah. All right.

745
01:23:34,800 --> 01:23:42,800
So this is all the formats that it can generate. Basically, the default is that it will generate

746
01:23:42,800 --> 01:23:54,800
this much if there are, if there's no microseconds. So if the microseconds are zero, it'll, the auto

747
01:23:54,800 --> 01:23:59,800
will generate this. And if the microseconds are anything other than zero, it'll generate that. If

748
01:23:59,800 --> 01:24:08,800
there's a time zone attached, it will generate as much of this portion as is necessary. So usually

749
01:24:08,800 --> 01:24:15,800
it's HHMM. If you're in some weird time zone, like one of the Pytz LMT zones, you'll sometimes get

750
01:24:15,800 --> 01:24:21,800
seconds. I don't know of any times when you'll get microseconds, but there is support for that. So

751
01:24:21,800 --> 01:24:28,800
like we can take a look. You can see if I have microseconds, it looks like that. If I have, if I

752
01:24:28,800 --> 01:24:34,800
don't have microseconds, it'll auto truncate. If I want to specifically make sure that I have

753
01:24:34,800 --> 01:24:40,800
microseconds, I can just specify any one of these things to say use all of that. There's no way to

754
01:24:40,800 --> 01:24:49,800
specify this. You can't always get microseconds for the time zone portion of it. You can also specify

755
01:24:49,800 --> 01:24:55,800
more truncation. So you can say hours, and then even though I have stuff in minutes and seconds,

756
01:24:55,800 --> 01:25:01,800
it'll just get truncated. If you want something that's more like what you print, like the statement

757
01:25:01,800 --> 01:25:08,800
for printing a daytime, you can change the separator to a space or change it to whatever you want.

758
01:25:08,800 --> 01:25:16,800
That can actually be any Unicode character. Like I think even like weird non-supported, like things

759
01:25:16,800 --> 01:25:22,800
not in UTF-8, like surrogate characters and stuff. And then for aware daytimes, you can see it'll

760
01:25:26,800 --> 01:25:34,800
just have this offset. And then, right, it supports all of these things. So before Python 3.7, there

761
01:25:34,800 --> 01:25:42,800
was no way to invert this. Like literally no way to cover all the use cases. Even STRP time wasn't

762
01:25:42,800 --> 01:25:48,800
able to handle it because STRP time only supported the inverse of STRF time, and STRF time does not

763
01:25:48,800 --> 01:25:54,800
have this colon, and there's no way to specify it. Python 3.7 brings two additions. One is STRP time,

764
01:25:54,800 --> 01:26:00,800
if you use the %z directive, it will now parse it correctly even if there's a colon. And then the

765
01:26:00,800 --> 01:26:06,800
other thing it brings is from ISO, which is the same thing as Python 3.7, is the same thing as

766
01:26:06,800 --> 01:26:12,800
Python 3.7. It will now parse it correctly even if there's a colon. And then the other thing it brings

767
01:26:12,800 --> 01:26:18,800
is from ISO format. And I know all this weird stuff about the separators and stuff because I actually

768
01:26:18,800 --> 01:26:24,800
added from ISO format to Python. So what this does is, and I also am like super specific about the

769
01:26:24,800 --> 01:26:30,800
guarantees, like most people will be like, oh, it just parses ISO 8601 time. So I'm like, no, you're not

770
01:26:30,800 --> 01:26:34,800
going to parse it correctly. Because what it actually does is it inverts the output of ISO format.

771
01:26:34,800 --> 01:26:40,800
It's a subtle difference, but it's a difference in the contract, right, which means that there's not going to be a

772
01:26:40,800 --> 01:26:46,800
z at the end. Like you can't take any ISO 8601 date time and parse it with this. You can only take things

773
01:26:46,800 --> 01:26:52,800
out of the output of ISO format. If you want something that parses ISO 8601 date times and only

774
01:26:52,800 --> 01:26:58,800
ISO 8601 date times, dateutil has dateutil.parser.iso parse. And that will work for a wider array of date

775
01:27:01,800 --> 01:27:07,800
times. And yeah, so that will work. And that will also work before Python 3.7. But this is much faster.

776
01:27:14,800 --> 01:27:20,800
It's an interesting thing to note is that from ISO format, if you pass it a data.py, it will

777
01:27:22,800 --> 01:27:28,800
pass it a string literal. It's actually faster to do that to get a date time than to create a

778
01:27:28,800 --> 01:27:34,800
date time literal. Like it's maybe twice as fast. And the reason for that is this is just on CPython,

779
01:27:34,800 --> 01:27:40,800
and I wouldn't rely on that because we might optimize other things. But it turns out the reason

780
01:27:40,800 --> 01:27:46,800
for that is CPython spends a surprising amount of time parsing the arguments. So if you

781
01:27:46,800 --> 01:27:52,800
pass a string to a date time, it's like, oh, turn that into a C string and then the parse takes like

782
01:27:52,800 --> 01:27:58,800
10 nanoseconds and then it spends most of the time constructing the date time. So anyway, that's some

783
01:27:58,800 --> 01:28:02,800
weird optimization thing that you probably shouldn't, it's like dangerous knowledge, you probably

784
01:28:02,800 --> 01:28:08,800
shouldn't even know it. So great. So that brings us to our exercise, which is write a function to

785
01:28:08,800 --> 01:28:14,800
parse a log message. We have this bonus exercise down here that I'm going to tell you about now

786
01:28:14,800 --> 01:28:20,800
because we're not going to get to it, which is this is some logger format, and we're going to use

787
01:28:20,800 --> 01:28:27,800
an ISO 8601 date time because these are absolute times. And we're going to be time zone aware, we're not

788
01:28:27,800 --> 01:28:32,800
going to make it UTC because when you're reading logs, you prefer to see things that are at least kind

789
01:28:32,800 --> 01:28:40,800
of in the ballpark of what your local time is, right? And if you want to configure your parser to

790
01:28:40,800 --> 01:28:46,800
have something that from ISO format can understand, you have to reconfigure it. So that's the bonus

791
01:28:46,800 --> 01:28:53,800
exercise is to actually change the logger to work this way. And it turns out that if you want to

792
01:28:53,800 --> 01:28:58,800
ignore the microseconds part and you also don't want to be able to like, you know, and you don't

793
01:28:58,800 --> 01:29:06,800
want this colon, it's like trivial to do this. And it's like a nightmare to do if you don't want

794
01:29:06,800 --> 01:29:13,800
that because you have to like subclass formatter and then like do all this weird stuff. So feel free

795
01:29:13,800 --> 01:29:18,800
to try your hand at that if you're going to be like the logging guru, but otherwise it's probably not

796
01:29:18,800 --> 01:29:26,800
worth your time. So yeah, so we're going to say that someone like slaved over this and figured out

797
01:29:26,800 --> 01:29:32,800
how to generate this output just to make it easier for you to do the log messages. And we'd like to

798
01:29:32,800 --> 01:29:40,800
write a parser that will take this, it'll break it apart, and then it'll have some structured

799
01:29:40,800 --> 01:29:48,800
JSON object that has the field's date time, which is the date time, and then level, which we'll just

800
01:29:48,800 --> 01:29:55,800
keep it as a string if you want to map it to an enum, like if you're super fancy, you can do that,

801
01:29:55,800 --> 01:30:03,800
but don't waste too much time on it. And then the name and then the message. In the test suite, I

802
01:30:03,800 --> 01:30:10,800
don't have anything where like the message contains a colon or anything, so that's fine. But if you

803
01:30:10,800 --> 01:30:16,800
want to handle that edge case, you could just use split with like, split takes a second argument, and

804
01:30:16,800 --> 01:30:24,800
if you pass it four, it'll be fine. Okay. Great. So let's take like 10 minutes for this.

805
01:30:24,800 --> 01:30:30,800
And I think that brings us to the break, so you can work into the break or whatever. I'll be around

806
01:30:30,800 --> 01:30:35,800
and make sure I can help. So green when you're done, red if you need help.

807
01:30:54,800 --> 01:30:56,800
Okay.

808
01:31:24,800 --> 01:31:26,800
Okay.

809
01:31:54,800 --> 01:31:56,800
Okay.

810
01:32:24,800 --> 01:32:26,800
Okay.

811
01:32:54,800 --> 01:32:56,800
Okay.

812
01:33:24,800 --> 01:33:26,800
Okay.

813
01:33:54,800 --> 01:33:56,800
Okay.

814
01:34:24,800 --> 01:34:26,800
Okay.

815
01:34:54,800 --> 01:34:56,800
Okay.

816
01:35:24,800 --> 01:35:26,800
Okay.

817
01:35:54,800 --> 01:35:56,800
Okay.

818
01:36:24,800 --> 01:36:26,800
Okay.

819
01:36:54,800 --> 01:36:56,800
Okay.

820
01:37:24,800 --> 01:37:26,800
Okay.

821
01:37:54,800 --> 01:37:56,800
Okay.

822
01:38:24,800 --> 01:38:26,800
Okay.

823
01:38:54,800 --> 01:38:56,800
Okay.

824
01:39:06,800 --> 01:39:11,800
So it's three o'clock now. I think three o'clock was like the schedule break time. I'm not

825
01:39:11,800 --> 01:39:18,800
entirely sure, but maybe, like, refreshments out there. Should I just go over the answer real

826
01:39:18,800 --> 01:39:23,800
I'm sure a lot of you are probably still working on it,

827
01:39:23,800 --> 01:39:26,400
but I'll just show it to you,

828
01:39:26,400 --> 01:39:28,440
and then you can pay attention or not,

829
01:39:28,440 --> 01:39:29,600
and I'll be around during the break

830
01:39:29,600 --> 01:39:30,860
so you can ask me questions

831
01:39:30,860 --> 01:39:32,780
if you just wanna keep working on it.

832
01:39:32,780 --> 01:39:36,120
But the way I would do this is I would say,

833
01:39:36,120 --> 01:39:41,120
let's say DTSTR level name message equals line.split,

834
01:39:41,120 --> 01:39:46,120
name message equals line.split,

835
01:39:47,920 --> 01:39:50,720
splitting on a colon with two spaces on it.

836
01:39:52,120 --> 01:39:53,520
Stay on page for sure.

837
01:39:53,520 --> 01:39:55,160
And then I'm gonna put four

838
01:39:55,160 --> 01:39:57,520
because I want at most four of these.

839
01:39:57,520 --> 01:40:00,560
And then I will say, or I want,

840
01:40:00,560 --> 01:40:02,760
like yeah, at most four I think.

841
01:40:02,760 --> 01:40:06,800
And then I just have to convert the DT string into a,

842
01:40:09,080 --> 01:40:09,960
into a date time.

843
01:40:09,960 --> 01:40:14,960
So date time from ISO format DTSTR.

844
01:40:17,880 --> 01:40:22,880
Then we can return date time DT level,

845
01:40:26,800 --> 01:40:31,800
level name, name, message, message.

846
01:40:32,240 --> 01:40:33,240
And there we go.

847
01:40:33,240 --> 01:40:35,240
And we'll check the tests.

848
01:40:35,240 --> 01:40:36,080
There we go.

849
01:40:36,080 --> 01:40:38,120
So that's how I did it.

850
01:40:38,120 --> 01:40:40,120
So we'll do a break.

851
01:40:40,120 --> 01:40:41,440
I'm gonna lose some of the message

852
01:40:41,440 --> 01:40:43,960
if the message contains Facebook.

853
01:40:43,960 --> 01:40:45,520
Oh no, actually I won't.

854
01:40:45,520 --> 01:40:47,440
See here, look.

855
01:40:47,440 --> 01:40:49,280
Blah, blah.

856
01:40:49,280 --> 01:40:51,800
Two, wait.

857
01:40:51,800 --> 01:40:53,600
Sorry, this should be a three.

858
01:40:55,600 --> 01:40:57,600
But I'm gonna do a break.

859
01:40:57,600 --> 01:40:59,600
So I'm gonna do a break.

860
01:41:00,280 --> 01:41:03,200
But the second argument to split

861
01:41:05,320 --> 01:41:06,360
truncates how many,

862
01:41:06,360 --> 01:41:08,360
it's like if you find this three times,

863
01:41:08,360 --> 01:41:09,560
once you find this three times,

864
01:41:09,560 --> 01:41:13,440
like stop, yeah, just like keep going for the end.

865
01:41:13,440 --> 01:41:16,920
So yeah, I always forget if it's like the number

866
01:41:16,920 --> 01:41:19,120
of values you want returned

867
01:41:19,120 --> 01:41:22,760
or the number of separators off by one.

868
01:41:22,760 --> 01:41:23,600
Okay, yeah.

869
01:41:23,600 --> 01:41:26,080
So we'll start up again at 320.

870
01:41:27,040 --> 01:41:28,080
Head out there.

871
01:41:28,080 --> 01:41:29,240
If someone like starts yelling at you,

872
01:41:29,880 --> 01:41:30,720
like get back in the room,

873
01:41:30,720 --> 01:41:32,080
like just let me know, I guess.

874
01:41:39,680 --> 01:41:42,680
Yeah, I'll be here for your questions on this or anything.

875
02:01:59,240 --> 02:02:04,240
It's 323 and someone asked me a question about leap seconds,

876
02:02:04,280 --> 02:02:05,680
so my ire is up.

877
02:02:07,080 --> 02:02:10,400
So I think we'll jump right into something soothing

878
02:02:10,400 --> 02:02:12,080
and talk about recurring events.

879
02:02:14,280 --> 02:02:16,080
So, right.

880
02:02:16,080 --> 02:02:17,600
So just a reminder,

881
02:02:17,600 --> 02:02:19,520
we're skipping the other two workbooks

882
02:02:19,520 --> 02:02:21,600
in the serializing and deserializing.

883
02:02:21,600 --> 02:02:23,120
Those will just be self-paced.

884
02:02:23,120 --> 02:02:24,520
So if you're interested in that,

885
02:02:24,520 --> 02:02:26,560
you can go to the link in the description

886
02:02:26,600 --> 02:02:27,720
in deserializing.

887
02:02:27,720 --> 02:02:30,000
Those will just be self-paced.

888
02:02:30,000 --> 02:02:35,000
And we're gonna jump to section 03-recurring-events,

889
02:02:35,560 --> 02:02:37,360
workbook 01, introduction.

890
02:02:38,600 --> 02:02:43,600
So the first workbook just has one example thing.

891
02:02:44,160 --> 02:02:47,360
And as you're going along,

892
02:02:47,360 --> 02:02:50,480
you can feel free to run some of these,

893
02:02:50,480 --> 02:02:53,320
I have some little bonus exercises you can play around with,

894
02:02:53,320 --> 02:02:56,920
but I wanna make sure that we definitely get

895
02:02:56,920 --> 02:02:58,000
to the second workbook

896
02:02:58,000 --> 02:03:00,120
because I think that's a more fun exercise.

897
02:03:00,120 --> 02:03:01,040
It was fun for me,

898
02:03:01,040 --> 02:03:05,000
so I don't know how well that generalizes.

899
02:03:05,000 --> 02:03:08,760
Okay, so we're gonna talk about recurring events.

900
02:03:11,480 --> 02:03:14,160
You would hope that it would be easy

901
02:03:14,160 --> 02:03:15,440
to express a recurring event

902
02:03:15,440 --> 02:03:17,280
because it's like this just happens every day

903
02:03:17,280 --> 02:03:22,280
or it happens every five hours or something,

904
02:03:22,400 --> 02:03:24,480
but I think we all know where this is going.

905
02:03:24,480 --> 02:03:28,280
That's obviously not going to be terribly simple

906
02:03:28,280 --> 02:03:31,640
because we have a lot of overloaded terms in daytimes

907
02:03:31,640 --> 02:03:34,760
and we have a lot of colloquial meanings

908
02:03:34,760 --> 02:03:36,640
like what is the length of one month

909
02:03:36,640 --> 02:03:39,920
or even one year, right?

910
02:03:39,920 --> 02:03:43,280
There's not a fixed amount of time that elapses in one month.

911
02:03:44,480 --> 02:03:49,240
So we need some kind of better way to clearly

912
02:03:49,240 --> 02:03:52,920
and in a standard way express things that recur.

913
02:03:52,920 --> 02:03:56,480
So I think the best standard that we can get for this

914
02:03:56,480 --> 02:04:00,840
comes from RFC 5545, which is the iCalendar spec.

915
02:04:01,880 --> 02:04:03,880
And this is actually like some kind of string format

916
02:04:03,880 --> 02:04:05,320
that is used for interchange

917
02:04:05,320 --> 02:04:08,160
between different like calendar systems.

918
02:04:08,160 --> 02:04:10,920
I think maybe ICS is based on this.

919
02:04:11,920 --> 02:04:13,480
And it's like this long spec.

920
02:04:13,480 --> 02:04:14,480
This is the second version.

921
02:04:14,480 --> 02:04:18,920
There's another version that this displaced.

922
02:04:19,480 --> 02:04:20,600
And then there are addendums to this

923
02:04:20,600 --> 02:04:24,440
and it's like 170 pages of like iCalendar stuff.

924
02:04:24,440 --> 02:04:28,080
And we are going to represent all our recurring times

925
02:04:28,080 --> 02:04:29,720
using the data type that's defined

926
02:04:29,720 --> 02:04:33,080
in like subsection 3.3.10.

927
02:04:33,080 --> 02:04:35,680
So it has like all these different types

928
02:04:35,680 --> 02:04:37,600
and of this 170 page spec,

929
02:04:37,600 --> 02:04:39,200
the next two workbooks will be devoted

930
02:04:39,200 --> 02:04:41,720
to a type defined in these eight pages.

931
02:04:42,920 --> 02:04:46,640
So I try and be as compliant with the spec as possible

932
02:04:46,640 --> 02:04:49,800
with my date util implementation of this.

933
02:04:49,800 --> 02:04:52,440
But some of the things are a little dicey

934
02:04:52,440 --> 02:04:54,840
and there were some non-compliant stuff

935
02:04:54,840 --> 02:04:58,400
that was already there before I took over date util.

936
02:04:58,400 --> 02:05:02,640
Another note is in date util,

937
02:05:02,640 --> 02:05:05,840
the way this worked out was that RFC 2445

938
02:05:05,840 --> 02:05:10,000
was standardized in the IETF

939
02:05:10,000 --> 02:05:11,400
and then date util was written.

940
02:05:11,400 --> 02:05:14,840
And then it was updated with RFC 5545

941
02:05:15,840 --> 02:05:17,920
at like five or six years later

942
02:05:17,920 --> 02:05:20,240
and date util never got totally upgraded.

943
02:05:20,240 --> 02:05:23,320
So I have some support for 5545.

944
02:05:23,320 --> 02:05:25,640
If you're interested in making open source contributions,

945
02:05:25,640 --> 02:05:28,560
I would love to see more support.

946
02:05:29,480 --> 02:05:31,640
The code in here is kind of tricky,

947
02:05:31,640 --> 02:05:35,520
but I would love to see someone go in there

948
02:05:35,520 --> 02:05:37,080
and take a crack at it.

949
02:05:37,080 --> 02:05:42,080
Okay, so the type that we're talking about

950
02:05:42,520 --> 02:05:45,000
is called an R-rule, which is a recurrence rule.

951
02:05:45,000 --> 02:05:46,480
It describes a recurrence.

952
02:05:46,480 --> 02:05:48,280
There are three fundamental elements.

953
02:05:48,280 --> 02:05:49,880
There are required elements.

954
02:05:49,880 --> 02:05:53,320
There's DT start, which is the start date of the recurrence.

955
02:05:53,320 --> 02:05:54,680
And if you're a physicist,

956
02:05:54,680 --> 02:05:56,920
this is kind of like the phase of it.

957
02:05:57,920 --> 02:05:59,080
This has some consequences.

958
02:05:59,080 --> 02:06:02,320
Basically, anything that doesn't recur,

959
02:06:02,320 --> 02:06:05,000
it picks up its original elements from the DT start.

960
02:06:05,000 --> 02:06:06,520
So that's something to note.

961
02:06:08,200 --> 02:06:09,320
And then there's freak,

962
02:06:09,320 --> 02:06:11,560
which is the fundamental frequency

963
02:06:11,560 --> 02:06:13,360
and that can be yearly, monthly,

964
02:06:13,360 --> 02:06:16,240
weekly, daily, hourly, minutely, or secondly.

965
02:06:16,240 --> 02:06:17,640
And then there's interval,

966
02:06:17,640 --> 02:06:19,640
which is basically the multiplier for freak, right?

967
02:06:19,640 --> 02:06:22,840
So if you have, so let's work with these actually.

968
02:06:22,840 --> 02:06:26,040
So first I'm gonna import all these like

969
02:06:26,040 --> 02:06:28,040
weird constants and stuff.

970
02:06:28,040 --> 02:06:29,760
And then I'm gonna describe this rule,

971
02:06:29,760 --> 02:06:31,600
which is an hourly rule.

972
02:06:31,600 --> 02:06:34,880
So hourly is an R-rule.

973
02:06:34,880 --> 02:06:36,480
Its frequency is hourly.

974
02:06:36,480 --> 02:06:38,240
Interval is one,

975
02:06:38,240 --> 02:06:41,360
and it starts on this day in 2016 at 9 a.m.

976
02:06:42,480 --> 02:06:44,080
So when I print this,

977
02:06:44,080 --> 02:06:46,800
you can see that it does what you would expect, right?

978
02:06:46,800 --> 02:06:48,920
It generates a daytime at nine,

979
02:06:48,920 --> 02:06:50,960
and then one at 10, and then one at 11.

980
02:06:52,960 --> 02:06:56,680
And these things are also like at least semi-immutable,

981
02:06:56,680 --> 02:06:58,480
but instead of mutating them,

982
02:06:58,480 --> 02:07:01,840
you really should, even if it's possible,

983
02:07:01,840 --> 02:07:04,080
you should use replace to generate a new one.

984
02:07:04,880 --> 02:07:08,760
So now I'm just gonna take that original rule,

985
02:07:08,760 --> 02:07:10,640
and I'm just gonna change DT start, right?

986
02:07:10,640 --> 02:07:13,160
So if I change DT start to 10 o'clock,

987
02:07:13,160 --> 02:07:15,600
we get the same hourly rule, three occurrences,

988
02:07:15,600 --> 02:07:17,920
10, 11, 12, right?

989
02:07:17,920 --> 02:07:18,960
Straightforward.

990
02:07:18,960 --> 02:07:22,520
And then interval, if I change that from one to two,

991
02:07:22,520 --> 02:07:26,880
the multiplier on hourly changes from one to two, right?

992
02:07:26,880 --> 02:07:29,840
So what that means is that I'm gonna get nine, 11, and 13

993
02:07:29,840 --> 02:07:31,240
instead of nine, 10, 11.

994
02:07:31,640 --> 02:07:36,640
I'm not sure, like this is a very redundant spec,

995
02:07:36,760 --> 02:07:40,960
so generally I would say go with the simplest possible rule

996
02:07:40,960 --> 02:07:45,960
that you can, and I think try to minimize

997
02:07:46,440 --> 02:07:48,600
the number of dates that are filtered out.

998
02:07:49,800 --> 02:07:51,720
Well, I'll get to that.

999
02:07:51,720 --> 02:07:54,720
Okay, so normally, if you'll notice,

1000
02:07:54,720 --> 02:07:57,320
I have this count argument here.

1001
02:07:57,320 --> 02:07:59,280
Normally, if you just take an R rule,

1002
02:08:00,200 --> 02:08:01,480
and you don't limit it in any way,

1003
02:08:01,480 --> 02:08:02,920
you don't put count or until,

1004
02:08:02,920 --> 02:08:05,600
that's just kind of a more abstract thing,

1005
02:08:05,600 --> 02:08:09,320
and it says generate recurrences indefinitely.

1006
02:08:09,320 --> 02:08:12,120
Indefinitely just means until the year 10,000

1007
02:08:12,120 --> 02:08:15,760
when the daytime class can't represent it anymore,

1008
02:08:15,760 --> 02:08:17,800
and then it throws an error.

1009
02:08:17,800 --> 02:08:20,160
So generally, these things are just like,

1010
02:08:20,160 --> 02:08:22,720
they lazily generate your datetimes,

1011
02:08:22,720 --> 02:08:25,280
so it's pretty easy to generate them,

1012
02:08:25,280 --> 02:08:27,440
but then as long as you don't call list on it,

1013
02:08:27,440 --> 02:08:29,000
it'll be fine.

1014
02:08:29,000 --> 02:08:31,760
But if you wanna clearly limit it,

1015
02:08:31,760 --> 02:08:34,280
there are two options, there's count and until.

1016
02:08:34,280 --> 02:08:39,280
Count says give me this number of them.

1017
02:08:39,360 --> 02:08:42,560
I want, in this case, I was like, show me three of them.

1018
02:08:42,560 --> 02:08:44,680
There's also until, so you can imagine,

1019
02:08:44,680 --> 02:08:49,680
oh, I have bar mitzvah practice at Hebrew school

1020
02:08:53,640 --> 02:08:56,720
or whatever every Saturday at 12,

1021
02:08:56,720 --> 02:08:58,160
but then when you turn 13,

1022
02:08:58,160 --> 02:08:59,160
you're gonna get bar mitzvahed,

1023
02:08:59,160 --> 02:09:01,960
so then that is no longer necessary.

1024
02:09:01,960 --> 02:09:04,800
So you would generate a rule that happens every Saturday

1025
02:09:04,800 --> 02:09:07,600
and then it stops on your 13th birthday.

1026
02:09:07,600 --> 02:09:10,000
So that would be an example of our rule.

1027
02:09:12,440 --> 02:09:16,560
And then you can also, as I mentioned before,

1028
02:09:16,560 --> 02:09:18,360
if you have one of these things that is indefinite,

1029
02:09:18,360 --> 02:09:20,600
you can also just get a subset of them.

1030
02:09:20,600 --> 02:09:22,800
So there's no natural number that you want.

1031
02:09:22,800 --> 02:09:27,040
You just really want, okay, I want the next occurrence

1032
02:09:27,040 --> 02:09:30,680
after next Friday or the last occurrence of this

1033
02:09:30,680 --> 02:09:32,720
before some date.

1034
02:09:32,720 --> 02:09:34,440
So there are three options.

1035
02:09:34,440 --> 02:09:36,360
There's after, before, and between.

1036
02:09:36,360 --> 02:09:40,160
After and before generate just one daytime

1037
02:09:40,160 --> 02:09:43,040
and then between generates a list.

1038
02:09:43,040 --> 02:09:45,440
So here I have this monthly thing.

1039
02:09:45,440 --> 02:09:50,400
It says every four months starting in 1995.

1040
02:09:50,400 --> 02:09:53,800
And I can just say, all right, so given this rule,

1041
02:09:53,800 --> 02:09:55,280
I wanna know the next thing,

1042
02:09:55,440 --> 02:09:57,720
there's an even number of months,

1043
02:09:57,720 --> 02:10:01,760
an even number of four month intervals after this time,

1044
02:10:01,760 --> 02:10:06,760
after 2015, like February 2015.

1045
02:10:06,760 --> 02:10:09,520
And you can see that it's March 10th.

1046
02:10:10,800 --> 02:10:15,800
And then the last one before 1997 is in November of 1996.

1047
02:10:18,800 --> 02:10:22,480
And then all of the recurrences in 2001

1048
02:10:22,480 --> 02:10:27,080
is between 2001, January 1st and January 1st, 2002.

1049
02:10:27,080 --> 02:10:30,800
And we get these three occurrences.

1050
02:10:30,800 --> 02:10:33,360
Okay, so I'm not gonna pause for this,

1051
02:10:33,360 --> 02:10:36,560
but feel free to like, if you can listen

1052
02:10:36,560 --> 02:10:40,120
and do it at the same time to just play around

1053
02:10:40,120 --> 02:10:43,560
and generate something that does every day at 1.30

1054
02:10:43,560 --> 02:10:47,040
or like every other week for six weeks.

1055
02:10:47,040 --> 02:10:49,200
Or and then play around with like,

1056
02:10:49,200 --> 02:10:52,120
what does after do after the last recurrence?

1057
02:10:52,120 --> 02:10:53,760
I think it probably returns none.

1058
02:10:55,560 --> 02:10:58,400
Oh, and the other thing is, I forgot to mention this,

1059
02:10:58,400 --> 02:11:01,040
but count and until are mutually exclusive.

1060
02:11:01,040 --> 02:11:02,480
So you can't use both.

1061
02:11:02,480 --> 02:11:05,640
You can implement something that will use both

1062
02:11:05,640 --> 02:11:08,640
in a sense, which is to say like you specify one

1063
02:11:08,640 --> 02:11:11,640
and then you just generate dates and then throw an error

1064
02:11:11,640 --> 02:11:15,540
or stop iterating over it once you reach the until.

1065
02:11:15,540 --> 02:11:18,400
But the spec says that you can specify one or the other

1066
02:11:18,400 --> 02:11:19,240
and not both.

1067
02:11:19,240 --> 02:11:21,880
So I think right now it's just a warning,

1068
02:11:21,880 --> 02:11:24,280
but it will eventually be an error in detail.

1069
02:11:26,200 --> 02:11:28,800
Okay, so that's fairly simple.

1070
02:11:28,800 --> 02:11:30,760
That's something you could basically do with time delta

1071
02:11:30,760 --> 02:11:33,120
other than with the yearly and stuff.

1072
02:11:33,120 --> 02:11:35,060
But then it gets a little more complicated

1073
02:11:35,060 --> 02:11:36,600
when you use these by rules.

1074
02:11:36,600 --> 02:11:41,600
So by rules are rules that modify the base recurrence.

1075
02:11:42,320 --> 02:11:46,080
So for example, and they have like by month,

1076
02:11:46,080 --> 02:11:50,380
by month day, by year day, by week number, by weekday.

1077
02:11:50,380 --> 02:11:53,700
And then these like exotic ones like by set pause.

1078
02:11:53,700 --> 02:11:58,700
This by Easter is the only thing that's not in the spec

1079
02:11:58,780 --> 02:12:00,220
that's in date util.

1080
02:12:00,220 --> 02:12:04,940
I think like this since the beginning of date util,

1081
02:12:04,940 --> 02:12:07,060
it's had support for calculating Easter.

1082
02:12:07,060 --> 02:12:10,460
And I don't know, like maybe the original developer was like,

1083
02:12:10,460 --> 02:12:11,900
well, we got these Easter days around,

1084
02:12:11,900 --> 02:12:13,120
like we might as well.

1085
02:12:14,120 --> 02:12:16,620
But I can imagine it being useful if you schedule something

1086
02:12:16,620 --> 02:12:19,220
that has to happen on Good Friday or something, right?

1087
02:12:20,380 --> 02:12:23,660
So the way these are interpreted

1088
02:12:26,260 --> 02:12:27,300
is a little counterintuitive.

1089
02:12:27,300 --> 02:12:29,920
And I wish I had like an intuitive explanation

1090
02:12:29,920 --> 02:12:31,140
of why it works this way.

1091
02:12:31,140 --> 02:12:33,540
And I'm sure there is one like based on the Nyquist theorem

1092
02:12:33,540 --> 02:12:36,340
or something, but I just haven't come up with it yet.

1093
02:12:36,340 --> 02:12:40,020
But when the by XXX rule,

1094
02:12:40,020 --> 02:12:43,420
or like when the by rule specifies component

1095
02:12:43,420 --> 02:12:46,580
whose like duration is greater than or equal

1096
02:12:46,580 --> 02:12:50,620
to the frequency, then it's a constraint

1097
02:12:50,620 --> 02:12:52,980
and it's gonna reduce the frequency of the occurrence.

1098
02:12:52,980 --> 02:12:57,820
So for example, here, I have this R rule and R rule,

1099
02:12:57,820 --> 02:13:01,100
it's daily, so it's gonna generate every single day.

1100
02:13:01,100 --> 02:13:02,780
It's going to generate it.

1101
02:13:02,780 --> 02:13:06,180
And then I'm gonna use these larger components

1102
02:13:06,180 --> 02:13:09,980
by month of 11 and by weekday, Tuesday,

1103
02:13:09,980 --> 02:13:13,980
that's equal to, it's like roughly equal to a time, right?

1104
02:13:14,020 --> 02:13:17,020
And so what that means is it's gonna start,

1105
02:13:17,020 --> 02:13:19,300
it's gonna generate a bunch of daily,

1106
02:13:19,300 --> 02:13:22,320
it's gonna generate one instance every single day.

1107
02:13:22,320 --> 02:13:25,620
And then if that day is not in November,

1108
02:13:25,620 --> 02:13:28,180
or if that day is not Tuesday,

1109
02:13:28,180 --> 02:13:31,440
then it will ignore that and move on to the next one, right?

1110
02:13:31,440 --> 02:13:36,440
So I've set a count of five and I have this restricted,

1111
02:13:37,060 --> 02:13:39,780
but I'm starting in January of 2015.

1112
02:13:39,780 --> 02:13:44,020
And if you look, I get, just with my count of five,

1113
02:13:44,020 --> 02:13:46,740
I get four dates, four Tuesdays in November in 2015

1114
02:13:46,740 --> 02:13:48,460
and one in 2016.

1115
02:13:48,460 --> 02:13:51,220
So you can see how like the count interacts with this

1116
02:13:51,220 --> 02:13:54,480
where you're generating a specific number of days

1117
02:13:54,480 --> 02:13:55,340
that have these rules, right?

1118
02:13:55,340 --> 02:13:59,500
So the by rules for larger components, they're filters

1119
02:13:59,500 --> 02:14:02,840
and it'll just filter everything out except for this.

1120
02:14:02,840 --> 02:14:05,780
Oh, and these accept scalars and they also accept

1121
02:14:05,780 --> 02:14:07,520
like pretty much any container type.

1122
02:14:07,520 --> 02:14:09,640
So tuples, lists, things like that.

1123
02:14:12,320 --> 02:14:14,840
If the rule is less than the frequency,

1124
02:14:14,840 --> 02:14:17,540
then it increases the number of occurrences, right?

1125
02:14:17,540 --> 02:14:19,240
So here's another rule.

1126
02:14:19,240 --> 02:14:21,960
This is a monthly rule and there are more,

1127
02:14:21,960 --> 02:14:25,000
there's more than one day in a month, right?

1128
02:14:25,000 --> 02:14:27,720
So the by month day is a lower frequency

1129
02:14:27,720 --> 02:14:29,360
or is a higher frequency.

1130
02:14:30,840 --> 02:14:33,380
The duration is shorter than a month, right?

1131
02:14:33,380 --> 02:14:35,400
So these by month days are gonna increase

1132
02:14:35,400 --> 02:14:37,500
the number of occurrences.

1133
02:14:38,500 --> 02:14:40,460
So what I have here is I say every month

1134
02:14:40,460 --> 02:14:43,040
on the first 15th and 30th of the month,

1135
02:14:43,040 --> 02:14:44,400
I want recurrences.

1136
02:14:44,400 --> 02:14:49,400
So you can see, even though the DT start is not a recurrence,

1137
02:14:49,780 --> 02:14:51,060
it's gonna give me the first,

1138
02:14:51,060 --> 02:14:54,020
it starts with the first one that is the 30th

1139
02:14:54,020 --> 02:14:56,820
and then it gives me the first 15th.

1140
02:14:56,820 --> 02:14:59,580
And you'll note that at the end of the month,

1141
02:14:59,580 --> 02:15:04,580
it didn't like fall back to January or to February 28th

1142
02:15:04,580 --> 02:15:07,420
and it didn't like jump forward to March 1st.

1143
02:15:08,340 --> 02:15:10,140
Well, I guess you could imagine that it did,

1144
02:15:10,140 --> 02:15:11,980
but I'll tell you it did not.

1145
02:15:11,980 --> 02:15:16,020
So, because if I change this to the second of the month,

1146
02:15:16,020 --> 02:15:20,100
you can see that it went, it goes to March 2nd, right?

1147
02:15:20,100 --> 02:15:25,100
The rule is that if a date time does not exist

1148
02:15:26,620 --> 02:15:30,460
in the calendar system, then you skip it.

1149
02:15:30,460 --> 02:15:35,100
And there's no way to configure this in DateUtil.

1150
02:15:35,100 --> 02:15:36,260
There is a way to configure it

1151
02:15:36,260 --> 02:15:39,780
in the more recent specs, but it's like,

1152
02:15:41,060 --> 02:15:43,220
it's a little complicated to implement

1153
02:15:43,220 --> 02:15:44,620
and I haven't done it yet.

1154
02:15:45,700 --> 02:15:47,500
So I've used by weekday a couple times.

1155
02:15:47,500 --> 02:15:50,620
This is kind of one of the more interesting ones

1156
02:15:50,620 --> 02:15:54,860
and it has kind of a little complicated use case,

1157
02:15:54,860 --> 02:15:58,500
like the way it interacts with the other components.

1158
02:15:58,500 --> 02:16:00,520
Weekday is one that you'll use a lot

1159
02:16:00,520 --> 02:16:04,340
and it just says that a recurrence will happen

1160
02:16:04,340 --> 02:16:06,260
on a specific day of the week.

1161
02:16:07,100 --> 02:16:09,240
And normally I just use the constants directly,

1162
02:16:09,240 --> 02:16:11,340
like Tuesday, Friday, something like that.

1163
02:16:11,340 --> 02:16:13,340
But occasionally you want to use,

1164
02:16:13,340 --> 02:16:15,220
you want something like the first Friday of the month

1165
02:16:15,220 --> 02:16:17,160
or the last Friday of the month.

1166
02:16:17,160 --> 02:16:21,100
So you can pass an argument and this is an index

1167
02:16:21,100 --> 02:16:25,540
and it's an index into the number of occurrences

1168
02:16:26,660 --> 02:16:29,820
of like the Friday or of that day of the week

1169
02:16:29,820 --> 02:16:32,100
within the period of the frequency.

1170
02:16:32,100 --> 02:16:34,500
So if the frequency is anything less than monthly,

1171
02:16:34,500 --> 02:16:35,740
it will just give you every Friday

1172
02:16:35,740 --> 02:16:38,500
no matter what number you put there.

1173
02:16:38,500 --> 02:16:43,500
If you use a monthly rule, then it will give you just,

1174
02:16:43,580 --> 02:16:45,480
in this case, the first Friday of the month

1175
02:16:45,480 --> 02:16:47,460
and the last Friday of the month.

1176
02:16:47,460 --> 02:16:50,220
So this is the first Friday, that's the last Friday.

1177
02:16:52,420 --> 02:16:56,220
If the frequency is, oh sorry,

1178
02:16:56,220 --> 02:16:58,460
this one is first Friday, last Friday,

1179
02:16:58,460 --> 02:16:59,660
first Friday, last Friday.

1180
02:17:00,580 --> 02:17:03,180
If the frequency is yearly,

1181
02:17:03,180 --> 02:17:05,460
then it will give you the first Friday of the year

1182
02:17:05,460 --> 02:17:07,140
and the last Friday of the year.

1183
02:17:08,060 --> 02:17:11,100
So this interaction I found out about

1184
02:17:11,100 --> 02:17:12,580
when I was writing these slides.

1185
02:17:12,580 --> 02:17:14,780
So it's not super well known.

1186
02:17:14,780 --> 02:17:15,620
Yes.

1187
02:17:15,620 --> 02:17:18,900
Is the onset based off of the painter's definition

1188
02:17:18,900 --> 02:17:21,620
that it is the onset that first opened

1189
02:17:21,620 --> 02:17:26,620
and then it was merely the onset in the beginning?

1190
02:17:27,500 --> 02:17:30,420
I mean, this is not a Python thing.

1191
02:17:30,420 --> 02:17:33,540
It comes from the iCalendar.

1192
02:17:33,540 --> 02:17:37,220
So yeah, I think it's a one-based index in both directions.

1193
02:17:37,220 --> 02:17:41,980
So the first and the last is minus one, the first is one.

1194
02:17:44,540 --> 02:17:45,380
Right.

1195
02:17:45,380 --> 02:17:48,700
So yeah, and for the small ones,

1196
02:17:48,700 --> 02:17:50,100
this is every Friday.

1197
02:17:51,900 --> 02:17:55,820
But yeah, so generally speaking with these,

1198
02:17:55,860 --> 02:17:58,660
unless you actually need a very specific frequency

1199
02:17:58,660 --> 02:18:02,860
for the reason that you're using these weekday things

1200
02:18:02,860 --> 02:18:05,340
and it actually matters what the frequency is,

1201
02:18:05,340 --> 02:18:07,100
try and keep the frequency.

1202
02:18:07,100 --> 02:18:08,900
Basically think about what it would look like

1203
02:18:08,900 --> 02:18:10,780
without, what the rule would look like

1204
02:18:10,780 --> 02:18:13,220
without filtering anything out

1205
02:18:13,220 --> 02:18:15,240
and try and pick the thing that generates

1206
02:18:15,240 --> 02:18:19,580
the least number of daytimes that get filtered out

1207
02:18:19,580 --> 02:18:20,980
because under the hood,

1208
02:18:20,980 --> 02:18:22,820
that will actually make things much slower.

1209
02:18:22,820 --> 02:18:24,580
So if I had a secondly rule

1210
02:18:24,580 --> 02:18:26,060
that generates every single second

1211
02:18:26,060 --> 02:18:29,580
from like with DT start of like 1970

1212
02:18:29,580 --> 02:18:32,940
and then I'm like filtering by day

1213
02:18:32,940 --> 02:18:35,180
and by hour and by minute and by second

1214
02:18:35,180 --> 02:18:38,540
so that it's actually just like a specific time of day

1215
02:18:38,540 --> 02:18:41,580
once a year, it will generate like thousands

1216
02:18:41,580 --> 02:18:42,860
and thousands of daytimes

1217
02:18:44,340 --> 02:18:46,740
and then most of them will get filtered out.

1218
02:18:46,740 --> 02:18:50,100
So I mean, maybe it doesn't generate actual daytimes

1219
02:18:50,100 --> 02:18:52,460
but it does a whole lot of math that it doesn't need to do.

1220
02:18:52,460 --> 02:18:56,980
So try and keep the filtering to a minimum

1221
02:18:56,980 --> 02:18:58,340
for performance reasons

1222
02:18:59,200 --> 02:19:01,300
but don't jump to that until you're starting

1223
02:19:01,300 --> 02:19:02,980
to see performance problems probably.

1224
02:19:02,980 --> 02:19:05,340
I mean, it's like a good baseline thing to do

1225
02:19:05,340 --> 02:19:08,580
but it may be that in six months

1226
02:19:08,580 --> 02:19:10,700
I find some way to like normalize these things

1227
02:19:10,700 --> 02:19:14,060
and there will actually be no performance difference.

1228
02:19:15,300 --> 02:19:17,020
So I'm just gonna show an example

1229
02:19:17,020 --> 02:19:20,000
of how you can use this to generate something

1230
02:19:20,000 --> 02:19:22,020
that may be hard to express otherwise.

1231
02:19:22,540 --> 02:19:24,380
Martin Luther King Day is a US holiday

1232
02:19:24,380 --> 02:19:27,700
and it's always the third Monday in January.

1233
02:19:29,580 --> 02:19:32,320
And its first observance was in 1986.

1234
02:19:33,460 --> 02:19:38,460
So let's say DT start equals date time 1986, 1, 1

1235
02:19:41,540 --> 02:19:46,540
and we'll do our rule will be frequency equals monthly

1236
02:19:46,540 --> 02:19:49,900
frequency equals monthly because it,

1237
02:19:52,060 --> 02:19:55,980
we need the third Monday of the month.

1238
02:19:55,980 --> 02:20:00,980
And then by weekday equals Monday one.

1239
02:20:02,860 --> 02:20:04,160
I guess I don't need this.

1240
02:20:05,500 --> 02:20:07,420
And then it needs to be in January.

1241
02:20:07,420 --> 02:20:10,660
So we'll say by month equals one.

1242
02:20:11,580 --> 02:20:16,580
And then I think that is it, right?

1243
02:20:21,260 --> 02:20:22,780
The third month, oh, you're right.

1244
02:20:22,780 --> 02:20:24,780
It's the third Monday, not the first one.

1245
02:20:29,060 --> 02:20:30,220
Yeah, but this is a monthly rule.

1246
02:20:30,220 --> 02:20:33,320
So otherwise it would generate January, February.

1247
02:20:34,460 --> 02:20:36,540
Yeah, I mean, you could use this if you had like a meetup

1248
02:20:36,540 --> 02:20:39,260
every third Monday of the month or something, right?

1249
02:20:39,260 --> 02:20:42,380
And then we need DT start, DT start.

1250
02:20:42,380 --> 02:20:45,220
I think by default DT start will be just like

1251
02:20:45,220 --> 02:20:46,100
the current date time.

1252
02:20:46,100 --> 02:20:50,860
So always specify your DT start interval defaults to one

1253
02:20:50,860 --> 02:20:52,480
frequency is required.

1254
02:20:52,480 --> 02:20:56,660
Okay, so we'll test this and I guess it just passed.

1255
02:20:57,900 --> 02:21:00,140
Sorry, I need more, I need more flare with these

1256
02:21:00,140 --> 02:21:02,900
or it like prints some amazing thing.

1257
02:21:04,260 --> 02:21:06,940
So yeah, so you can see how this would be useful.

1258
02:21:07,020 --> 02:21:10,900
There's also something related to this for things like this

1259
02:21:10,900 --> 02:21:12,420
which is called relative delta.

1260
02:21:12,420 --> 02:21:14,940
And that's a workbook we're not gonna get to

1261
02:21:14,940 --> 02:21:16,900
but it's materials slash zero four.

1262
02:21:16,900 --> 02:21:19,500
And there's like another 20 minutes worth of material there.

1263
02:21:19,500 --> 02:21:23,060
Okay, so we have an hour left.

1264
02:21:23,060 --> 02:21:28,060
I'd like to take this, we're gonna do this last workbook.

1265
02:21:28,660 --> 02:21:30,300
This is like a very interactive one.

1266
02:21:30,300 --> 02:21:35,300
So I think we're gonna do 10 minutes per exercise for this

1267
02:21:36,300 --> 02:21:37,780
and then depending on when we're done,

1268
02:21:37,780 --> 02:21:40,760
we can either jump back to one of the workbooks we skipped

1269
02:21:40,760 --> 02:21:42,740
or we can just do like 20 minutes of Q&A

1270
02:21:42,740 --> 02:21:43,860
or something like that.

1271
02:21:44,820 --> 02:21:47,780
Or we won't even get it done by in the next hour.

1272
02:21:47,780 --> 02:21:50,060
So let's see how it goes.

1273
02:21:50,060 --> 02:21:52,580
All right, so so far, honestly,

1274
02:21:52,580 --> 02:21:55,800
the things that we've done with our rules are,

1275
02:21:56,820 --> 02:22:00,140
well, sorry, the things that we've done with our rules so far

1276
02:22:01,560 --> 02:22:02,820
can get you very far, right?

1277
02:22:02,820 --> 02:22:06,900
They can do things like most holidays,

1278
02:22:06,900 --> 02:22:09,660
they can get you most kinds of meetings and things like that.

1279
02:22:09,660 --> 02:22:13,420
But there's kind of also more complicated things

1280
02:22:13,420 --> 02:22:16,940
like for example, every Sunday of the year,

1281
02:22:16,940 --> 02:22:19,460
except for Mother's Day, right?

1282
02:22:19,460 --> 02:22:20,780
And there's no way to express that

1283
02:22:20,780 --> 02:22:23,140
because it's actually like kind of an overlap

1284
02:22:23,140 --> 02:22:25,340
of two different rules, right?

1285
02:22:25,340 --> 02:22:27,900
And that's what our rule set is for.

1286
02:22:27,900 --> 02:22:32,700
Our rule set is kind of like a set of recurrences.

1287
02:22:33,860 --> 02:22:36,820
And the way it works is that you can combine

1288
02:22:36,820 --> 02:22:38,420
basically anything that generates,

1289
02:22:39,460 --> 02:22:42,900
you can combine basically anything that generates date times

1290
02:22:42,900 --> 02:22:47,500
to make just a set of recurrences.

1291
02:22:47,500 --> 02:22:49,220
And the interface looks like this.

1292
02:22:51,540 --> 02:22:53,140
Each one of these our rule sets is mutable,

1293
02:22:53,140 --> 02:22:55,700
so you'll construct one and then you'll just sort of

1294
02:22:55,700 --> 02:22:57,540
add things to it and subtract from it.

1295
02:22:58,420 --> 02:23:00,940
It has our rule which adds a recurrence rule to the set,

1296
02:23:00,940 --> 02:23:03,980
X rule which cancels out recurrences,

1297
02:23:04,820 --> 02:23:07,220
our date which is like adding one off dates,

1298
02:23:07,220 --> 02:23:10,140
and then X date which cancels one off dates.

1299
02:23:11,340 --> 02:23:13,060
So let's play around with this.

1300
02:23:14,500 --> 02:23:17,220
Right, so we'll start with our rule.

1301
02:23:17,220 --> 02:23:21,500
When you have two our rules and they can be combined

1302
02:23:21,500 --> 02:23:23,380
to make one set of recurrences.

1303
02:23:23,380 --> 02:23:26,820
So for example here, I have two rules.

1304
02:23:26,820 --> 02:23:30,460
One is the end of the month and the other is like

1305
02:23:30,460 --> 02:23:31,660
the last Friday of the month.

1306
02:23:31,660 --> 02:23:34,740
So you can imagine maybe you have some kind of event

1307
02:23:34,740 --> 02:23:36,260
that happens at the end of the month

1308
02:23:36,260 --> 02:23:39,420
and also the last Friday, like you have an alarm

1309
02:23:39,420 --> 02:23:41,500
and you want it to happen on the last Friday

1310
02:23:41,500 --> 02:23:44,540
because the developers are in,

1311
02:23:44,540 --> 02:23:47,580
it's like the day before they're gonna go out

1312
02:23:47,580 --> 02:23:52,580
for the weekend and then maybe you also want an alarm

1313
02:23:52,660 --> 02:23:56,020
for that anyone who's on call will actually see.

1314
02:23:56,860 --> 02:23:58,660
During the day that it's actually possibly

1315
02:23:58,660 --> 02:23:59,700
gonna be a problem which is like

1316
02:23:59,700 --> 02:24:02,220
some monthly transition or something.

1317
02:24:02,220 --> 02:24:05,620
I don't know why I spent so much time on this flavor text.

1318
02:24:05,620 --> 02:24:07,580
So here's what I have, right?

1319
02:24:07,580 --> 02:24:09,660
I have expressed these two things

1320
02:24:09,660 --> 02:24:12,020
and I kind of snuck in this end of the month rule

1321
02:24:12,020 --> 02:24:14,300
because this is actually a kind of hard thing to express

1322
02:24:14,300 --> 02:24:16,280
without that skipping back thing.

1323
02:24:17,700 --> 02:24:21,060
So this uses by set pause which I did not spend any time

1324
02:24:21,060 --> 02:24:23,740
talking about and you can like read the spec

1325
02:24:23,740 --> 02:24:25,380
and if you do that you'll probably understand it

1326
02:24:25,380 --> 02:24:28,940
even better than me but it's basically saying

1327
02:24:28,940 --> 02:24:33,940
like generate like this monthly thing generates

1328
02:24:34,460 --> 02:24:38,340
four day times in its set or up to four

1329
02:24:38,340 --> 02:24:40,340
depending on which ones exist and then by set pause

1330
02:24:40,340 --> 02:24:43,260
it's saying filter that down to be the last one.

1331
02:24:43,260 --> 02:24:45,480
So that's how this one works.

1332
02:24:46,500 --> 02:24:47,340
Yeah.

1333
02:24:52,940 --> 02:24:54,100
I think no.

1334
02:24:56,220 --> 02:24:59,300
I suppose it's, I don't know.

1335
02:24:59,300 --> 02:25:00,140
Let's see.

1336
02:25:01,900 --> 02:25:03,260
Oh, then maybe it does work.

1337
02:25:03,260 --> 02:25:04,100
I don't know.

1338
02:25:04,980 --> 02:25:08,140
Maybe, yeah, honestly I didn't even realize

1339
02:25:08,140 --> 02:25:11,860
that this one worked and then I like was reading something

1340
02:25:11,860 --> 02:25:13,220
and I was like oh my goodness this works

1341
02:25:13,220 --> 02:25:16,580
and then I like found myself talking about that

1342
02:25:16,580 --> 02:25:18,820
a year earlier like oh my goodness this works.

1343
02:25:18,820 --> 02:25:20,620
So I like learned things about this

1344
02:25:20,620 --> 02:25:22,400
and then immediately forget it.

1345
02:25:22,400 --> 02:25:24,580
So yes, I suppose it's very possible

1346
02:25:24,820 --> 02:25:27,180
that if by month they worked when you checked it out

1347
02:25:27,180 --> 02:25:29,540
then either there's an edge case that I wasn't thinking

1348
02:25:29,540 --> 02:25:32,540
about or I was just being stupid when I made these slides.

1349
02:25:32,540 --> 02:25:34,420
I think both of them are well within the realm

1350
02:25:34,420 --> 02:25:35,260
of possibility.

1351
02:25:36,540 --> 02:25:38,980
Okay, so no matter how we've constructed it

1352
02:25:41,300 --> 02:25:44,820
I can now combine these two and I have my R rule set.

1353
02:25:44,820 --> 02:25:47,300
I add one R rule, I add the other R rule

1354
02:25:47,300 --> 02:25:48,820
and then we're gonna print them out.

1355
02:25:48,820 --> 02:25:51,940
And so you'll notice I have two entries in March

1356
02:25:51,940 --> 02:25:54,220
and I have two entries in April

1357
02:25:54,220 --> 02:25:58,740
but then in May I only have one entry, right?

1358
02:25:58,740 --> 02:26:01,220
And the reason for that is that the last day of the month

1359
02:26:01,220 --> 02:26:03,180
in May is a Friday.

1360
02:26:04,100 --> 02:26:09,100
And the sort of set part of this is not really,

1361
02:26:10,140 --> 02:26:11,140
that's not just like,

1362
02:26:12,900 --> 02:26:15,620
it actually has properties like a set has

1363
02:26:15,620 --> 02:26:20,360
in the sense that if more than one recurrence rule

1364
02:26:20,360 --> 02:26:21,980
is generating a given daytime

1365
02:26:21,980 --> 02:26:24,220
it will only show that recurrence once.

1366
02:26:24,220 --> 02:26:27,460
So in this case both rules generated the last day of May

1367
02:26:27,460 --> 02:26:30,820
and so it said, okay, we'll just generate the last day of May

1368
02:26:30,820 --> 02:26:33,340
and ignore all the other rules that are also generating

1369
02:26:33,340 --> 02:26:34,340
the last day of May.

1370
02:26:37,020 --> 02:26:39,620
So that's something.

1371
02:26:39,620 --> 02:26:41,640
So now we're gonna start the exercise.

1372
02:26:41,640 --> 02:26:45,340
And this exercise here, it runs through the whole workbook

1373
02:26:45,340 --> 02:26:48,360
and it's essentially, so they build off of one another.

1374
02:26:48,360 --> 02:26:52,680
So if you end up messing things up

1375
02:26:52,680 --> 02:26:55,320
you may have to end up using kernel restart

1376
02:26:55,320 --> 02:26:58,380
and run all cells a couple times just in case like,

1377
02:26:58,380 --> 02:27:02,280
cause you know how Jupiter has state that can persist

1378
02:27:02,280 --> 02:27:04,080
in a way that you don't realize it.

1379
02:27:04,960 --> 02:27:07,960
So the exercise is that we're gonna build a bus schedule

1380
02:27:07,960 --> 02:27:10,080
and bus schedules can be complicated.

1381
02:27:10,080 --> 02:27:13,580
So hopefully we can see some of the complexity.

1382
02:27:14,440 --> 02:27:17,160
So the way it works, what we're gonna do is

1383
02:27:17,160 --> 02:27:18,660
we're gonna start with the base schedule

1384
02:27:18,660 --> 02:27:20,840
and the base schedule says that on weekdays,

1385
02:27:20,840 --> 02:27:24,920
Monday through Friday, the bus comes once an hour,

1386
02:27:24,920 --> 02:27:28,080
37 minutes after the hour, starting at 6.37

1387
02:27:28,080 --> 02:27:30,120
and running until 10.37, right?

1388
02:27:30,120 --> 02:27:32,560
So that's one recurrence per hour

1389
02:27:33,480 --> 02:27:36,960
and that's the total of, I don't know, however many,

1390
02:27:36,960 --> 02:27:39,080
23 minus sixes.

1391
02:27:40,840 --> 02:27:44,720
And then on weekends it has a different schedule.

1392
02:27:44,720 --> 02:27:46,840
It's like reduced schedule or something

1393
02:27:46,880 --> 02:27:50,040
from 8.07 to 7.07 at night.

1394
02:27:50,880 --> 02:27:53,760
It comes every hour, seven minutes after the hour.

1395
02:27:55,200 --> 02:27:59,960
So you can, if you don't wanna bother

1396
02:27:59,960 --> 02:28:04,960
like the two R rules for generating the schedules,

1397
02:28:06,200 --> 02:28:08,520
there's not anything terribly interesting

1398
02:28:08,520 --> 02:28:10,320
about like making the same thing twice.

1399
02:28:10,320 --> 02:28:12,740
So you can make that schedule,

1400
02:28:14,200 --> 02:28:16,240
feel free to like either make the schedule

1401
02:28:17,160 --> 02:28:19,200
for the weekday or the weekend

1402
02:28:19,200 --> 02:28:21,960
or you can just use the like weekday schedule

1403
02:28:21,960 --> 02:28:24,760
and then you write the R rule for the weekend schedule

1404
02:28:24,760 --> 02:28:26,040
and then you combine them.

1405
02:28:27,120 --> 02:28:31,240
And when you're done with that, you just run this,

1406
02:28:31,240 --> 02:28:35,120
you uncomment this and run our tests,

1407
02:28:35,120 --> 02:28:36,640
test basic bus schedule.

1408
02:28:36,640 --> 02:28:38,880
All right, so let's take 10 minutes

1409
02:28:38,880 --> 02:28:40,480
and that goes until four o'clock

1410
02:28:40,480 --> 02:28:44,680
and then remember, Red, if you need help

1411
02:28:44,680 --> 02:28:46,280
or raise your hand or something.

1412
02:29:17,080 --> 02:29:19,040
So, we're gonna do 10 minutes of this.

1413
02:29:19,040 --> 02:29:20,760
So, we're gonna do 10 minutes of this.

1414
02:29:20,760 --> 02:29:22,560
So, we're gonna do 10 minutes of this.

1415
02:29:22,560 --> 02:29:24,360
So, we're gonna do 10 minutes of this.

1416
02:29:24,360 --> 02:29:26,160
So, we're gonna do 10 minutes of this.

1417
02:29:26,160 --> 02:29:27,960
So, we're gonna do 10 minutes of this.

1418
02:29:27,960 --> 02:29:29,760
So, we're gonna do 10 minutes of this.

1419
02:29:29,760 --> 02:29:31,760
So, we're gonna do 10 minutes of this.

1420
02:29:31,760 --> 02:29:33,760
So, we're gonna do 10 minutes of this.

1421
02:29:33,760 --> 02:29:35,760
So, we're gonna do 10 minutes of this.

1422
02:29:35,760 --> 02:29:37,760
So, we're gonna do 10 minutes of this.

1423
02:29:37,760 --> 02:29:39,760
So, we're gonna do 10 minutes of this.

1424
02:29:39,760 --> 02:29:41,760
So, we're gonna do 10 minutes of this.

1425
02:29:41,760 --> 02:29:43,760
So, we're gonna do 10 minutes of this.

1426
02:29:43,760 --> 02:29:45,760
So, we're gonna do 10 minutes of this.

1427
02:29:46,620 --> 02:29:48,120
Okay.

1428
02:29:48,120 --> 02:30:15,280
Oh, one thing I forgot to mention.

1429
02:30:15,280 --> 02:30:25,120
If you want to see this, I guess I didn't put it here, but there's this thing helper.

1430
02:30:25,120 --> 02:30:31,160
So I have a helper function that makes it easier to see this.

1431
02:30:31,160 --> 02:30:36,360
It's called display underscore bus underscore schedule.

1432
02:30:36,360 --> 02:30:38,040
And you can see your progress.

1433
02:30:38,040 --> 02:30:41,720
Like, this is just the weekdays.

1434
02:30:41,720 --> 02:30:47,440
So this is maybe like a convenient way to look at your progress instead of parsing some

1435
02:30:47,440 --> 02:30:48,880
complicated list of date times.

1436
02:39:11,720 --> 02:39:23,160
It's four.

1437
02:39:23,160 --> 02:39:30,840
And I think whether, if you've done or not, let's just...

1438
02:39:30,840 --> 02:39:34,040
All right, so how many people are still working?

1439
02:39:34,040 --> 02:39:35,040
Okay.

1440
02:39:35,040 --> 02:39:39,720
That's a good fraction.

1441
02:39:39,720 --> 02:39:50,000
I think it's probably best to move on, but you can still work on it, work and listen.

1442
02:39:50,000 --> 02:39:56,160
But obviously, since these build on each other, you'll need the output of the first one for

1443
02:39:56,160 --> 02:39:57,160
the second one.

1444
02:39:57,160 --> 02:40:01,480
So if you don't end up getting it before it's time for the next one, you can just do weekend

1445
02:40:01,480 --> 02:40:02,480
schedule.

1446
02:40:03,080 --> 02:40:12,400
Well, yeah, you can do weekend schedule equals rr underscore answers dot get weekend schedule.

1447
02:40:12,400 --> 02:40:14,600
And now you have the weekend and weekday schedules.

1448
02:40:14,600 --> 02:40:26,040
And then you do bus schedule dot rrule weekday schedule, bus schedule dot rrule weekend schedule.

1449
02:40:26,040 --> 02:40:28,320
And that adds them both.

1450
02:40:28,320 --> 02:40:29,320
And now...

1451
02:40:29,320 --> 02:40:32,320
What's happening here?

1452
02:40:32,320 --> 02:40:36,760
Oh, I put weekday schedule.

1453
02:40:36,760 --> 02:40:40,320
I meant to put bus schedule.

1454
02:40:40,320 --> 02:40:41,320
Now I have these.

1455
02:40:41,320 --> 02:40:47,160
Okay, but I'm going to go through quickly how I would do the weekday schedule one.

1456
02:40:47,160 --> 02:40:51,720
So we'll say weekday schedule equals rrrule.

1457
02:40:51,720 --> 02:40:53,600
And you can use a daily rule or a monthly rule.

1458
02:40:53,600 --> 02:40:56,280
Or an hourly rule or whatever.

1459
02:40:56,280 --> 02:40:58,640
It doesn't really matter.

1460
02:40:58,640 --> 02:41:04,120
I'm going to use a daily rule because there will be less things filtered out.

1461
02:41:04,120 --> 02:41:06,240
Freq equals daily.

1462
02:41:06,240 --> 02:41:09,240
And then we know that we want to start.

1463
02:41:09,240 --> 02:41:15,640
It goes, let's say, oh, we already have our DT start at the top.

1464
02:41:16,640 --> 02:41:24,640
And the rule is that we need to do it every hour on the hour between 6 and 10.

1465
02:41:24,640 --> 02:41:27,320
So I'm going to say by hour equals range.

1466
02:41:27,320 --> 02:41:30,080
And again, you can use pretty much any iterator here.

1467
02:41:30,080 --> 02:41:33,320
6 and 23.

1468
02:41:33,320 --> 02:41:38,420
And then by minute equals 37 because I want it to be on the 37.

1469
02:41:38,420 --> 02:41:41,060
And then I need to filter it by weekdays.

1470
02:41:41,060 --> 02:41:46,300
So I'll say by weekday equals weekdays.

1471
02:41:46,300 --> 02:41:49,740
And I've helpfully defined that above.

1472
02:41:49,740 --> 02:41:54,420
And then for weekend schedule, it's basically the same thing.

1473
02:41:54,420 --> 02:41:58,440
Except instead of weekdays, it's weekends.

1474
02:41:58,440 --> 02:42:03,620
And instead of 6 to 11, it is 8 to 20.

1475
02:42:03,620 --> 02:42:06,500
And instead of 37, it's 7.

1476
02:42:06,500 --> 02:42:16,760
And now if I run these three right here, then I get, oh, this is wrong.

1477
02:42:16,760 --> 02:42:19,960
Oh, it's because I named this weekday schedule.

1478
02:42:19,960 --> 02:42:23,560
My mistake, my mistake.

1479
02:42:23,560 --> 02:42:24,360
There we go.

1480
02:42:24,360 --> 02:42:28,800
So you can see we have our schedule.

1481
02:42:28,800 --> 02:42:31,640
It should look like that.

1482
02:42:31,640 --> 02:42:32,160
OK.

1483
02:42:32,160 --> 02:42:35,360
And if I run the tests, hey, it works.

1484
02:42:35,360 --> 02:42:35,860
All right.

1485
02:42:35,860 --> 02:42:38,820
Let's move on next to discussing X rule.

1486
02:42:38,820 --> 02:42:43,680
So X rule is just like R rule, except instead of adding date times,

1487
02:42:43,680 --> 02:42:45,860
or adding recurrences, it just takes them away.

1488
02:42:45,860 --> 02:42:51,780
So what happens is under the hood, it's going to just generate one recurrence

1489
02:42:51,780 --> 02:42:54,260
from each of the different R rules and one recurrence from each

1490
02:42:54,260 --> 02:42:55,280
of the different X rules.

1491
02:42:55,280 --> 02:42:59,700
And then it's going to pop them off in order.

1492
02:42:59,700 --> 02:43:04,120
And if an X rule matches a recurrence, matches any of the R rules or R dates,

1493
02:43:04,120 --> 02:43:08,820
it's just going to obliterate that and then keep moving down the line.

1494
02:43:08,820 --> 02:43:13,000
And if it doesn't match anything, it just keeps moving down the line.

1495
02:43:13,000 --> 02:43:17,460
So this is, again, very similar to the diff behavior of a set.

1496
02:43:17,460 --> 02:43:21,540
If you have a set that has 1, 5, and 7 in it, and then you subtract 7,

1497
02:43:21,540 --> 02:43:22,780
you get 1, 5.

1498
02:43:22,780 --> 02:43:26,820
And if you subtract 9, you get 1, 5.

1499
02:43:26,820 --> 02:43:31,940
So here, I'm going to use X rule to implement that rule that I said

1500
02:43:31,940 --> 02:43:36,160
we couldn't do with just a pure R rule, which is every Sunday,

1501
02:43:36,160 --> 02:43:37,840
except Mother's Day.

1502
02:43:37,840 --> 02:43:48,160
And Mother's Day is one of these, huh, I'm going to just make this monthly,

1503
02:43:48,160 --> 02:43:51,280
is one of these second Sunday of the month kind of things.

1504
02:43:51,280 --> 02:43:58,560
And it says, so if I do this, you know, that's weird.

1505
02:43:58,560 --> 02:44:03,880
I guess yearly works, right, because that's actually when Mother's Day is.

1506
02:44:03,880 --> 02:44:07,680
So maybe I misled you about this Sunday thing.

1507
02:44:07,680 --> 02:44:10,920
Maybe if you have a bi-month, it's equivalent to being monthly.

1508
02:44:10,920 --> 02:44:14,000
This is so confusing.

1509
02:44:14,000 --> 02:44:19,820
So yeah, but in any case, let's just do it the other way.

1510
02:44:19,820 --> 02:44:21,360
So I have my every Sunday rule.

1511
02:44:21,360 --> 02:44:23,040
I have my Mother's Day rule.

1512
02:44:23,040 --> 02:44:24,840
I will create a rule set.

1513
02:44:24,840 --> 02:44:28,760
I'll make that the basis of the, I'll make the every Sunday rule the base

1514
02:44:28,760 --> 02:44:29,760
with R rule.

1515
02:44:29,760 --> 02:44:31,600
And then I'll exclude every Mother's Day.

1516
02:44:31,600 --> 02:44:40,960
So if I combine them together, you can see Mother's Day is May 12, 2019.

1517
02:44:40,960 --> 02:44:46,760
And then if you combine the two, you get, you know, Sunday, Sunday, Sunday,

1518
02:44:46,760 --> 02:44:48,920
and then a gap, and then Sunday, Sunday.

1519
02:44:48,920 --> 02:44:52,840
So that's it.

1520
02:44:52,840 --> 02:44:58,000
One useful trick that I found for limiting some rules, right, is that you

1521
02:44:58,000 --> 02:45:02,080
may have some kind of complicated rule, and then you want to, like, cut out a

1522
02:45:02,080 --> 02:45:06,960
certain, like, you want to cut out a certain subset of it.

1523
02:45:06,960 --> 02:45:12,120
You can use R rule.replace to do this by generating, you basically take an R

1524
02:45:12,120 --> 02:45:16,280
rule, you take the exact same, you create the exact same R rule, but modify it in

1525
02:45:16,280 --> 02:45:19,120
some slight way, right, and then you add that as an X rule.

1526
02:45:19,120 --> 02:45:22,160
So it's going to be generating based on very similar rules.

1527
02:45:22,240 --> 02:45:26,240
So for example, here I have a rule that generates every single Friday.

1528
02:45:26,240 --> 02:45:30,200
So it's a weekly rule Friday, and it generates it at nine and five.

1529
02:45:30,200 --> 02:45:32,920
Every Friday, nine and five.

1530
02:45:32,920 --> 02:45:38,800
And then Friday, and then say I want to exclude from that rule anything that's

1531
02:45:38,800 --> 02:45:40,560
on Friday the 13th.

1532
02:45:40,560 --> 02:45:43,840
You can't just kind of have, like, a filter lambda or whatever that's, like,

1533
02:45:43,840 --> 02:45:45,840
anything that matches this, filter it out.

1534
02:45:45,840 --> 02:45:48,880
So what you have to do is you have to generate the same date times, and you can

1535
02:45:48,880 --> 02:45:53,480
do that by just adding the by month day, which to 13, right?

1536
02:45:53,480 --> 02:45:58,560
So we want this rule, but only when it falls on Friday the 13th.

1537
02:45:58,560 --> 02:46:03,040
And if I add one and then subtract the other, then I'm going to get, you know,

1538
02:46:03,040 --> 02:46:07,080
nine and five every Friday except for Friday the 13th.

1539
02:46:07,080 --> 02:46:07,720
Okay.

1540
02:46:07,720 --> 02:46:17,320
So now we're going to go with the next exercise, which is to reduce the evening

1541
02:46:17,320 --> 02:46:18,400
bus service.

1542
02:46:18,440 --> 02:46:23,680
So, you know, after rush hour or whatever, we'll say that the buses, instead of

1543
02:46:23,680 --> 02:46:25,640
coming every hour, they come every other hour.

1544
02:46:25,640 --> 02:46:36,160
So we're going to take our original bus schedule, and we want to drop the, all the

1545
02:46:36,160 --> 02:46:42,040
recurrences that occur after, every other recurrence that occurs after 6 p.m.

1546
02:46:42,040 --> 02:46:46,280
So the seven o'clock and nine o'clock buses, they just are not in the schedule

1547
02:46:46,280 --> 02:46:47,200
anymore.

1548
02:46:47,200 --> 02:46:54,760
So go ahead and we'll take our original bus schedule object and modify that with

1549
02:46:54,760 --> 02:47:00,640
like an X rule or, I mean, I'll be, I'm just being suggestive, but yeah, an X

1550
02:47:00,640 --> 02:47:01,440
rule.

1551
02:47:01,440 --> 02:47:04,440
And then uncomment this for the tests.

1552
02:47:04,440 --> 02:47:09,200
And then we'll look at the answer at 418.

1553
02:47:47,200 --> 02:48:00,040
So someone just mentioned that I actually made a mistake here.

1554
02:48:00,040 --> 02:48:05,440
This is not supposed to be, like this will just pass this test because it's, this

1555
02:48:05,440 --> 02:48:06,840
is test basic bus schedule.

1556
02:48:06,840 --> 02:48:08,840
So you're going to have to change that to evening.

1557
02:48:09,560 --> 02:48:13,280
So test evening base schedule, bus schedule, and that will actually throw

1558
02:48:13,280 --> 02:48:14,680
errors until you fix it.

1559
02:48:15,680 --> 02:48:18,840
Of course, it's a totally uninformative error.

1560
02:48:18,840 --> 02:48:20,160
It's like, oh, this is wrong.

1561
02:48:20,160 --> 02:48:22,080
So again, sorry about that.

1562
02:56:44,680 --> 02:56:52,120
So it's 418.

1563
02:56:52,120 --> 02:56:54,720
So I'm going to take a crack at this.

1564
02:56:56,720 --> 02:56:57,320
All right.

1565
02:56:57,320 --> 02:57:07,280
So here we have, so now what we have so far, I'm going to display the schedule,

1566
02:57:07,280 --> 02:57:12,040
display bus schedule, bus schedule.

1567
02:57:12,040 --> 02:57:12,280
Right.

1568
02:57:12,280 --> 02:57:15,480
So what we have so far is we have our regular rule and what we need to

1569
02:57:15,480 --> 02:57:19,560
eliminate is this occurrence and this occurrence.

1570
02:57:19,560 --> 02:57:24,080
So that's a rule that can be deleted.

1571
02:57:24,080 --> 02:57:26,760
So we're going to use X rule for that.

1572
02:57:26,760 --> 02:57:33,920
So now what I need is I need the subset of, I need a rule that generates only

1573
02:57:33,920 --> 02:57:36,200
these occurrences and these occurrences.

1574
02:57:36,200 --> 02:57:37,120
Right.

1575
02:57:37,160 --> 02:57:47,400
So what I'll get is I'll have evening reduced equals our rule, freak equals,

1576
02:57:47,400 --> 02:57:49,560
actually, I can use that replace trick.

1577
02:57:49,560 --> 02:57:49,800
Right.

1578
02:57:49,800 --> 02:57:53,520
So I can say weekday schedule dot replace.

1579
02:57:53,520 --> 02:57:57,560
So I want to generate the exact same rule as we use for the weekday schedule.

1580
02:57:57,560 --> 02:58:03,120
But now instead of by hour being like six, seven, eight, nine, ten, I only want

1581
02:58:03,120 --> 02:58:06,280
the ones that are seven and nine in the evening.

1582
02:58:06,320 --> 02:58:12,920
So I can say by hour equals 19 and 21.

1583
02:58:12,920 --> 02:58:22,840
You can probably be, you know, you can also maybe do like range 19, 23, 2,

1584
02:58:22,840 --> 02:58:27,760
something like that, but it's only two elements, so it's actually less typing

1585
02:58:27,760 --> 02:58:32,200
to just specify all the hours.

1586
02:58:32,240 --> 02:58:39,640
So now I have that and I'm just going to see if it's exactly what I want.

1587
02:58:39,640 --> 02:58:40,040
Right.

1588
02:58:40,040 --> 02:58:42,040
Evening reduced.

1589
02:58:42,040 --> 02:58:43,520
You can see, yep, that's exactly what I wanted.

1590
02:58:43,520 --> 02:58:47,720
I just want the ones on the weekends or, you know, I mean the weeknights.

1591
02:58:47,720 --> 02:58:48,120
Okay.

1592
02:58:48,120 --> 02:58:55,960
So then I will take my bus schedule and I will add this as an X rule.

1593
02:58:55,960 --> 02:58:58,160
Evening reduced.

1594
02:58:58,160 --> 02:59:00,920
And when we check it again, here we go.

1595
02:59:00,960 --> 02:59:02,680
It's looking good.

1596
02:59:02,680 --> 02:59:05,080
And this is no longer failing.

1597
02:59:05,080 --> 02:59:05,600
Okay.

1598
02:59:05,600 --> 02:59:06,520
Great.

1599
02:59:06,520 --> 02:59:10,800
So now we've covered adding rules, we've covered subtracting rules, and then the

1600
02:59:10,800 --> 02:59:13,240
last thing is sort of one-offs, right?

1601
02:59:13,240 --> 02:59:17,920
There's no specific rule that generates these things.

1602
02:59:17,920 --> 02:59:25,480
It's really just, you know, this subset of it is, this extra thing is happening or

1603
02:59:25,480 --> 02:59:28,160
this particular date, it just gets canceled, right?

1604
02:59:28,160 --> 02:59:33,800
So, you know, you can imagine there's a meeting that's every Wednesday at 2 o'clock

1605
02:59:33,800 --> 02:59:37,920
and the person who organized the meeting is on vacation on June 12th, right?

1606
02:59:37,920 --> 02:59:39,360
That's not something that's recurring.

1607
02:59:39,360 --> 02:59:42,600
It's not every June 12th, it's just June 12th.

1608
02:59:42,600 --> 02:59:48,640
So what we do is if we have our rule for a meeting, we create an R rule set and we

1609
02:59:48,640 --> 02:59:52,960
add the meeting as the basis and then we say, let's just take the recurrence that

1610
02:59:53,000 --> 02:59:59,040
happens on June 12th, you know, and we could get that from dot after or dot before or

1611
02:59:59,040 --> 03:00:03,360
whatever or we can just manually put it in there.

1612
03:00:03,360 --> 03:00:06,160
And then we'll add that as an X date, right?

1613
03:00:06,160 --> 03:00:08,080
So it's just like cancel it out.

1614
03:00:08,080 --> 03:00:12,800
And so then what happens is we have, you know, it'll just skip the one on Wednesday.

1615
03:00:12,800 --> 03:00:15,240
But then you can imagine the meeting organizers, they're just out for that one

1616
03:00:15,240 --> 03:00:18,480
day because they have like a dance recital or something.

1617
03:00:18,480 --> 03:00:23,640
And so they just rescheduled for the next day.

1618
03:00:23,640 --> 03:00:30,280
So instead of it being June 12th at 2 o'clock, it's June 13th at 10 a.m.

1619
03:00:30,280 --> 03:00:33,800
So we can just do our, again, one-off exception.

1620
03:00:33,800 --> 03:00:37,480
We'll use our date and we'll just add a specific example.

1621
03:00:37,480 --> 03:00:38,240
So June 13th.

1622
03:00:38,240 --> 03:00:43,680
So normally this rule is, you know, every, what is it, every Wednesday at 2.

1623
03:00:43,680 --> 03:00:47,080
But here it's missing this one Wednesday and it's adding a Thursday.

1624
03:00:47,120 --> 03:00:47,800
Okay, great.

1625
03:00:47,800 --> 03:00:51,440
This is how you do like a stock exchange holiday calendar?

1626
03:00:51,440 --> 03:00:57,240
Yeah, depending on what the holiday, like, yeah, like certain bank holidays or like

1627
03:00:57,240 --> 03:01:00,840
Memorial Day, Mother's Day, those things like those, those ones are going to be,

1628
03:01:00,840 --> 03:01:02,120
you can use a rule for it.

1629
03:01:02,120 --> 03:01:09,480
But yeah, like certain hard-coded days like July 4th, December 25th, things like that.

1630
03:01:09,480 --> 03:01:15,520
Yeah, you could like, you would do hard-coded X dates or R dates or something like that.

1631
03:01:15,520 --> 03:01:16,920
Okay, all right.

1632
03:01:16,920 --> 03:01:26,720
So now we're going to do the last exercise in our, in our bus schedule, which is that you can,

1633
03:01:26,720 --> 03:01:32,080
you know, so far we've been in this idyllic town where buses all run on schedules and things.

1634
03:01:32,080 --> 03:01:36,280
But maybe it's getting a little like, it's getting a little more real.

1635
03:01:36,280 --> 03:01:38,000
Like this is like the wire stuff, right?

1636
03:01:38,000 --> 03:01:42,840
Because in our hypothetical town, the politicians are like, well, you know what?

1637
03:01:42,880 --> 03:01:48,120
We really need to do a lot of improvements to this bus line on, let's say, I don't know,

1638
03:01:48,120 --> 03:01:49,880
like November 3rd, 2020.

1639
03:01:49,880 --> 03:01:51,480
I'm like, wait, is that election day?

1640
03:01:51,480 --> 03:01:54,720
And they're like, yeah, how strange, like, that you guys can't get to the polls

1641
03:01:54,720 --> 03:01:55,800
if you take the bus.

1642
03:01:55,800 --> 03:01:57,640
Oh, well, anyway, I guess it's canceled.

1643
03:01:57,640 --> 03:02:04,400
So, you know, if you have ethical issues creating like this R rule set that actually cancels it,

1644
03:02:04,400 --> 03:02:09,080
like let's just imagine in our scenario that it's not that you're actually making the schedule,

1645
03:02:09,360 --> 03:02:13,360
that you're like documenting it and you're going to send it to FEC and be like,

1646
03:02:13,360 --> 03:02:15,760
we got to get these guys.

1647
03:02:15,760 --> 03:02:21,880
So, yeah, so let's just be descriptive about it and say, let's imagine,

1648
03:02:21,880 --> 03:02:36,120
let's use X date to cancel just one day's worth of bus schedule for the day of November 3rd, 2020.

1649
03:02:36,160 --> 03:02:41,880
And then we'll take, remember to use the green, like you guys may be getting the hang of this,

1650
03:02:41,880 --> 03:02:45,000
so put the green ones on if you guys are done early,

1651
03:02:45,000 --> 03:02:48,720
because once a good number of people are done, we'll just jump to the Q&A.

1652
03:02:48,720 --> 03:02:56,520
So, otherwise, we'll finish here at 4.32, something like that, like say eight minutes from now.

1653
03:10:36,120 --> 03:11:03,360
All right.

1654
03:11:03,360 --> 03:11:08,840
So, it is 4.32, we have eight minutes left.

1655
03:11:08,840 --> 03:11:14,040
So, I think I'm just going to show you guys how I'm going to do this,

1656
03:11:14,040 --> 03:11:20,640
and then we'll kick it into just some Q&A, and then you can always feel free to like,

1657
03:11:20,640 --> 03:11:27,320
you know, email me some questions, you know, later if you have them or if there's a little bit of time after,

1658
03:11:27,320 --> 03:11:31,080
I'm happy to answer some quick questions.

1659
03:11:31,080 --> 03:11:33,040
Okay.

1660
03:11:33,040 --> 03:11:40,920
So, show of hands, how many people finished the exercise before this?

1661
03:11:40,920 --> 03:11:41,680
Okay.

1662
03:11:41,680 --> 03:11:46,840
And of those people, how many finished this exercise by now?

1663
03:11:46,840 --> 03:11:48,640
So, a smaller fraction.

1664
03:11:48,640 --> 03:11:50,600
Okay.

1665
03:11:50,600 --> 03:11:51,920
I'm just trying to gauge like this.

1666
03:11:51,920 --> 03:11:56,520
I know that I've stacked it, so like the people who are a little slower on the earlier ones,

1667
03:11:56,520 --> 03:11:59,600
like they are falling further and further behind,

1668
03:11:59,600 --> 03:12:04,440
but I thought it might be nice to have a kind of theme running through the thing.

1669
03:12:04,440 --> 03:12:05,760
Great.

1670
03:12:05,760 --> 03:12:12,920
So, there's a bit of a trick to this one, I think, in that you can make it much easier.

1671
03:12:12,920 --> 03:12:18,720
You can just try and figure out what the recurrences are and then hard code them in.

1672
03:12:18,720 --> 03:12:25,560
Another way to do that is we already have a rule that generates all the bus schedule times

1673
03:12:25,600 --> 03:12:32,760
during this, during this, during that day, and that's the R rule that we're about to modify.

1674
03:12:32,760 --> 03:12:52,520
So, if I say recurrences on election day equals bus schedule dot between date time 2020-11-3,

1675
03:12:52,560 --> 03:12:55,480
date time 2020-11-4.

1676
03:12:55,480 --> 03:13:04,560
Oh, some of you may have tried to like just do an X, an X date on the, just the 2020-11-3,

1677
03:13:04,560 --> 03:13:10,520
which, you know, again, it would be nice if you could just sort of arbitrarily be like cancel everything on this day,

1678
03:13:10,520 --> 03:13:12,720
but that's just not how the standard works.

1679
03:13:12,720 --> 03:13:20,200
So, and this represents actually November 3rd, 2020 at midnight, right?

1680
03:13:20,200 --> 03:13:25,280
So, if there's not a recurrence at midnight, which there's not, it will cancel nothing.

1681
03:13:25,280 --> 03:13:31,920
So, we have, now we have recurrences on election day, right, which is a list,

1682
03:13:31,920 --> 03:13:33,800
and so we can just like iterate over this.

1683
03:13:33,800 --> 03:13:39,600
So, like forward DT in recurrences.

1684
03:13:39,600 --> 03:13:48,800
Oh, in recurrences on election day, bus schedule dot EX date DT,

1685
03:13:48,840 --> 03:13:51,080
and then we'll just like cancel those all out.

1686
03:13:51,080 --> 03:13:54,840
And you can see, like if I run this again, it will do nothing.

1687
03:13:54,840 --> 03:14:01,280
I mean, it'll probably make that bus schedule object a little bit bigger, but it doesn't matter, right?

1688
03:14:01,280 --> 03:14:07,280
So, what this did was it, the bus schedule dot EX date, it generated all the,

1689
03:14:07,280 --> 03:14:12,320
it generated all the recurrences on that date, and then we just went through one at a time and canceled them.

1690
03:14:12,320 --> 03:14:17,320
If you want to do R date, you could, you know, in the, there's this bonus exercise

1691
03:14:17,320 --> 03:14:21,960
where you can use an R date and just manually add in two more, and the flavor text is there like,

1692
03:14:21,960 --> 03:14:28,240
oh, we're bowing to pressure, so we'll give you a bus at 432 in the morning and one at 8 in the evening.

1693
03:14:28,240 --> 03:14:32,880
But don't worry, you can vote if you just get there at five in the morning.

1694
03:14:32,880 --> 03:14:35,560
So, all right, so that's done.

1695
03:14:35,560 --> 03:14:43,200
We have our test passing, and then at the end of the day, we can, oh, uncomment this,

1696
03:14:43,200 --> 03:14:47,240
and then actually name it the same as we named it in every other thing.

1697
03:14:47,240 --> 03:14:51,840
And we get our thing, oh, it's Tuesday.

1698
03:14:51,840 --> 03:14:55,880
Oh, I thought that it would have a Tuesday in there.

1699
03:14:55,880 --> 03:14:59,400
I guess I messed that up a little bit, but there should be a Tuesday, and it's empty.

1700
03:14:59,400 --> 03:15:02,040
But you can see it goes Monday and then Tuesday.

1701
03:15:02,040 --> 03:15:06,320
All right, so that's our bus schedule.

1702
03:15:06,320 --> 03:15:11,480
Again, there's a bunch more workbooks in here that you can go through.

1703
03:15:11,480 --> 03:15:16,480
Also, all this material is public domain, so if you want to take it back to your work

1704
03:15:16,720 --> 03:15:23,720
and show it to people or whatever, that's totally copacetic from a licensing perspective.

1705
03:15:23,720 --> 03:15:30,720
So, thank you very much for coming to my tutorial, and I would be happy to take some questions.

1706
03:15:31,720 --> 03:15:32,720
Oh.

1707
03:15:32,720 --> 03:15:37,720
So, the question is about serializing day times.

1708
03:15:38,720 --> 03:15:45,720
I think daytime works fine with pickle.

1709
03:15:45,720 --> 03:15:52,720
The time zone stuff, PyTZ and dateutil will do different things based on using them with

1710
03:15:52,720 --> 03:15:53,720
pickle.

1711
03:15:53,720 --> 03:15:58,720
I think dateutil's zones will like pickle all the information and then give you the

1712
03:15:58,720 --> 03:16:03,720
exact same TZ info back, even if your system date time has changed.

1713
03:16:03,720 --> 03:16:08,720
PyTZ, it may be different, but it's still a good way to get your data back.

1714
03:16:08,720 --> 03:16:11,720
So, I think that's all I have to say.

1715
03:16:11,720 --> 03:16:14,720
I think that's all I have to say.

1716
03:16:14,720 --> 03:16:17,720
I think that's all I have to say.

1717
03:16:18,720 --> 03:16:21,720
So, I think that's all I have to say.

1718
03:16:21,720 --> 03:16:24,720
I think that's all I have to say.

1719
03:16:24,720 --> 03:16:27,720
I think that's all I have to say.

1720
03:16:27,720 --> 03:16:30,720
I think that's all I have to say.

1721
03:16:30,720 --> 03:16:33,720
I think that's all I have to say.

1722
03:16:33,720 --> 03:16:36,720
I think that's all I have to say.

1723
03:16:36,720 --> 03:16:39,720
I think that's all I have to say.

1724
03:16:39,720 --> 03:16:42,720
I think that's all I have to say.

1725
03:16:42,720 --> 03:16:45,720
I think that's all I have to say.

1726
03:16:45,720 --> 03:16:48,720
I think that's all I have to say.

1727
03:16:48,720 --> 03:16:51,720
So, yeah, but other than that, I mean, generally speaking with pickles, I think you really

1728
03:16:51,720 --> 03:16:55,720
only want to use that from like one process to another process that are both the exact

1729
03:16:55,720 --> 03:16:58,720
same python on the same machine or maybe on a couple different machines that are all in

1730
03:16:58,720 --> 03:17:00,720
the cluster.

1731
03:17:00,720 --> 03:17:03,720
So, I think it works well enough for that use case.

1732
03:17:03,720 --> 03:17:08,720
And then, as for databases, I don't know too much about how it works with databases.

1733
03:17:08,720 --> 03:17:10,720
I think Postgres does an okay job.

1734
03:17:10,720 --> 03:17:12,720
There was a talk here last year.

1735
03:17:12,720 --> 03:17:17,800
last year, it was like a 45 minute talk on time zones, and he had a whole section on

1736
03:17:17,800 --> 03:17:23,360
different databases and how they handle time zones, and it was pretty good. So I think

1737
03:17:23,360 --> 03:17:30,360
his name was David Guden or Goulden, something like that. Okay. So other questions?

1738
03:17:43,720 --> 03:17:50,720
What? Which test? Oh, it's checking. Oh, so you want this to say 39? Oh, okay. All right,

1739
03:17:54,480 --> 03:18:01,480
yeah. So thank you. I will fix that. I'll either fix that or the test. All right. Any

1740
03:18:01,760 --> 03:18:04,760
other questions? Yes?

1741
03:18:04,760 --> 03:18:11,760
Okay. So the question is, could we use plus and minus operators for our real sets? I think

1742
03:18:11,760 --> 03:18:18,760
that that's fine. I think maybe I would want to override the bar and like the binary or

1743
03:18:18,760 --> 03:18:25,760
and binary and or it might be minus either way. The equivalent operation is in sets because

1744
03:18:25,760 --> 03:18:32,760
it's closer to what's happening. I'll have to think about that. I'm not sure that I really

1745
03:18:40,800 --> 03:18:47,800
want to be playing with the interface too much because there's plenty of people, like

1746
03:18:47,800 --> 03:18:53,800
there's a lot of other things to fix. I think that's fine. I think that's fine. I think

1747
03:18:53,800 --> 03:18:57,840
there's plenty of people, like there's a lot of other things to fix. But if you want

1748
03:18:57,840 --> 03:19:04,840
to jump on the issue tracker and come up with a little prototype of how it could work, I'd

1749
03:19:06,080 --> 03:19:13,080
be interested in discussing that. I want the software to be easy to use. Okay. Other questions?

1750
03:19:17,520 --> 03:19:20,760
So it's 4.40. Feel free to leave or feel free to stick around.

