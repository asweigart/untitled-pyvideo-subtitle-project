1
00:00:00,000 --> 00:00:06,400
Hello everybody. Welcome to the third talk in this afternoon block. First, well, third

2
00:00:06,400 --> 00:00:14,400
up, we're going to have Nicole Cisneros, trying to get that right, speaking about AITA, why

3
00:00:14,400 --> 00:00:25,600
internationalization and localization matter. Please welcome Nicole Cisneros.

4
00:00:25,600 --> 00:00:33,120
Hello everyone. Can you hear me fine? This is okay. So my name is Nicole, and I'm here

5
00:00:33,120 --> 00:00:41,240
today to talk about internationalization and localization and why these concepts are important

6
00:00:41,240 --> 00:00:48,400
for your applications in general. Oh, does anyone here know what AITA means? That's in

7
00:00:48,400 --> 00:00:56,040
the title? Oh, yeah, okay. So don't worry, it's not a bad language. I know that the standard

8
00:00:56,040 --> 00:01:01,920
for learning a new language is to learn the curse words first. That's not the case. Don't

9
00:01:01,920 --> 00:01:09,240
worry. So it's a Portuguese expression, actually, and it's used when something unexpected happens.

10
00:01:09,360 --> 00:01:19,400
By the end of the talk, you will understand why AITA is in the title of this presentation.

11
00:01:19,400 --> 00:01:24,360
And why do I have a Portuguese word in the title of my presentation? Well, because I'm

12
00:01:24,360 --> 00:01:32,920
Brazilian, and actually in Brazil, we speak Portuguese, not Spanish. Shocking, I know,

13
00:01:32,920 --> 00:01:41,280
but it's Portuguese. I'm a full stack developer at LabCodes. I work with Python in Django.

14
00:01:41,280 --> 00:01:50,200
In the backend and the frontend, I work with JavaScript, some Angular, some React stuff,

15
00:01:50,200 --> 00:01:57,600
and I'm a huge fan of the Python community. I'm part of the Python users group back in

16
00:01:57,600 --> 00:02:08,440
my state. I'm also part of the PyLadies group in my city. Brazil is very huge as the US.

17
00:02:08,440 --> 00:02:13,280
So I flagged my city over there in the map. It's a very sunny place. We have a lot of

18
00:02:13,280 --> 00:02:19,120
great beaches, so feel welcome to visit in time that you want some warmer place to be

19
00:02:19,120 --> 00:02:27,880
because he is very cold for me. And as I said, I work at LabCodes, which is a software studio

20
00:02:27,880 --> 00:02:35,760
based in Brazil that designs, implements, and scales digital products. We deliver great

21
00:02:35,760 --> 00:02:44,480
experiences and build web applications that fit our customers' needs using Python, Django,

22
00:02:44,480 --> 00:02:52,120
JavaScript, especially React. Our projects are centered in creating unique solutions

23
00:02:52,120 --> 00:02:59,920
and bringing value to their users and therefore to our customers. We have been partnering

24
00:02:59,920 --> 00:03:06,260
with the US clients for almost five years now and helping a big variety of companies

25
00:03:06,260 --> 00:03:14,180
from one-person startups and Y Combinator startups to well-established companies throughout

26
00:03:14,180 --> 00:03:21,380
the US. Our team is very talented and recognizes worldwide giving talks like this one and many

27
00:03:21,380 --> 00:03:27,460
conferences and mentoring people. And this is actually my second PyCon. Thanks to the

28
00:03:27,460 --> 00:03:32,340
support of LabCodes, they are very helpful. They help me to bring these talks together.

29
00:03:32,340 --> 00:03:38,540
They finance me to come here, so it's great. And I will be in the conference until tomorrow,

30
00:03:38,540 --> 00:03:42,820
so if you want to talk about LabCodes, ping me. My contact information will be in the

31
00:03:42,820 --> 00:03:48,620
last slide. And this year we are sponsoring PyGotham, which is going to happen in October

32
00:03:48,620 --> 00:03:54,100
in New York. So I hope I can see some of you lovely folks over there, too. I will be over

33
00:03:55,100 --> 00:04:03,820
there. So this is the agenda for this presentation. First, we are going to discuss the definition

34
00:04:03,820 --> 00:04:09,260
of internationalization and localization and why does it matter? Why is it important for

35
00:04:09,260 --> 00:04:15,860
your application? And then we will go over some of the internationalization tools that

36
00:04:15,860 --> 00:04:22,500
the developers have available to work with their Python and Django applications. Last,

37
00:04:22,500 --> 00:04:27,820
but definitely less important, I will present to you what we were able to do when managing

38
00:04:27,820 --> 00:04:37,420
localization, especially translations in a multiplatform system. Okay. So let's start

39
00:04:37,420 --> 00:04:44,900
by addressing the difference between localization and internationalization. Fun fact, I didn't

40
00:04:44,900 --> 00:04:54,940
know what I 18 N and L 10 N means until very recently. They are numeronimous, which means

41
00:04:54,940 --> 00:05:01,700
that there are 18 letters between I and N in internationalization. The same for localization.

42
00:05:01,700 --> 00:05:06,460
And to be honest, I didn't even know that numeronimous was a thing, but apparently it

43
00:05:07,460 --> 00:05:16,380
are. Localization is the process of adapting an application, a product, or even just a document

44
00:05:16,380 --> 00:05:22,500
to be more user-friendly to customers from different countries and different cultures.

45
00:05:22,500 --> 00:05:31,860
On the other hand, internationalization is the process of making the localization process of

46
00:05:31,860 --> 00:05:39,780
a product and application possible. So this is a step of design of development process. You need

47
00:05:39,780 --> 00:05:48,180
to make sure that your application is able to support localization. And as the Django documentation

48
00:05:48,180 --> 00:05:56,740
perfectly summarizes, localization is done by translators, while internationalization is done

49
00:05:56,740 --> 00:06:04,500
by developers. So here we are going to discuss some tools to help us internationalize our apps

50
00:06:04,500 --> 00:06:14,940
and make sure that it's able for translators to localize our apps. However, this simplified

51
00:06:14,940 --> 00:06:21,900
definition of internationalization and localization may give the wrong impression that this is just

52
00:06:21,900 --> 00:06:30,180
about translations. This process actually entails other adaptations needed in order to make your

53
00:06:30,180 --> 00:06:35,460
users more from different countries, from different cultures, to feel more comfortable using your

54
00:06:35,460 --> 00:06:47,220
product. I will go over some examples here to illustrate these adaptations. So here is map usage

55
00:06:47,220 --> 00:06:58,340
of different date formats that's used around the globe. The countries colored with cyan use the

56
00:06:58,340 --> 00:07:06,700
format day, month, year. The ones colored in yellow, they use the format year, month, day,

57
00:07:06,700 --> 00:07:14,340
and the green ones use both those formats, like the interchange between them. And only the USA

58
00:07:14,340 --> 00:07:24,380
uses the format month, day, year. This is another map usage, everything that I'm talking here I took

59
00:07:24,380 --> 00:07:33,300
from Wikipedia. This is another map usage, but this one is about number format. So the countries

60
00:07:33,300 --> 00:07:41,500
colored in green over there, they use comma as decimal separators and dots as thousand separators.

61
00:07:41,500 --> 00:07:48,500
And the countries in blue format the numbers using the other way around, like here, like dot for decimal

62
00:07:48,500 --> 00:07:55,460
and comma for thousand separators. So how are you going to show to your user, to your final user,

63
00:07:55,460 --> 00:08:00,980
these type of values? Like how do you know when to format one way and when to format another way?

64
00:08:00,980 --> 00:08:10,580
Another example of localization issue is currency conversion. If I'm browsing through Amazon back

65
00:08:10,620 --> 00:08:16,620
in my place, I want to see the price of products in Brazilian real, that's our currency, not in dollar,

66
00:08:16,620 --> 00:08:23,020
it doesn't make sense for me. So it's important to provide prices and other values converted to your

67
00:08:23,020 --> 00:08:34,380
local users. They should be able to know what they are paying for. Another interesting adaptation is

68
00:08:34,980 --> 00:08:43,540
bidirectional text and unicode character support. It's a very common issue and when bringing your

69
00:08:43,540 --> 00:08:50,580
application international, in this example, we can see how the Wikipedia page adapts to different

70
00:08:50,580 --> 00:08:58,020
languages. So here we have the common Wikipedia page for English language, and we can notice all

71
00:08:58,020 --> 00:09:09,140
the basic elements of the page, like the navigation sidebar is on the left, as we usually see. However,

72
00:09:09,940 --> 00:09:16,420
if you change the same page for Arabic, we can notice that the navigation bar migrated to the

73
00:09:16,420 --> 00:09:23,380
right side because this language is reading from right to left instead of left to right. So you can

74
00:09:23,380 --> 00:09:29,940
see that all the elements in the page had to change to mutate in order to adapt to the culture

75
00:09:29,940 --> 00:09:39,860
of people that speak Arabic. There are several other aspects that they need to take into

76
00:09:39,860 --> 00:09:48,420
consideration when localizing your apps. Coverage of measures between metric and imperial systems,

77
00:09:48,500 --> 00:09:55,220
for instance. Legal requirements that may be different from country to country. Sorting and

78
00:09:55,220 --> 00:10:02,500
presenting a list may be different. The way addresses and personal names are formatted,

79
00:10:02,500 --> 00:10:10,580
like family name goes first or last. Depends on the country. Time zone, calendar, and special

80
00:10:10,580 --> 00:10:21,140
holidays too. You need to take this into consideration. Yes, I know that we as developers

81
00:10:21,140 --> 00:10:28,260
are so used to code, to write code and documentation in English that we may not realize that

82
00:10:29,700 --> 00:10:38,500
there are only like 360 million native English speakers people in the world, and that only

83
00:10:38,500 --> 00:10:44,980
represents like less than 5% of the world population. And I know that it's very useful

84
00:10:44,980 --> 00:10:51,380
to have a common language for the communication between developers, but regarding your final user

85
00:10:52,340 --> 00:10:58,900
of the products that we are developing, English may not be that useful after all. And in fact,

86
00:10:58,900 --> 00:11:06,740
from the top 10 countries with most people using the internet, like only one is a native English

87
00:11:06,740 --> 00:11:13,300
speaker country. This is from 2017. So if you want to grab that share of the market,

88
00:11:13,860 --> 00:11:17,620
you need to go international. You need to be able to internationalize your app.

89
00:11:19,380 --> 00:11:25,780
Okay. So I hope that at this point I have convinced you how important it is.

90
00:11:29,060 --> 00:11:32,580
And now I'm going to show you how we can do that with Python.

91
00:11:32,980 --> 00:11:39,460
Okay. Let's go to review some tools that we can use that can help us with this task.

92
00:11:41,380 --> 00:11:47,700
It starts starting with the new get text package that's from the translation project. This

93
00:11:48,740 --> 00:11:54,260
package offers a runtime library that supports the retrieval of translated messages.

94
00:11:56,260 --> 00:12:02,100
A set of conventions about how programs should be written to support message catalogs.

95
00:12:03,140 --> 00:12:09,540
And a library supporting the parsing and the creation of files containing translated messages.

96
00:12:12,100 --> 00:12:19,860
So how does it work? Let's say that we have a simple hello world app here called eta app.py.

97
00:12:22,020 --> 00:12:30,260
Where we are using the get text Python module to create a text domain for our app over there. Like

98
00:12:30,260 --> 00:12:36,820
we are creating a text domain. We are saying where the translation is going to be held. The

99
00:12:36,820 --> 00:12:47,780
locale folder. And down here when we are saying our greeting, we are flagging that string as

100
00:12:47,780 --> 00:13:00,340
translatable. So if you run this code, it's going to print hello world as expected.

101
00:13:01,620 --> 00:13:05,620
It's not going to break because you don't have another translation for this code.

102
00:13:06,180 --> 00:13:15,860
So after you flagged your string to be translatable, the new module, they offer a

103
00:13:16,820 --> 00:13:22,340
tool that can collect all the strings that you marked as translatable in your code and generate

104
00:13:22,340 --> 00:13:31,460
a PO file containing all the strings that must be translated. So this is the method that we use to

105
00:13:31,460 --> 00:13:38,020
generate the text. It's a command line tool that you can run saying what's the domain that you

106
00:13:38,020 --> 00:13:51,300
created, which is our eta app, and what's the input file. The PO file that this method is going to

107
00:13:51,300 --> 00:13:59,780
generate contains a list of all the entries that you created. And the list of entries that you

108
00:13:59,940 --> 00:14:07,140
created is the list of all the entries that we flagged as translatable. And this is the basic

109
00:14:07,140 --> 00:14:13,700
structure for an entry in the PO file. We may have some comments for the translator trying to give

110
00:14:13,700 --> 00:14:24,020
some sort of context for them. Like the word may. We can say that this is may the month or may from

111
00:14:24,980 --> 00:14:33,460
the verb. It's a verb? Yeah, it's a verb. We can also add some references, some flags for the string.

112
00:14:34,660 --> 00:14:42,420
Then we have entry ID, which is the untranslated string that's going to remain untranslated.

113
00:14:43,940 --> 00:14:48,100
And we have the entry string that's going to be the translated string.

114
00:14:48,740 --> 00:14:57,620
So when we run the command x get text in the command line passing our eta app.py file,

115
00:14:58,980 --> 00:15:06,340
this is the PO file that comes back. At the top of the file, we have some metadata about the file.

116
00:15:06,340 --> 00:15:11,540
We have some information about the project, some information about the translation process.

117
00:15:12,180 --> 00:15:19,060
The idea of the PO file is that it should be readable for both developers and translators.

118
00:15:19,060 --> 00:15:26,580
So we have that meta tag information over there. And down here, we have even a reference for where

119
00:15:26,580 --> 00:15:34,500
the code, where in the code the string came from. It's in line seven. And then we have our entry.

120
00:15:34,500 --> 00:15:39,700
Once we have our PO file done, we can start now. We can start translating our terms for different

121
00:15:39,700 --> 00:15:45,860
languages. In this example, I'm translating the simple Portuguese. So I copied the PO file

122
00:15:46,660 --> 00:15:53,540
generated by the x get text command and started to translate my terms. And then I followed the

123
00:15:53,700 --> 00:15:59,620
recommended structure for my domain and my different languages that I want to support. So I have a

124
00:15:59,620 --> 00:16:05,460
folder for all the English domain PO files that I want to support. And then I create another one for

125
00:16:05,460 --> 00:16:12,180
the language, Portuguese. If I want to give support for French, I would need another folder and yet

126
00:16:12,180 --> 00:16:21,700
another PO file for French language. So I have a folder for the English domain. And then I create

127
00:16:21,860 --> 00:16:27,780
another one for the English domain. So, okay. Now I have two PO files for the two links that I want

128
00:16:27,780 --> 00:16:32,660
to support in my app, organizing this specific directory hierarchy as recommended by the new

129
00:16:33,380 --> 00:16:40,180
module. So in order to use now the translated strings in my code, I need to compile the PO

130
00:16:40,180 --> 00:16:48,820
file that's a portable object file into an MO file, which is a machine object file. And this is

131
00:16:48,820 --> 00:16:58,020
done by this tool in the new module, which is the message formatting tool. I pass what's the

132
00:16:58,020 --> 00:17:04,420
output, like what's the output file, which is going to be the MO and the PO that I'm compiling.

133
00:17:06,420 --> 00:17:10,820
When I run this for all my PO files, now I should have this structure for each language.

134
00:17:11,460 --> 00:17:22,100
I should have my MO and my PO file. Now, with my PO files compiled, I can now install the translation

135
00:17:22,100 --> 00:17:28,740
for the desired language in the get text tool in our Python code. So the translation method is able

136
00:17:28,740 --> 00:17:36,660
to find the correct MO file based on our directory structure, the domain text, that's eta app, and

137
00:17:37,220 --> 00:17:41,860
the language that I passed as parameter. So now if I run this code passing the language

138
00:17:43,380 --> 00:17:49,860
Portuguese from Brazil, I'm able to get ola mundo instead of hello world. That's the translated

139
00:17:50,740 --> 00:18:01,140
string. Another useful internationalization service in the Python module is the local

140
00:18:01,220 --> 00:18:10,180
module. This module has access to the POSIX local database and is especially handy for

141
00:18:10,180 --> 00:18:18,580
formatting dates, numbers, and currency. Let's take a look at this example where we are trying

142
00:18:18,580 --> 00:18:26,740
to translate to format a date, number, and currency using the local library. Here I'm

143
00:18:26,740 --> 00:18:35,780
importing the module. I'm changing all locale settings to English from the U.S. and retrieving

144
00:18:35,780 --> 00:18:41,380
the locale conventions. This locale convention is an object that contains all the conventions

145
00:18:41,380 --> 00:18:51,780
for the language in that country, such as decimal separator, thousand separator, currency symbol.

146
00:18:52,660 --> 00:19:00,100
We have all this in that object. Then I proceed to format my given date and price. Let's say it's a

147
00:19:00,980 --> 00:19:06,660
price application. I don't know. And using the locale format method, I can format my number

148
00:19:06,660 --> 00:19:14,260
without worrying about the decimal and thousand separator symbols. The same effect, I can

149
00:19:14,260 --> 00:19:22,740
accomplish the date format by passing the percent X directive to the date format function.

150
00:19:24,180 --> 00:19:31,140
This is the output. If I run that for English in the U.S., I have my date

151
00:19:32,740 --> 00:19:38,980
in the format that's used here, month, day, year. And the decimal separator is a dot,

152
00:19:39,060 --> 00:19:46,100
while the thousand separator is a comma. And also I have the dollar sign representing the U.S. dollar

153
00:19:46,100 --> 00:19:53,140
currency. Now, if I take the same code, but just changing the locale to Portuguese Brazil,

154
00:19:53,140 --> 00:19:58,020
just changing that parameter passing in that set locale function over there,

155
00:19:58,260 --> 00:20:06,740
I already have a different output. Now I have my date and my number and my currency

156
00:20:08,100 --> 00:20:16,580
following the conventions of Brazil. The date is formatted as day, month, year. And we have

157
00:20:16,580 --> 00:20:22,500
a, we have comma as the decimal separator, dots as the thousand separator, and we have the R

158
00:20:22,580 --> 00:20:27,780
plus the dollar sign, which represents our currency. Okay. Now, since I'm here to spread

159
00:20:27,780 --> 00:20:34,740
the word about internationalization, I want just to give, like, a tiny overview on how we can

160
00:20:34,740 --> 00:20:40,740
accomplish this on Django. With the framework, we are able to serve our content, to serve our web

161
00:20:40,740 --> 00:20:48,740
content based on, in different languages based on the accept language header that the base of the

162
00:20:49,460 --> 00:21:00,340
browser adds to our request object. So we are able to change depending on the end user. We need to

163
00:21:00,340 --> 00:21:08,820
know that language in order to return what they are expecting. For translations, we can flag

164
00:21:08,820 --> 00:21:17,220
translatable strings in both Python and template code. In the Python code, we can use the standard

165
00:21:17,220 --> 00:21:25,300
get text function and all the other get text module related functions that we already saw for

166
00:21:25,300 --> 00:21:34,020
Python code, for the Python part. It works in the Django part. One interesting feature of Django,

167
00:21:34,020 --> 00:21:40,260
though, is that we can have lazy translations, which is great because we can flag a string

168
00:21:41,060 --> 00:21:46,820
that will only be translated when the value is used in a string context, such as in the

169
00:21:46,820 --> 00:21:53,380
template Henry. So this is especially useful for translating help text and variables names in our

170
00:21:53,380 --> 00:22:02,900
modules, for example. On the other hand, we can use some special tags in our template code once you

171
00:22:03,620 --> 00:22:09,540
load the internationalization tag. We have the trans tag that translates just a single string.

172
00:22:10,420 --> 00:22:17,700
While the block trans is able to mark as translatable a block of strings in your template.

173
00:22:20,820 --> 00:22:26,580
To be honest, this slide covers only like 10 per cent of the features available for translation

174
00:22:26,580 --> 00:22:33,860
in Django. It's not the point of this presentation. I just want to give you a highlight. And you can

175
00:22:33,860 --> 00:22:39,860
check the documentation. They have everything explained there. It's very good. So go check it

176
00:22:39,860 --> 00:22:50,580
out if you want more details on how to use these features. The Django command line already has

177
00:22:50,580 --> 00:22:57,060
some facilitations for the whole process of generating a PO file and compiling the PO file

178
00:22:57,060 --> 00:23:04,340
already puts everything in that folder structure as recommended by the new project. So it does

179
00:23:04,340 --> 00:23:08,740
everything for you automatically. It has some comments that does this for you.

180
00:23:11,380 --> 00:23:18,260
Another support that we have from Django is related to time zones. When time zone support is

181
00:23:18,260 --> 00:23:25,860
activated in your Django settings, that means that Django will store date time objects in the UTC

182
00:23:25,860 --> 00:23:34,980
format in the UTC time zone and in the database and uses only time zone aware date time objects

183
00:23:34,980 --> 00:23:44,020
in the code. So because these date time objects now are time zone aware, Django is able to format

184
00:23:44,660 --> 00:23:50,420
the date and the time according to the time zone of your end user. So that's great.

185
00:23:50,420 --> 00:24:00,100
Okay. Now that I presented some tools that can help us internationalise our apps, I want to share

186
00:24:00,100 --> 00:24:08,420
with you a challenge that we came across back at LabCodes last year, which was to support localisation

187
00:24:09,060 --> 00:24:18,660
in a cross-platform system. To illustrate what I mean by cross-platform thing, I put together

188
00:24:18,660 --> 00:24:27,700
this diagram. Basically, we have in the front-end part of the system native apps for iOS and Android.

189
00:24:28,820 --> 00:24:36,100
We also have a web-based app, Actin, and Actin as a controller for those native mobile apps,

190
00:24:36,100 --> 00:24:43,780
we have a middleware that's written in Java. And this middleware consumes from some services from

191
00:24:43,780 --> 00:24:56,180
the API and also this API powers the data for our web app. As you can see, we have different

192
00:24:56,180 --> 00:25:08,740
technologies powering each piece of the whole system. And believe me, Java, Swift, the Android

193
00:25:08,740 --> 00:25:18,260
SDK, they don't use PO file to translate their messages as their message catalogue. Each one of

194
00:25:18,260 --> 00:25:26,500
them has their own file format. So that's the part where we came as a group, as a team, and we said,

195
00:25:26,500 --> 00:25:33,060
ATA. Yeah, we were in trouble in this part, like, how are we going to manage all this? It's all fun,

196
00:25:33,060 --> 00:25:38,180
it's all cool, and you have just your Python code over there, you work with Django and it's doing

197
00:25:38,180 --> 00:25:47,380
everything for you, but this time we were in trouble. So our goal was to collect the translatable

198
00:25:47,380 --> 00:25:52,740
strings from all those parts and send them to be translated by a team of translators.

199
00:25:54,260 --> 00:26:01,460
These translators would use a localization platform to translate the terms. Yeah, let's face it, that

200
00:26:01,460 --> 00:26:10,420
PO file to change a lot of strings wouldn't be the most fun thing to do. But we have several

201
00:26:10,420 --> 00:26:17,940
localization platforms. This is just like the top six that I got back from the Google search. And

202
00:26:19,300 --> 00:26:25,780
they usually have, like, all of them, I'm not sure if all of them, but they usually offer a nice API

203
00:26:25,780 --> 00:26:31,380
integration with the system in order for you to automate your process of sending all those terms,

204
00:26:31,380 --> 00:26:39,300
getting back the translations, and doing the whole flow. So I don't really have any preferences.

205
00:26:40,500 --> 00:26:48,180
I worked with TransFax for this project, but, like, just pick one, like, it's not, I don't have

206
00:26:49,140 --> 00:26:53,140
many opinions about this, but choose one. We have several.

207
00:26:55,620 --> 00:27:02,900
So in order to do this, in order to send everything there, and we came up with several

208
00:27:03,540 --> 00:27:10,740
different API services that would parse the different formats of message catalog files.

209
00:27:10,740 --> 00:27:21,780
So we have our PO file from our web-based platform. We also have PO file for the API part.

210
00:27:24,260 --> 00:27:34,260
We have the strings.xml for the Android native app. We have the localizable.strings file for

211
00:27:34,260 --> 00:27:43,140
the iOS app, and the messages.properties for the Java middleware part. So the API services

212
00:27:43,140 --> 00:27:48,580
had different services to handle and parse each one of those since they have different formats,

213
00:27:48,580 --> 00:27:56,580
so we have to deal with different parsing methods. And then the API would then aggregate these terms

214
00:27:56,580 --> 00:28:04,180
once we parsed everything and store it in a local data store. In this case, we are using Redis,

215
00:28:04,260 --> 00:28:12,980
just for performance sake, but it can be any data store, actually. And why we use a data store for

216
00:28:12,980 --> 00:28:20,580
this is because we don't want every time that someone sends a file to send all the terms to

217
00:28:20,580 --> 00:28:29,860
the localization platform. We want to avoid this bulk process, and if we are not sending only the

218
00:28:29,860 --> 00:28:36,500
different things that are being added or updated. So with the local data store, we are able to

219
00:28:36,500 --> 00:28:42,020
control this better, and only send actually the terms that need to be updated or added to the

220
00:28:42,740 --> 00:28:52,100
localization platform. In the API, we are also able to kind of aggregate the same terms

221
00:28:53,220 --> 00:28:58,020
that have different platforms. So, for instance, a button that says cancel,

222
00:28:58,820 --> 00:29:07,860
that's in every front-end platform. So that cancel, we will only send one cancel string to the

223
00:29:07,860 --> 00:29:14,820
localization platform, and the translator would need to translate cancel three times. It's useless.

224
00:29:15,540 --> 00:29:21,140
So the API also does this cleaning process in the terms. And once the aggregation is done,

225
00:29:21,140 --> 00:29:27,780
the API now sends the terms to the localization platform using the API integration. And now,

226
00:29:28,180 --> 00:29:34,340
all the terms are available for the translators to do their magic and translate everything.

227
00:29:36,580 --> 00:29:43,380
Also, these integrations, they also allow to send all those comments and all those context

228
00:29:44,580 --> 00:29:48,500
information that we can pass along to facilitate the work of our translators.

229
00:29:48,500 --> 00:29:58,500
Okay. Now we have the terms over there. Now the translators can do their job, they translate,

230
00:29:58,500 --> 00:30:05,940
and once the translation is done, our job now is to make these translated terms back to the

231
00:30:05,940 --> 00:30:12,500
platform. So the API does the same process, but in reverse. Now we get the translated terms from the

232
00:30:12,500 --> 00:30:22,980
API, we format them into the correct file format for each platform, and make them available for

233
00:30:22,980 --> 00:30:28,580
each developer, for each core team that's responsible for each one of them. There are some

234
00:30:28,580 --> 00:30:37,540
localization platforms that have a web hook that they can actually signal your API to inform you

235
00:30:37,540 --> 00:30:44,740
that the translation is done, and you can do this automatically. And you can look for something

236
00:30:44,740 --> 00:30:53,140
similar. And yeah, now we have this basic flow work, like we have all the way to send the

237
00:30:53,140 --> 00:30:58,180
translations to the platform, and to send the terms to the platform, and get the translations back.

238
00:31:00,980 --> 00:31:07,220
But this is not all. We also needed to review our deploy process, because now we needed to adjust

239
00:31:07,860 --> 00:31:17,300
our process to accommodate the translation process in between. So each platform now has to update

240
00:31:17,300 --> 00:31:23,460
the terms, send all the new terms that they want to send to the platform when they go to QA.

241
00:31:24,340 --> 00:31:31,540
We use the process of QA our system. So whenever they are ready for a QA deploy,

242
00:31:32,260 --> 00:31:38,260
they send all the terms to be translated. And the QA team now has to perform integration

243
00:31:39,140 --> 00:31:46,100
tests for different locales. And all these features are approved to go to production

244
00:31:46,820 --> 00:31:52,900
once they are tested, and once also all the strings are translated. So this is a slightly

245
00:31:53,700 --> 00:32:00,020
difference in our deploy process. Now we have to take into consideration not only our team to be

246
00:32:00,020 --> 00:32:04,420
ready, but also the translators team to be ready to translate everything.

247
00:32:06,740 --> 00:32:11,780
And this solution that I just described, they have been placed since last year,

248
00:32:11,780 --> 00:32:18,660
and so far it has been working. The team seems to be adjusted with the whole process of deploying,

249
00:32:19,940 --> 00:32:27,060
signalizing the translators, and the communications is well established. So it's working so far.

250
00:32:27,860 --> 00:32:34,820
Not a big deal, not many problems. However, now we have a new challenge coming.

251
00:32:36,500 --> 00:32:43,540
Something that I omit from the presentation of the platform is that about 60%

252
00:32:44,500 --> 00:32:50,820
of the data presented to the user actually comes from different data sources over there.

253
00:32:51,780 --> 00:32:58,340
And I'm not going into too many details about our ETL process of extracting, transforming,

254
00:32:58,340 --> 00:33:05,780
and loading this information into our API. However, it's important to notice that

255
00:33:05,780 --> 00:33:13,940
this data is constantly changing. So yeah, our next challenge is how we can manage these terms

256
00:33:14,900 --> 00:33:23,460
in an organic and performatic way. But this has to go to another talk because we are still planning.

257
00:33:23,460 --> 00:33:30,900
We have a huge question mark in our heads right now. We are in planning stage, and maybe next year

258
00:33:30,900 --> 00:33:34,980
I can come here with another talk and tell you what's the result of this huge plan.

259
00:33:37,700 --> 00:33:42,340
And yeah, that's it, folks. I was able to show you, I hope that I was able to show you

260
00:33:42,340 --> 00:33:45,380
how important localization and internationalization is.

261
00:33:47,140 --> 00:33:54,500
And I believe that the main lesson from this is that internationalization is a fundamental step

262
00:33:55,380 --> 00:34:05,140
in design and development process. Don't do like we did. We took months to flag all the strings

263
00:34:05,140 --> 00:34:12,980
and to internationalize each one of those platforms. The whole team was a group effort

264
00:34:12,980 --> 00:34:19,060
that took months until we came up with the solution. And don't do this. If you are in the

265
00:34:19,060 --> 00:34:27,300
beginning of your development process or if you are thinking of starting one, take internationalization

266
00:34:27,300 --> 00:34:32,740
into consideration. Even though you don't have big plans of going international, believe me,

267
00:34:32,820 --> 00:34:39,060
you want to go. And it's better to be ready now when the opportunity comes and you can do this

268
00:34:39,060 --> 00:34:46,260
without being a pain in the neck as it was for me. So be warned. Hope you do this. And

269
00:34:46,900 --> 00:34:48,900
yeah, thanks a lot and obrigada.

270
00:35:02,900 --> 00:35:12,900
Hey, great talk. Thank you. Did you ever have to deal with the migration of a Django app from

271
00:35:12,900 --> 00:35:21,940
Python 2 to Python 3 at any point? And how did you deal with internationalization with that?

272
00:35:22,820 --> 00:35:24,820
With that, yeah.

273
00:35:27,220 --> 00:35:34,020
Actually, we were already working with Python 3 when we did the internationalization process.

274
00:35:34,020 --> 00:35:40,900
We did that process before. I'm trying to think if we had like this was also like it was very close

275
00:35:40,980 --> 00:35:51,620
the transformation that the parsing. I'm trying to think if we had any apps that were at the same

276
00:35:51,620 --> 00:35:56,740
time. But I don't think so. I think I had everything in Python 3 before doing the

277
00:35:56,740 --> 00:36:04,420
internationalization process. Yeah, so it was okay. Okay. Were there any issues that you faced during

278
00:36:05,140 --> 00:36:10,580
internationalization? Oh, yes, actually, there is one that didn't get into the talk. It was

279
00:36:11,540 --> 00:36:18,260
the IDs. Because when you generate the PO file, the string that you flagged comes as an ID. And

280
00:36:19,060 --> 00:36:28,180
we actually had to use well formatted IDs like KMLKs or something like this. Because we would

281
00:36:28,180 --> 00:36:35,780
have like collisions of terms that didn't mean the same thing. So we had to go over all the IDs.

282
00:36:35,780 --> 00:36:43,940
That was a challenge, too. So when it comes to internationalizing an application, I imagine that

283
00:36:43,940 --> 00:36:49,060
maybe getting the last 5 to 10% is the hardest part because there might be different edge cases

284
00:36:49,060 --> 00:36:54,980
to handle. Like for example, one case you can imagine is maybe the translations aren't just

285
00:36:54,980 --> 00:37:00,820
single string replacements, but maybe they're strings that have like substitution areas for

286
00:37:00,820 --> 00:37:05,460
like a number or something like that or plural or singular. And I'm wondering if you can talk

287
00:37:05,460 --> 00:37:11,780
about some of these harder edge cases to completely internationalize an application.

288
00:37:11,780 --> 00:37:19,460
Yeah, like we had to do this for pluralization as they called. Like we had to treat these edgy cases

289
00:37:19,460 --> 00:37:30,900
on like feminine and masculine terms, prurals in our text. And in those different,

290
00:37:31,700 --> 00:37:38,500
and each of these cases is treated differently in the PO file and all those other files for all the

291
00:37:38,500 --> 00:37:45,300
other platforms. So it came down to sitting and establishing how we are going to handle those

292
00:37:45,300 --> 00:37:50,820
edgy cases for translating. Yeah. Okay, thank you. Thanks.

293
00:37:53,300 --> 00:37:58,500
Hi, thanks for the talk. It was really cool. I wondered if you could talk a bit more about

294
00:37:58,500 --> 00:38:04,420
about the QA process that you use to sort of like make sure that what's coming back from an

295
00:38:04,420 --> 00:38:10,100
external service is legitimately what you wanted to translate. Is that people internal who speak

296
00:38:10,100 --> 00:38:14,500
the language that are going over every line and how do you sort of make sure that there's not

297
00:38:15,140 --> 00:38:18,820
English strings sneaking through and that kind of side of things?

298
00:38:18,820 --> 00:38:25,220
Yeah, kind of this like because our QA team is not that big and we don't have people that speak

299
00:38:25,220 --> 00:38:30,820
both languages for this project. We were supporting Canada, French, French Canadian,

300
00:38:31,940 --> 00:38:39,700
but like our QA team didn't know French because it's based in the US. But like we looked for

301
00:38:40,340 --> 00:38:47,860
English terms when we were doing the QA process and overall we trusted the translators because

302
00:38:47,860 --> 00:38:52,740
like we had to separate our concerns if we were able to check everything we couldn't trust our

303
00:38:52,740 --> 00:39:02,580
translators. So we trusted them but like testing everything like we look for English maybe some

304
00:39:02,580 --> 00:39:09,460
terms that didn't get translated. But yeah that's basically it and it's quite a pain to do this at

305
00:39:09,460 --> 00:39:17,140
first but as I mentioned the team seems to be adapted well so far. So now we already know how

306
00:39:17,780 --> 00:39:21,700
French works and then when we change we are able to spot on any

307
00:39:21,700 --> 00:39:26,340
errors quickly more quickly than before. Cool, thanks.

308
00:39:29,700 --> 00:39:36,740
So I was curious about like the CSS styling and how you handled that like when things need to show

309
00:39:36,740 --> 00:39:41,620
up on the opposite side of the page. Did you guys have any of those cases and like how did you end

310
00:39:41,620 --> 00:39:54,180
up handling that? Yeah we had a special case for CSS translation and we actually didn't translate

311
00:39:54,980 --> 00:40:06,100
in the CSS file. We actually got back to JavaScript. So there was something that we had in a before text

312
00:40:06,340 --> 00:40:12,340
in the CSS file that we were like okay we can't do that and I actually didn't spend

313
00:40:12,340 --> 00:40:16,740
we didn't spend much time researching. We are just like okay let's change back to

314
00:40:17,300 --> 00:40:22,100
JavaScript for this part since we already had JavaScript enabled and doing a lot of things for

315
00:40:22,980 --> 00:40:30,820
CSS and then worked with that and we already worked with JavaScript translations in our front end.

316
00:40:30,820 --> 00:40:36,900
We had Django. Django also supports JavaScript. They have a catalog that they send back

317
00:40:37,860 --> 00:40:44,180
and also in Angular this project also had a tiny bit a little bit in Angular. So we also supported

318
00:40:44,180 --> 00:40:52,580
that so we ended up shifting from CSS to JavaScript. And I just want to make sure I understand

319
00:40:52,580 --> 00:41:00,020
your whole flow here. So you have like translation tools that you're using kind of in all these

320
00:41:00,020 --> 00:41:06,020
different languages and then you're passing the config files like from your back end like through

321
00:41:06,020 --> 00:41:12,260
your API to these different services in different languages is that correct? Actually we only have

322
00:41:12,260 --> 00:41:22,020
one platform for the translation process and what we do we grab all those files and compress

323
00:41:22,020 --> 00:41:27,620
not compress but aggregate them and pass to a single platform. So the translators they only

324
00:41:27,620 --> 00:41:36,500
have to work in a single platform. Translator supports several languages for the same set of

325
00:41:37,300 --> 00:41:43,380
strings. So we have the French translators but at any time they could add another like I don't know

326
00:41:43,380 --> 00:41:48,500
German translator team to work in the same platform. So we don't need to have a different

327
00:41:48,500 --> 00:41:53,860
platform for different translator teams. We only have one. Okay so it's like you're really

328
00:41:53,860 --> 00:42:00,020
dependent on like the back end to translate? Is that right? Yeah yeah like okay. But we have these

329
00:42:00,020 --> 00:42:09,860
services that's kind of an isolated service is in our API so we can now we may migrate to another

330
00:42:10,820 --> 00:42:16,340
platform. So now we just need to change that to communicate to integrate with a different API.

331
00:42:16,340 --> 00:42:23,300
But like they are very similar. So like the API is responsible for generating that file that goes

332
00:42:23,300 --> 00:42:27,460
to the front end applications. Yeah for each one of them. Okay thank you.

333
00:42:34,420 --> 00:42:36,820
How do you determine your user's preferred time zone?

334
00:42:38,420 --> 00:42:43,220
How do I sorry can you repeat? How do you determine your user's preferred time zone?

335
00:42:43,540 --> 00:42:53,940
Preferred time zone. I don't think that we do because I know that we take from the accept language.

336
00:42:53,940 --> 00:43:02,900
But since we store everything in UTC because we don't work with with date that much. So we

337
00:43:02,900 --> 00:43:08,660
store everything in UTC and we do this based on the location. Sorry we have we do have a time zone

338
00:43:08,660 --> 00:43:18,500
part of the process that we use moment.js in the front end and we are able to get the location of

339
00:43:18,500 --> 00:43:25,540
the user in the front end in the browser from the moment.js library and then we format that data in

340
00:43:25,540 --> 00:43:31,860
that. So the API is able to get the location of the user in the front end in the browser from the

341
00:43:31,860 --> 00:43:38,900
that. So the API sends everything UTC and then in the front end part we do the conversion using

342
00:43:38,900 --> 00:43:44,660
that information. Yeah I forgot about that moment.js part. Why do you do that?

343
00:43:46,740 --> 00:43:52,340
All right well thank you very much.

