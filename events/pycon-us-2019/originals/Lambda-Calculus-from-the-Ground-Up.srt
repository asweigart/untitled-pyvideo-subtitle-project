1
00:00:00,000 --> 00:00:07,000
All right. I think I'm going to start. I'd just like to welcome everybody to this. This

2
00:00:12,080 --> 00:00:19,080
is the Lambda Calculus tutorial. Hopefully you read the description of this, especially

3
00:00:19,400 --> 00:00:25,140
the part about nothing usefully practical being done in here. If you're expecting

4
00:00:25,140 --> 00:00:29,700
something that you're going to be able to use at work, you're probably in the wrong

5
00:00:29,700 --> 00:00:36,020
place. Also just a couple of little logistic things. You will get the most out of this

6
00:00:36,020 --> 00:00:43,020
by typing along and trying the code out as we go and experimenting. I will also emphasize

7
00:00:43,580 --> 00:00:50,220
that almost nothing is obvious in here. I want you to meet your neighbor at the table

8
00:00:50,420 --> 00:00:57,420
there and feel free to chat back and forth. What is he talking about? What are you doing?

9
00:00:57,500 --> 00:01:02,420
You're going to get more by trying stuff out, talking with each other. I also have an assistant,

10
00:01:02,420 --> 00:01:08,180
Brian Ward, in the back with a traveling microphone. If you have a question or something, just

11
00:01:08,180 --> 00:01:14,020
to make it a little bit easier for you people to maybe raise your hand and he'll come find

12
00:01:14,020 --> 00:01:20,820
you and you can ask the question. A little background on the tutorial. We're going to

13
00:01:20,820 --> 00:01:26,660
be talking about the Python's Lambda function a lot. You've probably seen things like this

14
00:01:26,660 --> 00:01:33,660
before, hopefully. One thing about Lambda is it is a way of defining a function in Python.

15
00:01:34,380 --> 00:01:41,020
It's just another way of defining a function. One kind of interesting challenge with Lambda

16
00:01:41,100 --> 00:01:47,220
is how to introduce it when teaching Python. I actually teach a lot of Python classes.

17
00:01:47,220 --> 00:01:51,740
This is something that usually comes up at some point, maybe with the sort function or

18
00:01:51,740 --> 00:01:57,180
something. It's like, oh, you use the Lambda function. Then you have to describe this to

19
00:01:57,180 --> 00:02:04,180
people. We have Stuart here who's taught a lot of classes. One question that sometimes

20
00:02:04,260 --> 00:02:11,260
comes out is why is it called Lambda? Does anybody encounter this in teaching Python

21
00:02:13,180 --> 00:02:20,180
to people? It's kind of a weird name. It's like, Lambda, what's that about? Then you

22
00:02:20,380 --> 00:02:26,620
start answering that, well, it's called Lambda because everybody else calls it Lambda, which

23
00:02:26,620 --> 00:02:33,620
is sort of a non-answer. It's just deflecting to some non-thing. Then people are going to

24
00:02:33,620 --> 00:02:38,620
ask, why does everybody else call it Lambda? It's like, well, they called it Lambda in

25
00:02:38,620 --> 00:02:44,060
Lisp or Scheme or something. It comes from Lisp. It's like, well, why did they call

26
00:02:44,060 --> 00:02:50,460
it Lambda? It's like, well, they took it from the Lambda calculus. If somebody asks,

27
00:02:50,460 --> 00:02:57,460
what's the Lambda calculus? You start running away in horror. Actually, just personally,

28
00:02:58,540 --> 00:03:03,420
before doing this tutorial, I didn't even really know the Lambda calculus at all. I

29
00:03:03,420 --> 00:03:08,460
think I'd crossed paths with it in graduate school at some point. At the time that I did

30
00:03:08,460 --> 00:03:13,740
it, I was studying for qualifying exams and spending the other half of my time playing

31
00:03:13,740 --> 00:03:20,740
Duke Nukem or something like that. My memory of the Lambda calculus was just zero. This

32
00:03:20,900 --> 00:03:27,900
tutorial is kind of born out of that. It's like, what is the Lambda calculus? I don't

33
00:03:27,900 --> 00:03:32,700
know. How does it work? I think it's going to be really cool. My experience with it is

34
00:03:32,700 --> 00:03:37,660
this is just insane and crazy. I think it'll be fun. That's what we're going to talk

35
00:03:37,660 --> 00:03:43,260
about. I'm going to step you through it in maybe an unusual way. The thing that I wanted

36
00:03:43,260 --> 00:03:50,260
to start with is actually that thing that I got up on the slide, the Lambda X there.

37
00:03:53,340 --> 00:03:58,460
How would you teach what's happening there to a 10-year-old? I have a 10-year-old kid.

38
00:03:58,460 --> 00:04:05,460
He's in third, fourth grade. They're doing math. Forget the Lambda part of that for a

39
00:04:05,500 --> 00:04:12,500
second. If you were to describe how a function works, what's going on there? How would you

40
00:04:14,820 --> 00:04:15,820
teach that?

41
00:04:15,820 --> 00:04:16,820
Yeah?

42
00:04:16,820 --> 00:04:23,820
Yeah. But it's not even about the name. If you have a 10-year-old and you're just saying

43
00:04:23,820 --> 00:04:30,820
F of four, what do you do there? Maybe overthinking it. You just replace the function with a

44
00:04:53,820 --> 00:04:59,900
function. You replace the X. If you were to describe what that does, it's like you replace

45
00:04:59,900 --> 00:05:06,900
the X with four. Then you do math. It's like three times four plus one. You describe the

46
00:05:07,500 --> 00:05:12,100
function as, well, the whole thing that's just going on there is you just replace the

47
00:05:12,100 --> 00:05:16,540
X. Function. Substitute the X.

48
00:05:16,540 --> 00:05:20,500
There's some interesting things that you could get into with a kid. If you said, well, what

49
00:05:20,500 --> 00:05:27,500
if you have F two plus three? How does that work? There's their issue. It's like, okay,

50
00:05:27,500 --> 00:05:34,140
you're going to get 16. Do you do the two plus three first? Do you get three times five

51
00:05:34,140 --> 00:05:41,140
plus one? Is that how you do that? Or do you do that? Do you just literally take the two

52
00:05:41,940 --> 00:05:48,940
plus three and plug it in for the F? There are some variations there. Basically, function,

53
00:05:49,780 --> 00:05:55,220
you take the thing in parentheses and you substitute the X.

54
00:05:55,220 --> 00:06:02,220
You have that. Now, the thing that we're going to start with is what if you were teaching

55
00:06:02,660 --> 00:06:09,660
programming and you decided right at this point to stop? You don't need to know anything

56
00:06:10,540 --> 00:06:17,540
else. What if you had this thought experiment where it's like you actually do not have

57
00:06:18,940 --> 00:06:25,940
to do anything else other than substituting the X? Imagine that you had Python. You're

58
00:06:27,580 --> 00:06:32,140
going to do the scene from the Holy Grail on Python. You're going to start chopping

59
00:06:32,140 --> 00:06:39,140
things away from Python. Non-essential parts of Python. I'll help you out here. No packages

60
00:06:40,800 --> 00:06:47,800
or modules. That would solve a lot of problems. Get rid of that. What if you had no objects?

61
00:06:48,940 --> 00:06:55,940
Or no numbers? Or no strings? Or no data types? You basically just start carving it away.

62
00:07:01,180 --> 00:07:06,980
Or you just start stripping things down. It's like how much of it could you actually cut

63
00:07:06,980 --> 00:07:13,980
away and still actually have something that you could compute with? Do anything useful?

64
00:07:14,980 --> 00:07:21,980
The thing that we're going to talk about here is actually an idea which is what if functions

65
00:07:23,340 --> 00:07:28,980
are actually the only thing in the universe? Not only functions, but just single argument

66
00:07:28,980 --> 00:07:35,980
functions. Nothing else exists. You can write a function like you can say F of X. You can

67
00:07:36,020 --> 00:07:41,420
have that. But you're not allowed to do anything else in your whole language. Now, this is

68
00:07:41,420 --> 00:07:44,940
going to get a little bit mind bending because you're thinking of function like if you said

69
00:07:44,940 --> 00:07:51,940
return X plus 1. No. There's no numbers. And there's no plus either. We don't have any

70
00:07:52,180 --> 00:07:59,180
operator. That's a little weird. You can't do this because we only have single argument

71
00:07:59,860 --> 00:08:06,860
function. This actually solves a lot of problems, by the way. If you only have one argument,

72
00:08:07,300 --> 00:08:11,900
you don't need defaults or keywords or positional only arguments. If you're following that

73
00:08:11,900 --> 00:08:18,900
debate, it sort of collapses. You can have multiple arguments. You could do something

74
00:08:20,880 --> 00:08:27,880
like that, but it's hard to decide whether that's very useful. It's sort of under specified.

75
00:08:28,460 --> 00:08:35,460
You could have a function X, takes an X and returns X. They always take an argument. They

76
00:08:37,340 --> 00:08:44,340
don't. Zero argument functions are not allowed. There's no if statements. We got rid of control

77
00:08:45,540 --> 00:08:52,060
flow. I didn't put it on the list, but control flow. Once you start thinking about control

78
00:08:52,060 --> 00:08:58,060
flow, it's going to lead to things like exceptions and all that's evil. No. We don't want to

79
00:08:58,060 --> 00:09:02,460
know. Control flow is gone. The only thing that you have is basically single argument

80
00:09:02,460 --> 00:09:09,460
function. You could do things like this. That's okay. X is a function. The reason it's a function

81
00:09:15,220 --> 00:09:19,380
is because functions are the only thing that exists in the whole universe. By default,

82
00:09:19,380 --> 00:09:26,380
it has to be a function. I'm not clear what that does. You could also create a function.

83
00:09:27,380 --> 00:09:34,380
This is technically allowed. You could do something like that. It's a little strange,

84
00:09:34,980 --> 00:09:40,380
but you could have a function that defines a new single argument function only. It has

85
00:09:40,380 --> 00:09:46,300
to be single argument. The only thing that you could do with a function is call a function.

86
00:09:46,300 --> 00:09:50,700
Keep in mind, we have no numbers or operators or anything other than just calling a function.

87
00:09:50,700 --> 00:09:57,700
You could return that. You could do this sort of stuff, but now the challenge is could you

88
00:10:00,500 --> 00:10:06,620
actually do anything with that? Again, you've taken Python. You've just chopped everything

89
00:10:06,620 --> 00:10:13,620
off of it except for functions, single argument function. Is there anything in the real world

90
00:10:14,620 --> 00:10:21,620
of anything that you can do with this programming restriction? I'm going to let you ponder that

91
00:10:24,340 --> 00:10:31,340
for a couple of minutes here. It's a little tough, I think. I'm trying to gauge whether

92
00:10:31,340 --> 00:10:38,340
anybody has any thoughts on the zero. The thing that's a little weird about it is it

93
00:10:47,460 --> 00:10:54,460
feels extremely abstract at this point. Keep in mind, did we just lose audio for a second?

94
00:10:55,460 --> 00:11:02,460
Do you have audio back there? I think we've lost audio. Do you have audio? You're getting

95
00:11:07,300 --> 00:11:14,300
audio in the recording? Maybe just the speaker. At this point, it actually feels very, very

96
00:11:14,300 --> 00:11:21,300
weirdly abstract. Just to emphasize, in this system, there is literally nothing other than

97
00:11:27,100 --> 00:11:34,100
a single argument function. There are no bits or anything. You can return a single argument

98
00:11:36,020 --> 00:11:43,020
function. Actually, that's an interesting multiple things. That's a very interesting

99
00:11:44,460 --> 00:11:48,300
thing. That would imply the existence of a data structure or something like a tuple.

100
00:11:48,300 --> 00:11:55,300
As long as your multiple things is a single argument function. Functions can be passed

101
00:11:57,260 --> 00:12:01,980
around. You can pass functions. You can return functions as long as they're single argument

102
00:12:01,980 --> 00:12:08,980
functions. Well, as long as it's a function. It's a real brain. It's a very simple thing.

103
00:12:14,820 --> 00:12:20,180
Maybe one way to think about this is like a weird escape room that I've put you in from

104
00:12:20,180 --> 00:12:25,260
coding. It's like, okay, we've got this style guide, which is extremely easy to remember

105
00:12:25,260 --> 00:12:32,260
because single argument functions. That's it. But the question is, how do you do anything

106
00:12:32,260 --> 00:12:39,260
with it? Actually, names are not technically allowed either, but I'm going to break that

107
00:12:40,180 --> 00:12:46,980
rule just to be able to do anything. It turns out that having names of global variables

108
00:12:46,980 --> 00:12:53,980
is not really technically allowed either, but we're going to whiten that rule.

109
00:12:57,580 --> 00:13:01,940
So in looking at this, at first glance, it's going to be like, this is just, okay, I don't

110
00:13:01,940 --> 00:13:08,940
even know where to start with this. So I thought I would start you with actually something

111
00:13:09,660 --> 00:13:14,860
real that you could model with this. It's going to be something really unexpected, I

112
00:13:14,860 --> 00:13:21,860
think. But you could model a switch using this. I was trying to think about how to make

113
00:13:23,180 --> 00:13:28,260
this tutorial go full stack down to the bare metal, basically. You've got to talk about

114
00:13:28,260 --> 00:13:35,260
electricity and other things. So let's say you have like a switch like that. This is

115
00:13:35,660 --> 00:13:42,660
a switch, like left, right. It has two inputs, A and B. It has an output on that. That is

116
00:13:43,060 --> 00:13:48,260
actually something that you could model in this system, but the way it's going to work

117
00:13:48,260 --> 00:13:55,260
is going to be a little strange. I'm going to write a function left that takes in a single

118
00:13:56,140 --> 00:14:03,140
argument because everything has to take single argument. And then inside, whoa, okay, hot

119
00:14:04,140 --> 00:14:11,140
audio excitement there. I'm going to define a function F that returns the A and then I

120
00:14:15,740 --> 00:14:20,700
return the function back. Now at first glance, that's going to look really weird. I'm going

121
00:14:20,700 --> 00:14:27,700
to write a function right that does the same thing. Well, almost the same thing. Okay,

122
00:14:28,700 --> 00:14:35,700
so I'm going to have you type that in. Now how this is going to work is this is essentially

123
00:14:39,020 --> 00:14:45,700
like a chaining of functions where you provide an argument to the first, like the outer function.

124
00:14:45,700 --> 00:14:51,580
You say like, okay, left, A, that's five volts or something. Okay, think electricity. And

125
00:14:52,060 --> 00:14:58,060
then what it is doing is returning a function back. Like it's returning this F back.

126
00:14:58,060 --> 00:15:05,060
Oh, well, okay. Ignore that for the moment. Ignore that. No. Yeah, I'm breaking the rules

127
00:15:07,940 --> 00:15:14,940
a little bit. But you're onto something important here in a second. Okay, so what's happening

128
00:15:15,340 --> 00:15:19,660
is like two inputs are coming in. There's like an A, which is like the five volts, and

129
00:15:19,660 --> 00:15:26,660
then the B is like maybe ground or something. And what left is doing is it picks out the

130
00:15:26,660 --> 00:15:32,380
A basically. Like if you're in the left position, it means that you're picking the A. You're

131
00:15:32,380 --> 00:15:38,620
connected to the A. And if you were to do the same thing with like the right function,

132
00:15:38,620 --> 00:15:44,140
it would come back and it would say, well, you're connected to the ground. Now the thing

133
00:15:44,140 --> 00:15:51,140
that's kind of wild about this is that these functions, they don't really represent like

134
00:15:51,140 --> 00:15:56,740
a thing. It's not a bit. It's not a piece of data or anything. What they're representing

135
00:15:56,740 --> 00:16:03,740
is a behavior basically. Like the behavior of left means that you're connected to the

136
00:16:03,740 --> 00:16:10,220
A. And the behavior of the right means you're connected to the B. In some sense, it doesn't

137
00:16:10,500 --> 00:16:17,500
really care what you pass in here. Like you could have left of loud, maybe like the loud

138
00:16:17,500 --> 00:16:23,620
soft or something. If you're in the left, it means you're loud. If you're right, it

139
00:16:23,620 --> 00:16:30,620
means you're soft. It's still a little abstract, but essentially you've got, you're modeling

140
00:16:31,980 --> 00:16:36,460
again like a behavior. It's like the behavior of a switch is that if it's in the left position,

141
00:16:36,460 --> 00:16:40,860
you're connected to the A input. And if you're in the right position, you're connected to

142
00:16:40,860 --> 00:16:47,860
the B input. And that's what is happening here. Let me just pause for a second. Again,

143
00:16:50,220 --> 00:16:54,820
I definitely want you to try typing in the code as we go and trying this stuff out. So

144
00:16:54,820 --> 00:17:01,820
I'll give you a minute to try that. While you're doing that, by the way, I do want to

145
00:17:01,820 --> 00:17:08,260
say, I do want to make a mention that this technique that we're doing here, this is not

146
00:17:08,260 --> 00:17:13,140
part of our system, but this technique of writing single argument functions, like let's

147
00:17:13,140 --> 00:17:20,140
say you had a function add, like that, where it took two arguments. You could rewrite that

148
00:17:22,060 --> 00:17:29,060
in a really funny way using single arguments. And I'm going to give you a little bit of

149
00:17:31,940 --> 00:17:38,180
this is not going to win you points at work doing some trick like that, but you can basically

150
00:17:38,180 --> 00:17:44,300
you can take multiple argument functions and turn them into single argument functions.

151
00:17:44,300 --> 00:17:51,300
This is something known as currying. If you've ever heard that term before, it's sometimes

152
00:17:51,420 --> 00:17:54,700
something people will throw around that term. It's basically a way of like take, you can

153
00:17:54,700 --> 00:17:58,900
take multiple argument functions and just kind of turn them into single argument functions.

154
00:17:59,580 --> 00:18:02,540
Again you're going to have a lot of explaining to do at a code review if you were to show

155
00:18:02,540 --> 00:18:09,540
up with something like that normally, but that's what's happening. All right, how are

156
00:18:09,700 --> 00:18:16,700
people doing? Questions? Okay. Next thing we're going to talk about is could you take

157
00:18:18,020 --> 00:18:25,020
that and spin it into the notion of truth? Most computers do have a notion of Boolean

158
00:18:26,020 --> 00:18:33,020
values, right? Like you have true and false. Could you represent like true and false using

159
00:18:35,020 --> 00:18:41,060
this scheme in some way? And the reason that I kind of did the switch example is that you

160
00:18:41,060 --> 00:18:46,420
could think about it like that. Like think about your computer. What is a true value

161
00:18:46,420 --> 00:18:51,900
on your computer? It's an electrical device, right? It means electricity flowing around

162
00:18:51,900 --> 00:18:58,900
in there. What is true? Yeah, something. I mean it's like a bit on your computer. What

163
00:18:59,620 --> 00:19:05,360
is a bit? I mean is it like, it's probably like, it's either like five volts or three

164
00:19:05,360 --> 00:19:10,580
volts or something. I mean it's like there's electricity on it or it's the ground. It's

165
00:19:10,580 --> 00:19:17,580
one or the other. And it turns out that maybe that switch code that we had is the same thing

166
00:19:17,580 --> 00:19:24,580
that we could kind of do for true and false. I'm going to switch over to the lambda there

167
00:19:26,860 --> 00:19:33,860
just to shorten the syntax a little bit, shorten the amount of typing. So maybe true and false

168
00:19:35,540 --> 00:19:41,020
are kind of the same thing. Basically what true is, is it's like a behavior. Basically

169
00:19:41,020 --> 00:19:47,380
true means that you're connected to the first value, whatever it is. Five volts or something.

170
00:19:47,380 --> 00:19:54,380
So we're talking about computers again. And false is the opposite. It's kind of arbitrary

171
00:19:56,780 --> 00:20:01,500
in a way. But if you think about true and false values, it's like you have true and

172
00:20:01,500 --> 00:20:06,300
you have false and true is supposed to be the opposite of false. I'm never quite sure

173
00:20:06,300 --> 00:20:11,980
with the news these days. But normally true and false are meant to be opposites. And that's

174
00:20:12,180 --> 00:20:18,100
kind of what's going on here. You've got X and Y, true and false. True is one of them

175
00:20:18,100 --> 00:20:24,840
and false is the other one. And again it's a little odd because we're not representing

176
00:20:24,840 --> 00:20:31,840
true and false as a concrete thing. It's not a bit. It's not a piece of data or anything.

177
00:20:32,060 --> 00:20:37,740
It's strictly like a behavior. The behavior of true is that you're connected to the first

178
00:20:37,820 --> 00:20:44,820
thing and the behavior of false is that you're connected to the second thing. Question up

179
00:20:46,660 --> 00:20:47,660
here.

180
00:20:47,660 --> 00:20:50,660
I'm a little bothered by the absence of fact finding.

181
00:20:50,660 --> 00:20:51,660
Fact finding?

182
00:20:51,660 --> 00:20:58,660
Yeah, you know, it's like the thing where you have to report. Are you sure there's

183
00:20:58,660 --> 00:21:04,660
cannibalism going on? Because no, no, we're just reporting that there's cannibalism going

184
00:21:04,660 --> 00:21:05,660
on.

185
00:21:05,660 --> 00:21:06,660
Right.

186
00:21:07,580 --> 00:21:14,580
So the hair that stands up on my neck is that we won't in some sense be able to have the

187
00:21:16,580 --> 00:21:21,580
sort of fact finding that you need to have an actual Boolean structure.

188
00:21:21,580 --> 00:21:28,580
Yeah, there's like nothing concrete to really hang onto here. It's like true. No, I find

189
00:21:28,580 --> 00:21:35,580
this really disturbing. It's like true is not a thing. It's just like, well, it's whatever

190
00:21:37,340 --> 00:21:43,980
the first, it's whatever the x is. That's what true is.

191
00:21:43,980 --> 00:21:50,180
The only thing that we know about the rules here is that technically it has to be a single

192
00:21:50,180 --> 00:21:55,700
argument function. These values like five volts and ground, that's bogus. Normally

193
00:21:55,700 --> 00:22:00,020
I can't do that. Normally I would have to do something like this. I'd have to say,

194
00:22:00,020 --> 00:22:06,060
well, you can do true and true and false. That would be okay. Or you could have a function

195
00:22:06,060 --> 00:22:13,060
of one argument. You could say lambda x is x. I mean, I could say true of f, false. But

196
00:22:16,700 --> 00:22:22,700
that is making my head explode because it feels even more ungrounded than it was before

197
00:22:23,100 --> 00:22:26,940
doing that.

198
00:22:26,940 --> 00:22:33,940
It's very weird. It gets even weirder if I challenge you to start implementing the Boolean

199
00:22:34,060 --> 00:22:41,060
operators like not, and, and, or. Let me take that away. No, here's a challenge. How could

200
00:22:41,060 --> 00:22:48,060
you define not? Just to be clear about the behavior of not, not true is basically false.

201
00:22:56,780 --> 00:23:03,780
And not false is basically true. At least it was the last time I checked anyway. So,

202
00:23:03,780 --> 00:23:10,780
yeah, Brian, you want to try to get people to do the mic on the question here?

203
00:23:11,060 --> 00:23:12,060
Yeah.

204
00:23:12,060 --> 00:23:17,460
Just to sort of keep inventory here, are you cheating again here for narrative purposes

205
00:23:17,460 --> 00:23:22,660
at the end or do you, do we have a universe that has identity?

206
00:23:22,660 --> 00:23:29,660
I'm cheating with Python here. No, the assert statement is that that's some Python stuff.

207
00:23:30,100 --> 00:23:33,780
It becomes a little bit hard to talk about if there's not, like, if there's literally

208
00:23:33,780 --> 00:23:37,620
nothing but it's a...

209
00:23:37,620 --> 00:23:42,860
So the question is how in the world would you, how would you do not? And this is where

210
00:23:42,860 --> 00:23:47,020
things are going to, I mean, it's already probably very abstract and weird. I mean,

211
00:23:47,020 --> 00:23:50,900
it's like, wait, it's like true and false are functions and like, and, and, and what

212
00:23:50,900 --> 00:23:56,940
does it mean? And, and, and so like, let's think about the, the, the not for a second.

213
00:23:56,940 --> 00:24:02,260
The only thing that exists in this universe is function. So one thing that we can say

214
00:24:02,300 --> 00:24:09,300
about not is that X is definitely a function. Okay. We know it's a function because that's

215
00:24:10,300 --> 00:24:14,780
the only thing that exists. So that we have a hundred percent guarantee that it's a function.

216
00:24:14,780 --> 00:24:20,860
Okay. So we, we know that it's, that, that it's going to be a function. The other thing

217
00:24:20,860 --> 00:24:27,780
that we, that we know is that if, if our intent is to pass true and false to that thing, those

218
00:24:27,780 --> 00:24:32,180
are functions that have the two arguments. Remember the behavior of true is that you

219
00:24:32,180 --> 00:24:38,300
choose the first thing and the behavior of false is you choose the second thing. So we

220
00:24:38,300 --> 00:24:44,900
know that we can, we can do this. Like we say, return X something and then something,

221
00:24:44,900 --> 00:24:51,900
something else. And exactly right. So, so common up here, just reverse it. So if X is

222
00:24:52,180 --> 00:24:58,860
true, what you want to do is pick out false. Like the behavior of true is you pick the

223
00:24:58,860 --> 00:25:05,860
first thing and if it's false, you pick out the second thing. So not true is false and

224
00:25:12,060 --> 00:25:19,060
not false is true. Okay. So looks, looks, looks a little strange.

225
00:25:21,900 --> 00:25:28,900
Leave that up there. Gets a bit more interesting if you start thinking about and and or function.

226
00:25:28,900 --> 00:25:35,900
What if you wanted to have, what if you wanted to have something like that? So what you want

227
00:25:59,900 --> 00:26:06,900
to do? Let me, let me let you ponder that this one for a second. I'm going to give you

228
00:26:08,440 --> 00:26:15,440
a little hint on this one. One hint here is to understand how Python does and ors. So

229
00:26:20,440 --> 00:26:24,860
if I were to say two and three in Python. Keep in mind this is not allowed in our system

230
00:26:24,860 --> 00:26:29,380
because we have no numbers, but we're just talking about Python here. What does that

231
00:26:29,380 --> 00:26:41,580
return? So that returns three, but what about zero and three? What if I were to do zero

232
00:26:41,580 --> 00:26:54,100
and three? What does that return? You're kind of seeing like a hint of how to do this from

233
00:26:54,100 --> 00:27:04,260
Python. Basically, if the first item in and is a true value, Python goes to the second

234
00:27:04,260 --> 00:27:10,380
value and uses that to determine the result. Like if the first thing is true, the only

235
00:27:10,380 --> 00:27:14,940
way you know whether it's true or false is to look at the second value. If the first

236
00:27:14,940 --> 00:27:21,140
thing is false, like zero, then you're just done. You know that it's false. So what comes

237
00:27:21,140 --> 00:27:32,100
back is zero. That is going to be a little bit of the trick here. We're going to look

238
00:27:32,100 --> 00:27:36,620
at the first value, the X. We're going to basically look at it and say, okay, what are

239
00:27:36,620 --> 00:27:45,940
you X? Are you a true value or are you a false value? Then I'm going to return some things

240
00:27:45,940 --> 00:28:00,580
back. Just give her a few seconds to kind of ponder it here. What do you think you would

241
00:28:01,580 --> 00:28:16,380
go in this first parenthesis here? Somebody said, I think you put Y in there basically.

242
00:28:16,380 --> 00:28:22,220
If X is true, the behavior of true is you pick the first thing. It's like true picks

243
00:28:22,220 --> 00:28:30,300
the first thing. If it's true, the result of and is solely determined by what Y is.

244
00:28:30,300 --> 00:28:37,260
If X is true, then whatever Y is, that is the result. If Y is true, then it's true.

245
00:28:37,260 --> 00:28:47,100
If Y is false, then it's false. If X is false, then what is the result? It could just be

246
00:28:47,100 --> 00:28:54,100
X. If X is false, then the thing is false. You could do that. It turns out that that

247
00:28:54,100 --> 00:29:00,260
exactly does that. It's kind of mind-boggling, but you can try it out. And true and true

248
00:29:00,420 --> 00:29:10,940
is true. And true and false is false. And false and true is false. And false and false

249
00:29:10,940 --> 00:29:19,940
is false. It is giving you the Boolean logic. Again, it's a real sneaky thing going on there.

250
00:29:19,940 --> 00:29:22,940
It's like, yeah.

251
00:29:22,940 --> 00:29:32,940
Doing this, how much do you think, or did you ever draw or think about a truth table

252
00:29:32,940 --> 00:29:38,300
that you might make in a logic class? The syntax totally messes me up. It's very hard

253
00:29:38,300 --> 00:29:44,420
to read. It blocks my thinking. But when you see a simple truth table where you write T,

254
00:29:44,420 --> 00:29:49,660
T, F, F, and you do all of that, that logic becomes very simple and easy to understand.

255
00:29:49,660 --> 00:29:55,020
When you think about not, you just put the little curly thing in front of it. If you

256
00:29:55,020 --> 00:30:02,020
think about the and or the or, those become very simple and easy to understand. When thinking

257
00:30:02,020 --> 00:30:09,860
about this, the syntax blocks me. But that idea is very easy to understand. Did you look

258
00:30:09,860 --> 00:30:13,100
at something like that when thinking about this?

259
00:30:13,100 --> 00:30:19,580
The answer is yes. I've seen logic from math classes. I think the difficulty, at least

260
00:30:19,580 --> 00:30:24,420
for me, is how do you bridge that to this world where the only thing that you have is

261
00:30:24,420 --> 00:30:25,900
a single argument function.

262
00:30:25,900 --> 00:30:32,300
But then the truth table is a single argument function, right? It takes a one-piece.

263
00:30:32,300 --> 00:30:42,020
Right, but how do you encode it? Yes, you get in the X and the Y, but how to take the

264
00:30:42,020 --> 00:30:47,780
logic table and turn it into something that I can type within the rules of what I'm allowed

265
00:30:47,780 --> 00:30:53,820
to type becomes really challenging because there's no if statement. There's no control

266
00:30:53,820 --> 00:30:59,980
flow or anything in this. The only thing I can do is function call. It becomes this really

267
00:30:59,980 --> 00:31:08,620
weird puzzle where it's like, how do I do this when the only operation that I can do

268
00:31:08,620 --> 00:31:18,780
is call a function? You're exactly on the right track, though. If you're looking at

269
00:31:18,780 --> 00:31:25,740
this thinking, that is insane. I never would have come up with that. That is totally the

270
00:31:25,740 --> 00:31:36,220
correct response to that. Don't ask this on any job interview question, by the way. It's

271
00:31:36,220 --> 00:31:45,300
sort of crazy. The OR operator is also kind of a similar thing. I mean, OR, what do you

272
00:31:45,300 --> 00:31:55,060
think for that? Think about the OR logically. If the first argument to the OR was true.

273
00:31:55,060 --> 00:32:06,260
Yeah, you just got to switch the order of the X and Y to reverse. Yeah, to do the OR. If X was true,

274
00:32:06,260 --> 00:32:14,620
then you're done. It's X. The behavior of OR is like, if you're true, it's true. If X is not true,

275
00:32:14,620 --> 00:32:24,780
then it must be Y. Whatever Y is, and you'll get that. So OR true and false is true. Or

276
00:32:24,820 --> 00:32:37,860
false and false is false. You can build it up, but it is sort of, you know, it's tricky. I would not

277
00:32:37,860 --> 00:32:41,380
claim that this is obvious. If you've never seen this before, it's like, whoa.

278
00:32:41,380 --> 00:32:48,300
Yeah, so I just tried this, but OR false and true comes out with problems.

279
00:32:48,300 --> 00:33:08,100
So OR false and true comes out with... Yeah, that should be okay. Debugging some of this is a real

280
00:33:08,100 --> 00:33:18,660
challenge sometimes. All right, did everybody get that code entered, by the way? Just trying it out.

281
00:33:18,660 --> 00:33:23,860
Again, a lot of the code in here is something that's like, try it out, and you sort of stare

282
00:33:23,860 --> 00:33:34,260
in disbelief that it's like, this shouldn't be working, or it's sort of nuts. I do think it's

283
00:33:34,260 --> 00:33:38,260
kind of interesting, though, where it's like, we basically started with nothing, where it's like,

284
00:33:38,260 --> 00:33:45,060
you have functions and substitution, and now all of a sudden we have Boolean logic. The thing that,

285
00:33:45,060 --> 00:33:49,140
again, it's a little strange is that there's nothing concrete here again. It's like, there is

286
00:33:49,140 --> 00:33:55,420
no bit or data structure. It's all purely behavior, basically. Like, you know, like the behavior of

287
00:33:55,420 --> 00:34:01,660
OR is that, well, if the first thing has the behavior of true, then the result of OR is the

288
00:34:01,660 --> 00:34:07,620
behavior of true. It feels like sort of very kind of nebulous and abstract.

289
00:34:07,620 --> 00:34:15,700
So, you can only have kind of a single argument function, right? But then you made add with the

290
00:34:15,700 --> 00:34:20,020
kind of two function calls, right? So we can then infer that we could have kind of infinite number

291
00:34:20,020 --> 00:34:25,460
of function calls, right? So technically, you could take any number of things, right? And so,

292
00:34:25,460 --> 00:34:30,580
if you wanted to represent something, say you wanted to represent, you know, a simple kind of

293
00:34:30,700 --> 00:34:36,580
three-letter alphabet, right? You could just have each bit, so to speak, be some n number of

294
00:34:36,580 --> 00:34:39,540
function calls to represent a string in that alphabet, right?

295
00:34:39,540 --> 00:34:44,900
You are exactly right. And you're actually on to the very next thing we're going to talk about,

296
00:34:44,900 --> 00:34:53,980
which is, like, how would you represent numbers? You want to represent, like,

297
00:34:53,980 --> 00:34:58,540
integers or something? Let's forget about letters, per se. But let's say you were thinking about

298
00:34:58,620 --> 00:35:06,260
numbers. And one thing with the numbers is to maybe not overthink the numbers, but to go back to

299
00:35:06,260 --> 00:35:10,740
kindergarten. Okay, so, like, how do they teach, like, preschoolers how to do numbers? And it's

300
00:35:10,740 --> 00:35:15,300
like there's a lot of, like, finger counting kind of stuff, like one and two and three. And then they

301
00:35:15,300 --> 00:35:18,900
show you pictures of, like, well, how many gummy bears are there? And how many, you know, it's

302
00:35:18,900 --> 00:35:25,220
always showing, like, a visual representation of, like, a certain number of things. Or maybe you do,

303
00:35:25,220 --> 00:35:34,220
like, score marks or some other thing. And if you wanted to do numbers, could you do something

304
00:35:34,220 --> 00:35:40,540
like that with functions? And the answer is actually yes. We had the comment up here. It's

305
00:35:40,540 --> 00:35:46,940
like, since you can have, like, an infinite number of function calls, maybe you could use that for

306
00:35:46,940 --> 00:35:57,780
numbers. Let me show you one of them to give you kind of an idea. Like, maybe one is where you do

307
00:35:57,780 --> 00:36:06,580
one function call on X. Like you say, F of X. I call the function once. That's the number one. It's

308
00:36:06,580 --> 00:36:17,700
like a repeat. And then maybe the number two is like two function calls of X. Like you just say F

309
00:36:17,700 --> 00:36:30,260
of F of X. It's like holding my fingers up where it's like two, okay? What would three be? Big quiz

310
00:36:30,260 --> 00:36:37,860
time. What is three in this universe? Yeah, F of X. Now, you're gonna look at that. You're gonna say,

311
00:36:37,860 --> 00:36:45,700
like, what is that? Like, I mean, okay, so it's like, again, this is like purely, it's like

312
00:36:45,700 --> 00:36:54,900
functions all the way through. But like, what is going on here exactly? What the numbers are

313
00:36:54,900 --> 00:37:00,900
representing, again, is a behavior. It's not a thing. It's not a bit pattern or anything like

314
00:37:00,900 --> 00:37:09,100
that. The behavior of three, for instance, means that you take a function F and you call it like

315
00:37:09,100 --> 00:37:15,060
three times on some, like you start with F of X and then you do F like three times in a row. Let

316
00:37:15,060 --> 00:37:20,740
me show you an example. Let's say you had a function increment. Again, this is not allowed

317
00:37:20,740 --> 00:37:27,420
in our rules, okay? So this is like we're, okay, legal in the rules, but this is just purely for

318
00:37:27,420 --> 00:37:34,420
like demonstration purposes. Basically, what the numbers are is if I said Inker of zero,

319
00:37:34,420 --> 00:37:46,340
that's like the number one. I did Inker one time. If I did Inker Inker zero, that's two times. I did

320
00:37:46,340 --> 00:37:52,700
Inker two times. And then if you said Inker Inker, like if I started doing it like a whole bunch of

321
00:37:52,700 --> 00:37:58,900
times, I mean, essentially, it's like repeating that function basically a whole bunch of times.

322
00:37:58,900 --> 00:38:06,300
Essentially, what we've got up here at the top is an abstraction of that idea where instead of

323
00:38:06,300 --> 00:38:14,140
writing out like Inker Inker Inker Inker like that, I could just say three Inker zero, and it would

324
00:38:14,140 --> 00:38:21,380
do it. It's like three basically you give me a function and a starting point and it will just

325
00:38:21,380 --> 00:38:29,220
like turn the crank like that many times, like three times. The thing that's really odd about it

326
00:38:29,220 --> 00:38:35,680
is it's all extremely abstract. It has, like the number three does not actually care what the

327
00:38:35,680 --> 00:38:40,820
function is or what the X is. It's like, again, it's like a behavior where it's just like, I'm

328
00:38:40,820 --> 00:38:47,060
going to turn the crank three times. I don't really know what it is or I don't even really care

329
00:38:47,060 --> 00:38:52,700
what's going on. I'm just going to turn the crank three times on it. I mean, just as something

330
00:38:52,700 --> 00:38:59,500
wildly different here, I mean, I could have a function P that maybe this thing takes a, we'll

331
00:38:59,500 --> 00:39:04,980
introduce like Python tuples or something just to do something really radically different here.

332
00:39:04,980 --> 00:39:13,060
Like here's a function where you give it like a tuple like zero zero or something and it increments

333
00:39:13,060 --> 00:39:20,260
the first value and so forth. You could start, you could do that. Like you could say, well,

334
00:39:20,260 --> 00:39:28,220
what's three of P applied to the tuple zero zero? And it comes back with like three two. I mean,

335
00:39:28,220 --> 00:39:32,580
essentially it's just like turning, like the numbers are basically just like turning the gears

336
00:39:32,580 --> 00:39:41,060
without any regard for what the actual function is. As long as it's a function with single argument.

337
00:39:41,060 --> 00:39:52,620
Okay, we're still in the single argument case here. Let me put the code back up. Let me ask,

338
00:39:52,620 --> 00:39:57,020
see if there are questions here. Let's pause for a second. I do want you to enter that code and try

339
00:39:57,020 --> 00:40:04,020
it out here. So if we're, you said there were no exceptions in there, right? But seeing as how

340
00:40:04,020 --> 00:40:08,620
you're starting to do math, right? If you get to divide, what happens when you divide by zero?

341
00:40:08,620 --> 00:40:15,860
We haven't even gotten there yet. We don't even know how to add yet. We don't have to divide. I

342
00:40:15,860 --> 00:40:23,220
mean, are you like, that's like in the next version or something. No, but like, like all we, all we

343
00:40:23,220 --> 00:40:30,740
have now is just like a representation of numbers. Like, like, okay, the number three and four, you

344
00:40:30,740 --> 00:40:36,180
know, like, I mean, we can type them out. We're actually, actually hitting a bit of a problem here,

345
00:40:36,180 --> 00:40:43,300
which is like, how do I get more numbers into my system? I mean, you got to, or we just make like

346
00:40:43,300 --> 00:40:49,980
a big file with like the first million numbers in it and then like type it out. I mean, that's a

347
00:40:49,980 --> 00:40:57,580
little, so that's, that's a little bit weird. There are some other kind of interesting things going on

348
00:40:57,580 --> 00:41:08,060
as well. Like, like, let me, what if you were to do something like this? Like four times, like four of

349
00:41:08,060 --> 00:41:19,580
three. I don't know, like what if you were to do that? Remember that a number means that you've

350
00:41:19,580 --> 00:41:23,820
repeat something a bunch of times. So what I did here is I just said, well, I'm going to do the three

351
00:41:23,820 --> 00:41:34,460
function four times. No, let's try it like a increment zero. No, no, no. What do you think the result is there?

352
00:41:37,900 --> 00:41:39,420
Any 12?

353
00:41:42,060 --> 00:41:42,940
81. Yeah.

354
00:41:42,940 --> 00:41:50,780
What that's doing is it's doing, it's doing exponentiation. It's doing three to the fourth power.

355
00:41:52,620 --> 00:42:01,100
Like three means do something three times. So if you do three times three, that's nine. Times three is 27. Times three is 81.

356
00:42:01,100 --> 00:42:14,460
Yeah, at some point. Yeah, but that the, but, but already like just from that, you're maybe getting a little bit of a hint of some,

357
00:42:14,460 --> 00:42:22,460
of like some math, mathy stuff where it's like, huh, okay, this is weird. Like, okay, like the, like the behavior of four is to repeat something four times.

358
00:42:22,460 --> 00:42:33,500
The part of this that I am following is when I see the one, the two, the three, and the four is those things are creating function objects in Python.

359
00:42:33,500 --> 00:42:38,780
And they're unique objects and they represent unique things, which we've happened to name three and four and two.

360
00:42:38,780 --> 00:42:44,460
Yeah. So is that helping me or making it harder for me to understand the rest of this?

361
00:42:44,860 --> 00:42:54,140
And we have names too. Yeah, I, it's, I have to name them something just to even refer to it at this point.

362
00:42:54,140 --> 00:42:59,420
I mean, the thing that I, that I want you to focus on is that, that they are functions.

363
00:42:59,420 --> 00:43:07,420
Okay. So lambda defines a function and this is a function that returns another function.

364
00:43:08,300 --> 00:43:16,300
I'm going to, I'm going to be stretching you on the syntax a little bit here, but it's like, this is a function that returns another function.

365
00:43:16,300 --> 00:43:21,980
And then what it's doing is it's, it's, it's just doing like F of F of F of F of F like a bunch of time.

366
00:43:21,980 --> 00:43:28,700
And then the number of times that you do that is what the number is, how you're representing the number.

367
00:43:28,700 --> 00:43:36,300
It's like, and again, it's like, think like it's like finger counting, like from kindergarten, just in a really horribly gone astray, basically.

368
00:43:36,380 --> 00:43:39,420
So it's, but it's the same, same idea there.

369
00:43:43,420 --> 00:43:49,740
I was thinking until we typed in four, three that you could make some sort of a ten and hundreds kind of a thing.

370
00:43:49,740 --> 00:43:52,740
And then you could do ten of three and it would be like thirteen.

371
00:43:52,740 --> 00:43:59,260
And that's how you get more numbers in. But I haven't quite figured out how to do multiplication yet because I thought four, three was going to be twelve.

372
00:43:59,260 --> 00:44:01,700
Right. I thought it was going to be twelve. So I'm lost.

373
00:44:01,700 --> 00:44:02,220
But.

374
00:44:06,900 --> 00:44:13,380
So in, in, in the syntax that you use where we do like the one, two and three, you have a lot of kind of nesting going on.

375
00:44:13,380 --> 00:44:19,340
It looks a little clearer to me when you write things with just, you know, kind of a, where you did a, a, zero.

376
00:44:19,340 --> 00:44:24,540
Right. So where you have like the single argument in each of the of the parentheses.

377
00:44:24,540 --> 00:44:29,900
Right. So if you took something there and you just had some long, like if you wanted like you created the bit earlier.

378
00:44:29,940 --> 00:44:36,820
Right. I mean, you could create, you know, like a four bit representation of something with four of those kind of parentheses in there.

379
00:44:36,820 --> 00:44:41,820
If you passed in true in the first one and zeros and the others, you represent some binary number.

380
00:44:41,820 --> 00:44:49,020
Right. You could do one in each block. And right. You could combine them in all these sorts of ways where now you suddenly start having a bit.

381
00:44:51,220 --> 00:44:57,100
I think you probably could do numbers in that way. But then like, like, I mean, you could go like down the binary route of numbers.

382
00:44:57,100 --> 00:45:01,580
But then you're going to hit like an upper limit at some point. Now you're writing binary.

383
00:45:02,220 --> 00:45:07,980
I haven't explored that angle and I got to go down that direction. But it's I mean, I could see going that way.

384
00:45:10,900 --> 00:45:15,820
Yeah. This this thing here is something known as the church numerals, by the way, is kind of a name for it.

385
00:45:17,260 --> 00:45:24,940
There is a challenge, though, and we're kind of we're kind of getting to it, which is well, before we get to the challenge, there's some other challenges.

386
00:45:25,820 --> 00:45:28,700
One challenge is how do you implement zero?

387
00:45:32,820 --> 00:45:38,700
That's a picture of the black hole, by the way, that had a bunch of Python code involved. I thought I'd include that there.

388
00:45:43,580 --> 00:45:46,260
There's no no concept. Yeah.

389
00:45:47,860 --> 00:45:54,420
The thing that with the zero is that first of all, there is a there's an API for for numbers.

390
00:45:55,660 --> 00:46:07,980
Not to talk about APIs in here, but the API for a number is that you take an F and you take an X. If it's not that it's not a number. OK, so it's like there is a very strict protocol for what numbers are going to be.

391
00:46:09,300 --> 00:46:15,020
The other the other thing. Oh, but by the way, I'm getting kind of tired of typing the lambda, by the way.

392
00:46:16,380 --> 00:46:18,980
So I'm going to use lambda.

393
00:46:18,980 --> 00:46:30,860
I realize that this is not going to work in your editor, but you're going to have to do a little. I'm going to require you to do a little mental substitution here. So I think the key to a good tutorial is to use a custom environment.

394
00:46:30,860 --> 00:46:39,300
So we'll come to that in a second. So the zero is basically going to be lambda F lambda X.

395
00:46:40,100 --> 00:46:44,700
And the question is like, how would how would you represent zero in this?

396
00:46:45,500 --> 00:46:55,180
In the system, a one is it's like one usage of F and two is two usages of F and three is three usage of usage of F. What do you think the zero is?

397
00:46:56,180 --> 00:47:05,100
Zero usage. Yeah, X like like you didn't use F at all. It's like you just gave me an F and X and it's like OK, didn't do anything to it.

398
00:47:08,580 --> 00:47:18,500
So like the zero basically means you didn't do anything. So if I said like zero inker of like zero, it means you just stayed at zero. You didn't call the you didn't call the function.

399
00:47:26,180 --> 00:47:29,980
So where this is going where this going that question in the back there.

400
00:47:32,180 --> 00:47:36,820
So does this mean that zero and true are equivalent? Yes, OK.

401
00:47:37,780 --> 00:47:53,500
They have the same behavior. I'm not going to make that association because I'm already quite confused as it is. And like, what's where I'm going to try to keep zero and true is different things. But but yeah, you will notice that the that the implementation of the zero is exactly the same as true.

402
00:47:54,500 --> 00:48:00,420
No, no, wait, it's the zero. It's the implementation of false actually, right? Because like the behavior of false is to pick the second thing.

403
00:48:02,900 --> 00:48:06,220
So here we're picking out the second thing. We're picking out the egg.

404
00:48:12,900 --> 00:48:15,020
We clean up a bit while you're thinking about that.

405
00:48:17,100 --> 00:48:22,140
OK, so got zero. The thing we're going to look at look at next, though, great question over here.

406
00:48:23,500 --> 00:48:34,020
So it's it's impossible to implement numbers without the anchor function, right? The anchor function is a side of like that is a Python thing.

407
00:48:35,500 --> 00:48:48,100
Used only for illustration. OK, yeah, so you can actually see the number. No, so that the strange thing about like if you look at that, like if you look at yeah, if you look at like three, it just comes back and says I'm a lambda function.

408
00:48:49,100 --> 00:48:51,700
And then it's like it's purely abstract. Like it's like.

409
00:48:53,100 --> 00:49:00,700
What is that like and like the basically the concept of three? It's a function that does something three times.

410
00:49:02,100 --> 00:49:07,700
And in order to see the effect of it, I have to I have to provide a function for it to look at.

411
00:49:08,700 --> 00:49:16,300
I mean, I could write different functions like like here's one that adds like a star to X. Maybe we do like strings or something.

412
00:49:17,700 --> 00:49:25,300
What would happen there is if I did three of F and then gave it like an empty string or something, it's like essentially you're giving it like the starting point.

413
00:49:26,700 --> 00:49:31,700
And then you're like the three represents like turning the crank three times on it.

414
00:49:31,700 --> 00:49:42,300
I think it's really hard to kind of mentally like have like wrap my brain around this because there is nothing sort of concrete here, which is really sort of weird.

415
00:49:42,700 --> 00:49:49,700
In each case, so you're giving it like an empty value as like the second argument. Is that is that just to give it is that because it's a natural starting point.

416
00:49:49,700 --> 00:49:52,700
Yeah, you have to have to kick off with like an initial value.

417
00:49:52,700 --> 00:49:53,300
Yeah.

418
00:49:53,300 --> 00:49:57,300
Now the thing we're going to look at the look at next, but just kind of push forward a little bit here.

419
00:49:58,300 --> 00:50:04,300
What if you did want to use do math with this thing like add and multiply and other stuff.

420
00:50:05,300 --> 00:50:13,300
One of the one of the problems is that you have all the numbers hard coded least so far like I've just been typing them in and it's like, well, that's just terrible.

421
00:50:13,300 --> 00:50:16,300
I don't want to I don't want to I don't want to do that.

422
00:50:16,300 --> 00:50:19,300
And then the question is like, well, how would you go beyond that?

423
00:50:19,300 --> 00:50:25,300
And it actually takes you it kind of into this this thought of like, well, what is the most minimal thing that you need to do math?

424
00:50:26,300 --> 00:50:32,300
The picture up here of piano, there are these piano axioms for math.

425
00:50:32,300 --> 00:50:39,300
There may be a little bit abstract, but the way that they're kind of phrased is they sort of they start off saying zero is a number.

426
00:50:39,300 --> 00:50:43,300
And then you get into all this talk about creating successors of numbers.

427
00:50:43,300 --> 00:50:46,300
Like if you have a number, can you get to the next number?

428
00:50:46,300 --> 00:50:47,300
And then could you build number?

429
00:50:47,300 --> 00:50:48,300
Could you build numbers?

430
00:50:48,300 --> 00:50:54,300
And then you get into the idea of like, well, what is the most minimal thing that you need to do math?

431
00:50:54,300 --> 00:51:00,300
The picture up here of piano, there are these piano axioms for math.

432
00:51:02,300 --> 00:51:05,300
And you can do math by just being able to get to the next thing.

433
00:51:05,300 --> 00:51:15,300
Basically, the act of counting like if you can count like go from the number two to the number three, can you start doing like more interesting math operations?

434
00:51:15,300 --> 00:51:17,300
And the answer the answer is yes.

435
00:51:17,300 --> 00:51:19,300
But the challenge here.

436
00:51:22,300 --> 00:51:31,300
Is implement successor like can you write a function that would take a number and then get you to the next number?

437
00:51:32,300 --> 00:51:35,300
This is typed out as suck, by the way, S-U-C-C.

438
00:51:35,300 --> 00:51:46,300
So we're going to have a function successor as input is going to take a number.

439
00:51:50,300 --> 00:51:56,300
And again, I'm going to have you're going to have to sort of mentally translate my lambda character into Python, by the way.

440
00:51:56,300 --> 00:51:58,300
Looks like that.

441
00:51:58,300 --> 00:52:04,300
So every everywhere you see the lambda character, you're going to you're going to you're going to type lambda.

442
00:52:04,300 --> 00:52:08,300
And the question is, what are we going to what are we going to do here?

443
00:52:08,300 --> 00:52:11,300
So just just just make sure we're clear about what's going on here.

444
00:52:11,300 --> 00:52:19,300
If I say successor of two, what's going to pop out of that is basically three.

445
00:52:19,300 --> 00:52:21,300
But that's what we want to have happen.

446
00:52:21,300 --> 00:52:26,300
So so we're going to have this function basically takes a number.

447
00:52:26,300 --> 00:52:29,300
It's going to have a number coming out.

448
00:52:29,300 --> 00:52:34,300
And so the question is, how is that going to work exactly?

449
00:52:39,300 --> 00:52:40,300
You're correct.

450
00:52:40,300 --> 00:52:45,300
One one one more function call one more one more function.

451
00:52:45,300 --> 00:52:47,300
No, you are you are absolutely correct.

452
00:52:47,300 --> 00:52:49,300
It is one more.

453
00:52:49,300 --> 00:52:50,300
It's like spinal tap, right?

454
00:52:50,300 --> 00:52:53,300
You're at 10 and you need to go one more.

455
00:52:53,300 --> 00:52:54,300
You go to 11. Right.

456
00:52:54,300 --> 00:52:55,300
You know, the famous scene.

457
00:52:55,300 --> 00:52:57,300
You're going to have one more function.

458
00:52:57,300 --> 00:53:07,300
But before you do that, you have to you have to sort of think like we said, what like what is this successor thing returning exactly?

459
00:53:07,300 --> 00:53:09,300
It's returning a number.

460
00:53:09,300 --> 00:53:16,300
And the critical thing about numbers is they have a numbers have a very specific API.

461
00:53:16,300 --> 00:53:24,300
Think about the API to a number not to bring API into class, but the interface to a number is that there is always an F.

462
00:53:24,300 --> 00:53:27,300
And there is an X. That is the API to a number.

463
00:53:27,300 --> 00:53:31,300
And it turns out that that is what you're going to do here.

464
00:53:36,300 --> 00:53:39,300
Maybe parentheses might help this out a little bit.

465
00:53:39,300 --> 00:53:45,300
Like basically you're going to be returning a number that takes an F and it takes an X.

466
00:53:46,300 --> 00:53:50,300
OK, I'm going to return that.

467
00:53:50,300 --> 00:53:53,300
We're going to use your comment, which is exactly correct.

468
00:53:53,300 --> 00:53:57,300
You're going to do one more F. That's the go to the next number.

469
00:53:57,300 --> 00:53:58,300
You have to go one more.

470
00:53:58,300 --> 00:54:02,300
So there's going to be an F out front, which is the one more.

471
00:54:02,300 --> 00:54:06,300
But then what is what is going to go in the in the parentheses here?

472
00:54:06,300 --> 00:54:11,300
So the behavior of a number, right?

473
00:54:11,300 --> 00:54:12,300
It's like a number.

474
00:54:12,300 --> 00:54:16,300
You basically give it an F and an X and it repeats that many times.

475
00:54:16,300 --> 00:54:19,300
So this is this is basically the old number here.

476
00:54:19,300 --> 00:54:21,300
OK, so that's the old number.

477
00:54:21,300 --> 00:54:23,300
And then we have the extra F on front.

478
00:54:23,300 --> 00:54:27,300
That's taking us to the next to the next number.

479
00:54:30,300 --> 00:54:34,300
So if I were to say successively, I would say successively.

480
00:54:34,300 --> 00:54:40,300
So if I were to say successor of four, for instance, it's going to come back with this crazy result.

481
00:54:40,300 --> 00:54:42,300
It's going to say, OK, function lambda.

482
00:54:42,300 --> 00:54:44,300
You're like, what is that?

483
00:54:44,300 --> 00:54:48,300
Well, if that is working correctly, it's a function.

484
00:54:48,300 --> 00:54:52,300
So I'm going to use my magic underscore variable here.

485
00:54:52,300 --> 00:54:57,300
I should be able to pass that like anchor in zero and I'll come back say, oh, it's five.

486
00:54:57,300 --> 00:54:59,300
The successor of four is five.

487
00:54:59,300 --> 00:55:03,300
So if you use that, you're getting five.

488
00:55:07,300 --> 00:55:11,300
OK, now just to see the syntax of that written out.

489
00:55:11,300 --> 00:55:13,300
I did anticipate this problem, by the way.

490
00:55:13,300 --> 00:55:16,300
So I'm going to leave that.

491
00:55:16,300 --> 00:55:18,300
What do you think about doing it as a step?

492
00:55:22,300 --> 00:55:23,300
Yeah.

493
00:55:23,300 --> 00:55:25,300
I really like this kind of feedback.

494
00:55:25,300 --> 00:55:32,300
You have that lambda symbol and then you have the syntax because you have that lambda symbol and you have the word lambda.

495
00:55:32,300 --> 00:55:36,300
But we began the talk with the idea of substitution.

496
00:55:36,300 --> 00:55:41,300
So you just take that symbol and you substitute this other symbol into it and then it kind of works.

497
00:55:41,300 --> 00:55:44,300
Yeah, I'm just doing it because I'm lazy.

498
00:55:44,300 --> 00:55:46,300
Yeah.

499
00:55:46,300 --> 00:55:48,300
Yeah.

500
00:55:49,300 --> 00:55:51,300
Now, one thing.

501
00:55:51,300 --> 00:55:53,300
Now, your comment on the notation.

502
00:55:53,300 --> 00:55:55,300
I actually am.

503
00:55:55,300 --> 00:55:58,300
I am doing something very deliberate here, which I'll get to.

504
00:55:58,300 --> 00:56:08,300
If you read papers about the lambda calculus, they tend to use very cryptic mathematical notation with the lambda character and other stuff.

505
00:56:08,300 --> 00:56:12,300
I am steering you a little bit in that direction.

506
00:56:12,300 --> 00:56:23,300
So at this point, this is basically Python code, except that I have replaced the lambda word with the lambda character.

507
00:56:23,300 --> 00:56:28,300
If you must know, my editor is literally doing like a string replace on it.

508
00:56:28,300 --> 00:56:30,300
I have a custom environment.

509
00:56:30,300 --> 00:56:35,300
It's taking my code and it's just like, oh, if you see the lambda character, just replace it with the word lambda.

510
00:56:35,300 --> 00:56:40,300
So it's a notational shortcut there.

511
00:56:40,300 --> 00:56:46,300
If you're done with that, by the way, I'm going to give you the challenge of implementing add-ins multiply.

512
00:56:46,300 --> 00:56:49,300
Wait a second here.

513
00:56:49,300 --> 00:56:51,300
Yeah.

514
00:56:51,300 --> 00:56:53,300
A successor.

515
00:56:53,300 --> 00:56:55,300
Do we have a decrementer?

516
00:56:55,300 --> 00:56:57,300
Can we go back?

517
00:56:57,300 --> 00:56:59,300
We do not.

518
00:56:59,300 --> 00:57:01,300
And I'm not going to address that question right now.

519
00:57:01,300 --> 00:57:07,300
But it is something to think about, which is like, how would you go to the previous number?

520
00:57:08,300 --> 00:57:12,300
Like, how do you undo a function call?

521
00:57:12,300 --> 00:57:16,300
That seems like a really weirdly tricky kind of crazy thing.

522
00:57:16,300 --> 00:57:19,300
And I'm not going to address that right this second.

523
00:57:19,300 --> 00:57:25,300
I want to comment on the underscore method so everybody's clear, including myself.

524
00:57:25,300 --> 00:57:31,300
That's just a helper so you can not call successor for incrementer zero kind of thing?

525
00:57:31,300 --> 00:57:36,300
Yeah. Underscore is the result of the last thing you do in the REPL in Python.

526
00:57:36,300 --> 00:57:43,300
So if you've used Jupiter or the Python REPL, the underscore always holds the last result of whatever you did.

527
00:57:43,300 --> 00:57:45,300
So I'm using that here.

528
00:57:45,300 --> 00:57:53,300
So the result of the last thing I did here was the successor of four.

529
00:57:53,300 --> 00:57:56,300
But you could do this kind of stuff.

530
00:57:56,300 --> 00:58:00,300
You could say do the successor of the successor of four.

531
00:58:00,300 --> 00:58:02,300
Do it twice.

532
00:58:02,300 --> 00:58:06,300
And then pass in the incur function in zero and come back.

533
00:58:06,300 --> 00:58:07,300
That's sick.

534
00:58:07,300 --> 00:58:10,300
You know, two successors of four is sick.

535
00:58:21,300 --> 00:58:27,300
That last example, by the way, is giving you a hint on how to do add.

536
00:58:28,300 --> 00:58:30,300
Well, say you wanted to add two numbers.

537
00:58:30,300 --> 00:58:32,300
Like you wanted to add two and three.

538
00:58:32,300 --> 00:58:36,300
And you wanted to describe this again to like a kindergartener or something like that.

539
00:58:36,300 --> 00:58:38,300
And you wanted to do it with finger counting or something.

540
00:58:38,300 --> 00:58:43,300
You could say, well, if you had two, you want to add three, you push up like three fingers.

541
00:58:43,300 --> 00:58:44,300
It's like one, two, three.

542
00:58:44,300 --> 00:58:46,300
And then you look at how many you have.

543
00:58:46,300 --> 00:58:50,300
Basically, you just did three successors of two.

544
00:58:50,300 --> 00:58:55,300
Like two and three is three successors of two.

545
00:58:55,300 --> 00:58:57,300
And you could do that.

546
00:58:57,300 --> 00:59:05,300
Like basically the way that add would work is you would take y and you would say apply that.

547
00:59:05,300 --> 00:59:10,300
Like take the successor function and apply it a whole bunch of times to the other number.

548
00:59:15,300 --> 00:59:21,300
So when I learn math, like there's a certain way to kind of think about it.

549
00:59:21,300 --> 00:59:29,300
But I mean, there's the other idea, which is that multiplication is just repeated addition, right?

550
00:59:29,300 --> 00:59:32,300
And exponentiation is just repeated multiplication.

551
00:59:32,300 --> 00:59:37,300
So you have these things that are kind of nesting or just like repetitions of themselves, right?

552
00:59:37,300 --> 00:59:43,300
So now that you can add one to something, which is why the Italian guy for his name.

553
00:59:43,300 --> 00:59:45,300
But he had to start somewhere.

554
00:59:45,300 --> 00:59:46,300
So he started with zero.

555
00:59:46,300 --> 00:59:48,300
He said you could add one to something.

556
00:59:48,300 --> 00:59:52,300
And if you can just do that some infinite number of times, you can get anything.

557
00:59:52,300 --> 00:59:53,300
Yeah.

558
00:59:53,300 --> 00:59:54,300
Yeah.

559
00:59:54,300 --> 00:59:56,300
So that's kind of what's going on here.

560
00:59:56,300 --> 01:00:02,300
It's like once you have the successor function, you can start using that to get to different spots, right?

561
01:00:02,300 --> 01:00:08,300
So if you have like two numbers, x and y, and you wanted to add those together, you would take like the second.

562
01:00:08,300 --> 01:00:14,300
Like if you had four plus five, you could get to nine by doing five successors of four.

563
01:00:14,300 --> 01:00:20,300
Like if four is your starting point and then you turn the crank on the successor function five times.

564
01:00:25,300 --> 01:00:28,300
So add ends up looking like this thing that I've got here.

565
01:00:28,300 --> 01:00:36,300
I'm going to put up the Python syntax for that again, just to have you try that out.

566
01:00:41,300 --> 01:00:43,300
Yeah, we'll get to that later.

567
01:00:43,300 --> 01:00:47,300
What you want to be able to use the lambda in your Python code now?

568
01:00:53,300 --> 01:00:55,300
What, the custom environment?

569
01:00:55,300 --> 01:00:57,300
Nah, nobody wants to know about that.

570
01:00:59,300 --> 01:01:01,300
Better off not knowing.

571
01:01:01,300 --> 01:01:02,300
Yeah.

572
01:01:02,300 --> 01:01:06,300
Multiplication is something that you can also do.

573
01:01:06,300 --> 01:01:10,300
In the interest of time, I might just kind of show you what that looks like.

574
01:01:10,300 --> 01:01:17,300
We'll leave it as a, what it was left as an exercise to the reader to fully grock that.

575
01:01:17,300 --> 01:01:24,300
Basically the way that multiply works, like imagine that you have like three times four.

576
01:01:24,300 --> 01:01:32,300
What you do with multiply is you're going to take the function, like you take one of the numbers, like x.

577
01:01:32,300 --> 01:01:35,300
X is one of the numbers, so that's like three.

578
01:01:35,300 --> 01:01:38,300
We're going to do three repetitions of f.

579
01:01:40,300 --> 01:01:41,300
Oh, yeah.

580
01:01:45,300 --> 01:01:47,300
Then we're going to do that y time.

581
01:01:50,300 --> 01:01:52,300
We'll try this out here.

582
01:01:52,300 --> 01:02:12,300
That one is maybe, honestly this one is something that I have found very difficult to kind of wrap one's brain around, is the multiplication.

583
01:02:12,300 --> 01:02:16,300
It's essentially you have a number x, and like what is the behavior of x?

584
01:02:16,300 --> 01:02:17,300
It's like a repetition.

585
01:02:17,300 --> 01:02:25,300
If I have a number four and I give it a function, then x of that function, that means like doing f four times.

586
01:02:25,300 --> 01:02:28,300
That's what that means.

587
01:02:28,300 --> 01:02:36,300
Then if you put this y out front, it's like you're repeating that four times f like three times in a sequence there.

588
01:02:36,300 --> 01:02:38,300
It's a little weird, but...

589
01:02:38,300 --> 01:02:43,300
The thing that breaks my brain about that one is that it has an f, and add doesn't.

590
01:02:43,300 --> 01:02:53,300
I feel like I know that f is coming from the outside and that we are calling f underneath, but that's what killed me.

591
01:02:53,300 --> 01:02:57,300
Not that that's a useful comment, but that's what really lost me.

592
01:02:57,300 --> 01:02:59,300
I would agree on that.

593
01:02:59,300 --> 01:03:11,300
Did that answer your question?

594
01:03:11,300 --> 01:03:12,300
You had a question?

595
01:03:12,300 --> 01:03:15,300
Okay.

596
01:03:15,300 --> 01:03:19,300
Is anybody's mind fully shattered here?

597
01:03:19,300 --> 01:03:22,300
A little bit.

598
01:03:22,300 --> 01:03:28,300
I don't want to dwell too much on the exact implementation of that.

599
01:03:28,300 --> 01:03:36,300
I think maybe the interesting thing here is that we have bootstrapped ourselves out of nothing.

600
01:03:36,300 --> 01:03:42,300
This idea where it's like, oh, all you have is single argument functions and you have nothing else.

601
01:03:42,300 --> 01:03:45,300
All of a sudden we do math.

602
01:03:45,300 --> 01:03:50,300
We have not violated any rule here about any of the functions.

603
01:03:50,300 --> 01:03:52,300
It's like pure functions.

604
01:03:52,300 --> 01:03:54,300
It's like we have this behavior of math.

605
01:03:54,300 --> 01:04:03,300
The thing that's really unsettling about it is that it just feels like really, again, really, really abstract and strange.

606
01:04:03,300 --> 01:04:06,300
There is that.

607
01:04:06,300 --> 01:04:12,300
Yeah?

608
01:04:12,300 --> 01:04:14,300
Could it be rewritten with the add that was just made?

609
01:04:14,300 --> 01:04:16,300
It still breaks things because it has...

610
01:04:16,300 --> 01:04:28,300
The sole purpose of the incur function is for me to actually visualize what we have here because everything is basically a function.

611
01:04:28,300 --> 01:04:37,300
If I were to say something like mole four times three, it just comes back and it's like lambda.

612
01:04:37,300 --> 01:04:46,300
I have no way to visualize that as a number because what that is is it's like a behavior basically.

613
01:04:46,300 --> 01:04:51,300
That's a function that has the behavior of doing four times three.

614
01:04:51,300 --> 01:04:57,300
I can't view it unless I apply it to something.

615
01:04:57,300 --> 01:05:02,300
I have to do something with that to actually see the effect of it.

616
01:05:02,300 --> 01:05:06,300
The incur function is actually not needed.

617
01:05:06,300 --> 01:05:13,300
It's not really part of what we're doing, but I need it to actually just show you the result of the thing.

618
01:05:13,300 --> 01:05:19,300
Would it for this then make more sense to define a print function that just applies incur and zero?

619
01:05:19,300 --> 01:05:22,300
We could do that. Sure.

620
01:05:22,300 --> 01:05:29,300
We could do show and or something.

621
01:05:29,300 --> 01:05:31,300
Again, this is Python.

622
01:05:31,300 --> 01:05:38,300
We do not have a print statement in this lambda calculus world here, but this is just debugging only.

623
01:05:38,300 --> 01:05:40,300
You could do that.

624
01:05:40,300 --> 01:05:50,300
What would happen there is you could then show the last result just to debug it.

625
01:05:50,300 --> 01:06:01,300
It's really hard to debug this stuff if you're not on top of it.

626
01:06:01,300 --> 01:06:04,300
Try writing equality?

627
01:06:04,300 --> 01:06:07,300
We could try, but I would not be successful.

628
01:06:07,300 --> 01:06:18,300
It can be done, but we'll get to something similar to that.

629
01:06:18,300 --> 01:06:25,300
This is kind of interesting because when I look at what you've written there, which is multiply four and three,

630
01:06:25,300 --> 01:06:30,300
multiplication basically takes two arguments.

631
01:06:30,300 --> 01:06:37,300
You've written it as it takes single arguments, but my mind just drops the middle parenthesis and substitutes a comma there.

632
01:06:37,300 --> 01:06:40,300
Multiplication definitely seems to be a behavior to me.

633
01:06:40,300 --> 01:06:43,300
It's a little machine that turns some crank.

634
01:06:43,300 --> 01:06:47,300
Four and three represent numbers, which kind of feel like state.

635
01:06:47,300 --> 01:06:55,300
You've defined them earlier as behaviors, but it has to go back to zero, which is also actually a function.

636
01:06:55,300 --> 01:07:01,300
Zero itself is a function, but it's kind of the initial state starting point,

637
01:07:01,300 --> 01:07:11,300
of which InKr is then your kind of grounding machine.

638
01:07:11,300 --> 01:07:18,300
I'm seeing F here as a generate starting value thing where you're shoving InKr zero into that.

639
01:07:18,300 --> 01:07:21,300
If you just plugged zero into that, would it still work?

640
01:07:21,300 --> 01:07:25,300
Like here? Like that?

641
01:07:25,300 --> 01:07:28,300
No, I mean sorry, the numeral zero just for the debugging.

642
01:07:28,300 --> 01:07:32,300
Oh, that? It would blow up because it's not a function.

643
01:07:32,300 --> 01:07:38,300
If you did it, well I lost my...

644
01:07:38,300 --> 01:07:45,300
If I tried to do that, it blows up because it's basically trying to call that as a function.

645
01:07:45,300 --> 01:07:47,300
What about InKr of negative one?

646
01:07:47,300 --> 01:07:48,300
Same thing.

647
01:07:48,300 --> 01:07:51,300
Same thing? Okay.

648
01:07:51,300 --> 01:07:57,300
Actually, I don't want zero there.

649
01:07:57,300 --> 01:07:59,300
InKr. Yeah, InKr.

650
01:07:59,300 --> 01:08:03,300
All right, now I do want to do one little digression here.

651
01:08:03,300 --> 01:08:06,300
You're going to indulge me for a second here.

652
01:08:06,300 --> 01:08:11,300
This thing that we're doing with the numbers is a little weird.

653
01:08:11,300 --> 01:08:14,300
Well, maybe a lot weird actually.

654
01:08:14,300 --> 01:08:17,300
Where you have the chaining of operations like that.

655
01:08:17,300 --> 01:08:25,300
I was trying to think of some way to bring this back to Python in some capacity.

656
01:08:25,300 --> 01:08:33,300
One example that I was thinking about was maybe the JSON object from hell problem.

657
01:08:33,300 --> 01:08:36,300
Okay, probably people do stuff with the web, right?

658
01:08:36,300 --> 01:08:38,300
You get a lot of dictionaries.

659
01:08:38,300 --> 01:08:42,300
It's like dictionaries upon dictionaries and all this kind of stuff.

660
01:08:42,300 --> 01:08:48,300
What if you wrote a function, like you had a function like getC,

661
01:08:48,300 --> 01:08:50,300
where you gave me a dictionary,

662
01:08:50,300 --> 01:08:59,300
and then what you were trying to do is navigate down into that.

663
01:08:59,300 --> 01:09:00,300
Like that.

664
01:09:00,300 --> 01:09:02,300
GetC of data.

665
01:09:02,300 --> 01:09:08,300
Essentially, what it's doing is it's navigating down into nested dictionary.

666
01:09:08,300 --> 01:09:13,300
That thing that you're doing there is kind of the same as this function thing

667
01:09:13,300 --> 01:09:16,300
of repeated application of some operation, basically.

668
01:09:16,300 --> 01:09:19,300
You do the get on the outer dictionary, and then you take the result of that,

669
01:09:19,300 --> 01:09:27,300
you do the get on that, and you're kind of progressively going down into a bunch of dictionary.

670
01:09:27,300 --> 01:09:29,300
Do people see that?

671
01:09:29,300 --> 01:09:32,300
Yeah, question in the middle.

672
01:09:32,300 --> 01:09:36,300
I thought you said this wasn't going to be relevant for work.

673
01:09:36,300 --> 01:09:38,300
Oh, you'll see in a second.

674
01:09:38,300 --> 01:09:41,300
I'm going to make it irrelevant in a second here.

675
01:09:41,300 --> 01:09:45,300
So you have this chain.

676
01:09:45,300 --> 01:09:48,300
I've had code like this that you have to deal with.

677
01:09:48,300 --> 01:09:50,300
You have the chain dictionary thing.

678
01:09:50,300 --> 01:09:56,300
But one of the problems that you sometimes run into is that people give you malformed data.

679
01:09:56,300 --> 01:09:59,300
Maybe they just give it an empty dictionary or something,

680
01:09:59,300 --> 01:10:02,300
and then all of a sudden you start getting key errors all the way down.

681
01:10:02,300 --> 01:10:04,300
It's like, oh, okay.

682
01:10:04,300 --> 01:10:09,300
So I have this dictionary, but the item might be there or might not be there.

683
01:10:09,300 --> 01:10:17,300
And one of the things that you might do to fix that is to do a bunch of if statements

684
01:10:17,300 --> 01:10:20,300
or some crazy thing like this.

685
01:10:20,300 --> 01:10:22,300
I'm going to write something out.

686
01:10:22,300 --> 01:10:37,300
You're not going to like the code here.

687
01:10:37,300 --> 01:10:40,300
We're going to have a horrible code review later here.

688
01:10:40,300 --> 01:10:47,300
But you might write something like this where it's like, okay, I have this getC function.

689
01:10:47,300 --> 01:10:50,300
It will go down into a nested dictionary.

690
01:10:50,300 --> 01:10:53,300
But if you give me a dictionary that does not have the data in there,

691
01:10:53,300 --> 01:10:58,300
it's not going to blow up because it's using the get method.

692
01:10:58,300 --> 01:11:02,300
It's trying to basically play defense a little bit.

693
01:11:02,300 --> 01:11:07,300
Does everybody see that?

694
01:11:07,300 --> 01:11:08,300
Okay.

695
01:11:08,300 --> 01:11:16,300
What is your thought on this code that's in there?

696
01:11:16,300 --> 01:11:18,300
Yeah, D is not a good name.

697
01:11:18,300 --> 01:11:23,300
One thought is just this none check.

698
01:11:23,300 --> 01:11:25,300
Yeah, well, yeah, I'm assuming types.

699
01:11:25,300 --> 01:11:27,300
We should have gotten rid of those.

700
01:11:27,300 --> 01:11:29,300
Yeah, no, there's like assumption of types.

701
01:11:29,300 --> 01:11:34,300
But one thing that's a little weird is there's a lot of code repetition kind of going on here.

702
01:11:34,300 --> 01:11:39,300
It's like I do the if check and then I do the get.

703
01:11:39,300 --> 01:11:44,300
So I'm going to do a little trick on this.

704
01:11:44,300 --> 01:11:47,300
I'm going to write a function called perhaps.

705
01:11:47,300 --> 01:11:49,300
You're going to love this.

706
01:11:49,300 --> 01:11:54,300
Where you give me a D and a function like that.

707
01:11:54,300 --> 01:11:59,300
And then what I'm going to do is I'm going to check the D.

708
01:11:59,300 --> 01:12:06,300
Basically, if D is not none, then I'm going to return the function applied to D.

709
01:12:06,300 --> 01:12:09,300
And if it is, then I'll just return none back.

710
01:12:09,300 --> 01:12:14,300
So I'm going to write like a little helper function like that.

711
01:12:14,300 --> 01:12:17,300
And you're saying, where is Dave going with this exactly?

712
01:12:17,300 --> 01:12:20,300
Okay, so here's how this is going to work.

713
01:12:20,300 --> 01:12:24,300
You would basically say like perhaps data.

714
01:12:24,300 --> 01:12:26,300
And then you would give it a function.

715
01:12:26,300 --> 01:12:32,300
I'm going to use lambda here just because we've been doing lambda so much.

716
01:12:32,300 --> 01:12:33,300
We'll do that.

717
01:12:33,300 --> 01:12:36,300
So the idea is like you give me data and a function.

718
01:12:36,300 --> 01:12:43,300
And as long as the data is like a not none, like a dictionary or something, I'm going to call the function.

719
01:12:43,300 --> 01:12:53,300
If you were to try the same thing on like an empty dictionary, it just comes back with nothing.

720
01:12:53,300 --> 01:12:56,300
Where it's like, oh, well, the empty dictionary didn't, you know.

721
01:12:56,300 --> 01:13:02,300
Well, actually, it would have called this, but you're just getting like the none back.

722
01:13:02,300 --> 01:13:07,300
Okay, so I'm writing like this little perhaps function.

723
01:13:07,300 --> 01:13:11,300
And maybe I could start doing some chaining with that.

724
01:13:20,300 --> 01:13:22,300
You're not going to like this, but.

725
01:13:28,300 --> 01:13:32,300
Oh, the data is that.

726
01:13:32,300 --> 01:13:34,300
Okay.

727
01:13:35,300 --> 01:13:44,300
Doing this like crazy, this crazy kind of function where it's like you give me a piece of data and you give me a function.

728
01:13:44,300 --> 01:13:51,300
And it's basically it's like, well, I'll only call the function if the data looks good.

729
01:13:51,300 --> 01:13:56,300
Like if I can move forward, I'll try calling the function.

730
01:13:58,300 --> 01:14:00,300
And so you could start like chaining this stuff up.

731
01:14:00,300 --> 01:14:04,300
Now, this is where it's going to lose relevance for work.

732
01:14:04,300 --> 01:14:09,300
I mean, somebody made the comment, it's like, oh, I actually could use this at work until we started doing this.

733
01:14:09,300 --> 01:14:18,300
So, you know, maybe you've got this whole like chain of stuff going on.

734
01:14:23,300 --> 01:14:28,300
We're going to see if I can actually type that in.

735
01:14:28,300 --> 01:14:33,300
Okay, so this is like a totally different formulation of this thing.

736
01:14:33,300 --> 01:14:35,300
I've got this like perhaps function.

737
01:14:35,300 --> 01:14:38,300
And then I have this like this callback or something.

738
01:14:38,300 --> 01:14:40,300
And it's like it's just chaining the thing.

739
01:14:40,300 --> 01:14:42,300
It's kind of like what we're doing with the numbers, right?

740
01:14:42,300 --> 01:14:44,300
You know, like the F of F of F of F.

741
01:14:44,300 --> 01:14:47,300
Here it's like perhaps, perhaps, perhaps.

742
01:14:47,300 --> 01:14:48,300
It's actually like the song.

743
01:14:48,300 --> 01:14:50,300
I don't know whether people know the song.

744
01:14:50,300 --> 01:14:53,300
There's like a famous song where it's like perhaps, perhaps, perhaps.

745
01:14:53,300 --> 01:14:55,300
So you're doing that.

746
01:14:55,300 --> 01:15:00,300
You might look at that and just say, well, that is, that is completely nuts.

747
01:15:00,300 --> 01:15:03,300
Like, why would I type that in?

748
01:15:05,300 --> 01:15:08,300
I don't know how our heads here.

749
01:15:08,300 --> 01:15:13,300
I'm going to fix that by introducing a class.

750
01:15:22,300 --> 01:15:24,300
Classes are not part of the lambda calculus, by the way.

751
01:15:24,300 --> 01:15:25,300
This is a digression.

752
01:15:25,300 --> 01:15:27,300
Okay, so I'm going to introduce a class.

753
01:15:27,300 --> 01:15:33,300
And then as one does, we're going to do operator overloading.

754
01:15:35,300 --> 01:15:38,300
And we're going to do the check here.

755
01:15:50,300 --> 01:15:53,300
We're going to do a little bit of magic on it.

756
01:15:53,300 --> 01:15:58,300
What this is going to allow us to do, and let me pull the slide up a little bit here,

757
01:15:58,300 --> 01:16:01,300
is you're going to be able to do perhaps data

758
01:16:01,300 --> 01:16:05,300
and then start chaining it through a bunch of function.

759
01:16:05,300 --> 01:16:24,300
Oh, you get an object back.

760
01:16:24,300 --> 01:16:27,300
And then the value has the 42 in it.

761
01:16:27,300 --> 01:16:29,300
So you end up with that.

762
01:16:29,300 --> 01:16:32,300
There's going to be a quiz on this later.

763
01:16:32,300 --> 01:16:38,300
This is, in some sense, this is kind of an extension of the number idea.

764
01:16:38,300 --> 01:16:41,300
It's like you're turning the crank where it's like you're taking functions

765
01:16:41,300 --> 01:16:44,300
and you're applying a function one after the other,

766
01:16:44,300 --> 01:16:49,300
except that you've got this extra weird little check in there.

767
01:16:51,300 --> 01:16:52,300
It's a little weird.

768
01:16:52,300 --> 01:16:56,300
Probably job security would go up substantially pulling a stunt like that.

769
01:16:56,300 --> 01:17:01,300
And so the reason that I've done this, you're like, where is he going with this?

770
01:17:01,300 --> 01:17:11,300
I guess my only comment on this is that perhaps this is a monad.

771
01:17:11,300 --> 01:17:16,300
If you've ever heard that term kind of floated around by the functional programming people,

772
01:17:16,300 --> 01:17:20,300
it's very difficult to kind of pin down what it is.

773
01:17:20,300 --> 01:17:24,300
And this is an example of one.

774
01:17:24,300 --> 01:17:30,300
So if you've ever heard that, it's associated with like turning the crank on a lot of function composition

775
01:17:30,300 --> 01:17:34,300
and other things.

776
01:17:34,300 --> 01:17:40,300
I am carefully choosing my words here because anybody, yeah, perhaps this is an example of a monad.

777
01:17:40,300 --> 01:17:44,300
I've been very careful there because like any time anybody tries to define monad,

778
01:17:44,300 --> 01:17:48,300
they get like about a thousand people coming on Hacker News and pouncing on them to tell them how it's wrong.

779
01:17:48,300 --> 01:17:50,300
So I'm fully expecting that.

780
01:17:50,300 --> 01:17:55,300
But I'm choosing my words carefully here.

781
01:17:55,300 --> 01:18:00,300
Like if it ever comes up, if somebody says anything about monads, you could just say, oh, it's like the song.

782
01:18:00,300 --> 01:18:03,300
You know, the perhaps, perhaps, perhaps song.

783
01:18:03,300 --> 01:18:06,300
And then they'll probably get like even more angry.

784
01:18:06,300 --> 01:18:09,300
Who knows here.

785
01:18:09,300 --> 01:18:11,300
We do have to do the break in a second.

786
01:18:11,300 --> 01:18:13,300
So I'm going to we're going to do that.

787
01:18:13,300 --> 01:18:17,300
Can you repeat what you said that the API was that something takes what?

788
01:18:17,300 --> 01:18:22,300
A function and a number?

789
01:18:22,300 --> 01:18:24,300
For which part? The perhaps thing?

790
01:18:24,300 --> 01:18:27,300
No, no, no. I mean, just kind of earlier you said we had one basic API, right?

791
01:18:27,300 --> 01:18:30,300
Oh, for numbers. Yeah, numbers.

792
01:18:30,300 --> 01:18:33,300
It's always a function and a starting point.

793
01:18:33,300 --> 01:18:34,300
Function and starting point.

794
01:18:34,300 --> 01:18:39,300
Starting point, yeah.

795
01:18:39,300 --> 01:18:41,300
All right. We are going to do a break.

796
01:18:41,300 --> 01:18:45,300
When we come back, we're going to do it's going to get even more insane.

797
01:18:45,300 --> 01:18:51,300
Now, when we come back, we're actually going to talk about how to do something that looks like computation with this.

798
01:18:51,300 --> 01:18:55,300
Like, can you write things like recursion and loops and other other things?

799
01:18:55,300 --> 01:18:57,300
We have to build a little bit of stuff up for that.

800
01:18:57,300 --> 01:19:00,300
But let's do a break.

801
01:19:00,300 --> 01:19:03,300
So I think we're breaking until ten forty five.

802
01:19:03,300 --> 01:19:05,300
I think it's the end of the break.

803
01:19:15,300 --> 01:19:20,300
Thank you.

804
01:19:45,300 --> 01:19:50,300
Thank you.

805
01:20:15,300 --> 01:20:20,300
Thank you.

806
01:20:45,300 --> 01:20:50,300
Thank you.

807
01:21:15,300 --> 01:21:20,300
Thank you.

808
01:21:45,300 --> 01:21:50,300
Thank you.

809
01:22:15,300 --> 01:22:20,300
Thank you.

810
01:22:45,300 --> 01:22:50,300
Thank you.

811
01:23:15,300 --> 01:23:20,300
Thank you.

812
01:23:45,300 --> 01:23:50,300
Thank you.

813
01:24:15,300 --> 01:24:20,300
Thank you.

814
01:24:45,300 --> 01:24:50,300
Thank you.

815
01:25:15,300 --> 01:25:20,300
Thank you.

816
01:25:45,300 --> 01:25:50,300
Thank you.

817
01:26:15,300 --> 01:26:20,300
Thank you.

818
01:26:45,300 --> 01:26:50,300
Thank you.

819
01:27:15,300 --> 01:27:20,300
Thank you.

820
01:27:45,300 --> 01:27:50,300
Thank you.

821
01:28:15,300 --> 01:28:20,300
Thank you.

822
01:28:45,300 --> 01:28:50,300
Thank you.

823
01:29:15,300 --> 01:29:20,300
Thank you.

824
01:29:45,300 --> 01:29:50,300
Thank you.

825
01:30:15,300 --> 01:30:20,300
Thank you.

826
01:30:45,300 --> 01:30:50,300
Thank you.

827
01:31:15,300 --> 01:31:20,300
Thank you.

828
01:31:45,300 --> 01:31:50,300
Thank you.

829
01:32:15,300 --> 01:32:20,300
Thank you.

830
01:32:45,300 --> 01:32:50,300
Thank you.

831
01:33:15,300 --> 01:33:20,300
Thank you.

832
01:33:45,300 --> 01:33:50,300
Thank you.

833
01:34:15,300 --> 01:34:20,300
Thank you.

834
01:34:45,300 --> 01:34:50,300
Thank you.

835
01:35:15,300 --> 01:35:20,300
Thank you.

836
01:35:45,300 --> 01:35:50,300
Thank you.

837
01:36:15,300 --> 01:36:20,300
Thank you.

838
01:36:45,300 --> 01:36:50,300
Thank you.

839
01:37:15,300 --> 01:37:20,300
Thank you.

840
01:37:45,300 --> 01:37:50,300
Thank you.

841
01:38:15,300 --> 01:38:20,300
Thank you.

842
01:38:45,300 --> 01:38:50,300
Thank you.

843
01:39:15,300 --> 01:39:20,300
Thank you.

844
01:39:45,300 --> 01:39:50,300
Thank you.

845
01:40:15,300 --> 01:40:20,300
Thank you.

846
01:40:45,300 --> 01:40:50,300
Thank you.

847
01:41:15,300 --> 01:41:20,300
We'll get started in about three minutes here.

848
01:41:45,300 --> 01:41:50,300
Thank you.

849
01:42:15,300 --> 01:42:20,300
Thank you.

850
01:42:45,300 --> 01:42:50,300
We'll start in a second here.

851
01:42:50,300 --> 01:42:55,300
Everybody's ready for the post break quiz, right?

852
01:42:55,300 --> 01:43:00,300
Same thing.

853
01:43:00,300 --> 01:43:05,300
Everybody's ready for the post break quiz, right?

854
01:43:05,300 --> 01:43:10,300
Everybody's ready for the post break quiz, right?

855
01:43:10,300 --> 01:43:15,300
Okay.

856
01:43:15,300 --> 01:43:20,300
Okay.

857
01:43:20,300 --> 01:43:25,300
Okay.

858
01:43:25,300 --> 01:43:30,300
Okay.

859
01:43:30,300 --> 01:43:35,300
Okay.

860
01:43:35,300 --> 01:43:40,300
Okay.

861
01:43:40,300 --> 01:43:45,300
All right.

862
01:43:45,300 --> 01:43:50,300
I'm showing 1045, so I'm going to continue here.

863
01:43:50,300 --> 01:43:55,300
I've got a fair number of people back. That's good. Okay.

864
01:43:55,300 --> 01:44:00,300
What we're going to start with is I actually wanted to do a little bit of discussion

865
01:44:00,300 --> 01:44:05,300
about what we've been doing in the first part.

866
01:44:05,300 --> 01:44:10,300
The first thing that I actually wanted to talk about was function definitions a little bit.

867
01:44:10,300 --> 01:44:15,300
One thing that I kind of stepped you through in the first part of the class this morning is this idea of defining

868
01:44:15,300 --> 01:44:20,300
nested functions. We had the and function, which I think

869
01:44:20,300 --> 01:44:25,300
looked something like that.

870
01:44:25,300 --> 01:44:30,300
One of the things that I noticed is that some of this was actually getting shortened down.

871
01:44:30,300 --> 01:44:35,300
I was progressively using things like the lambda function instead.

872
01:44:35,300 --> 01:44:40,300
Instead of doing that, you could say, well, return a lambda function.

873
01:44:40,300 --> 01:44:45,300
Or you could write the whole thing basically as a lambda function.

874
01:44:45,300 --> 01:44:50,300
Like that. Basically, just sort of making it

875
01:44:50,300 --> 01:44:55,300
more compact.

876
01:44:55,300 --> 01:45:00,300
One thought that you can kind of explore is just what is the minimum notation

877
01:45:00,300 --> 01:45:05,300
to specify what I'm doing here?

878
01:45:05,300 --> 01:45:10,300
You're writing functions in different ways. The def format is what you're probably most familiar with as Python

879
01:45:10,300 --> 01:45:15,300
programmers, but then taking it down to lambdas, making it more and more compact.

880
01:45:15,300 --> 01:45:20,300
I started using the lambda character.

881
01:45:20,300 --> 01:45:25,300
You can start asking questions like, can you take it even further than that?

882
01:45:25,300 --> 01:45:30,300
The answer is yes.

883
01:45:30,300 --> 01:45:35,300
One of the things that you could do with this is you could look at parts of this where

884
01:45:35,300 --> 01:45:40,300
if you have two lambdas in a row like that, you could just write it as one.

885
01:45:45,300 --> 01:45:50,300
That's another syntax for it.

886
01:45:50,300 --> 01:45:55,300
You could also look at some of these things like these things at the end are basically

887
01:45:55,300 --> 01:46:00,300
chained function calls, like x is applied to y, is applied to x.

888
01:46:00,300 --> 01:46:05,300
You could just get rid of the parentheses.

889
01:46:05,300 --> 01:46:10,300
Then as a final step, you could just get rid of the colon too,

890
01:46:10,300 --> 01:46:15,300
because one dot is clearly easier to type than two dots.

891
01:46:15,300 --> 01:46:20,300
You could write the code like that.

892
01:46:20,300 --> 01:46:25,300
The reason that I'm showing you that is that's the syntax

893
01:46:25,300 --> 01:46:30,300
that you will see if you start reading papers about lambda calculus.

894
01:46:30,300 --> 01:46:35,300
They tend to use this very mathematical syntax. Essentially, all of these things are basically

895
01:46:35,300 --> 01:46:40,300
the same. This last thing, this is a function that takes

896
01:46:40,300 --> 01:46:45,300
two arguments, sort of one at a time. It's kind of hidden.

897
01:46:45,300 --> 01:46:50,300
It's applying x applied to y to apply to x. If you wanted to see the Python code for that,

898
01:46:50,300 --> 01:46:55,300
that's what it is. It's literally Python code that's doing that,

899
01:46:55,300 --> 01:47:00,300
but it's been written in a highly compact way.

900
01:47:00,300 --> 01:47:05,300
If you start looking at lambda calculus, you're going to see

901
01:47:05,300 --> 01:47:10,300
this kind of use of symbols basically.

902
01:47:10,300 --> 01:47:15,300
The question I have is pretty useless, but I think it's in the spirit of the whole

903
01:47:15,300 --> 01:47:20,300
exercise we're having. But it's great, by the way. I like it.

904
01:47:20,300 --> 01:47:25,300
Using the syntax, can x and y be more than one character, or that's a limit?

905
01:47:25,300 --> 01:47:30,300
Usually in the lambda calculus, the variables are one letter.

906
01:47:30,300 --> 01:47:35,300
Okay, so you only have like 26 or something like that?

907
01:47:35,300 --> 01:47:40,300
I think actually in the lambda's calculus paper,

908
01:47:40,300 --> 01:47:45,300
if you need more, you just put bars above it or something, or subscripts or something.

909
01:47:45,300 --> 01:47:50,300
It's a math paper, so they kind of go in the math thing. But as written, though,

910
01:47:50,300 --> 01:47:55,300
you only need 26 variables. You don't need more than that.

911
01:47:55,300 --> 01:48:00,300
So when I think of the word calculus, maybe this is an incorrect or incomplete

912
01:48:00,300 --> 01:48:05,300
kind of understanding of it, it's generally understood as the study of the rates of change.

913
01:48:05,300 --> 01:48:10,300
Is calculus in here meaning anything about rates of change, or what does the term

914
01:48:10,300 --> 01:48:15,300
calculus mean when they say it's in the calculus?

915
01:48:15,300 --> 01:48:20,300
It's nothing to do with calculus as you would have learned in high school or anything like that.

916
01:48:20,300 --> 01:48:25,300
But your question is actually onto something else. So part of what you have in this lambda calculus

917
01:48:25,300 --> 01:48:30,300
is a certain symbology, if you will, where it's like this is a way of writing a function.

918
01:48:30,300 --> 01:48:35,300
You have x and y are variables, and lambda means you have a function,

919
01:48:35,300 --> 01:48:40,300
and variables next to each other means that you're calling functions and so forth.

920
01:48:40,300 --> 01:48:45,300
So actually where the calculus part of it comes in is there are a bunch of conversions

921
01:48:45,300 --> 01:48:50,300
that take place on these lambda expressions. There's actually

922
01:48:50,300 --> 01:48:55,300
some things that you can do with functions.

923
01:48:55,300 --> 01:49:00,300
I'll kind of go through some of these rules. One rule

924
01:49:00,300 --> 01:49:05,300
is that you can rename an argument.

925
01:49:05,300 --> 01:49:10,300
Let me illustrate that. So let's say you had lambda x, y,

926
01:49:10,300 --> 01:49:15,300
x, y, x. You could, if you wanted to, just change one of the variables to some other name.

927
01:49:15,300 --> 01:49:20,300
This is something you can do in the IDE, right, in Python.

928
01:49:20,300 --> 01:49:25,300
It's like, oh, that was a dumb name for some variable. I'm just going to change the variable to some new name.

929
01:49:25,300 --> 01:49:30,300
You can do that. So that is one rule, is you can rename arguments.

930
01:49:30,300 --> 01:49:35,300
There is a caveat. You can't introduce a name clash.

931
01:49:35,300 --> 01:49:40,300
So if somebody was already using the variable z

932
01:49:40,300 --> 01:49:45,300
for some purpose, I can't just rename x to z.

933
01:49:45,300 --> 01:49:50,300
So you can rename things as long as you don't introduce a clash.

934
01:49:50,300 --> 01:49:55,300
This is something known as alpha conversion.

935
01:49:55,300 --> 01:50:00,300
If you kind of read papers on this.

936
01:50:00,300 --> 01:50:05,300
Another rule is that you can substitute

937
01:50:05,300 --> 01:50:10,300
argument.

938
01:50:10,300 --> 01:50:15,300
So let's say you had some lambda expression like this.

939
01:50:15,300 --> 01:50:20,300
And then you applied it to some value like

940
01:50:20,300 --> 01:50:25,300
a function call.

941
01:50:25,300 --> 01:50:30,300
Although it's obscured by all the lambdas and stuff.

942
01:50:30,300 --> 01:50:35,300
It's basically what you're doing is you're saying, okay, take all this stuff and now pass

943
01:50:35,300 --> 01:50:40,300
a, b into it. Basically what the substitution rule is saying is that you could take

944
01:50:40,300 --> 01:50:45,300
whatever is in the parentheses there and substitute it in for the x.

945
01:50:45,300 --> 01:50:50,300
So you could rewrite this basically saying, okay, this is lambda y

946
01:50:50,300 --> 01:50:55,300
and now I'm going to put the a, b in the place of wherever the x is,

947
01:50:55,300 --> 01:51:00,300
I'm going to put a, b in there.

948
01:51:00,300 --> 01:51:05,300
This is kind of the essence of a function call. If you apply a function to arguments,

949
01:51:05,300 --> 01:51:10,300
you can take the argument and you can stick it into the function.

950
01:51:10,300 --> 01:51:15,300
Yeah.

951
01:51:15,300 --> 01:51:20,300
Could we see the notation for multiply? I'm curious about the

952
01:51:20,300 --> 01:51:25,300
nested parameters. Do you have to keep the parentheses or what does that look like?

953
01:51:25,300 --> 01:51:30,300
So let's see, where was multiply here?

954
01:51:30,300 --> 01:51:35,300
I have it up.

955
01:51:35,300 --> 01:51:40,300
I think you actually do need the parentheses there.

956
01:51:40,300 --> 01:51:45,300
There is a notion of precedence. Sometimes you need to group things

957
01:51:45,300 --> 01:51:50,300
in a certain way and parentheses are still used to do that. So if you need to group things

958
01:51:50,300 --> 01:51:55,300
in a certain way.

959
01:51:55,300 --> 01:52:00,300
So the parentheses do actually have significance.

960
01:52:00,300 --> 01:52:05,300
You said it was lambda y, but where does that first y come from?

961
01:52:05,300 --> 01:52:10,300
So the y, this is where this thing gets really confusing.

962
01:52:10,300 --> 01:52:15,300
Here there is only a single argument, which is the a, b.

963
01:52:15,300 --> 01:52:20,300
And it turns out that the a, b went in as the argument x.

964
01:52:20,300 --> 01:52:25,300
And because it only went into the x, the y is

965
01:52:25,300 --> 01:52:30,300
remaining. There is a remaining argument y that needs to be provided.

966
01:52:30,300 --> 01:52:35,300
If you had a second thing out here like z, then that would become

967
01:52:35,300 --> 01:52:40,300
what you would have is the y would basically go away and you would have the z.

968
01:52:40,300 --> 01:52:45,300
So the reason that was

969
01:52:45,300 --> 01:52:50,300
basically a lambda y there is I only gave one of the argument.

970
01:52:50,300 --> 01:52:55,300
I don't want to dwell on this too much, like the

971
01:52:55,300 --> 01:53:00,300
substitution thing, but the gist of the idea here is that you can basically

972
01:53:00,300 --> 01:53:05,300
substitute the arguments. It's like you literally take the argument and you just paste it

973
01:53:05,300 --> 01:53:10,300
into the thing. There is also a caveat on that

974
01:53:10,300 --> 01:53:15,300
that you can't introduce name clashes

975
01:53:15,300 --> 01:53:20,300
also with that. Here is kind of a weird example. Let's say you had

976
01:53:20,300 --> 01:53:25,300
lambda x, y, x, y, x and then you decided to pass in

977
01:53:25,300 --> 01:53:30,300
x, y into that.

978
01:53:30,300 --> 01:53:35,300
This is like a really mind bending thing because it's like is

979
01:53:35,300 --> 01:53:40,300
that x, y the same as the x, y that's in the function?

980
01:53:40,300 --> 01:53:45,300
Let me give you a python example of this. Let's say you had a function like

981
01:53:45,300 --> 01:53:50,300
f of x, y like that. Maybe

982
01:53:50,300 --> 01:53:55,300
2 times x plus y or something. We're in the python world.

983
01:53:55,300 --> 01:54:00,300
Let's say you had an outer x and an outer y

984
01:54:00,300 --> 01:54:05,300
like that. It's basically scoping issues. Is the outer x

985
01:54:05,300 --> 01:54:10,300
the same as the x in that function?

986
01:54:10,300 --> 01:54:15,300
No, because it's like x was basically an argument that got passed in.

987
01:54:15,300 --> 01:54:20,300
The global x's and the local x's are different.

988
01:54:20,300 --> 01:54:25,300
That is the same thing that's happening here. If I have a

989
01:54:25,300 --> 01:54:30,300
function that takes x and y as an argument and does something with it,

990
01:54:30,300 --> 01:54:35,300
any x, y that's outside, that's actually a different x, y.

991
01:54:35,300 --> 01:54:40,300
You can actually run into really weird problems with that.

992
01:54:40,300 --> 01:54:45,300
Actually maybe a different example of that. Let's say I were just to pass in y

993
01:54:45,300 --> 01:54:50,300
there. This does not get reduced to lambda y, y, y, y.

994
01:54:50,300 --> 01:54:55,300
It's like no.

995
01:54:55,300 --> 01:55:00,300
The only way that you can actually fix that is you have to

996
01:55:00,300 --> 01:55:05,300
rename one of the variables. That's actually what the first rule is about. If you want to do that,

997
01:55:05,300 --> 01:55:10,300
you would have to rename one of the variables and then you could

998
01:55:10,300 --> 01:55:15,300
do the thing.

999
01:55:15,300 --> 01:55:20,300
Like that. Again, I don't want to totally dwell

1000
01:55:20,300 --> 01:55:25,300
on that. But that's another... This is getting back to your question. How's the calculus

1001
01:55:25,300 --> 01:55:30,300
coming into this? This is sort of it. You have this symbology

1002
01:55:30,300 --> 01:55:35,300
here where you have these lambda expressions and you can replace variables and you can

1003
01:55:35,300 --> 01:55:40,300
substitute things. One of the other things that you can do...

1004
01:55:40,300 --> 01:55:45,300
Let me just tell you what this is. This is like beta reduction is what this is called.

1005
01:55:45,300 --> 01:55:50,300
Oh,

1006
01:55:50,300 --> 01:55:55,300
yeah, yeah, yeah.

1007
01:55:55,300 --> 01:56:00,300
Good catch there.

1008
01:56:00,300 --> 01:56:05,300
The debugging is always a little difficult on that.

1009
01:56:05,300 --> 01:56:10,300
You have rules like that. There is another rule that is...

1010
01:56:10,300 --> 01:56:15,300
I'll do kind of a simple example of it.

1011
01:56:15,300 --> 01:56:20,300
One rule is that you can

1012
01:56:20,300 --> 01:56:25,300
make a function. Let's say you had this x equals 3 just sitting there in your

1013
01:56:25,300 --> 01:56:30,300
Python program or you really wanted to annoy people with it, like at work or something.

1014
01:56:30,300 --> 01:56:35,300
You could take that and just turn it into a lambda function

1015
01:56:35,300 --> 01:56:40,300
that just had 3 passed into it.

1016
01:56:40,300 --> 01:56:45,300
I don't know why you would necessarily do that.

1017
01:56:45,300 --> 01:56:50,300
You could just say, oh, I'm going to make a function and then I'll pass in the argument as the value of the

1018
01:56:50,300 --> 01:56:55,300
function. You're going to end up basically back where you started.

1019
01:56:55,300 --> 01:57:00,300
Think of it as gratuitous obfuscation or something. That's another thing that you can do with this

1020
01:57:00,300 --> 01:57:05,300
is introduce functions or introduce a variable and so forth.

1021
01:57:05,300 --> 01:57:10,300
If you look at some of the papers on some of this stuff,

1022
01:57:10,300 --> 01:57:15,300
they actually talk about these substitutions. This is a slide

1023
01:57:15,300 --> 01:57:20,300
from the Lambda Calculus book from 1941.

1024
01:57:20,300 --> 01:57:25,300
He's talking about these rules. You can replace parts of formulas

1025
01:57:25,300 --> 01:57:30,300
with name substitutions. It's talking about basically symbol replacement,

1026
01:57:30,300 --> 01:57:35,300
like substitutions and so forth. One of the reasons why

1027
01:57:35,300 --> 01:57:40,300
this is talking about this is where is it going exactly? You have this

1028
01:57:40,300 --> 01:57:45,300
weird symbolic system and these rules for replacing things.

1029
01:57:45,300 --> 01:57:50,300
In the early 20th century, there was a lot of discussion about the nature

1030
01:57:50,300 --> 01:57:55,300
of math. Specifically, could all of mathematics

1031
01:57:55,300 --> 01:58:00,300
be derived solely from symbolic

1032
01:58:00,300 --> 01:58:05,300
manipulation? If you had the proper set of axioms

1033
01:58:05,300 --> 01:58:10,300
expressed in symbols, could you derive all of mathematical truth

1034
01:58:10,300 --> 01:58:15,300
from that representation? There's a whole school of formalism in math.

1035
01:58:15,300 --> 01:58:20,300
Formal systems and axioms and all this stuff. David Hilbert was one of

1036
01:58:20,300 --> 01:58:25,300
the main figures at the center of a lot of that. Basically,

1037
01:58:25,300 --> 01:58:30,300
posing questions, it's like, can you decide any math problem

1038
01:58:30,300 --> 01:58:35,300
by just turning the crank on a symbol manipulator?

1039
01:58:35,300 --> 01:58:40,300
No creativity at all. If you had the right set of axioms

1040
01:58:40,300 --> 01:58:45,300
because you just turned the crank and proved stuff by turning the crank, would you eventually

1041
01:58:45,300 --> 01:58:50,300
get to mathematical truth from that? There's a whole lot of

1042
01:58:50,300 --> 01:58:55,300
stuff that came out of that work. One question

1043
01:58:55,300 --> 01:59:00,300
that got posed, it is this question, can all of math be derived from

1044
01:59:00,300 --> 01:59:05,300
a formal system? If you had a statement from logic, this is

1045
01:59:05,300 --> 01:59:10,300
kind of a statement of a problem. If you had a statement from first order logic, could you write an algorithm

1046
01:59:10,300 --> 01:59:15,300
that would just tell you yes or no whether that statement was true or not?

1047
01:59:15,300 --> 01:59:20,300
It's kind of an interesting idea. It's like, wow, that'd be kind of cool.

1048
01:59:20,300 --> 01:59:25,300
If you just specify a problem and then it's like Star Trek or something. Like, computer, tell me if it's

1049
01:59:25,300 --> 01:59:30,300
true or not. That would be awesome. It's kind of posing

1050
01:59:30,300 --> 01:59:35,300
that question. Is there an algorithm to do that?

1051
01:59:35,300 --> 01:59:40,300
The short answer is no. There's a whole bunch of stuff that came out of the

1052
01:59:40,300 --> 01:59:45,300
1920s and 30s. One thing that came out was the incompleteness

1053
01:59:45,300 --> 01:59:50,300
theorem. Kurt Gödel probably butchered the pronunciation on that.

1054
01:59:50,300 --> 01:59:55,300
There was a result saying that you could not prove statements about arithmetic

1055
01:59:55,300 --> 02:00:00,300
within a formal system. That kind of came out. The lambda calculus

1056
02:00:00,300 --> 02:00:05,300
early 1930s was kind of in that same school

1057
02:00:05,300 --> 02:00:10,300
as well, basically proving that you could not have an axiomatic system or you could

1058
02:00:10,300 --> 02:00:15,300
prove these statements. All the stuff that we've been doing kind of emerged

1059
02:00:15,300 --> 02:00:20,300
out of that. You can still buy the book.

1060
02:00:20,300 --> 02:00:25,300
This is the Calculia of Lambda Conversion. It's kind of interesting to look at, but this is from 1941

1061
02:00:25,300 --> 02:00:30,300
by Alonzo Church. It kind of talks about that.

1062
02:00:30,300 --> 02:00:35,300
A lot of what's actually being talked about is just how do you mathematically

1063
02:00:35,300 --> 02:00:40,300
describe the ability to calculate something?

1064
02:00:40,300 --> 02:00:45,300
How do you mathematically describe an algorithm? That's kind of like a really

1065
02:00:45,300 --> 02:00:50,300
weird kind of problem. We all know what an algorithm is. It's like a

1066
02:00:50,300 --> 02:00:55,300
step-by-step process, but how would you mathematically

1067
02:00:55,300 --> 02:01:00,300
formulate that? In some sense, the lambda calculus is really about that.

1068
02:01:00,300 --> 02:01:05,300
Some other figures at this time, by the way, you have Turing. There's Turing

1069
02:01:05,300 --> 02:01:10,300
machines also around 1936. One of the big results is proving that Turing

1070
02:01:10,300 --> 02:01:15,300
machines and lambda calculus are equivalent to each other. I'm not going to go further

1071
02:01:15,300 --> 02:01:20,300
into that, but just trying to put some historical context to sort of when

1072
02:01:20,300 --> 02:01:25,300
this took place and what they were thinking about. A lot of it was this thinking about

1073
02:01:25,300 --> 02:01:30,300
math. Can you prove all of math through algorithms? The things are basically

1074
02:01:30,300 --> 02:01:35,300
showing that you could not. That's kind of some interesting history

1075
02:01:35,300 --> 02:01:40,300
on it. Where we're going to pick up with it here is

1076
02:01:40,300 --> 02:01:45,300
talking about programming. About 20 years later,

1077
02:01:45,300 --> 02:01:50,300
you have the creation of Lisp programming. I think 1960

1078
02:01:50,300 --> 02:01:55,300
is when Lisp came out. In the start of the tutorial, it kind of mentions

1079
02:01:55,300 --> 02:02:00,300
like, well, everybody calls it lambda because Lisp called it lambda.

1080
02:02:00,300 --> 02:02:05,300
If you read the paper on Lisp, it's kind of like, why do they call it lambda?

1081
02:02:05,300 --> 02:02:10,300
What are they thinking about? As far as I can tell,

1082
02:02:10,300 --> 02:02:15,300
the only real influence possibly is the notation of the

1083
02:02:15,300 --> 02:02:20,300
lambda. The lambda calculus paper actually is cited in the

1084
02:02:20,300 --> 02:02:25,300
Lisp paper, but it's kind of cited in this way where it's like, well, we're going to use

1085
02:02:25,300 --> 02:02:30,300
the lambda notation to define functions because there's some convenient features

1086
02:02:30,300 --> 02:02:35,300
of that. The actual Lisp paper is actually talking more about AI.

1087
02:02:35,300 --> 02:02:40,300
They're trying to build a system for AI programming or some other thing.

1088
02:02:40,300 --> 02:02:45,300
I was not able to see any other mention of the lambda calculus

1089
02:02:45,300 --> 02:02:50,300
in the Lisp paper, but they're kind of borrowing the notation for it.

1090
02:02:50,300 --> 02:02:55,300
It looks like they're doing a slightly different thing with the notation because they're passing two arguments

1091
02:02:55,300 --> 02:03:00,300
into the...they just kind of went their own way with it.

1092
02:03:00,300 --> 02:03:05,300
What you can do in Lisp, like Lisp, you can write functions with multiple arguments.

1093
02:03:05,300 --> 02:03:10,300
They're thinking of lambda as a convenient way to encode functions and what are known as

1094
02:03:10,300 --> 02:03:15,300
S expressions and other things. The notation is sort of coming from lambda calculus,

1095
02:03:15,300 --> 02:03:20,300
but it doesn't seem like much else is actually coming from...like Lisp is not doing all this

1096
02:03:20,300 --> 02:03:25,300
crazy number stuff and encoding things in that way.

1097
02:03:25,300 --> 02:03:30,300
It's sort of an interesting connection there.

1098
02:03:30,300 --> 02:03:35,300
Lisp in some way is kind of an interesting jumping off point

1099
02:03:35,300 --> 02:03:40,300
for what we're going to do next because one of the things in Lisp that was very focused on was

1100
02:03:40,300 --> 02:03:45,300
Lisp processing. That's the whole name of the language. Lisp is short for

1101
02:03:45,300 --> 02:03:50,300
Lisp processing. One question that we sort of run into

1102
02:03:50,300 --> 02:03:55,300
is in this lambda calculus world, is there any way

1103
02:03:55,300 --> 02:04:00,300
to actually build a data structure? Let's say you wanted to do

1104
02:04:00,300 --> 02:04:05,300
lists. How in the world are you going to do

1105
02:04:05,300 --> 02:04:10,300
lists? Is there any way to make a tuple or a pair

1106
02:04:10,300 --> 02:04:15,300
or anything? In the Lisp world, there are some

1107
02:04:15,300 --> 02:04:20,300
functions for building data structures. There's basically a function cons,

1108
02:04:20,300 --> 02:04:25,300
which essentially builds a pairing of data.

1109
02:04:25,300 --> 02:04:30,300
There's a function car that gives you the thing on the left, and then there's a

1110
02:04:30,300 --> 02:04:35,300
function cutter, which gives you the thing on the right. The names, by the way, are taken from the IBM

1111
02:04:35,300 --> 02:04:40,300
704 hardware on which the Lisp was first implemented.

1112
02:04:40,300 --> 02:04:45,300
Those function names are kind of weird, but there's this

1113
02:04:45,300 --> 02:04:50,300
question. Could you build a data structure entirely out of a

1114
02:04:50,300 --> 02:04:55,300
function definition? The answer is

1115
02:04:55,300 --> 02:05:00,300
you can. I'm going to do this in Python in kind of a weird way to start.

1116
02:05:00,300 --> 02:05:05,300
Let's say you wrote a function like cons

1117
02:05:05,300 --> 02:05:10,300
av. One way that you could build a data structure is you

1118
02:05:10,300 --> 02:05:15,300
could define an inner function. I'm just going to call it select.

1119
02:05:15,300 --> 02:05:20,300
You pass in an argument, and then you just check the argument.

1120
02:05:20,300 --> 02:05:25,300
If it's zero, you return a, and if it's one, you return

1121
02:05:25,300 --> 02:05:30,300
b. Then you just return that

1122
02:05:30,300 --> 02:05:35,300
function back. It looks a little hacky and weird, but

1123
02:05:35,300 --> 02:05:40,300
it actually works. You could say p is equal to cons two, three,

1124
02:05:40,300 --> 02:05:45,300
and it comes back, and it's like, well, here's this function.

1125
02:05:45,300 --> 02:05:50,300
Then you would call the function with zero or one to get the data that you want.

1126
02:05:50,300 --> 02:05:55,300
You can do it.

1127
02:05:55,300 --> 02:06:00,300
You could write car as basically returning p of zero,

1128
02:06:00,300 --> 02:06:05,300
and you could write cutter of p returning

1129
02:06:05,300 --> 02:06:10,300
p of one. Don't do this at work. This would be a terrible thing.

1130
02:06:10,300 --> 02:06:15,300
Your coworkers would sort of hate seeing this sort of thing, but

1131
02:06:15,300 --> 02:06:20,300
it's kind of remarkable in a way where it's like actually it is kind of like a data

1132
02:06:20,300 --> 02:06:25,300
structure just totally from function definition.

1133
02:06:25,300 --> 02:06:30,300
I'm not using a tuple or anything there. It's like here's a function.

1134
02:06:30,300 --> 02:06:35,300
It's got this weird selector thing in the middle of it.

1135
02:06:35,300 --> 02:06:40,300
Everybody kind of see that?

1136
02:06:40,300 --> 02:06:45,300
Now where I'm going with this, you're saying, okay, where's he going with this?

1137
02:06:45,300 --> 02:06:50,300
Didn't we do a selector thing at the start of the morning?

1138
02:06:50,300 --> 02:06:55,300
Yeah, the switch thing. We just did that. We did the

1139
02:06:55,300 --> 02:07:00,300
switch thing. Maybe that's

1140
02:07:00,300 --> 02:07:05,300
how we build a data structure. Instead of doing this cons thing like that,

1141
02:07:05,300 --> 02:07:10,300
maybe we can do it using kind of the lambda thing.

1142
02:07:10,300 --> 02:07:15,300
Let me pull up the slide a little bit. We're going to have a function that takes in

1143
02:07:15,300 --> 02:07:20,300
two arguments, and then we're going to define a function

1144
02:07:20,300 --> 02:07:25,300
that's kind of like our selector here. We're going to have our argument s,

1145
02:07:25,300 --> 02:07:30,300
and then we're just going to use it to select the two arguments.

1146
02:07:30,300 --> 02:07:35,300
Now you're looking at that saying there's no way that can work.

1147
02:07:35,300 --> 02:07:40,300
If I say cons two, three, it comes back and it's like, ah, this is

1148
02:07:40,300 --> 02:07:45,300
horrible lambda function. The way that you're supposed to use that

1149
02:07:45,300 --> 02:07:50,300
is you would pass in like maybe true or false or something. If I said P of true,

1150
02:07:50,300 --> 02:07:55,300
it comes back and it picks the two out. Remember that

1151
02:07:55,300 --> 02:08:00,300
true is the thing that picked the first argument. True is going to pick out the A,

1152
02:08:00,300 --> 02:08:05,300
and false is going to pick out the three.

1153
02:08:05,300 --> 02:08:10,300
I don't know.

1154
02:08:10,300 --> 02:08:15,300
Is that crazy or not?

1155
02:08:15,300 --> 02:08:20,300
You can do that.

1156
02:08:20,300 --> 02:08:25,300
You basically have a data structure.

1157
02:08:25,300 --> 02:08:30,300
Keep in mind that two and three are not part of this, but I'm just using it for

1158
02:08:30,300 --> 02:08:35,300
illustration here. You can say cars P.

1159
02:08:35,300 --> 02:08:40,300
You could use your numbers here. We're not really using the arguments.

1160
02:08:40,300 --> 02:08:45,300
We're just storing the argument.

1161
02:08:45,300 --> 02:08:50,300
I'll give you a second to type that in there.

1162
02:08:50,300 --> 02:08:55,300
I think this is actually a really mind blowing idea where it's like

1163
02:08:55,300 --> 02:09:00,300
a function and can build it just from a function you can create a data structure.

1164
02:09:00,300 --> 02:09:05,300
Sort of out of nothingness. It's like this is not a

1165
02:09:05,300 --> 02:09:10,300
list. It's not a list. I'm not storing any kind of data and any sort of thing

1166
02:09:10,300 --> 02:09:15,300
that you would recognize, but it's just pure function.

1167
02:09:15,300 --> 02:09:20,300
Although we could link them together.

1168
02:09:20,300 --> 02:09:25,300
If you wanted to make a linked list or something,

1169
02:09:25,300 --> 02:09:30,300
you could do cons of two or three or something.

1170
02:09:30,300 --> 02:09:35,300
A question about language.

1171
02:09:35,300 --> 02:09:40,300
I don't know in the papers what terms they use. Maybe they use lambda or something.

1172
02:09:40,300 --> 02:09:45,300
Do you know when the term function got introduced or how that came about?

1173
02:09:45,300 --> 02:09:50,300
I have no idea. Function has been used in math forever.

1174
02:09:50,300 --> 02:09:55,300
I'm not sure of the history on that.

1175
02:09:55,300 --> 02:10:00,300
I think one of the interesting things here is when I think in a beginning

1176
02:10:00,300 --> 02:10:05,300
programming class, if they talk about a function, they'll often refer to it as a machine.

1177
02:10:05,300 --> 02:10:10,300
They'll draw it as a little box with some robot arms or something.

1178
02:10:10,300 --> 02:10:15,300
I think back to this time,

1179
02:10:15,300 --> 02:10:20,300
they were working with more machinery than what we have now.

1180
02:10:20,300 --> 02:10:25,300
I don't know how language comes about and constructs these metaphors

1181
02:10:25,300 --> 02:10:30,300
which we think about these problems with.

1182
02:10:30,300 --> 02:10:35,300
You're actually on to something interesting.

1183
02:10:35,300 --> 02:10:40,300
In the paper about lambda calculus, one of the things that he talks about is

1184
02:10:40,300 --> 02:10:45,300
what is a function exactly?

1185
02:10:45,300 --> 02:10:50,300
It's a function that you pass it in and it produces some output.

1186
02:10:50,300 --> 02:10:55,300
He leaves it totally as that.

1187
02:10:55,300 --> 02:11:00,300
There's an argument and you place it and some output comes out.

1188
02:11:00,300 --> 02:11:05,300
One thing that he actually talks about is, keep in mind, they're trying to prove

1189
02:11:05,300 --> 02:11:10,300
all of mathematics. They're thinking about way more than numbers.

1190
02:11:10,300 --> 02:11:15,300
In math class, you often think of, you have a function and you pass it two and then you get four out of it.

1191
02:11:15,300 --> 02:11:20,300
One of the things in the paper is he talks about things from the actual calculus.

1192
02:11:20,300 --> 02:11:25,300
Let's say you have a function and you want to compute the derivative of a function.

1193
02:11:25,300 --> 02:11:30,300
That's a function. There would be a higher order function

1194
02:11:30,300 --> 02:11:35,300
where a function comes in and it figures out what the derivative function is

1195
02:11:35,300 --> 02:11:40,300
and the derivative comes out.

1196
02:11:40,300 --> 02:11:45,300
They're thinking about functions in this really generic way where something comes in, something comes out,

1197
02:11:45,300 --> 02:11:50,300
and it can describe everything. If you want to do numbers, that's fine. If you want to do functions, that's fine.

1198
02:11:50,300 --> 02:11:55,300
It's very, very

1199
02:11:55,300 --> 02:12:00,300
weirdly generic.

1200
02:12:00,300 --> 02:12:05,300
Have you ever got this data thing up here?

1201
02:12:05,300 --> 02:12:10,300
I always find this deeply weird.

1202
02:12:10,300 --> 02:12:15,300
The first time I saw this, I was like, no way. Wait, what?

1203
02:12:15,300 --> 02:12:20,300
Building a data structure out of a function like that?

1204
02:12:20,300 --> 02:12:25,300
One of the reasons why I'm having you do this, by the way,

1205
02:12:25,300 --> 02:12:30,300
is because you're doing this in a way that's not really a function.

1206
02:12:30,300 --> 02:12:35,300
How do you get the previous number?

1207
02:12:35,300 --> 02:12:40,300
What in the world could this possibly have to do with pairs or data structures?

1208
02:12:40,300 --> 02:12:45,300
One thing that I forget, I think you might have asked it,

1209
02:12:45,300 --> 02:12:50,300
how do you get from the one number to the previous number?

1210
02:12:50,300 --> 02:12:55,300
How would you get two out of that?

1211
02:12:55,300 --> 02:13:00,300
You're on the right track, actually.

1212
02:13:00,300 --> 02:13:05,300
Maybe not the successor function, but one approach for this,

1213
02:13:05,300 --> 02:13:10,300
and this is a total hack, by the way, is you could

1214
02:13:10,300 --> 02:13:15,300
start with 0, 0 as a pair, and then you

1215
02:13:15,300 --> 02:13:20,300
could ratchet your way up to 3.

1216
02:13:20,300 --> 02:13:25,300
You could essentially say, I'm going to go up to 3.

1217
02:13:25,300 --> 02:13:30,300
But as I go, I'm building pairs.

1218
02:13:30,300 --> 02:13:35,300
The first thing in the pair is the number, and the second thing in the pair is the previous number.

1219
02:13:35,300 --> 02:13:40,300
Maybe I could use that

1220
02:13:40,300 --> 02:13:45,300
to figure out how to get the predecessor number.

1221
02:13:45,300 --> 02:13:50,300
I actually already kind of

1222
02:13:50,300 --> 02:13:55,300
did an example of that. I had this weird tuple thing. I don't know whether you remember that.

1223
02:13:55,300 --> 02:14:00,300
I'm not even sure it's in my environment here.

1224
02:14:00,300 --> 02:14:05,300
I had this weird tuple thing. Well, I'll type it in again.

1225
02:14:05,300 --> 02:14:10,300
I had this function, maybe I'll call it T,

1226
02:14:10,300 --> 02:14:15,300
where I had this weird thing where I was making a tuple

1227
02:14:15,300 --> 02:14:20,300
where I did like this.

1228
02:14:20,300 --> 02:14:25,300
Then I did some weird thing where it's like, take three applications of T

1229
02:14:25,300 --> 02:14:30,300
and then apply it to the tuple 0, 0.

1230
02:14:30,300 --> 02:14:35,300
What this thing is doing is this T function, if you make

1231
02:14:35,300 --> 02:14:40,300
a tuple, there's your tuple, and then you apply it to A, it basically

1232
02:14:40,300 --> 02:14:45,300
ratchets its way up

1233
02:14:45,300 --> 02:14:50,300
up through the numbers.

1234
02:14:50,300 --> 02:14:55,300
Maybe I could do something like that. We're in the Python world right now, but

1235
02:14:55,300 --> 02:15:00,300
maybe you could do something along that line.

1236
02:15:00,300 --> 02:15:05,300
Metaphorically, this feels like if you have a crank and it's always turning right,

1237
02:15:05,300 --> 02:15:10,300
you just turn that crank upside down and now you have a left turning crank. We actually don't care that these things are 0s or 1s.

1238
02:15:10,300 --> 02:15:15,300
We just care that the arm is turning in a certain direction.

1239
02:15:15,300 --> 02:15:20,300
It seems like it's easy to get hung up on the fact that there's 0, and 0 kind of means something to us as people.

1240
02:15:20,300 --> 02:15:25,300
The negative number somewhat means something. In a very strictly mechanical sense,

1241
02:15:25,300 --> 02:15:30,300
you're just performing these actions. It's a right turn or it's a left turn, and that's really all it is.

1242
02:15:30,300 --> 02:15:35,300
You have to figure out how to inverse this.

1243
02:15:35,300 --> 02:15:40,300
This isn't even really reversing the direction. It's turning the crank on something that produces something a little bit different.

1244
02:15:40,300 --> 02:15:45,300
What we're going to do with this is

1245
02:15:45,300 --> 02:15:50,300
we could take that t function and turn it into

1246
02:15:50,300 --> 02:15:55,300
actually, let me do it with the lambda here.

1247
02:15:55,300 --> 02:16:00,300
We could do this in the lambda calculus. We could write this function t where it's like,

1248
02:16:00,300 --> 02:16:05,300
give me a pair, and then I'm going to do exactly what's up there.

1249
02:16:05,300 --> 02:16:10,300
I'm going to basically say I'm going to do a cons. That's the act of making the tubal.

1250
02:16:10,300 --> 02:16:15,300
The first element of the cons is basically the successor of the car, the P.

1251
02:16:15,300 --> 02:16:20,300
I'll try to say that a couple of times.

1252
02:16:20,300 --> 02:16:25,300
The first item is basically, the car is the leftmost one.

1253
02:16:25,300 --> 02:16:30,300
The first one, yeah.

1254
02:16:30,300 --> 02:16:35,300
I think that will work. We could write something like that.

1255
02:16:35,300 --> 02:16:40,300
It's basically doing the same thing as the other function.

1256
02:16:40,300 --> 02:16:45,300
It's just written in using our terminology here.

1257
02:16:45,300 --> 02:16:50,300
P0 is basically, that's the car.

1258
02:16:50,300 --> 02:16:55,300
Plus 1 is the successor of that. Then P0 is the car again.

1259
02:16:55,300 --> 02:17:00,300
You could write a function like that.

1260
02:17:00,300 --> 02:17:05,300
You could write a function like that.

1261
02:17:05,300 --> 02:17:10,300
If I were to take one of my numbers, like 4, and apply it to t,

1262
02:17:10,300 --> 02:17:15,300
and then apply it to a starting point,

1263
02:17:15,300 --> 02:17:20,300
like that,

1264
02:17:20,300 --> 02:17:25,300
this is exactly the same thing that I was doing with the Python thing above.

1265
02:17:25,300 --> 02:17:30,300
Let me save it here. You're like, well, what is that? It's basically a pair.

1266
02:17:30,300 --> 02:17:35,300
If I were to look at the first thing in the pair,

1267
02:17:35,300 --> 02:17:40,300
and then apply it to my anchor function or something, it comes back and says,

1268
02:17:40,300 --> 02:17:45,300
well, that's 4. It basically ratcheted its way up this sequence of pairs.

1269
02:17:45,300 --> 02:17:50,300
Then the second one is the previous number.

1270
02:17:50,300 --> 02:17:55,300
Question here.

1271
02:17:55,300 --> 02:18:00,300
I anticipate this is the next thing you're going to say,

1272
02:18:00,300 --> 02:18:05,300
but that means we're only storing one previous.

1273
02:18:05,300 --> 02:18:10,300
Sure, we can go back to this previous one that we stored, but we still can't undo function calls.

1274
02:18:10,300 --> 02:18:15,300
We can go back to zero all the time,

1275
02:18:15,300 --> 02:18:20,300
or you have to count from zero every time.

1276
02:18:20,300 --> 02:18:25,300
This is a horribly impractical way to do this.

1277
02:18:25,300 --> 02:18:30,300
If you wanted to get the previous number to 10,000 or something,

1278
02:18:30,300 --> 02:18:35,300
we've got to do 10,000 function calls to get up to 10,000, and then we go back one and throw it out.

1279
02:18:35,300 --> 02:18:40,300
The way the predecessor works is you basically take a number,

1280
02:18:40,300 --> 02:18:45,300
so here's your number n, and you're going to apply that number to this t function,

1281
02:18:45,300 --> 02:18:50,300
which means you're going to ratchet your way up.

1282
02:18:50,300 --> 02:18:55,300
You're going to work your way up, and then when you're done with the whole thing,

1283
02:18:55,300 --> 02:19:00,300
you just discard it and you take the cutter of it. Whatever the second number is that will give you that.

1284
02:19:00,300 --> 02:19:05,300
It feels wildly impractical because my brain has already

1285
02:19:05,300 --> 02:19:10,300
abstracted away the fact that a number is all of the calls from zero up to that number anyway.

1286
02:19:10,300 --> 02:19:15,300
That's why my brain was...

1287
02:19:15,300 --> 02:19:20,300
If I've done that right, this should work.

1288
02:19:20,300 --> 02:19:25,300
We had this example where we did four applied to three.

1289
02:19:25,300 --> 02:19:30,300
I don't know whether you remember that. We got this crazy result where it's like, oh, that's 81.

1290
02:19:30,300 --> 02:19:35,300
It was like doing exponentiation. If this predecessor thing is working,

1291
02:19:35,300 --> 02:19:40,300
I should be able to say B is the predecessor of A, and the predecessor

1292
02:19:40,300 --> 02:19:45,300
of A better be 80 unless I've done something wrong here, which it's possible that I have.

1293
02:19:45,300 --> 02:19:50,300
Oh, I think t needs to have...

1294
02:19:50,300 --> 02:19:55,300
You need to apply t to 0, 0.

1295
02:19:55,300 --> 02:20:00,300
Let's...

1296
02:20:00,300 --> 02:20:05,300
And apply it to t.

1297
02:20:05,300 --> 02:20:10,300
Apply it to t.

1298
02:20:10,300 --> 02:20:15,300
Let's try it out here.

1299
02:20:15,300 --> 02:20:20,300
80.

1300
02:20:20,300 --> 02:20:25,300
80.

1301
02:20:25,300 --> 02:20:30,300
This is just mind-blowing.

1302
02:20:30,300 --> 02:20:35,300
Again, it's wildly impractical. You would never in a programming language,

1303
02:20:35,300 --> 02:20:40,300
if you wanted to get to the previous number, you're not going to count up to the number

1304
02:20:40,300 --> 02:20:45,300
back one. Why would you do that?

1305
02:20:45,300 --> 02:20:50,300
In some sense, you're seeing... This is the more mathematical side of this thing.

1306
02:20:50,300 --> 02:20:55,300
If you're just talking about pure math, it all exists in this

1307
02:20:55,300 --> 02:21:00,300
world of infinite abstraction. This is not an implementation so much,

1308
02:21:00,300 --> 02:21:05,300
but it's a way of showing that you can get to the previous number

1309
02:21:05,300 --> 02:21:10,300
if you need to.

1310
02:21:10,300 --> 02:21:15,300
Yeah.

1311
02:21:15,300 --> 02:21:20,300
Is this kind of similar to async programming in that you define a behavior and then at the very bottom you shove an event loop into it

1312
02:21:20,300 --> 02:21:25,300
and then let the magic work?

1313
02:21:25,300 --> 02:21:30,300
You think it needs an await in there somewhere?

1314
02:21:30,300 --> 02:21:35,300
I'm going to run it over to the language summit, which is taking place down the hall.

1315
02:21:35,300 --> 02:21:40,300
Okay.

1316
02:21:40,300 --> 02:21:45,300
Do people have that entered? Do I need to leave the code up there for a second?

1317
02:21:45,300 --> 02:21:50,300
I do think that's kind of an ingenious hack, actually.

1318
02:21:50,300 --> 02:21:55,300
It's like how do I get the previous number? It's like basically making a bunch of pairs

1319
02:21:55,300 --> 02:22:00,300
and then you just store the number in the previous number and then you toss

1320
02:22:00,300 --> 02:22:05,300
the first number away. I'm not sure I would have thought of that.

1321
02:22:05,300 --> 02:22:10,300
If I had just given a blank slate, you'd say, give me the previous number.

1322
02:22:10,300 --> 02:22:15,300
I'm not that sure that would have come to mind.

1323
02:22:15,300 --> 02:22:20,300
What is a pair? Is a pair like a state change? State one is the left-hand side and state two is the right-hand side?

1324
02:22:20,300 --> 02:22:25,300
I know that it's two things.

1325
02:22:25,300 --> 02:22:30,300
It's like a pair of two values and it's a function

1326
02:22:30,300 --> 02:22:35,300
where you pass it a function to select one of the two values.

1327
02:22:35,300 --> 02:22:40,300
Everything is a function.

1328
02:22:40,300 --> 02:22:45,300
I don't know.

1329
02:22:45,300 --> 02:22:50,300
I'll leave that up for a second there.

1330
02:22:50,300 --> 02:22:55,300
I forget who asked about equality, but

1331
02:22:55,300 --> 02:23:00,300
that is actually kind of a next step for this thing.

1332
02:23:00,300 --> 02:23:05,300
We're kind of building up some machinery here. We do have the ability to go down

1333
02:23:05,300 --> 02:23:10,300
now. Oh, you could implement subtraction, by the way.

1334
02:23:10,300 --> 02:23:15,300
I should do subtraction.

1335
02:23:15,300 --> 02:23:20,300
Subtraction turns out to be fairly easy.

1336
02:23:20,300 --> 02:23:25,300
If I want to take five and subtract three or subtract two from it,

1337
02:23:25,300 --> 02:23:30,300
how do you do that? You apply the predecessor function two times to five.

1338
02:23:30,300 --> 02:23:35,300
If I wanted to subtract y from x,

1339
02:23:35,300 --> 02:23:40,300
you would just do y applications of predecessor to x.

1340
02:23:40,300 --> 02:23:45,300
Let's just make sure that works there.

1341
02:23:45,300 --> 02:23:50,300
Yeah, it's like once you can get to the one number before,

1342
02:23:50,300 --> 02:23:55,300
then the way that subtraction is, it's like

1343
02:23:55,300 --> 02:24:00,300
you just do that. So, I'm going to do that.

1344
02:24:00,300 --> 02:24:05,300
If you can test a number for

1345
02:24:05,300 --> 02:24:10,300
zero, this allows you to start

1346
02:24:10,300 --> 02:24:15,300
checking things. Why would you want to test a number for

1347
02:24:15,300 --> 02:24:20,300
zero? If you can start doing tests,

1348
02:24:20,300 --> 02:24:25,300
you can start checking things.

1349
02:24:25,300 --> 02:24:30,300
Why would you want to test a number for zero? If you can start doing tests,

1350
02:24:30,300 --> 02:24:35,300
then maybe you could start thinking about control flow.

1351
02:24:35,300 --> 02:24:40,300
If statements. How does an if statement work?

1352
02:24:40,300 --> 02:24:45,300
You have an if, and then you test something, and then you pick one of two branches.

1353
02:24:45,300 --> 02:24:50,300
That would be an interesting feature to have

1354
02:24:50,300 --> 02:24:55,300
if we're going to do programming.

1355
02:24:55,300 --> 02:25:00,300
The next challenge here is how would you test a number

1356
02:25:00,300 --> 02:25:05,300
to see whether it's zero or not?

1357
02:25:05,300 --> 02:25:10,300
Let me give you a hint on this.

1358
02:25:10,300 --> 02:25:15,300
Keep in mind that a number, like if I have the number two,

1359
02:25:15,300 --> 02:25:20,300
it was basically that.

1360
02:25:20,300 --> 02:25:25,300
The number zero

1361
02:25:25,300 --> 02:25:30,300
was that.

1362
02:25:30,300 --> 02:25:35,300
Numbers are always going to take two inputs there.

1363
02:25:35,300 --> 02:25:40,300
Do you have a question on that?

1364
02:25:40,300 --> 02:25:45,300
Keep in mind numbers, they always have these two inputs. There's always an F, there's always an X.

1365
02:25:45,300 --> 02:25:50,300
If N is a number, then it's a function that has these two inputs. It has an F and an X.

1366
02:25:50,300 --> 02:25:55,300
How would I make that return true

1367
02:25:55,300 --> 02:26:00,300
if N is zero?

1368
02:26:10,300 --> 02:26:15,300
A little hint on it.

1369
02:26:15,300 --> 02:26:20,300
The behavior of zero

1370
02:26:20,300 --> 02:26:25,300
is that it always returns the X.

1371
02:26:25,300 --> 02:26:30,300
If you have zero, it just universally returns the X.

1372
02:26:30,300 --> 02:26:35,300
I'm going to do that, my is zero check.

1373
02:26:35,300 --> 02:26:40,300
If N is a number and it's zero, I'm just going to return true

1374
02:26:40,300 --> 02:26:45,300
because that's what I'm trying to test. If it's zero, it's true.

1375
02:26:45,300 --> 02:26:50,300
If N is zero, that is definitely going to return true.

1376
02:26:50,300 --> 02:26:55,300
The question is

1377
02:26:55,300 --> 02:27:00,300
what do you put here?

1378
02:27:00,300 --> 02:27:05,300
You're very close.

1379
02:27:05,300 --> 02:27:10,300
The thing that's going to go here

1380
02:27:10,300 --> 02:27:15,300
is you can make a function that just always returns false.

1381
02:27:15,300 --> 02:27:20,300
Keep in mind the second argument

1382
02:27:20,300 --> 02:27:25,300
or the first argument to a number has to be a function.

1383
02:27:25,300 --> 02:27:30,300
This is a function that takes an argument, but we just totally disregard the argument.

1384
02:27:30,300 --> 02:27:35,300
We just always return false. It turns out that that

1385
02:27:35,300 --> 02:27:40,300
works. If we do is zero, zero, it comes back as true.

1386
02:27:40,300 --> 02:27:45,300
If we do is zero, one,

1387
02:27:45,300 --> 02:27:50,300
it comes back as false. It always comes back as false for the other

1388
02:27:50,300 --> 02:27:55,300
number. Essentially what's happening with that is the zero is kind of like a special case

1389
02:27:55,300 --> 02:28:00,300
where the function is actually never called. This false function

1390
02:28:00,300 --> 02:28:05,300
just never gets executed. Instead you get true back.

1391
02:28:05,300 --> 02:28:10,300
If you have any other number, then this thing gets called and it's like, well, that's just always false.

1392
02:28:10,300 --> 02:28:15,300
Just a

1393
02:28:15,300 --> 02:28:20,300
realization of something that I found my brain doing

1394
02:28:20,300 --> 02:28:25,300
that might help somebody else is sometimes you use

1395
02:28:25,300 --> 02:28:30,300
F. I'm used to thinking F as a function. Yes, in this case it's going to be a function,

1396
02:28:30,300 --> 02:28:35,300
but it's not the name of the function, it's actually the argument.

1397
02:28:35,300 --> 02:28:40,300
The lambda F in the middle with the false is not

1398
02:28:40,300 --> 02:28:45,300
the function. It's accepting an argument.

1399
02:28:45,300 --> 02:28:50,300
It could be anything. It could be X, it could be G.

1400
02:28:50,300 --> 02:28:55,300
F has special meaning in my brain and I keep conflating it in weird ways.

1401
02:28:55,300 --> 02:29:00,300
The fact that everything is a function here is just

1402
02:29:00,300 --> 02:29:05,300
mind blowing.

1403
02:29:05,300 --> 02:29:10,300
I'll leave that up for a few minutes here.

1404
02:29:10,300 --> 02:29:15,300
Oh,

1405
02:29:15,300 --> 02:29:20,300
I don't know.

1406
02:29:20,300 --> 02:29:25,300
Like if I said is zero is zero?

1407
02:29:25,300 --> 02:29:30,300
I'm not sure what that is going to do.

1408
02:29:30,300 --> 02:29:35,300
Well, it comes back as true, but I'm not exactly sure what to make of it.

1409
02:29:35,300 --> 02:29:40,300
As a Python programmer, I'll just say

1410
02:29:40,300 --> 02:29:45,300
that's some kind of duck typing thing and I'm not sure what that is.

1411
02:29:45,300 --> 02:29:50,300
It works, but you don't know why and what the answer is.

1412
02:29:50,300 --> 02:29:55,300
Technically not true. Maybe it's a type error.

1413
02:29:55,300 --> 02:30:00,300
Where this is going?

1414
02:30:00,300 --> 02:30:05,300
Think about what we've got. We've got Boolean logic,

1415
02:30:05,300 --> 02:30:10,300
we've got add and subtract, we've got multiply,

1416
02:30:10,300 --> 02:30:15,300
we have the ability to do data, we have the cons thing.

1417
02:30:15,300 --> 02:30:20,300
What we have built is a weird assembly code of function.

1418
02:30:20,300 --> 02:30:25,300
It's pure functions, but think of it as maybe an instruction set or something.

1419
02:30:25,300 --> 02:30:30,300
We have all these things you can do and, or not, suck,

1420
02:30:30,300 --> 02:30:35,300
you've got all of this stuff

1421
02:30:35,300 --> 02:30:40,300
and it's kind of like machine code

1422
02:30:40,300 --> 02:30:45,300
in a way. It's a very strange kind of machine code

1423
02:30:45,300 --> 02:30:50,300
in that it's so abstract. It's just purely in this world of functions

1424
02:30:50,300 --> 02:30:55,300
where it exists, but if you have that,

1425
02:30:55,300 --> 02:31:00,300
maybe you can start doing more interesting things like writing recursive functions

1426
02:31:00,300 --> 02:31:05,300
and other things. Maybe a challenge here

1427
02:31:05,300 --> 02:31:10,300
could you implement a factorial function?

1428
02:31:10,300 --> 02:31:15,300
I'll do it in kind of a normal Python way first.

1429
02:31:25,300 --> 02:31:30,300
Could you implement that? This is a function that's like turning the crank,

1430
02:31:30,300 --> 02:31:35,300
it's actually doing kind of interesting stuff. Can that be implemented

1431
02:31:35,300 --> 02:31:40,300
using the assembly language that we had on the

1432
02:31:40,300 --> 02:31:45,300
previous thing? Let's actually try that out.

1433
02:31:45,300 --> 02:31:50,300
Here's how it's going to work.

1434
02:31:50,300 --> 02:31:55,300
The argument to fact is n. That's going to be the argument

1435
02:31:55,300 --> 02:32:00,300
to our function. We're going to take a number. What is the very first thing

1436
02:32:00,300 --> 02:32:05,300
that you're doing in the function? You're doing an

1437
02:32:05,300 --> 02:32:10,300
is zero check. We're going to do a check, is zero of n.

1438
02:32:10,300 --> 02:32:15,300
What is that going to return, by the way?

1439
02:32:15,300 --> 02:32:20,300
It's going to return true or false. What do true and false do?

1440
02:32:20,300 --> 02:32:25,300
They pick values out. I'm going to

1441
02:32:25,300 --> 02:32:30,300
break this across multiple lines, but true and false

1442
02:32:30,300 --> 02:32:35,300
kind of act like an if statement.

1443
02:32:35,300 --> 02:32:40,300
True, you have two values, A and B. You pick one of them.

1444
02:32:40,300 --> 02:32:45,300
That's what's going to happen here.

1445
02:32:45,300 --> 02:32:50,300
What is the true part of it? One.

1446
02:32:50,300 --> 02:32:55,300
What is the false part of it?

1447
02:32:55,300 --> 02:33:00,300
If it's not zero, then we're doing like a multiply.

1448
02:33:00,300 --> 02:33:05,300
We have a multiply operator where we're going to multiply n

1449
02:33:05,300 --> 02:33:10,300
by fact by the predecessor of n.

1450
02:33:10,300 --> 02:33:15,300
There's a fair number of parentheses there.

1451
02:33:15,300 --> 02:33:20,300
Make sure it's not a syntax error.

1452
02:33:20,300 --> 02:33:25,300
It's kind of a, admittedly, it's a little tough to

1453
02:33:25,300 --> 02:33:30,300
wrap one's brain around that, but it's almost a literal translation of the Python code

1454
02:33:30,300 --> 02:33:35,300
into this kind of low level machine code.

1455
02:33:35,300 --> 02:33:40,300
If it's zero, if it is, we're going to return one. If it's not, we're going to multiply n by

1456
02:33:40,300 --> 02:33:45,300
factorial of n minus one, or the predecessor of n.

1457
02:33:45,300 --> 02:33:50,300
Anybody get that to work?

1458
02:33:50,300 --> 02:33:55,300
Anybody get that to work?

1459
02:33:55,300 --> 02:34:00,300
Yeah.

1460
02:34:00,300 --> 02:34:05,300
Yeah.

1461
02:34:05,300 --> 02:34:10,300
Yeah.

1462
02:34:10,300 --> 02:34:15,300
Yeah.

1463
02:34:15,300 --> 02:34:20,300
Yeah.

1464
02:34:20,300 --> 02:34:25,300
It's kind of like the, I don't know, like one of these battle scenes

1465
02:34:25,300 --> 02:34:30,300
where the evil villain dies and the whole evil army dies at the same time.

1466
02:34:30,300 --> 02:34:35,300
We've kind of worked up to this point now that the whole thing just blows up in infinite

1467
02:34:35,300 --> 02:34:40,300
recursion. It's like totally disappointing.

1468
02:34:40,300 --> 02:34:45,300
So if you do that, do people get the maximum recursion thing?

1469
02:34:45,300 --> 02:34:50,300
What's going on with that?

1470
02:34:50,300 --> 02:34:55,300
We have definitely invented a loop, but

1471
02:34:55,300 --> 02:35:00,300
it has run away from us.

1472
02:35:00,300 --> 02:35:05,300
The, the,

1473
02:35:05,300 --> 02:35:10,300
the,

1474
02:35:10,300 --> 02:35:15,300
no.

1475
02:35:15,300 --> 02:35:20,300
Increasing the recursion depth will not help this.

1476
02:35:20,300 --> 02:35:25,300
The basic problem here is that we are using a highly inferior programming language called

1477
02:35:25,300 --> 02:35:30,300
Python. No, I say that facetiously.

1478
02:35:30,300 --> 02:35:35,300
I don't know why this is blowing up.

1479
02:35:35,300 --> 02:35:40,300
If I, let's say I have a function f of x and I return like three times x plus one.

1480
02:35:40,300 --> 02:35:45,300
If I say f of like two plus ten, how does that work exactly?

1481
02:35:45,300 --> 02:35:50,300
It does the argument first

1482
02:35:50,300 --> 02:35:55,300
and then it calls the function. Like basically Python evaluates arguments

1483
02:35:55,300 --> 02:36:00,300
like so if like, you know, like the arg goes first

1484
02:36:00,300 --> 02:36:05,300
and essentially what we have done in Python is we have written a function

1485
02:36:05,300 --> 02:36:10,300
that is kind of like an if statement. I mean for lack of a better description,

1486
02:36:10,300 --> 02:36:15,300
we've written a function like choose a, b

1487
02:36:15,300 --> 02:36:20,300
where we have a, like we have a test. Like we have something that looks like

1488
02:36:20,300 --> 02:36:25,300
this. Like if t return a, else return b.

1489
02:36:25,300 --> 02:36:30,300
That is kind of what's going on with like the true and false basically

1490
02:36:30,300 --> 02:36:35,300
or the is zero test in a sense. We're basically saying like, like imagine like

1491
02:36:35,300 --> 02:36:40,300
let's say you have like a is two and b is three. We've written a function where it's like

1492
02:36:40,300 --> 02:36:45,300
okay choose, like if a less than b, choose a otherwise b. We've written

1493
02:36:45,300 --> 02:36:50,300
like a conditional essentially. And the problem with that

1494
02:36:50,300 --> 02:36:55,300
is that that, you can't do that. Like here's an example of how you can't

1495
02:36:55,300 --> 02:37:00,300
do that. Like let's say I decided to choose, like choose a

1496
02:37:00,300 --> 02:37:05,300
not equal to zero, a one divided by a.

1497
02:37:05,300 --> 02:37:10,300
Like that's right.

1498
02:37:10,300 --> 02:37:15,300
Like let's say you've written, wrote a function like that. It's basically going to

1499
02:37:15,300 --> 02:37:20,300
blow up because it's actually trying to do both of the arguments at the same time.

1500
02:37:20,300 --> 02:37:25,300
I mean like in that function it's basically saying oh I'm doing the a and I'm

1501
02:37:25,300 --> 02:37:30,300
doing the one divided by a at the same time. And like it just like

1502
02:37:30,300 --> 02:37:35,300
explodes. Essentially it doesn't know what to do. That is not

1503
02:37:35,300 --> 02:37:40,300
how control flow works in most languages. Like if I were to write this out using like a

1504
02:37:40,300 --> 02:37:45,300
like an if statement in Python, like a if a not equal to zero else one divided by a.

1505
02:37:45,300 --> 02:37:50,300
Oh maybe it should be equal to zero.

1506
02:37:50,300 --> 02:37:55,300
Let's try that. That does not blow up.

1507
02:37:55,300 --> 02:38:00,300
Whereas my other one does.

1508
02:38:00,300 --> 02:38:05,300
The reason that this one doesn't blow up is that Python is smart enough to not go

1509
02:38:05,300 --> 02:38:10,300
down the else. Like it basically does the check first and then it decides

1510
02:38:10,300 --> 02:38:15,300
like I'm going to do one or the other. And that is what is killing

1511
02:38:15,300 --> 02:38:20,300
our code up here is that when you do these functions like the one

1512
02:38:20,300 --> 02:38:25,300
and the multiply, it's basically doing both. Like it goes down both paths.

1513
02:38:25,300 --> 02:38:30,300
And it turns out that the second path just explodes in infinite recursion.

1514
02:38:30,300 --> 02:38:35,300
Essentially it has to do with Python like

1515
02:38:35,300 --> 02:38:40,300
eagerly evaluating arguments. It's like it always wants to evaluate arguments.

1516
02:38:40,300 --> 02:38:45,300
So it's like running away with the calculation.

1517
02:38:45,300 --> 02:38:50,300
Yes. But not in the way that you might think.

1518
02:38:50,300 --> 02:38:55,300
So the solution to this is actually

1519
02:38:55,300 --> 02:39:00,300
yeah you can turn that off but the question is how do you do that?

1520
02:39:00,300 --> 02:39:05,300
Let me go to the interactive example here.

1521
02:39:05,300 --> 02:39:10,300
So let's say you wanted to turn off one divided by a.

1522
02:39:10,300 --> 02:39:15,300
This is the thing that has the zero division. So let's say you wanted to get rid of that.

1523
02:39:15,300 --> 02:39:20,300
How would you not do that? Well one of the ways that you would not do it

1524
02:39:20,300 --> 02:39:25,300
is you could shove it into like a zero argument function.

1525
02:39:25,300 --> 02:39:30,300
Like you could just say f is lambda. Like no arguments.

1526
02:39:30,300 --> 02:39:35,300
And then you put the one divided by a in there. You're like

1527
02:39:35,300 --> 02:39:40,300
what did that do exactly? Well what you're doing there is you're basically delaying the calculation

1528
02:39:40,300 --> 02:39:45,300
to some later point in time. Like if I want to do that

1529
02:39:45,300 --> 02:39:50,300
then I could put parentheses on it and I could let the thing fire basically.

1530
02:39:50,300 --> 02:39:55,300
And it turns out that you could do that with like this choose function.

1531
02:39:55,300 --> 02:40:00,300
Like you could say choose t a b. If t

1532
02:40:00,300 --> 02:40:05,300
return a per n. Keep in mind this is a really subtle

1533
02:40:05,300 --> 02:40:10,300
change here.

1534
02:40:10,300 --> 02:40:15,300
Like you're evaluating only if the thing is needed essentially. So what you would

1535
02:40:15,300 --> 02:40:20,300
do with that is you could say choose a equals zero

1536
02:40:20,300 --> 02:40:25,300
and then you would shove like basically lambdas into this thing.

1537
02:40:25,300 --> 02:40:30,300
Oh I need to have like my thing there.

1538
02:40:30,300 --> 02:40:35,300
That is

1539
02:40:35,300 --> 02:40:40,300
admittedly a little

1540
02:40:40,300 --> 02:40:45,300
weird. It's basically addressing like a problem with Python.

1541
02:40:45,300 --> 02:40:50,300
I mean Python wants to like eagerly do all the arguments. What we're doing with this lambda

1542
02:40:50,300 --> 02:40:55,300
trick is we're basically pulling it back from the brink essentially saying like okay note

1543
02:40:55,300 --> 02:41:00,300
the arguments basically are functions and I'm only going to

1544
02:41:00,300 --> 02:41:05,300
evaluate that function if I need to go down that branch. That is essentially what's happening.

1545
02:41:05,300 --> 02:41:10,300
So there's a question in the back there.

1546
02:41:10,300 --> 02:41:15,300
Everything is more sane doing it the way

1547
02:41:15,300 --> 02:41:20,300
Python does it. I think most programmers like when you call a function you like

1548
02:41:20,300 --> 02:41:25,300
to have the arguments evaluated. So almost every programming

1549
02:41:25,300 --> 02:41:30,300
language works in the way that Python does.

1550
02:41:30,300 --> 02:41:35,300
Yeah it's like if all the evaluation gets delayed

1551
02:41:35,300 --> 02:41:40,300
then everything just gets crazy. I mean it's like

1552
02:41:40,300 --> 02:41:45,300
just being a

1553
02:41:45,300 --> 02:41:50,300
yeah. No you would not do this.

1554
02:41:50,300 --> 02:41:55,300
I mean this is sort of illustrating. You're kind of getting into like this

1555
02:41:55,300 --> 02:42:00,300
evaluation issue with Python. Like how do things happen?

1556
02:42:00,300 --> 02:42:05,300
And it turns out that it blows up what we've done with the lambda calculus because

1557
02:42:05,300 --> 02:42:10,300
this factorial thing is not working because it's basically

1558
02:42:10,300 --> 02:42:15,300
evaluating like both branches kind of at the same time and it's like exploding.

1559
02:42:15,300 --> 02:42:20,300
Now we can fix it. Now I will just preface this

1560
02:42:20,300 --> 02:42:25,300
as saying that this is mainly required because of Python.

1561
02:42:25,300 --> 02:42:30,300
You know basically the

1562
02:42:30,300 --> 02:42:35,300
eager evaluation. One way that I can fix this is I can essentially

1563
02:42:35,300 --> 02:42:40,300
implement like a different implementation of true and false.

1564
02:42:40,300 --> 02:42:45,300
I apologize for doing this but

1565
02:42:45,300 --> 02:42:50,300
the way that you can redo it is you're going to introduce a function call.

1566
02:43:05,300 --> 02:43:10,300
Like that. And then I'm also going to have to redo the

1567
02:43:10,300 --> 02:43:15,300
zero function.

1568
02:43:15,300 --> 02:43:20,300
So I'm going to have to

1569
02:43:20,300 --> 02:43:25,300
I'm basically going to have to introduce

1570
02:43:25,300 --> 02:43:30,300
like this extra function call in there.

1571
02:43:30,300 --> 02:43:35,300
And then in this fact thing I'm going to have to do this like lambda trick.

1572
02:43:35,300 --> 02:43:40,300
I'm not super happy about doing this. This is really not part of the

1573
02:43:40,300 --> 02:43:45,300
lambda calculus that we're doing here. This is purely a hack

1574
02:43:45,300 --> 02:43:50,300
to get Python to not do both branches of that, of the if basically.

1575
02:43:50,300 --> 02:43:55,300
So I can make it work but I've got to do this like patch up.

1576
02:44:00,300 --> 02:44:05,300
I'll give you a few

1577
02:44:05,300 --> 02:44:10,300
moments to kind of type that in.

1578
02:44:10,300 --> 02:44:15,300
So if you do that it's going to work.

1579
02:44:15,300 --> 02:44:20,300
Actually this concept of when things evaluate

1580
02:44:20,300 --> 02:44:25,300
is actually a really big deal in functional programming. I mean if you get into some of these other languages like

1581
02:44:25,300 --> 02:44:30,300
Pascal and all sorts of stuff they focus a lot on this. Like when do things evaluate?

1582
02:44:30,300 --> 02:44:35,300
Is it evaluated lazily? Does it evaluate eagerly?

1583
02:44:35,300 --> 02:44:40,300
When do things happen? And we're kind of facing that.

1584
02:44:40,300 --> 02:44:45,300
Again having to work around some limitations of Python and that

1585
02:44:45,300 --> 02:44:50,300
it does not allow this kind of lazy evaluation.

1586
02:44:50,300 --> 02:44:55,300
I don't know.

1587
02:44:55,300 --> 02:45:00,300
Do you have a question, Yarco?

1588
02:45:00,300 --> 02:45:05,300
Are you doing

1589
02:45:05,300 --> 02:45:10,300
a swag bag? Like promotion?

1590
02:45:10,300 --> 02:45:15,300
Okay.

1591
02:45:15,300 --> 02:45:20,300
Yeah, it looks

1592
02:45:20,300 --> 02:45:25,300
at the end of this tutorial it's like Thelma and Louise or something. I'm running away and then like

1593
02:45:25,300 --> 02:45:30,300
all that. Did anybody get that to work?

1594
02:45:30,300 --> 02:45:35,300
It's pretty mind blowing. It's like wow.

1595
02:45:35,300 --> 02:45:40,300
Recursion here.

1596
02:45:40,300 --> 02:45:45,300
Do you just get around that by having a dummy argument basically?

1597
02:45:45,300 --> 02:45:50,300
I've had to break it here

1598
02:45:50,300 --> 02:45:55,300
and actually you could put a dummy argument in there

1599
02:45:55,300 --> 02:46:00,300
but I'm not sure that it adds clarity actually. I was actually thinking about

1600
02:46:00,300 --> 02:46:05,300
this in the preparation of this tutorial because it's like if you add

1601
02:46:05,300 --> 02:46:10,300
a dummy argument then I have to put something in here.

1602
02:46:10,300 --> 02:46:15,300
I mean like I could just pass like some dumb

1603
02:46:15,300 --> 02:46:20,300
it breaks it in spirit. No, you could make it work by just

1604
02:46:20,300 --> 02:46:25,300
passing a dummy argument. I kind of felt honestly in prepping

1605
02:46:25,300 --> 02:46:30,300
I sort of felt like this is already a hack to kind of deal with Python.

1606
02:46:30,300 --> 02:46:35,300
And it's not just leaving it as just a zero argument. Just acknowledge that

1607
02:46:35,300 --> 02:46:40,300
okay this is a Python specific hack that we have to do.

1608
02:46:40,300 --> 02:46:45,300
It's a little unfortunate. I mean it's like normally in the lambda calculus you would not need to do this

1609
02:46:45,300 --> 02:46:50,300
because it's not like the lambda calculus doesn't specify like an evaluation order.

1610
02:46:50,300 --> 02:46:55,300
So like mathematically it's not needed but it's like a purely Python

1611
02:46:55,300 --> 02:47:00,300
required thing here.

1612
02:47:00,300 --> 02:47:05,300
I would just argue that it's not a Python requirement. It's a programming

1613
02:47:05,300 --> 02:47:10,300
requirement right? Because like I said most programming languages would do this right?

1614
02:47:10,300 --> 02:47:15,300
Python does have a few things that it does that makes it weird compared to other languages. This is not one of them.

1615
02:47:15,300 --> 02:47:20,300
No, like you would have to do this in C or you'd have to do this in Scheme or Lisp.

1616
02:47:20,300 --> 02:47:25,300
The only place you probably would not have to, well not the only place, but you wouldn't have to do this in Haskell

1617
02:47:25,300 --> 02:47:30,300
for instance because you'd have to do lazy evaluation and that.

1618
02:47:30,300 --> 02:47:35,300
Now there is something kind of coming up. We got that to work.

1619
02:47:35,300 --> 02:47:40,300
We're not done with this yet. One thing that we are abusing

1620
02:47:40,300 --> 02:47:45,300
is the fact that the lambda calculus does not actually allow

1621
02:47:45,300 --> 02:47:50,300
global variables.

1622
02:47:50,300 --> 02:47:55,300
There are no global variables. There's no assignment. It's only functions.

1623
02:47:55,300 --> 02:48:00,300
And all of this stuff that I'm doing with the assignment of the names

1624
02:48:00,300 --> 02:48:05,300
like fact equal is zero equal and so forth, that is technically not allowed.

1625
02:48:05,300 --> 02:48:10,300
You're not allowed to just make a variable and store it. Because this kind of implies

1626
02:48:10,300 --> 02:48:15,300
storage. If I make a name, it's like, oh it must be storing it someplace.

1627
02:48:15,300 --> 02:48:20,300
You can't do that. That is not

1628
02:48:20,300 --> 02:48:25,300
a legal kind of thing to do. And it actually presents a really

1629
02:48:25,300 --> 02:48:30,300
interesting programming problem when you start talking about recursion.

1630
02:48:30,300 --> 02:48:35,300
And here's

1631
02:48:35,300 --> 02:48:40,300
why it becomes interesting with recursion.

1632
02:48:40,300 --> 02:48:45,300
If you're doing this recursive stuff, you have to

1633
02:48:45,300 --> 02:48:50,300
refer to yourself basically. Like that's the whole way that recursion works.

1634
02:48:50,300 --> 02:48:55,300
It's like you have factorial and it's like I have factorial and then a bunch of stuff and then in the middle of

1635
02:48:55,300 --> 02:49:00,300
factorial I have this self reference.

1636
02:49:00,300 --> 02:49:05,300
Like,

1637
02:49:05,300 --> 02:49:10,300
right, but how do I get myself? No, it's a weird problem.

1638
02:49:10,300 --> 02:49:15,300
I want to do this in Python for a second. But you have this function

1639
02:49:15,300 --> 02:49:20,300
like let's say you had a factorial function in Python. We're going to do it with lambda

1640
02:49:20,300 --> 02:49:25,300
here. Just like lambda n. And I'm going to do it in kind of a shorter way.

1641
02:49:25,300 --> 02:49:30,300
Like 1 if n equals 0, else n times fact n minus 1.

1642
02:49:30,300 --> 02:49:35,300
So let's say you had something like that. Let's just make sure that it works.

1643
02:49:35,300 --> 02:49:40,300
Lambda.

1644
02:49:40,300 --> 02:49:45,300
Okay, back to 24.

1645
02:49:45,300 --> 02:49:50,300
Okay, so here's the challenge.

1646
02:49:50,300 --> 02:49:55,300
How would you

1647
02:49:55,300 --> 02:50:00,300
rewrite that to not have a self reference to yourself?

1648
02:50:00,300 --> 02:50:05,300
Like to not have that fact. Like how would you get rid of that?

1649
02:50:05,300 --> 02:50:10,300
What?

1650
02:50:10,300 --> 02:50:15,300
No, we're working purely with functions.

1651
02:50:15,300 --> 02:50:20,300
So we can't do like for loops or anything like that.

1652
02:50:20,300 --> 02:50:25,300
You have to use a Y combinator? Eventually.

1653
02:50:25,300 --> 02:50:30,300
You're jumping the gun on where we're heading here. So we're heading to something like that.

1654
02:50:30,300 --> 02:50:35,300
No, it's, you can't have, like basically you cannot have

1655
02:50:35,300 --> 02:50:40,300
that global reference.

1656
02:50:40,300 --> 02:50:45,300
Like that is the thing that isn't, like we do not want that.

1657
02:50:45,300 --> 02:50:50,300
We're not allowed to have that. And so if you can't have that,

1658
02:50:50,300 --> 02:50:55,300
there's this question of like, well, what do you do there?

1659
02:50:55,300 --> 02:51:00,300
And one of the things that you could do there is you could pass it as an argument

1660
02:51:00,300 --> 02:51:05,300
at first glance.

1661
02:51:05,300 --> 02:51:10,300
At first glance,

1662
02:51:10,300 --> 02:51:15,300
that's going to look crazy.

1663
02:51:15,300 --> 02:51:20,300
Let me just shorten it up a little bit.

1664
02:51:20,300 --> 02:51:25,300
I mean, you could do that. You could like introduce like an extra argument there

1665
02:51:25,300 --> 02:51:30,300
and then just pass the function in as an extra argument.

1666
02:51:30,300 --> 02:51:35,300
I actually already kind of did a horrible trick with that. Like I think at one point I said, like if you had X is two,

1667
02:51:35,300 --> 02:51:40,300
you could actually say X is equal to like lambda Y, Y and then apply it to two

1668
02:51:40,300 --> 02:51:45,300
as this like totally just dumb thing that you could do in code.

1669
02:51:45,300 --> 02:51:50,300
That is kind of what we're doing here. Or it's just like, okay, if I can't have the fact

1670
02:51:50,300 --> 02:51:55,300
in there, I'll just pull it out as an argument.

1671
02:51:55,300 --> 02:52:00,300
No, this doesn't work in Python.

1672
02:52:00,300 --> 02:52:05,300
No, no, no. So you're going to look at that and you're going to say, wait a minute.

1673
02:52:05,300 --> 02:52:10,300
You're just like, no. Like all that happened there is

1674
02:52:10,300 --> 02:52:15,300
you moved the fact out into this outer part.

1675
02:52:15,300 --> 02:52:20,300
And it's like, you're like Beasley. It's like, come on, man.

1676
02:52:20,300 --> 02:52:25,300
You can't do that. What are you doing?

1677
02:52:25,300 --> 02:52:30,300
You can't do that. You cannot have the factor.

1678
02:52:30,300 --> 02:52:35,300
It seems like the factorial is just a name to help us describe

1679
02:52:35,300 --> 02:52:40,300
that particular combination of functions. There's no actual storing of global things.

1680
02:52:40,300 --> 02:52:45,300
We've just given it a name as a convenience for us to refer to that particular

1681
02:52:45,300 --> 02:52:50,300
combination. Anything that has that combination will then be a factorial.

1682
02:52:50,300 --> 02:52:55,300
And if you change that combination, then it's just something else and it's just some other name.

1683
02:52:55,300 --> 02:53:00,300
So why do we even care about storing that name?

1684
02:53:00,300 --> 02:53:05,300
Why do we care about globals or variables? It just doesn't even matter.

1685
02:53:05,300 --> 02:53:10,300
The problem here is I need to have a reference to myself.

1686
02:53:10,300 --> 02:53:15,300
I mean, on the implementation, yeah, but on the math level, who cares?

1687
02:53:15,300 --> 02:53:20,300
Yeah. Well, even kind of on the math reference,

1688
02:53:20,300 --> 02:53:25,300
if you're going to express recursion, there's kind of this like, okay, you're going to recurse, but how do you

1689
02:53:25,300 --> 02:53:30,300
reference the... There's kind of a weird cycle set up where it's like you're recursing, but

1690
02:53:30,300 --> 02:53:35,300
how do you get a reference to the thing that you're recursing on?

1691
02:53:35,300 --> 02:53:40,300
No, it's wild. Now, the solution to this will blow your mind, actually.

1692
02:53:40,300 --> 02:53:45,300
Okay, so keep in mind, I cannot use fact there. Fact,

1693
02:53:45,300 --> 02:53:50,300
that is no. Okay, so that is God there. So the solution to this problem

1694
02:53:50,300 --> 02:53:55,300
is to do the opposite of everything that you've been taught about proper software

1695
02:53:55,300 --> 02:54:00,300
and to do the opposite of don't repeat yourself.

1696
02:54:00,300 --> 02:54:05,300
And what is the opposite of don't repeat yourself? Repeat yourself.

1697
02:54:05,300 --> 02:54:10,300
If you need to pass yourself in

1698
02:54:10,300 --> 02:54:15,300
as an argument, you just cut and paste the code and do it twice.

1699
02:54:15,300 --> 02:54:20,300
So you have to keep cutting and pasting

1700
02:54:20,300 --> 02:54:25,300
until you get to your zero representation, right? No, because it's

1701
02:54:25,300 --> 02:54:30,300
F. So this thing, the first argument is F,

1702
02:54:30,300 --> 02:54:35,300
which is the recursive function. So I'm going to pass

1703
02:54:35,300 --> 02:54:40,300
myself. I'm going to take the code and I'm going to paste it in there and I'm going to pass it in there.

1704
02:54:40,300 --> 02:54:45,300
Now, it still doesn't work. Keep in mind,

1705
02:54:45,300 --> 02:54:50,300
if I try that, it's going to blow up with some exception.

1706
02:54:50,300 --> 02:54:55,300
And it's like, okay, what is wrong

1707
02:54:55,300 --> 02:55:00,300
there?

1708
02:55:10,300 --> 02:55:15,300
Yeah.

1709
02:55:15,300 --> 02:55:20,300
Now, the thing that's wrong here is I'm not following the API.

1710
02:55:20,300 --> 02:55:25,300
Not to get back to APIs, but the API to this thing is you pass a function first

1711
02:55:25,300 --> 02:55:30,300
and a number second. And I'm not doing that here.

1712
02:55:30,300 --> 02:55:35,300
Like when I do the recursive call and I say F of N minus 1, I'm not following the API.

1713
02:55:35,300 --> 02:55:40,300
I'm just passing the number. There's like, I need the F.

1714
02:55:40,300 --> 02:55:45,300
Like where's the F? I'm missing an argument

1715
02:55:45,300 --> 02:55:50,300
basically. I have a two argument function, fact, like this.

1716
02:55:50,300 --> 02:55:55,300
The F and the N, that's two arguments. I'm only passing one of the arguments.

1717
02:55:55,300 --> 02:56:00,300
So now there's this problem, like where do I get the second argument?

1718
02:56:05,300 --> 02:56:10,300
You just pass it in.

1719
02:56:10,300 --> 02:56:15,300
I think that's what you said. You just pass F. Like F is the function.

1720
02:56:15,300 --> 02:56:20,300
So you pass it. Like F is a two argument function.

1721
02:56:20,300 --> 02:56:25,300
It takes an F and an N. The first argument is F.

1722
02:56:25,300 --> 02:56:30,300
So you just pass it as the second argument, or as the first argument.

1723
02:56:30,300 --> 02:56:35,300
Works perfectly.

1724
02:56:35,300 --> 02:56:40,300
Looks a little bad.

1725
02:56:40,300 --> 02:56:45,300
A lot bad. Like having the duplicated function

1726
02:56:45,300 --> 02:56:50,300
thing there.

1727
02:56:50,300 --> 02:56:55,300
Yeah, we're going to get to that.

1728
02:56:55,300 --> 02:57:00,300
I guess we should do the slide update there.

1729
02:57:00,300 --> 02:57:05,300
No, this is crazy.

1730
02:57:05,300 --> 02:57:10,300
It's like, okay, so you can do a recursive function

1731
02:57:10,300 --> 02:57:15,300
and just,

1732
02:57:15,300 --> 02:57:20,300
you don't need the name there.

1733
02:57:20,300 --> 02:57:25,300
Maybe just to illustrate

1734
02:57:25,300 --> 02:57:30,300
that the name is kind of unimportant, I could actually, I could just take this code

1735
02:57:30,300 --> 02:57:35,300
and just drop it,

1736
02:57:35,300 --> 02:57:40,300
just drop it in like a print statement.

1737
02:57:40,300 --> 02:57:45,300
Yeah, print function. So you could just print, like, you know, lambda,

1738
02:57:45,300 --> 02:57:50,300
and then drop like five on it, like that.

1739
02:57:50,300 --> 02:57:55,300
And it would work.

1740
02:57:55,300 --> 02:58:00,300
It's just like a big expression. I mean, if you really wanted to make this

1741
02:58:00,300 --> 02:58:05,300
hardcore, you could just put it inside an F string probably, and then

1742
02:58:05,300 --> 02:58:10,300
it would work. I'm not going to do that, but that's

1743
02:58:10,300 --> 02:58:15,300
kind of amazing.

1744
02:58:15,300 --> 02:58:20,300
Alright, everybody get that.

1745
02:58:20,300 --> 02:58:25,300
Yeah, there will be a quiz later.

1746
02:58:25,300 --> 02:58:30,300
Yeah, question there.

1747
02:58:30,300 --> 02:58:35,300
That's depending on the short circuiting of the arguments, right? So if the first branch evaluates to

1748
02:58:35,300 --> 02:58:40,300
zero, then it just returns zero, sorry. If the first branch evaluates

1749
02:58:40,300 --> 02:58:45,300
to one, okay, okay. Yeah, definitely the short circuiting, we need that.

1750
02:58:45,300 --> 02:58:50,300
Like, that not going down both paths. And Python is kind of giving us that.

1751
02:58:50,300 --> 02:58:55,300
So I want to say a little bit more about that.

1752
02:58:55,300 --> 02:59:00,300
This whole thing, the whole repeating yourself

1753
02:59:00,300 --> 02:59:05,300
part of it should have made you feel like really kind of awful

1754
02:59:05,300 --> 02:59:10,300
in a way. I mean, normally in programming you don't want to do that, like having to repeat

1755
02:59:10,300 --> 02:59:15,300
like cut and paste code. I mean, actually reading that is kind of making my eyes

1756
02:59:15,300 --> 02:59:20,300
bleed a little bit. Trying to figure that out.

1757
02:59:20,300 --> 02:59:25,300
And I want to talk about an alternate way of doing this.

1758
02:59:25,300 --> 02:59:30,300
Before I do that, I want to talk about school for a second.

1759
02:59:30,300 --> 02:59:35,300
I don't see anybody like head down on the desk really here too bad. But like in school,

1760
02:59:35,300 --> 02:59:40,300
like in math class, did you ever have that experience of like this is so boring.

1761
02:59:40,300 --> 02:59:45,300
I just want to die. Like, you know, can the next 45 minutes pass?

1762
02:59:45,300 --> 02:59:50,300
And then in trying to pass the time, there was like a common thing

1763
02:59:50,300 --> 02:59:55,300
that I used to do, which was to pull out my hand calculator.

1764
02:59:55,300 --> 03:00:00,300
And then you just start pressing buttons on the calculator and you're like, I'm so bored.

1765
03:00:00,300 --> 03:00:05,300
Has anybody done this square root thing where it's like get the calculator and you punch a number

1766
03:00:05,300 --> 03:00:10,300
and you just start doing square root over and over and over again and the numbers get smaller

1767
03:00:10,300 --> 03:00:15,300
and then eventually it hits one and then it just starts hitting one and one and one and one and one over again.

1768
03:00:15,300 --> 03:00:20,300
I can't be the only one who's done that. So I'm sure that

1769
03:00:20,300 --> 03:00:25,300
everyone has done that.

1770
03:00:25,300 --> 03:00:30,300
So one of the things that you were doing there is actually

1771
03:00:30,300 --> 03:00:35,300
exploring one of the most interesting things of all about the lambda calculus

1772
03:00:35,300 --> 03:00:40,300
and recursive functions and other things. So one of the things that you've found in doing that

1773
03:00:40,300 --> 03:00:45,300
is you found something known as a fixed point.

1774
03:00:45,300 --> 03:00:50,300
It's kind of a mathematical term, but a fixed point, it's basically a function

1775
03:00:50,300 --> 03:00:55,300
where if you give it like an input, you just get the input back.

1776
03:00:55,300 --> 03:01:00,300
Like square root of one is one. It turns out that one is a fixed point of square root,

1777
03:01:00,300 --> 03:01:05,300
meaning that if you just call square root like over and over and over and over again,

1778
03:01:05,300 --> 03:01:10,300
you just end up back where you started.

1779
03:01:10,300 --> 03:01:15,300
So you end up with something, that's an example of a fixed point.

1780
03:01:15,300 --> 03:01:20,300
Basically you have a function, you give it an input, you get the same thing back.

1781
03:01:20,300 --> 03:01:25,300
And one question you can ask is like is this in any way

1782
03:01:25,300 --> 03:01:30,300
possibly related to recursion?

1783
03:01:30,300 --> 03:01:35,300
What you're doing with recursion is you're kind of turning the crank on this function, like f of f of f of f of f.

1784
03:01:35,300 --> 03:01:40,300
It's kind of the same thing that you were doing with the calculator, right?

1785
03:01:40,300 --> 03:01:45,300
It's like okay, I'm pushing the square root button over and over and over again.

1786
03:01:45,300 --> 03:01:50,300
Is there anything that you can get from that?

1787
03:01:50,300 --> 03:01:55,300
So to talk about that, I'm going to go back to this factorial function for a second.

1788
03:01:55,300 --> 03:02:00,300
I'm going to do it as kind of the lambda version of it.

1789
03:02:06,300 --> 03:02:11,300
This is what we started with. This is our kind of original function.

1790
03:02:11,300 --> 03:02:16,300
And one of the things that we did in the previous part

1791
03:02:16,300 --> 03:02:21,300
is we did this trick with the variable name.

1792
03:02:21,300 --> 03:02:26,300
So we did this fact where we passed it like an f.

1793
03:02:37,300 --> 03:02:42,300
And then we did that. This was the thing where it's like, well that makes no sense at all.

1794
03:02:42,300 --> 03:02:47,300
I mean like, what do you mean? Like you have the fact on both sides of the

1795
03:02:47,300 --> 03:02:52,300
both sides of the equation there.

1796
03:02:52,300 --> 03:02:57,300
I'm going to take out the middle part of that

1797
03:02:57,300 --> 03:03:02,300
and put it into its own variable.

1798
03:03:11,300 --> 03:03:16,300
I'm essentially taking out the part in the parentheses.

1799
03:03:16,300 --> 03:03:21,300
I'm taking that and putting it in its own variable.

1800
03:03:21,300 --> 03:03:26,300
Maybe I'll put parentheses around it just to emphasize that.

1801
03:03:39,300 --> 03:03:44,300
So if you do that, you're going to end up

1802
03:03:44,300 --> 03:03:49,300
with kind of this weird statement at the end. I'm going to put some comments on this

1803
03:03:49,300 --> 03:03:54,300
by the way because I'm not sure that the things that follow are not going to work as Python code

1804
03:03:54,300 --> 03:03:59,300
for a second. But what's happening is I kind of took the middle of this thing out.

1805
03:03:59,300 --> 03:04:04,300
And then you end up with this relation.

1806
03:04:04,300 --> 03:04:09,300
Fact equals R of fact.

1807
03:04:09,300 --> 03:04:14,300
People kind of see how that came about there.

1808
03:04:14,300 --> 03:04:19,300
It's basically the sneaky variable trick where I turned fact into a variable

1809
03:04:19,300 --> 03:04:24,300
and then kind of factored it out there.

1810
03:04:24,300 --> 03:04:29,300
If you look at that last statement

1811
03:04:29,300 --> 03:04:34,300
and you ponder it a little bit, it turns out that you'll realize that fact

1812
03:04:34,300 --> 03:04:39,300
must be a fixed point of R.

1813
03:04:39,300 --> 03:04:44,300
The whole idea on a fixed point is that you have a function

1814
03:04:44,300 --> 03:04:49,300
where you pass something in and then you get the identical thing back.

1815
03:04:49,300 --> 03:04:54,300
This is exactly the thing that we did with the square root.

1816
03:04:54,300 --> 03:04:59,300
Square root of one is one. This is saying that it's basically

1817
03:04:59,300 --> 03:05:04,300
R of fact gets you back to fact.

1818
03:05:04,300 --> 03:05:09,300
This R, that has to be a fixed point

1819
03:05:09,300 --> 03:05:14,300
of whatever that R function is.

1820
03:05:21,300 --> 03:05:26,300
That should be exploding a little bit here. I'm thinking of it just purely mathematically right now.

1821
03:05:26,300 --> 03:05:31,300
It's a question over there.

1822
03:05:31,300 --> 03:05:36,300
So that then implies basically that fact is a fixed

1823
03:05:36,300 --> 03:05:41,300
behavior of R?

1824
03:05:41,300 --> 03:05:46,300
I wouldn't say it's a fixed behavior necessarily, but the behavior of R is that if you give it this

1825
03:05:46,300 --> 03:05:51,300
fact function, you're going to get back the original fact function, whatever it is.

1826
03:05:51,300 --> 03:05:56,300
So is

1827
03:05:56,300 --> 03:06:01,300
one, is a fixed point a kind of identity? You give something, you get the same thing back.

1828
03:06:01,300 --> 03:06:06,300
Also, when you use the term fact must be a fixed point of R,

1829
03:06:06,300 --> 03:06:11,300
R is also a function, right? Does that mean that there's other fixed points of it or does it have just one fixed point?

1830
03:06:11,300 --> 03:06:16,300
There must be some set of R's that give you back things.

1831
03:06:16,300 --> 03:06:21,300
They may be infinite fixed points of R.

1832
03:06:21,300 --> 03:06:26,300
There's multiple relations?

1833
03:06:26,300 --> 03:06:31,300
One thing that's a little weird about this is we still do not know what fact is.

1834
03:06:31,300 --> 03:06:36,300
This statement, if I were to write in Python

1835
03:06:36,300 --> 03:06:41,300
fact equals R fact, that's not going to work.

1836
03:06:41,300 --> 03:06:46,300
How is that supposed to work? Fact doesn't even exist yet.

1837
03:06:46,300 --> 03:06:51,300
That's invalid Python code.

1838
03:06:51,300 --> 03:06:56,300
We don't even know what fact is as part of code.

1839
03:06:56,300 --> 03:07:01,300
If I were to look at this, I don't really know what fact is. I know what R is.

1840
03:07:01,300 --> 03:07:06,300
R is that, this thing up here. I don't know what fact is.

1841
03:07:06,300 --> 03:07:11,300
The thing that's weird about fact is that if I can figure out what it is, then fact equals R fact.

1842
03:07:11,300 --> 03:07:16,300
I don't know what it is.

1843
03:07:16,300 --> 03:07:21,300
I just know that if it's a fixed point of R, then that must be true.

1844
03:07:21,300 --> 03:07:26,300
Yeah.

1845
03:07:26,300 --> 03:07:31,300
So can we really, because fact is just a name,

1846
03:07:31,300 --> 03:07:36,300
are we really asserting that that's an equality and not just an assignment?

1847
03:07:36,300 --> 03:07:41,300
I think that's the thing I'm struggling with.

1848
03:07:41,300 --> 03:07:46,300
One in square root of one makes sense because one isn't a name of a thing. It's an actual value.

1849
03:07:46,300 --> 03:07:51,300
It's not really an assignment.

1850
03:07:51,300 --> 03:07:56,300
One is the name of that particular zero function.

1851
03:07:56,300 --> 03:08:01,300
Right, but like fact here,

1852
03:08:01,300 --> 03:08:06,300
are we saying we get back the same function after we pass it into R?

1853
03:08:06,300 --> 03:08:11,300
This is not really an assignment,

1854
03:08:11,300 --> 03:08:16,300
it's a mathematical relationship that is being expressed here.

1855
03:08:16,300 --> 03:08:21,300
Mathematically, fact is equal to R fact.

1856
03:08:21,300 --> 03:08:26,300
The big leap that we're going to take,

1857
03:08:26,300 --> 03:08:31,300
this is the huge leap, and you're going to have to bear with me for a second on this,

1858
03:08:31,300 --> 03:08:36,300
suppose that there actually was a function

1859
03:08:36,300 --> 03:08:41,300
I have not told you what this is,

1860
03:08:41,300 --> 03:08:46,300
by the way, but this is a typical math trick.

1861
03:08:46,300 --> 03:08:51,300
Suppose that there actually existed something that could compute what the fixed point was.

1862
03:08:51,300 --> 03:08:56,300
So let's say there was some function Y that existed in the world

1863
03:08:56,300 --> 03:09:01,300
somewhere where Y of R basically computed the fixed point of R.

1864
03:09:01,300 --> 03:09:06,300
Whatever it is, we don't know what it is,

1865
03:09:06,300 --> 03:09:11,300
but let's just assume that there's some function that was out there

1866
03:09:11,300 --> 03:09:16,300
that could do that.

1867
03:09:16,300 --> 03:09:21,300
If that thing existed, and again this is very much math talk,

1868
03:09:21,300 --> 03:09:26,300
assume that it existed, and we don't know what it is, but assume that it's out there.

1869
03:09:26,300 --> 03:09:31,300
If that thing existed, then you could say this,

1870
03:09:31,300 --> 03:09:36,300
you could say Y of R is equal to RY of R.

1871
03:09:36,300 --> 03:09:41,300
All I'm doing there is replacing fact.

1872
03:09:41,300 --> 03:09:46,300
If fact is a fixed point of R, then Y of R equals RY of R.

1873
03:09:46,300 --> 03:09:51,300
You could do that.

1874
03:09:51,300 --> 03:09:56,300
It's still not clear how in the world that would help you now,

1875
03:09:56,300 --> 03:10:01,300
because it's like okay great, okay awesome,

1876
03:10:01,300 --> 03:10:06,300
RY of R is equal to RY of R.

1877
03:10:06,300 --> 03:10:11,300
I'm going to do my little recursion trick.

1878
03:10:11,300 --> 03:10:16,300
Basically what you have there is you have recursion.

1879
03:10:16,300 --> 03:10:21,300
The recursion trick was this thing where you pulled it out into a variable.

1880
03:10:21,300 --> 03:10:26,300
Like that.

1881
03:10:26,300 --> 03:10:31,300
That's what we did with the fact function.

1882
03:10:31,300 --> 03:10:36,300
We basically said we're going to pull fact out of there.

1883
03:10:36,300 --> 03:10:41,300
Then we're going to put it as an argument.

1884
03:10:41,300 --> 03:10:46,300
One of the things in the trick is we basically said you couldn't do it.

1885
03:10:46,300 --> 03:10:51,300
You can't just put the YR in there.

1886
03:10:51,300 --> 03:10:56,300
What you have to do is the thing that you didn't want to do, which is the repeat yourself trick.

1887
03:10:56,300 --> 03:11:01,300
The solution to the fact was to repeat yourself.

1888
03:11:01,300 --> 03:11:06,300
It turns out that we're going to repeat ourselves.

1889
03:11:06,300 --> 03:11:11,300
This little trick here, this is the

1890
03:11:11,300 --> 03:11:16,300
repeat yourself trick.

1891
03:11:16,300 --> 03:11:21,300
When we did that trick with the fact function though, there was one other thing that we had to do.

1892
03:11:21,300 --> 03:11:26,300
We had to do the hack with the F.

1893
03:11:26,300 --> 03:11:31,300
If you looked at the fact thing, we had to do this F of F thing.

1894
03:11:31,300 --> 03:11:36,300
If we're going to do the repeat yourself trick, we have to do that here.

1895
03:11:36,300 --> 03:11:41,300
Instead of having X, I have to say X of X.

1896
03:11:41,300 --> 03:11:46,300
I have to do the trick on it.

1897
03:11:46,300 --> 03:11:51,300
Maybe I'll do that as a separate step.

1898
03:12:01,300 --> 03:12:06,300
That was that necessary hack. The extra X in there.

1899
03:12:06,300 --> 03:12:11,300
The extra call.

1900
03:12:11,300 --> 03:12:16,300
If you look at that, it's almost starting to look like a formula

1901
03:12:16,300 --> 03:12:21,300
actually.

1902
03:12:21,300 --> 03:12:26,300
One thing that we could do with it is pull out the R.

1903
03:12:31,300 --> 03:12:36,300
I probably have too many parentheses.

1904
03:12:36,300 --> 03:12:41,300
Parentheses there.

1905
03:12:41,300 --> 03:12:46,300
We got the R there.

1906
03:12:46,300 --> 03:12:51,300
It looks like you have R on both sides actually.

1907
03:12:51,300 --> 03:12:56,300
I'm going to pull out the R.

1908
03:12:56,300 --> 03:13:01,300
It looks like you have R on both sides actually.

1909
03:13:01,300 --> 03:13:06,300
Maybe you could just drop it.

1910
03:13:17,300 --> 03:13:22,300
Maybe you can end up with something like that.

1911
03:13:22,300 --> 03:13:27,300
I'm going to pull out the R.

1912
03:13:27,300 --> 03:13:32,300
I'm going to pull out the R.

1913
03:13:32,300 --> 03:13:37,300
This is the Y.

1914
03:13:37,300 --> 03:13:42,300
It's a device to do recursion in functional languages.

1915
03:13:42,300 --> 03:13:47,300
It's a little hairy to derive that.

1916
03:13:47,300 --> 03:13:52,300
The way that you use it

1917
03:13:52,300 --> 03:13:57,300
is you would write out your recursive relationship here.

1918
03:13:57,300 --> 03:14:02,300
You would say R is that.

1919
03:14:02,300 --> 03:14:07,300
Then you would say fact is equal to Y of R.

1920
03:14:07,300 --> 03:14:12,300
If that thing is working, it should produce a recursive function for you

1921
03:14:12,300 --> 03:14:17,300
through serious magic.

1922
03:14:17,300 --> 03:14:22,300
In theory.

1923
03:14:22,300 --> 03:14:27,300
One of the reasons

1924
03:14:27,300 --> 03:14:32,300
for doing this

1925
03:14:32,300 --> 03:14:37,300
is that term Y Combinator is something that

1926
03:14:37,300 --> 03:14:42,300
is kind of interesting to see what it is.

1927
03:14:42,300 --> 03:14:47,300
It's actually a device for doing recursion.

1928
03:14:47,300 --> 03:14:52,300
If you do it, you're going to find that it does not work.

1929
03:14:52,300 --> 03:14:57,300
Typical Python style. Question in the middle there.

1930
03:14:57,300 --> 03:15:02,300
I'm just wondering what the expanded version of the

1931
03:15:02,300 --> 03:15:07,300
dot in the Y is.

1932
03:15:07,300 --> 03:15:12,300
It's colon basically.

1933
03:15:12,300 --> 03:15:17,300
We're getting near the end.

1934
03:15:17,300 --> 03:15:22,300
If you type that up, you are going to find that it does not work

1935
03:15:22,300 --> 03:15:27,300
because of an infinite recursion error.

1936
03:15:27,300 --> 03:15:32,300
That is actually getting back to Python's evaluation problem.

1937
03:15:32,300 --> 03:15:37,300
The fact that it does eager argument evaluation.

1938
03:15:37,300 --> 03:15:42,300
The solution to that problem is ironically

1939
03:15:42,300 --> 03:15:47,300
the solution to all Python problems.

1940
03:15:47,300 --> 03:15:52,300
You're on the right track. I wasn't thinking meta classes because we don't have classes here.

1941
03:15:52,300 --> 03:15:57,300
What do you do?

1942
03:15:57,300 --> 03:16:02,300
Let's say you have a function

1943
03:16:02,300 --> 03:16:07,300
2 times X plus 1.

1944
03:16:07,300 --> 03:16:12,300
If I were to write a function G of X where I just flipped it around and said F of X.

1945
03:16:12,300 --> 03:16:17,300
If I were to do that,

1946
03:16:17,300 --> 03:16:22,300
that's basically what you're doing with a decorator.

1947
03:16:22,300 --> 03:16:27,300
You're writing a function that wraps around another function.

1948
03:16:27,300 --> 03:16:32,300
It produces the same kind of result for reasons that I will not completely explain.

1949
03:16:32,300 --> 03:16:37,300
No, it takes X.

1950
03:16:37,300 --> 03:16:42,300
G takes X and then G just takes the X and passes it along.

1951
03:16:42,300 --> 03:16:47,300
This is kind of like a decorator expanded out.

1952
03:16:47,300 --> 03:16:52,300
It's wrapping. You write a wrapper function.

1953
03:16:52,300 --> 03:16:57,300
It turns out that if you do that,

1954
03:16:57,300 --> 03:17:02,300
you can do this in the lambda calculus.

1955
03:17:02,300 --> 03:17:07,300
It's going to look a little weird, but what I'm going to do is take an F

1956
03:17:07,300 --> 03:17:12,300
and then I'm just going to introduce an extra argument

1957
03:17:12,300 --> 03:17:17,300
and then I'm just going to pass it through.

1958
03:17:27,300 --> 03:17:32,300
I have a feeling I'm probably missing a parenthesis in there somewhere.

1959
03:17:32,300 --> 03:17:37,300
Let's try that.

1960
03:17:37,300 --> 03:17:42,300
The infinite recursion is God at this point.

1961
03:17:52,300 --> 03:17:57,300
It seems to be working there.

1962
03:17:57,300 --> 03:18:02,300
There will definitely be a quiz about that one.

1963
03:18:02,300 --> 03:18:07,300
Part of what's happening there is deferring evaluation

1964
03:18:07,300 --> 03:18:12,300
so that it doesn't get this infinite recursion.

1965
03:18:12,300 --> 03:18:17,300
It turns out that that lets you write these recursive functions.

1966
03:18:17,300 --> 03:18:22,300
As you stare in that

1967
03:18:22,300 --> 03:18:27,300
in disbelief perhaps,

1968
03:18:27,300 --> 03:18:32,300
we can do Fibonacci numbers.

1969
03:18:47,300 --> 03:18:52,300
This is kind of a recursive Fibonacci thing.

1970
03:18:52,300 --> 03:18:57,300
You can say Fib is equal to YR1 for instance.

1971
03:19:04,300 --> 03:19:09,300
I don't know what the tenth Fibonacci number is, but it's...

1972
03:19:17,300 --> 03:19:22,300
The head's fully exploded here.

1973
03:19:22,300 --> 03:19:27,300
If you've heard of the Y Combinator, that's what it is.

1974
03:19:27,300 --> 03:19:32,300
Something for enabling recursion.

1975
03:19:32,300 --> 03:19:37,300
Question in the front here.

1976
03:19:37,300 --> 03:19:42,300
I'm trying to think, what is the relationship of all of this

1977
03:19:42,300 --> 03:19:47,300
and this function substitution to the idea of currying.

1978
03:19:47,300 --> 03:19:52,300
Obviously named after Haskell B. Curry and the language.

1979
03:19:52,300 --> 03:19:57,300
Informally, I always use currying as freezing a particular parameter

1980
03:19:57,300 --> 03:20:02,300
of a multiple parameter function.

1981
03:20:02,300 --> 03:20:07,300
If you had four, now you have three. If you have three, you have two.

1982
03:20:07,300 --> 03:20:12,300
It's a function parameter function.

1983
03:20:12,300 --> 03:20:17,300
Maybe you just get to zero, which then becomes the callable itself.

1984
03:20:17,300 --> 03:20:22,300
The question about currying is this conversion of multiple arguments to single arguments.

1985
03:20:22,300 --> 03:20:27,300
That's...

1986
03:20:27,300 --> 03:20:32,300
I don't think

1987
03:20:32,300 --> 03:20:37,300
recursion is necessarily related to the currying thing.

1988
03:20:37,300 --> 03:20:42,300
The currying is more of just that all functions take one argument.

1989
03:20:42,300 --> 03:20:47,300
Instead of having multiple argument functions, you can have the one argument function.

1990
03:20:47,300 --> 03:20:52,300
It's actually kind of interesting that you would bring up currying.

1991
03:20:52,300 --> 03:20:57,300
We're basically at the end, but I'm going to make a few comments.

1992
03:20:57,300 --> 03:21:02,300
This business with combinators is actually the work of another guy.

1993
03:21:02,300 --> 03:21:07,300
There's this Moses Ilyich Schoenfinkle, who's kind of known as the inventor of

1994
03:21:07,300 --> 03:21:12,300
combatory logic. It turns out that all the lambda calculus papers

1995
03:21:12,300 --> 03:21:17,300
reference this guy. Curry built on his work.

1996
03:21:17,300 --> 03:21:22,300
It turns out that this guy is the one who invented currying, actually,

1997
03:21:22,300 --> 03:21:27,300
in the 20s. He's actually much earlier,

1998
03:21:27,300 --> 03:21:32,300
and it's cited in the papers.

1999
03:21:32,300 --> 03:21:37,300
It's an interesting story on this. It turns out that you can actually get rid of the

2000
03:21:37,300 --> 03:21:42,300
requirement of defining new functions and derive all of lambda calculus

2001
03:21:42,300 --> 03:21:47,300
from a few so-called combinator primitives.

2002
03:21:47,300 --> 03:21:52,300
I'm not going to get into that here, because I don't fully understand it. My head has already

2003
03:21:52,300 --> 03:21:57,300
exploded on the previous stuff. This is kind of an earlier

2004
03:21:57,300 --> 03:22:02,300
thing. This guy is kind of interesting. His story is sort of tragic.

2005
03:22:02,300 --> 03:22:07,300
I think he went insane at the age of 28, and then all of his

2006
03:22:07,300 --> 03:22:12,300
math papers got burned for fuel in the Russian winter in 1942 or something.

2007
03:22:12,300 --> 03:22:17,300
Not a lot of information is known.

2008
03:22:17,300 --> 03:22:22,300
He is cited by Alonzo Church and some of the papers on lambda calculus.

2009
03:22:22,300 --> 03:22:27,300
It's sort of interesting. Final comments on this.

2010
03:22:27,300 --> 03:22:32,300
We're basically at the end. I was trying to think

2011
03:22:32,300 --> 03:22:37,300
what to even make of this tutorial.

2012
03:22:37,300 --> 03:22:42,300
Having seen this the first time, I was like, this is just insane.

2013
03:22:42,300 --> 03:22:47,300
Why would you do this? In the description of the tutorial, I was like,

2014
03:22:47,300 --> 03:22:52,300
you're not going to do anything practical. I don't see you walking away

2015
03:22:52,300 --> 03:22:57,300
saying, I'm going to implement my web app using lambda calculus or something.

2016
03:22:57,300 --> 03:23:02,300
No.

2017
03:23:02,300 --> 03:23:07,300
You're not going to make a programming language that literally operates in this way that we've described.

2018
03:23:07,300 --> 03:23:12,300
I think there is something interesting about it.

2019
03:23:12,300 --> 03:23:17,300
One thing I think is interesting is I think a lot of the mainstream programming languages

2020
03:23:17,300 --> 03:23:22,300
are based on this abstraction on hardware. If you think about Python or C

2021
03:23:22,300 --> 03:23:27,300
Java or something like that, so much of it is like, you have operations, you have memory,

2022
03:23:27,300 --> 03:23:32,300
you have pointers, there's this idea of the hardware running machine code.

2023
03:23:32,300 --> 03:23:37,300
There's a whole bunch of stuff that's going on under the covers.

2024
03:23:37,300 --> 03:23:42,300
I think as a programmer, it's useful to have that as a mental working model.

2025
03:23:42,300 --> 03:23:47,300
There's memory and arrays and memory and stuff going on. Even though that's your model,

2026
03:23:47,300 --> 03:23:52,300
it's not a code usually. I don't know, is anybody writing machine code in here?

2027
03:23:52,300 --> 03:23:57,300
We're at a Python conference, I'm not writing machine code.

2028
03:23:57,300 --> 03:24:02,300
I'm probably thinking about the machine though. If I'm doing NumPy or something,

2029
03:24:02,300 --> 03:24:07,300
I'm thinking about memory and arrays and all this stuff. I think there's maybe

2030
03:24:07,300 --> 03:24:12,300
something similar going on with the lambda calculus. If you're going to start

2031
03:24:12,300 --> 03:24:17,300
exploring functional programming languages, you get into Haskell and Scala

2032
03:24:17,300 --> 03:24:22,300
and Scheme and Lisp and you start branching off into other topics like type theory

2033
03:24:22,300 --> 03:24:27,300
and other things, you actually find that a lot of this lambda calculus stuff is all over the place.

2034
03:24:27,300 --> 03:24:32,300
One of the books that I'm working on right now is a types and programming languages book

2035
03:24:32,300 --> 03:24:37,300
talking about type theory. I don't actually know that much about type theory.

2036
03:24:37,300 --> 03:24:42,300
I'm trying to wrap my brain around it. The very first example in that book is lambda calculus.

2037
03:24:42,300 --> 03:24:47,300
There's a like, oh, let's just have this hypothetical minimal programming language

2038
03:24:47,300 --> 03:24:52,300
that happens to be called lambda calculus and we'll put types on it or some things.

2039
03:24:52,300 --> 03:24:57,300
You start to see it everywhere. Even though you would never

2040
03:24:57,300 --> 03:25:02,300
maybe code with the lambda calculus, it's more of maybe a

2041
03:25:02,300 --> 03:25:07,300
mental model of functional programming, doing things with functions and different

2042
03:25:07,300 --> 03:25:12,300
ways of composing functions and other things. I think that would probably be

2043
03:25:12,300 --> 03:25:17,300
the takeaway from this, is just kind of an exposure to this really amazing

2044
03:25:17,300 --> 03:25:22,300
functional programming world and some of the stuff that you can do there.

2045
03:25:22,300 --> 03:25:27,300
I think that's it. Yeah. The end of that.

2046
03:25:27,300 --> 03:25:32,300
Thanks for coming to this. Just as a little background,

2047
03:25:32,300 --> 03:25:37,300
if you're interested in kind of getting more into this kind of stuff,

2048
03:25:37,300 --> 03:25:42,300
the avenue for me getting into it is I started doing some study of this structure

2049
03:25:42,300 --> 03:25:47,300
and interpretation of computer programs book or the famous SICP book.

2050
03:25:47,300 --> 03:25:52,300
It does not cover lambda calculus. That's not part of that book, but it talks a lot about

2051
03:25:52,300 --> 03:25:57,300
functional programming and some of these things. That is actually what kind of got me

2052
03:25:57,300 --> 03:26:02,300
interested in that. If you're looking for maybe a gateway

2053
03:26:02,300 --> 03:26:07,300
to learning more about this kind of thinking and all that stuff, I would look at that.

2054
03:26:07,300 --> 03:26:12,300
It's kind of a starting point. That's it. That's all I've got.

2055
03:26:12,300 --> 03:26:17,300
We can take a few minutes of more questions. Otherwise, I've got to let you go to lunch.

2056
03:26:17,300 --> 03:26:22,300
Thank you.

2057
03:26:22,300 --> 03:26:27,300
Alright. Thanks for coming.

