1
00:00:00,000 --> 00:00:04,600
All right.

2
00:00:04,600 --> 00:00:05,600
Welcome everyone.

3
00:00:05,600 --> 00:00:09,000
Just a reminder to make sure you turn off any sound devices.

4
00:00:09,000 --> 00:00:12,760
Otherwise, you will get a stare from me.

5
00:00:12,760 --> 00:00:14,160
We have Shannon Zhu here.

6
00:00:14,160 --> 00:00:21,400
She is going to be speaking on leveraging the type system to write secure applications.

7
00:00:21,400 --> 00:00:26,200
All right.

8
00:00:26,200 --> 00:00:28,280
Hi.

9
00:00:28,280 --> 00:00:31,960
I'm going to be talking today about how you can leverage the type system in Python to

10
00:00:31,960 --> 00:00:34,360
write more secure applications.

11
00:00:34,360 --> 00:00:36,640
A little bit about myself first.

12
00:00:36,640 --> 00:00:40,120
I work at Facebook on the product security team.

13
00:00:40,120 --> 00:00:43,760
The mission of our team is to find, fix, and prevent code level security vulnerabilities

14
00:00:43,760 --> 00:00:46,240
across the Facebook family of apps.

15
00:00:46,240 --> 00:00:49,520
More specifically, I work on the static analysis effort within that team.

16
00:00:49,520 --> 00:00:53,880
I've spent the past two years building a static analyzer and type checker for Python called

17
00:00:53,880 --> 00:00:56,120
Pyre.

18
00:00:56,120 --> 00:01:01,080
In this talk, I'll be covering how you can build security tools on top of the type system

19
00:01:01,080 --> 00:01:06,680
in Python and also why we might choose to approach security this way.

20
00:01:06,680 --> 00:01:10,360
We'll go over two techniques in particular that are made possible by the type system,

21
00:01:10,360 --> 00:01:15,080
both with the purpose of improving application security at scale.

22
00:01:15,080 --> 00:01:21,480
The first of these is secure application frameworks, which work by systematically denoting certain

23
00:01:21,480 --> 00:01:26,520
types as or certain objects as safe or unsafe and then leveraging a static type checker

24
00:01:26,520 --> 00:01:30,680
along with some simple library modifications to catch security vulnerabilities as type

25
00:01:30,680 --> 00:01:31,680
errors.

26
00:01:31,680 --> 00:01:34,840
Secondly, I'll be going into taint analysis.

27
00:01:34,840 --> 00:01:38,440
I'll talk in more detail about what this means later, but high level.

28
00:01:38,440 --> 00:01:43,200
This is a way that you can statically trace data flow across your code base.

29
00:01:43,200 --> 00:01:46,720
That's an intentionally vague description because data flow can mean a lot of different

30
00:01:46,720 --> 00:01:50,680
things, which actually makes this tool pretty flexible and able to catch a lot of intricate

31
00:01:50,680 --> 00:01:51,680
problems.

32
00:01:51,680 --> 00:01:56,560
A brief overview of how we'll begin to discuss these two techniques.

33
00:01:56,560 --> 00:02:01,080
First I'll get into some background about the problems that we're trying to solve and

34
00:02:01,080 --> 00:02:03,600
why we wanted to invest in these tools in the first place.

35
00:02:03,600 --> 00:02:09,960
Then I'll get into a classic shell injection example to help explain how both of these

36
00:02:09,960 --> 00:02:12,520
techniques work in detail.

37
00:02:12,520 --> 00:02:18,240
Then we'll get into a slightly more nuanced security vulnerability, which helps demonstrate

38
00:02:18,400 --> 00:02:22,120
some of the flexibility of what taint analysis can model.

39
00:02:22,120 --> 00:02:25,840
And finally, we'll talk a little bit about the characteristics of both of these techniques

40
00:02:25,840 --> 00:02:31,080
and why we find them so powerful and essential for security at Facebook.

41
00:02:31,080 --> 00:02:33,720
So what was our motivation?

42
00:02:33,720 --> 00:02:36,440
A couple years ago we had a bit of a problem.

43
00:02:36,440 --> 00:02:42,720
The Instagram code base is a very large monolithic Python code base that has gradual types.

44
00:02:42,720 --> 00:02:46,560
And we already knew that we wanted to invest in type checking for a variety of reasons,

45
00:02:46,560 --> 00:02:52,640
including the bug exposure, the code maintainability, and the consistency guarantees among some

46
00:02:52,640 --> 00:02:54,640
other reasons.

47
00:02:54,640 --> 00:02:57,640
And type checking was kind of slow, and it was getting slower with the more types that

48
00:02:57,640 --> 00:02:58,640
we added.

49
00:02:58,640 --> 00:03:02,320
So we really cared about having really fast, live incremental checks that would help us

50
00:03:02,320 --> 00:03:08,800
push for type adoption and enable us to build security tooling at scale.

51
00:03:08,800 --> 00:03:14,000
So we previously had a really great experience at Facebook adding types to PHP and then using

52
00:03:14,040 --> 00:03:19,280
those types to build a graph of all the function calls across the code base, which then enables

53
00:03:19,280 --> 00:03:23,960
us to build a taint analyzer that's fast enough to run on a code base of 100 million lines

54
00:03:23,960 --> 00:03:28,960
of code on every change set, of which there are thousands every day.

55
00:03:28,960 --> 00:03:34,240
And in doing so, find more security vulnerabilities than security review or our bug bounty program

56
00:03:34,240 --> 00:03:38,680
in the past year, which is a lot of these were found before the code even lands.

57
00:03:38,680 --> 00:03:44,880
So these are really huge security wins that we wanted to be able to replicate in Python.

58
00:03:44,880 --> 00:03:49,520
So our solution was to build Pyre, which is a static analyzer and type checker with two

59
00:03:49,520 --> 00:03:50,520
goals in mind.

60
00:03:50,520 --> 00:03:53,440
So first, we wanted a fast and scalable type checker.

61
00:03:53,440 --> 00:03:57,840
But most importantly, we wanted a tool that was conceived from the very beginning as a

62
00:03:57,840 --> 00:04:02,360
platform for deeper static analysis for security.

63
00:04:02,360 --> 00:04:07,080
And we wanted to be able to reuse a lot of the backend of our type checker to extend

64
00:04:07,080 --> 00:04:12,560
and basically turn into a taint analyzer like the one we have for PHP.

65
00:04:12,560 --> 00:04:14,600
So fast forward to today.

66
00:04:14,600 --> 00:04:17,560
We've built this type checker and the static analyzer.

67
00:04:17,560 --> 00:04:21,200
So let's get into some examples about how all of this works.

68
00:04:21,200 --> 00:04:24,000
As promised, we'll start with shell injection.

69
00:04:24,000 --> 00:04:29,360
And we'll discuss how both type frameworks and taint analysis work in a little more detail

70
00:04:29,360 --> 00:04:32,560
to systematically catch this vulnerability.

71
00:04:32,560 --> 00:04:35,240
And we'll do missing privacy checks after.

72
00:04:35,240 --> 00:04:37,800
So first, a word about shell injection.

73
00:04:37,800 --> 00:04:42,520
As many of you might know, this is a really large and well-known class of security vulnerabilities

74
00:04:42,520 --> 00:04:44,680
that actually has known solutions.

75
00:04:44,680 --> 00:04:50,280
But it's not a solved problem because those solutions are not consistently applied.

76
00:04:50,280 --> 00:04:52,440
And you'll see what I mean with an example.

77
00:04:52,440 --> 00:04:57,840
So here we have a function called get image, which takes a URL, constructs a get command

78
00:04:57,840 --> 00:05:01,680
with it, and executes that command with OS system.

79
00:05:01,680 --> 00:05:04,280
So let's introduce a problem.

80
00:05:04,320 --> 00:05:08,400
So here's a function called convert, which asks the user for a URL that they're interested

81
00:05:08,400 --> 00:05:11,320
in and then passes that URL into get image.

82
00:05:11,320 --> 00:05:17,520
So essentially, we have user input here flowing directly into something that executes a command

83
00:05:17,520 --> 00:05:19,280
with that user input.

84
00:05:19,280 --> 00:05:23,880
Why might this be terrible?

85
00:05:23,880 --> 00:05:29,800
So you can, as you might imagine, an attacker can just supply some whatever URL followed

86
00:05:29,800 --> 00:05:34,240
by a semicolon and then whatever command that they desire to execute on your system.

87
00:05:34,240 --> 00:05:37,160
So in this case, they're wiping it.

88
00:05:37,160 --> 00:05:42,680
And in real life, this might actually come from, say, a Django endpoint or a piece of

89
00:05:42,680 --> 00:05:45,040
a request rather than a call to raw input.

90
00:05:45,040 --> 00:05:48,240
But I'm just minimizing the amount of code you have to read.

91
00:05:48,240 --> 00:05:50,740
So we're using raw input.

92
00:05:50,740 --> 00:05:58,280
So what we would really like to do here, the known solution here, is to sanitize the, basically

93
00:05:58,280 --> 00:06:02,200
escape the argument while we're constructing the command here.

94
00:06:02,200 --> 00:06:06,120
And so instead of executing this, which is two commands, the second of which is completely

95
00:06:06,120 --> 00:06:11,680
determined by an attacker, you would instead be executing your intended command with the

96
00:06:11,680 --> 00:06:15,760
attacker's applied input as just a string argument.

97
00:06:15,760 --> 00:06:21,100
And so this will just fetch some nonsense and not delete anything from your system.

98
00:06:21,100 --> 00:06:24,920
And you might say, well, duh, this is a known solution, so you should just feel bad if you

99
00:06:24,920 --> 00:06:26,840
don't remember to do it.

100
00:06:27,800 --> 00:06:32,760
It might be true in some cases, but you might want to remember that in this example, you

101
00:06:32,760 --> 00:06:36,760
might not own or even know about the contents of one of these two functions, or you might

102
00:06:36,760 --> 00:06:40,240
not be aware of where certain data that you're working with is coming from or where it might

103
00:06:40,240 --> 00:06:43,880
eventually end up or what it might touch as it gets there.

104
00:06:43,880 --> 00:06:49,320
So in this case, we would like a way to catch this type of vulnerability across many layers

105
00:06:49,320 --> 00:06:54,680
of indirection, even if it happens to occur in something that seems unrelated to what

106
00:06:54,680 --> 00:06:56,800
you're working on.

107
00:06:56,800 --> 00:07:02,720
So how can we systematically ensure that all commands that we execute are safe?

108
00:07:02,720 --> 00:07:07,360
We want a systematic solution that doesn't just pattern match around the syntax of sensitive

109
00:07:07,360 --> 00:07:11,680
calls, and we also want a scalable solution that doesn't require the application author

110
00:07:11,680 --> 00:07:17,080
to remember this all the time or put in a lot of extra work.

111
00:07:17,080 --> 00:07:23,560
So going back to our example, we could write a simple library function called secure format,

112
00:07:23,560 --> 00:07:27,400
and all this does is add some escaping, so that would probably be in the form of quotes

113
00:07:27,400 --> 00:07:32,240
around the arguments before constructing the string as usual, which would make this

114
00:07:32,240 --> 00:07:34,520
code snippet safe again.

115
00:07:34,520 --> 00:07:38,120
And then the key here is that we can then leverage the type system to ensure that this

116
00:07:38,120 --> 00:07:40,800
simple solution is always applied.

117
00:07:40,800 --> 00:07:44,880
And we can do this by introducing a safe string type, which we define to be the same as any

118
00:07:44,880 --> 00:07:50,080
other string, except it's always safe to directly execute.

119
00:07:50,080 --> 00:07:53,600
And it's worth noting that all safe strings are strings and all string literals are safe

120
00:07:53,600 --> 00:07:55,640
strings.

121
00:07:55,640 --> 00:07:59,240
And then we can write something like this, which might look familiar to you if you've

122
00:07:59,240 --> 00:08:03,640
worked with type Python before, which is essentially a type signature.

123
00:08:03,640 --> 00:08:11,000
So here we're mandating that my custom library function secure format takes in a safe string

124
00:08:11,000 --> 00:08:15,800
as the formatter and then any safe or unsafe strings as the arguments.

125
00:08:15,800 --> 00:08:19,800
It does the escaping, and so therefore it always outputs a safe string at the end.

126
00:08:19,840 --> 00:08:25,800
And then we can annotate any sensitive functions like OS system or eval as accepting safe strings.

127
00:08:25,800 --> 00:08:31,960
So if you were to take a string and pass it in and you hadn't sanitized the arguments,

128
00:08:31,960 --> 00:08:36,360
you would get a type error here saying, sorry, it expected a safe string, but you gave me

129
00:08:36,360 --> 00:08:38,960
a string.

130
00:08:38,960 --> 00:08:39,960
So awesome.

131
00:08:39,960 --> 00:08:44,080
We can eliminate an entire class of vulnerability here by taking advantage of the way that types

132
00:08:44,080 --> 00:08:49,640
guarantee semantic consistency across your code base and then just adding some security

133
00:08:49,640 --> 00:08:52,280
implications to those types.

134
00:08:52,280 --> 00:08:56,720
And a nice bonus is that you improve some code readability as well because you have

135
00:08:56,720 --> 00:08:59,200
some more nuanced labeling of your objects.

136
00:08:59,200 --> 00:09:02,800
And you can essentially get these warnings live.

137
00:09:02,800 --> 00:09:07,880
So if you already have code editor integration with a type checker, you can see this warning

138
00:09:07,880 --> 00:09:12,400
the moment you write the vulnerability before you even put up your code for review by a

139
00:09:12,400 --> 00:09:15,480
security engineer or not.

140
00:09:15,720 --> 00:09:19,960
And it's really nice that there's no mental overhead here for application engineers and

141
00:09:19,960 --> 00:09:27,880
you're not betting the security of your application on whether or not the application engineers

142
00:09:27,880 --> 00:09:33,280
have understood and have planned for these security vulnerabilities.

143
00:09:33,280 --> 00:09:38,200
So now in our code base by default, instead of format, let's say we always are using secure

144
00:09:38,200 --> 00:09:39,640
format.

145
00:09:39,640 --> 00:09:46,320
You might wonder whether as a particularly stubborn application author that I can still

146
00:09:46,320 --> 00:09:52,200
find a way to write a shell injection vulnerability into this function even with secure format.

147
00:09:52,200 --> 00:09:54,480
What if we really tried?

148
00:09:54,480 --> 00:09:59,880
So the key here is to take a look at this raw string and realize that the type checker

149
00:09:59,880 --> 00:10:04,200
cares about the type of this raw string, but it doesn't care or know about what the contents

150
00:10:04,200 --> 00:10:05,660
of that raw string are.

151
00:10:05,660 --> 00:10:12,500
So you can do things such as double escape in which the manually added escapes here would

152
00:10:12,500 --> 00:10:16,500
cancel out the escaping done in secure format.

153
00:10:16,500 --> 00:10:21,500
Or you can write higher order shell injection in which the argument that you pass in is

154
00:10:21,500 --> 00:10:23,660
supposed to be a string that will be executed as a command.

155
00:10:23,660 --> 00:10:29,580
So even if you sanitize your argument, it will still get executed, doesn't matter.

156
00:10:29,580 --> 00:10:34,420
And similarly, if you decide to set the command itself with your argument rather than one

157
00:10:34,420 --> 00:10:39,500
of those arguments to the command, that will again be executed even if it's a string.

158
00:10:39,500 --> 00:10:44,300
So it looks like we have a solution to the common use case of shell injection, but we

159
00:10:44,300 --> 00:10:49,780
would still like to be able to catch very specific special cases that bypass our secure

160
00:10:49,780 --> 00:10:51,340
framework.

161
00:10:51,340 --> 00:10:55,740
And something like this is actually a really great candidate for a taint analysis.

162
00:10:55,740 --> 00:10:58,660
So let's introduce how this works with some terminology.

163
00:10:58,660 --> 00:11:00,600
So we care about three things here.

164
00:11:00,600 --> 00:11:04,920
We care about sources of user controlled input, which are called sources.

165
00:11:04,920 --> 00:11:09,640
And then we care about objects that contain or maybe have touched user controlled input.

166
00:11:09,640 --> 00:11:11,880
And we call this taint.

167
00:11:11,880 --> 00:11:16,200
And finally, we care about sensitive functions that taint should never reach.

168
00:11:16,200 --> 00:11:17,200
And we call these sinks.

169
00:11:17,200 --> 00:11:21,560
And these might be OS system or eval or some other functions that we don't want to take

170
00:11:21,560 --> 00:11:23,960
user controlled input.

171
00:11:23,960 --> 00:11:30,300
And in taint analysis, we care about tracing the flow of taint from sources to sinks.

172
00:11:31,000 --> 00:11:33,900
And it's worth noting that in this case, we happen to care about user controlled input.

173
00:11:33,900 --> 00:11:36,020
So that's what we're saying taint is.

174
00:11:36,020 --> 00:11:39,780
But in other security vulnerability examples, we might be tracing something else as taint

175
00:11:39,780 --> 00:11:42,080
instead.

176
00:11:42,080 --> 00:11:45,720
So to visualize this, we're going back to our original example.

177
00:11:45,720 --> 00:11:51,780
And here we want to mark input as a source of user controlled input.

178
00:11:51,780 --> 00:11:56,140
And we do this by something that looks a lot like a type signature, but we call this a

179
00:11:56,140 --> 00:11:57,740
taint summary.

180
00:11:57,740 --> 00:12:01,740
And so here's the signature of input.

181
00:12:01,740 --> 00:12:04,620
And we're just annotating it as returning a taint source.

182
00:12:04,620 --> 00:12:06,420
And then we'll do something similar for sink.

183
00:12:06,420 --> 00:12:12,140
We want to mark the first parameter of OS system as a sink.

184
00:12:12,140 --> 00:12:16,120
And then to help visualize the flow of taint here, I've just highlighted it all in yellow.

185
00:12:16,120 --> 00:12:19,820
And we see that there is a flow from a source to a sink.

186
00:12:19,820 --> 00:12:24,980
But like before, keep in mind that this might happen across tens or hundreds of different

187
00:12:24,980 --> 00:12:25,980
function calls.

188
00:12:26,020 --> 00:12:27,700
So it might not be quite so obvious.

189
00:12:27,700 --> 00:12:34,540
And in order to do this at scale, the first step that taint analysis does is to calculate

190
00:12:34,540 --> 00:12:37,660
the remaining summaries based on the ones that were provided.

191
00:12:37,660 --> 00:12:40,740
So here we have these two.

192
00:12:40,740 --> 00:12:42,140
And let's look at get image.

193
00:12:42,140 --> 00:12:43,780
And we'll start analyzing the body here.

194
00:12:43,780 --> 00:12:45,800
And we see that there is one parameter.

195
00:12:45,800 --> 00:12:47,980
And it does flow into a sink.

196
00:12:47,980 --> 00:12:53,140
And so for all intents and purposes, we can mark get image, the first parameter of get

197
00:12:53,140 --> 00:12:55,540
image as itself a sink.

198
00:12:55,540 --> 00:13:01,340
That way when we see it somewhere else, we don't have to enter the body again to investigate.

199
00:13:01,340 --> 00:13:05,500
So now if we look at the body of convert, there aren't any interesting parameters to

200
00:13:05,500 --> 00:13:06,500
follow.

201
00:13:06,500 --> 00:13:07,580
But we do see a source.

202
00:13:07,580 --> 00:13:11,580
And so we're going to trace that source and see that it flows into a sink, which is get

203
00:13:11,580 --> 00:13:13,080
image.

204
00:13:13,080 --> 00:13:19,940
So we can flag this here for review as a potential shell injection vulnerability.

205
00:13:20,700 --> 00:13:25,900
And you might have noticed actually that so far for this example, we've been using format

206
00:13:25,900 --> 00:13:27,980
instead of secure format.

207
00:13:27,980 --> 00:13:32,460
And this is an example of a taint in, taint out function, which is designated this way.

208
00:13:32,460 --> 00:13:38,900
So we basically are saying that if the arguments are tainted, then the return type of format

209
00:13:38,900 --> 00:13:40,540
will be tainted.

210
00:13:40,540 --> 00:13:44,200
But as you might remember, we did have our handy secure format.

211
00:13:44,200 --> 00:13:48,540
And what we can do is change the signature here to designate.

212
00:13:48,540 --> 00:13:52,060
If the arguments are tainted, the return type is not actually.

213
00:13:52,060 --> 00:13:54,380
So this is called a sanitizer.

214
00:13:54,380 --> 00:13:58,960
And when we pass, when taint passes through this, it gets removed.

215
00:13:58,960 --> 00:14:02,780
So at this point, we can model everything with our taint analyzer that we could with

216
00:14:02,780 --> 00:14:04,580
our secure framework.

217
00:14:04,580 --> 00:14:08,660
But we can go a little further here because we're not constrained and we're not limited

218
00:14:08,660 --> 00:14:10,380
to type consistency.

219
00:14:10,380 --> 00:14:15,900
So what we can do is label that remaining parameter to secure format and flag this to

220
00:14:15,900 --> 00:14:20,580
our taint analyzer and say that actually whether or not the return type of secure format is

221
00:14:20,580 --> 00:14:25,220
tainted depends on the contents of the string.

222
00:14:25,220 --> 00:14:31,900
So like secure frameworks, taint analysis can flag data flowing into specific functions

223
00:14:31,900 --> 00:14:35,540
and distinguish whether that data has been sanitized or not.

224
00:14:35,540 --> 00:14:38,980
But we can see that it's especially useful for modeling high complexity bugs because

225
00:14:38,980 --> 00:14:42,220
it's not tied to type consistency.

226
00:14:42,220 --> 00:14:44,780
It does, however, also rely on a type code base.

227
00:14:44,780 --> 00:14:50,300
And you might remember that in our previous, in our example, we were lucky enough to calculate

228
00:14:50,300 --> 00:14:54,780
the summary of get image before we looked at convert.

229
00:14:54,780 --> 00:14:58,780
But to do this at scale, we actually need a graph of all the function calls built with

230
00:14:58,780 --> 00:15:01,980
types to inform our taint analysis.

231
00:15:01,980 --> 00:15:07,460
So this allows us to scale to very large code bases and avoid false positives.

232
00:15:07,460 --> 00:15:11,460
And the final thing to note is that taint analysis does require security engineers to

233
00:15:11,460 --> 00:15:17,260
define those initial sources and sinks and some security input to refine some of the

234
00:15:17,260 --> 00:15:18,340
rules.

235
00:15:18,340 --> 00:15:22,740
And it's relatively slow, so you can't do it instantaneously maybe in a type editor

236
00:15:22,740 --> 00:15:27,260
like or in a code editor like type checking could be done.

237
00:15:27,260 --> 00:15:31,500
But this is fast enough to run on continuous integration on change sets.

238
00:15:31,500 --> 00:15:36,180
So it is still fast enough to be feasible.

239
00:15:36,180 --> 00:15:41,140
So to recap, we see that shell injection has a lot of known solutions.

240
00:15:41,140 --> 00:15:44,580
And we can use type frameworks to systematically apply those.

241
00:15:44,580 --> 00:15:48,620
And in this way, secure frameworks can take out huge classes of vulnerabilities like shell

242
00:15:48,620 --> 00:15:53,860
injection or SQL injection or cross-site scripting without security knowledge on the part of

243
00:15:53,860 --> 00:15:56,780
application engineers.

244
00:15:56,780 --> 00:16:00,060
We also see that some specific edge cases do exist.

245
00:16:00,060 --> 00:16:04,140
And taint analysis can systematically model and catch those.

246
00:16:04,140 --> 00:16:09,780
So we can kind of fill in that type frameworks catch almost all shell injection vulnerabilities

247
00:16:09,780 --> 00:16:14,300
and taint analysis can model the remaining cases.

248
00:16:14,300 --> 00:16:17,440
But there are also other things that we might want to catch that aren't just edge cases

249
00:16:17,440 --> 00:16:22,440
of problems that are already 99.9% solved by secure frameworks.

250
00:16:22,440 --> 00:16:25,700
So let's get into one of those.

251
00:16:25,700 --> 00:16:27,660
This image might look familiar to you.

252
00:16:27,660 --> 00:16:32,380
It's the PyCon 2019 Facebook event, which you can view in a browser if you hit a particular

253
00:16:32,460 --> 00:16:35,060
Facebook.com URL.

254
00:16:35,060 --> 00:16:38,240
And let's imagine that part of the back end looks something like this.

255
00:16:38,240 --> 00:16:39,500
We check if a user is logged in.

256
00:16:39,500 --> 00:16:44,540
And if they are, we go fetch the event data from the database for display.

257
00:16:44,540 --> 00:16:50,180
So now there might be other privacy checks that we actually want to perform here before

258
00:16:50,180 --> 00:16:52,500
we just go ahead and read from the database.

259
00:16:52,500 --> 00:16:55,960
So for instance, you might have a private event, which is supposed to be secret from

260
00:16:55,960 --> 00:17:00,800
anyone that's not explicitly invited, in which case you do want to make sure that every time

261
00:17:00,800 --> 00:17:04,680
we fetch that event, we check whether that user has been invited.

262
00:17:04,680 --> 00:17:09,320
So how can we use taint analysis to ensure that the necessary set of privacy checks,

263
00:17:09,320 --> 00:17:13,120
which might be very large, always happen?

264
00:17:13,120 --> 00:17:17,640
So to review last time, we used taint to model user-controlled input, and we cared about

265
00:17:17,640 --> 00:17:20,900
when it flowed into sensitive APIs.

266
00:17:20,900 --> 00:17:25,200
This time, we care about any objects with unchecked permissions, and we care about when

267
00:17:25,200 --> 00:17:27,680
those flow into database reads or writes.

268
00:17:28,360 --> 00:17:31,880
It's again worth noting that this could be extended to a variety of other things, such

269
00:17:31,880 --> 00:17:36,280
as modeling user information and when that flows into logging or things like that.

270
00:17:36,280 --> 00:17:41,400
So in this example, very briefly, like before, we have a database read that we want to mark

271
00:17:41,400 --> 00:17:42,800
as a sync.

272
00:17:42,800 --> 00:17:48,200
We mark any source of a user object as a source of taint, and this might contain various types

273
00:17:48,200 --> 00:17:49,560
of taint.

274
00:17:49,560 --> 00:17:55,260
And then a sanitizer that is the privacy check, which removes taint when the object flows

275
00:17:55,340 --> 00:17:57,820
through this function.

276
00:17:57,820 --> 00:18:02,340
So like before, we can calculate function signatures and trace taint and see whether

277
00:18:02,340 --> 00:18:06,940
it's been sanitized across many modules and layers of indirection.

278
00:18:06,940 --> 00:18:09,300
And you might ask, okay, that sounds great.

279
00:18:09,300 --> 00:18:14,300
It seems pretty familiar, but then why not use type frameworks here?

280
00:18:14,300 --> 00:18:18,740
We already saw that we were able to determine whether a string was safe to execute or not

281
00:18:18,740 --> 00:18:23,700
using type frameworks, so why can't we determine whether a user object is safe to fetch from

282
00:18:23,700 --> 00:18:25,820
a database?

283
00:18:25,820 --> 00:18:31,220
And so the key here is that for type frameworks to work, you need a valid type hierarchy,

284
00:18:31,220 --> 00:18:35,540
which worked out really well with safe strings and strings, but this falls apart really quickly

285
00:18:35,540 --> 00:18:40,040
if the security conditions that you care about don't form a clean hierarchy.

286
00:18:40,040 --> 00:18:45,220
So if you don't believe me, we'll go into a quick example here where you have a user

287
00:18:45,220 --> 00:18:51,600
object and maybe you care if they're logged in, but maybe you might also want a specifically

288
00:18:51,600 --> 00:18:53,580
not logged in user.

289
00:18:53,580 --> 00:18:55,860
So it's not quite a hierarchy here, so that's fine.

290
00:18:55,860 --> 00:18:56,860
Let's make them parallel.

291
00:18:56,860 --> 00:19:02,420
Okay, so like maybe you also care about whether they've been invited or not to this event.

292
00:19:02,420 --> 00:19:06,940
Maybe you care if they're over 18 or if they're under 18, and maybe you care if they're friends

293
00:19:06,940 --> 00:19:10,540
with the content creator of whatever they're trying to view.

294
00:19:10,540 --> 00:19:15,540
Maybe you care if they're in some experiment group, and it just goes on and on.

295
00:19:15,540 --> 00:19:21,740
And then for every sensitive function that you care about, you have to subset some but

296
00:19:21,780 --> 00:19:27,180
not all of these security conditions to define your own custom type here, and we're not even

297
00:19:27,180 --> 00:19:32,700
getting into the mess of global users that have global permissions set that maybe you

298
00:19:32,700 --> 00:19:39,180
don't actually want to be valid as flowing into your sensitive function.

299
00:19:39,180 --> 00:19:44,320
So this gets out of hand even in really simple situations.

300
00:19:44,320 --> 00:19:49,340
So going back to our examples, we see here that type frameworks are not really a viable

301
00:19:49,340 --> 00:19:54,820
solution to finding missing privacy checks because you have to conform to that type hierarchy,

302
00:19:54,820 --> 00:19:56,420
and that's not always possible.

303
00:19:56,420 --> 00:20:04,380
But taint analysis is a lot more flexible in this way, and so it can catch these.

304
00:20:04,380 --> 00:20:09,180
Then it's worth noting that taint...

305
00:20:09,180 --> 00:20:14,640
So we know that taint analysis can model data with a lot more flexibility than a type checker,

306
00:20:14,640 --> 00:20:18,820
but there are a lot of different kinds of data flow patterns that we haven't even started

307
00:20:18,820 --> 00:20:21,540
to talk about today.

308
00:20:21,540 --> 00:20:27,820
So taint analysis can model direct taint to sync flows that we've seen already, and it

309
00:20:27,820 --> 00:20:34,300
might also model indirect flows where user-controlled data controls the loading of other data, for

310
00:20:34,300 --> 00:20:44,500
instance, and kind of separately or very differently, it can also model taint that controls a conditional,

311
00:20:44,500 --> 00:20:48,280
and then we can know that everything under that conditional branch is operating under

312
00:20:48,440 --> 00:20:49,880
some taint control.

313
00:20:49,880 --> 00:20:55,240
And in this way, we can model things like privacy oracles or a variety of other examples.

314
00:20:55,240 --> 00:20:59,920
And I would like to get into a little more detail here, but in the interest of time,

315
00:20:59,920 --> 00:21:03,320
I can't, but I'd be really happy to answer questions about some of the details of the

316
00:21:03,320 --> 00:21:06,200
other things that taint analysis can model.

317
00:21:06,200 --> 00:21:13,400
Okay, so hopefully these examples helped illustrate both the flexibility of taint analysis and

318
00:21:13,480 --> 00:21:19,400
the efficiency with which secure type frameworks can just eliminate whole classes of security

319
00:21:19,400 --> 00:21:22,000
vulnerabilities at scale.

320
00:21:22,000 --> 00:21:24,600
So let's go over some takeaways.

321
00:21:24,600 --> 00:21:30,400
Secure frameworks, we see leverage types to explicitly differentiate safe and unsafe practices,

322
00:21:30,400 --> 00:21:33,640
which is really useful when you have clear states on data that you can model as input

323
00:21:33,640 --> 00:21:38,940
or output to functions, and that conforms to a valid type hierarchy.

324
00:21:38,940 --> 00:21:44,460
You get warnings once a vulnerability is typed, which is really fast and also does not rely

325
00:21:44,460 --> 00:21:49,980
on application engineers to understand any of the details of security vulnerabilities.

326
00:21:49,980 --> 00:21:54,740
And it is, as we've seen, somewhat limited in what can be modeled, and the limitations

327
00:21:54,740 --> 00:21:59,980
are described by those first two bullet points of what this typically models.

328
00:21:59,980 --> 00:22:04,380
So then we have taint analysis, on the other hand, which does require some tuning to get

329
00:22:04,540 --> 00:22:09,580
signal to noise, but it can model a lot of subtle vulnerabilities, and it can be extremely

330
00:22:09,580 --> 00:22:13,500
useful for tracking complex data flow.

331
00:22:13,500 --> 00:22:18,140
And it synergizes really well with a bug bounty program, which often reports edge cases or

332
00:22:18,140 --> 00:22:22,780
very specific vulnerabilities that happen to show up in your code base.

333
00:22:22,780 --> 00:22:29,300
And so given one of those, you can model this as taint, track that taint flow, and eliminate

334
00:22:29,300 --> 00:22:33,400
all other kinds of that vulnerability across your code base, and also make sure that this

335
00:22:33,400 --> 00:22:36,480
never gets introduced again.

336
00:22:36,480 --> 00:22:42,080
And it's worth noting that taint analysis can be a little faster in this way, like it

337
00:22:42,080 --> 00:22:47,360
has a shorter iteration cycle, because you can define these signatures and the rules,

338
00:22:47,360 --> 00:22:50,960
and then just run it on your code base, whereas oftentimes secure frameworks require some

339
00:22:50,960 --> 00:22:55,000
time to build the framework, to do the code mod and push for adoption before you get the

340
00:22:55,000 --> 00:23:01,000
automatic, instant response detection that we were talking about before.

341
00:23:01,000 --> 00:23:05,280
So really, neither approach is sufficient alone, and they're both really powerful because

342
00:23:05,280 --> 00:23:11,280
they can analyze the semantics of code and comprehensively follow all branches of code

343
00:23:11,280 --> 00:23:16,800
flow through many layers of interaction, but even so, good application security is still

344
00:23:16,800 --> 00:23:19,720
an exercise in defense in depth.

345
00:23:19,720 --> 00:23:23,160
And just because we have some fancy static analysis tools doesn't mean we rely on them

346
00:23:23,160 --> 00:23:24,160
exclusively.

347
00:23:24,160 --> 00:23:28,160
And in this talk, I've gone over the first few bullets here, which are type checking,

348
00:23:28,160 --> 00:23:32,160
for frameworks and static analysis, but there's just as much depth in the efforts that we

349
00:23:32,160 --> 00:23:39,800
put into dynamic analysis and other methods of catching security vulnerabilities.

350
00:23:39,800 --> 00:23:45,960
So here are some quick stats on our experience with type-based static analysis in PHP and

351
00:23:45,960 --> 00:23:46,960
Python so far.

352
00:23:46,960 --> 00:23:51,060
And we just got started building and running taint analysis for Python a little earlier

353
00:23:51,060 --> 00:23:55,560
this year, but we've already had success finding security vulnerabilities with the tool.

354
00:23:55,560 --> 00:23:59,640
And our experience with PHP is a little more mature, and we were able to find well over

355
00:23:59,640 --> 00:24:04,360
a thousand vulnerabilities last year and mostly before any of them were even committed.

356
00:24:04,360 --> 00:24:10,380
And this is also on a massive code base with a whole lot of changes every day.

357
00:24:10,380 --> 00:24:17,160
So in conclusion, we found a lot of security wins using type-based frameworks and security-focused

358
00:24:17,160 --> 00:24:20,740
static analysis, and this might be useful for you, too.

359
00:24:20,740 --> 00:24:24,600
If you're interested, Pyre is open sourced, and you can find the documentation and the

360
00:24:24,640 --> 00:24:27,840
GitHub repository at this URL.

361
00:24:27,840 --> 00:24:32,800
And if you'd like to learn more about Pyre or hear more about some of the pieces that

362
00:24:32,800 --> 00:24:37,760
this talk glossed over, there are some other really great talks on how we built Pyre for

363
00:24:37,760 --> 00:24:45,360
speed and also two talks from PyCon last year about how we actually built the static analyzer

364
00:24:45,360 --> 00:24:52,080
on top of the type checker in Pyre and for some other reasons why you might want to type

365
00:24:52,080 --> 00:24:56,680
your dynamic Python code base and how you could do that at scale.

366
00:24:56,680 --> 00:25:00,900
And finally, here are the other members of the Pyre team, most of whom are in the audience

367
00:25:00,900 --> 00:25:03,320
as well.

368
00:25:03,320 --> 00:25:08,880
And if I have extra time, I'm happy to take questions.

369
00:25:08,880 --> 00:25:15,080
Okay.

370
00:25:15,080 --> 00:25:17,680
We have about room for five minutes of questions.

371
00:25:18,280 --> 00:25:21,280
So if anybody has questions, feel free to use the microphones.

372
00:25:37,280 --> 00:25:38,280
Hey.

373
00:25:38,280 --> 00:25:39,280
Great talk.

374
00:25:39,280 --> 00:25:40,280
Thank you.

375
00:25:40,280 --> 00:25:41,280
Very interesting subject.

376
00:25:41,280 --> 00:25:46,880
You said that the code bases you work with are basically monoliths.

377
00:25:47,080 --> 00:25:51,680
Do you have any experience sort of following a Tain across the service boundary in sort

378
00:25:51,680 --> 00:25:55,080
of the microservice architecture or any tips?

379
00:25:55,080 --> 00:25:56,080
Yeah.

380
00:25:56,080 --> 00:26:04,480
So we work with some thrift, so basically C and Python boundaries, but I'm actually

381
00:26:04,480 --> 00:26:09,600
not super familiar myself with the details there, but we should talk afterwards and I

382
00:26:09,600 --> 00:26:12,080
think some of my teammates might be able to answer your question.

383
00:26:12,080 --> 00:26:14,080
Sounds good.

384
00:26:14,280 --> 00:26:19,680
You mentioned the annotations of Taint sources and Taint sinks and using different layering

385
00:26:19,680 --> 00:26:21,480
than static type checking.

386
00:26:21,480 --> 00:26:22,840
Where do those annotations actually live?

387
00:26:22,840 --> 00:26:26,680
Are they also in line in the code base or does security maintain them elsewhere?

388
00:26:26,680 --> 00:26:28,280
Yeah, so they're elsewhere.

389
00:26:28,280 --> 00:26:33,160
So the given ones are provided as configuration to the Taint analyzer and the other ones are

390
00:26:33,160 --> 00:26:35,460
inferred dynamically as the Taint analyzer runs.

391
00:26:35,460 --> 00:26:38,640
So these aren't actually in line in code.

392
00:26:38,640 --> 00:26:41,080
They're not exposed to application engineers at all.

393
00:26:42,080 --> 00:26:50,880
Hi, I was just wondering, in the code I noticed that you had the OS.system marked as a Taint

394
00:26:50,880 --> 00:26:52,680
source with no further annotation.

395
00:26:52,680 --> 00:26:58,480
Are they generics that take a Taint source of a string or do they obliterate the original

396
00:26:58,480 --> 00:26:59,480
annotations?

397
00:26:59,480 --> 00:27:05,080
So they're separate from type annotations entirely and yes, they do actually take parameters

398
00:27:05,080 --> 00:27:08,240
that describe in more detail what that Taint source or sink are.

399
00:27:08,240 --> 00:27:13,160
So for instance, we would say it's user controlled source and the sink we might say is remote

400
00:27:13,160 --> 00:27:15,160
code execution sink.

401
00:27:15,160 --> 00:27:18,920
That way when we actually follow the trace, we have all of the function calls but also

402
00:27:18,920 --> 00:27:24,240
we can determine what kind of vulnerability this might be by the combination.

403
00:27:24,240 --> 00:27:27,440
And they're separate from the annotations, the type annotations.

404
00:27:27,440 --> 00:27:28,440
Thank you.

405
00:27:28,440 --> 00:27:39,440
Hi, could you briefly give some differences between Pyre and MyPy?

406
00:27:39,440 --> 00:27:40,440
Sure.

407
00:27:40,440 --> 00:27:46,440
So they're both type checkers and Pyre was at least like first built as just a type checker.

408
00:27:46,440 --> 00:27:52,440
I don't think, I think the biggest difference is that we extend Pyre to do a lot of the

409
00:27:52,440 --> 00:27:57,440
security-based static analysis and that was the main reason why we wanted to build a different

410
00:27:57,440 --> 00:28:00,440
back end for type checking.

411
00:28:00,440 --> 00:28:05,440
I guess besides that, I think we try to aim for a lot of the same type errors and have

412
00:28:05,440 --> 00:28:08,440
a lot of consistency between what's considered a type error or not.

413
00:28:08,440 --> 00:28:13,440
So we go with the PEP and we try to catch the same set of errors.

414
00:28:13,440 --> 00:28:19,440
So you would not expect it to be too difficult to go from MyPy to Pyre?

415
00:28:19,440 --> 00:28:20,440
No, I don't think so.

416
00:28:20,440 --> 00:28:23,440
I think the set of type errors should be the same.

417
00:28:23,440 --> 00:28:28,440
And if there are any things that are covered or not covered by either of the type checkers,

418
00:28:28,440 --> 00:28:31,440
I think that would be worth flagging and something that we would want to fix.

419
00:28:31,440 --> 00:28:35,440
Thank you.

420
00:28:35,440 --> 00:28:41,440
Hey, so you said that some of your functions in the code base were marked as taking a tainted

421
00:28:41,440 --> 00:28:43,440
input and sanitizing it.

422
00:28:43,440 --> 00:28:50,440
But doesn't the type of sanitizing depend on what sync is using it?

423
00:28:50,440 --> 00:28:57,440
So certain functions that are marked as sanitizers will sanitize a specific kind of taint.

424
00:28:57,440 --> 00:29:02,440
So it's true that maybe you have a sanitizer that's like a privacy check and user controlled

425
00:29:02,440 --> 00:29:03,440
inputs flowing through that.

426
00:29:03,440 --> 00:29:04,440
It doesn't matter.

427
00:29:04,440 --> 00:29:08,440
It won't sanitize that kind of taint from the object.

428
00:29:08,440 --> 00:29:13,440
So that's kind of similar to the previous question about whether there are parameters

429
00:29:13,440 --> 00:29:16,440
on those sources and syncs and on taint.

430
00:29:16,440 --> 00:29:17,440
And yes, there are.

431
00:29:17,440 --> 00:29:20,440
So it would differentiate in that way.

432
00:29:20,440 --> 00:29:26,440
So what I meant was even if you were sanitizing for like a shell injection attack, wouldn't

433
00:29:26,440 --> 00:29:32,440
the nature of how you sanitize that depend on the exact function that was using that

434
00:29:32,440 --> 00:29:33,440
string?

435
00:29:33,440 --> 00:29:39,440
You mean certain syncs might not actually consider this to be sanitized?

436
00:29:39,440 --> 00:29:40,440
Oh, yeah.

437
00:29:40,440 --> 00:29:43,440
So if that were the case, we would probably want to model that taint as something slightly

438
00:29:43,440 --> 00:29:44,440
different.

439
00:29:44,440 --> 00:29:50,440
So I don't think the sanitizer itself is aware of what the syncs are or what they're looking

440
00:29:50,440 --> 00:29:51,440
for.

441
00:29:51,440 --> 00:29:52,440
But if the taint...

442
00:29:52,440 --> 00:29:56,440
That seems to imply that the nature of taint is slightly different there for different

443
00:29:56,440 --> 00:29:57,440
syncs.

444
00:29:57,440 --> 00:29:59,440
So we just use different taint objects.

445
00:30:03,440 --> 00:30:06,440
Unfortunately, we're going to have to wrap up the questions here.

446
00:30:06,440 --> 00:30:09,440
But I believe Shannon and the rest of the PIER team are willing to answer questions outside

447
00:30:09,440 --> 00:30:10,440
the hall.

448
00:30:10,440 --> 00:30:12,440
Thank you so much, Shannon.

449
00:30:12,440 --> 00:30:13,440
Thank you.

