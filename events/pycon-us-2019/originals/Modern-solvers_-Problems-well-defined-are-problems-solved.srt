1
00:00:00,000 --> 00:00:03,120
Full room, thank you very much.

2
00:00:03,120 --> 00:00:04,680
It's nice to see you all.

3
00:00:04,680 --> 00:00:05,840
Welcome to PyCon.

4
00:00:05,840 --> 00:00:07,440
Thanks for inviting me.

5
00:00:07,440 --> 00:00:14,120
I've been waiting for a long time to do this.

6
00:00:14,120 --> 00:00:16,000
Live long and prosper.

7
00:00:16,000 --> 00:00:19,400
Peace and long life.

8
00:00:19,400 --> 00:00:24,160
43 years have I waited for that.

9
00:00:24,160 --> 00:00:27,480
There it was.

10
00:00:27,480 --> 00:00:28,760
I was a young man.

11
00:00:28,760 --> 00:00:31,240
I saw a show that inspired me.

12
00:00:31,240 --> 00:00:33,000
This fellow is Spock.

13
00:00:33,000 --> 00:00:34,600
They have a terrible problem.

14
00:00:34,600 --> 00:00:36,880
They have a smart computer.

15
00:00:36,880 --> 00:00:40,000
Kirk was assessing the danger of the problem.

16
00:00:40,000 --> 00:00:41,760
What was the nature of it?

17
00:00:41,760 --> 00:00:46,080
And Spock said something that inspired me for the rest of my life.

18
00:00:46,080 --> 00:00:49,560
What was the M5 computer?

19
00:00:49,560 --> 00:00:53,320
The multi-tronic computer made by Dr. Deistrom.

20
00:00:53,320 --> 00:00:59,360
It is the human mind amplified by the instantaneous relays possible in a computer.

21
00:00:59,360 --> 00:01:06,520
And it sent chills down my spine.

22
00:01:06,520 --> 00:01:11,720
It wasn't a great episode.

23
00:01:11,720 --> 00:01:13,720
But that sentence was important.

24
00:01:13,720 --> 00:01:17,200
And to me it wasn't about the Dr. Deistrom computer.

25
00:01:17,200 --> 00:01:21,900
The more interesting part is the human mind being amplified by the instantaneous relays

26
00:01:21,900 --> 00:01:23,340
of the computer.

27
00:01:23,340 --> 00:01:26,100
Can we use our machines to make ourselves smarter?

28
00:01:26,100 --> 00:01:29,540
We've waited a long time to have that happen.

29
00:01:29,540 --> 00:01:31,500
Algorithms have been around for a long time.

30
00:01:31,500 --> 00:01:39,860
Depth first search, breadth first search, Monte Carlo tree search, graph traversal algorithms.

31
00:01:39,860 --> 00:01:43,020
Over 30 years ago I was reading books on neural networks.

32
00:01:43,020 --> 00:01:44,980
None of these things are new.

33
00:01:44,980 --> 00:01:45,980
What has changed?

34
00:01:45,980 --> 00:01:48,540
They have been put together in interesting ways.

35
00:01:48,540 --> 00:01:50,340
The algorithms have become smarter.

36
00:01:50,340 --> 00:01:53,300
Our computation power has become massive.

37
00:01:53,300 --> 00:01:55,660
And these machines have gotten smart.

38
00:01:55,660 --> 00:02:01,420
And so we have a new way that we can program that we didn't have available to us before.

39
00:02:01,420 --> 00:02:06,460
And so the theme of the talk is instead of writing programs, we write descriptions of

40
00:02:06,460 --> 00:02:10,060
the problem and then let solvers go solve them.

41
00:02:10,060 --> 00:02:12,220
And I think we live in a wonderful time.

42
00:02:12,220 --> 00:02:14,100
It's a great time to be alive.

43
00:02:14,100 --> 00:02:18,660
And I'd like to show you some of these tools.

44
00:02:18,660 --> 00:02:24,020
Actually the best way to show them is not with real world applications, is to show games

45
00:02:24,020 --> 00:02:28,660
or puzzles or toy problems.

46
00:02:28,660 --> 00:02:33,060
To the extent that these tools can solve those problems, they can also solve our real world

47
00:02:33,060 --> 00:02:34,640
problems.

48
00:02:34,640 --> 00:02:36,980
So I'd like you to use your imagination a little bit.

49
00:02:36,980 --> 00:02:41,300
If I show you the solution to a puzzle, we have to mentally translate that to something

50
00:02:42,300 --> 00:02:50,100
interesting, which is optimizing our programs, finding bugs in multithreaded code, et cetera.

51
00:02:50,100 --> 00:02:53,420
So without further ado, I will take you through.

52
00:02:53,420 --> 00:02:55,060
Let's do a quick intro.

53
00:02:55,060 --> 00:02:56,460
Where are we headed?

54
00:02:56,460 --> 00:03:00,260
Problems to find or wills solved?

55
00:03:00,260 --> 00:03:03,980
I found something on the net that said things better than I could say them, so I'll just

56
00:03:03,980 --> 00:03:06,660
put it up on the screen.

57
00:03:06,660 --> 00:03:12,500
Actually it's easier to make rules than to find a way to follow them.

58
00:03:12,500 --> 00:03:18,660
So sometimes if you just have a description of a problem, it automatically gives a solution

59
00:03:18,660 --> 00:03:21,340
if we put it into a solution finder.

60
00:03:21,340 --> 00:03:24,460
So the tour I'm going to give you is I have a lot of stuff to cover.

61
00:03:24,460 --> 00:03:27,200
I'm going to show you depth first and breadth first search.

62
00:03:27,200 --> 00:03:30,360
That doesn't sound interesting, but it is in fact powerful.

63
00:03:30,360 --> 00:03:33,900
The next step up in capabilities is called SAT solvers.

64
00:03:33,900 --> 00:03:35,380
In a way it's kind of boring.

65
00:03:35,380 --> 00:03:40,500
It's following truth tables, but once the truth tables become really large, they become

66
00:03:40,500 --> 00:03:42,220
very, very powerful.

67
00:03:42,220 --> 00:03:45,020
So I'd like to show you what they're capable of and how to access them from the Python

68
00:03:45,020 --> 00:03:46,020
world.

69
00:03:46,020 --> 00:03:48,480
Reinforcement learning is a very simple concept.

70
00:03:48,480 --> 00:03:50,700
We do it to ourselves all of the time.

71
00:03:50,700 --> 00:03:51,980
We've taught machines how to do it.

72
00:03:51,980 --> 00:03:55,860
I'll show the simple algorithm for that.

73
00:03:55,860 --> 00:03:58,820
Then I'll take you into a space probably a lot of you have never been into.

74
00:03:58,820 --> 00:04:02,180
How many of you have heard of TLA plus?

75
00:04:02,180 --> 00:04:03,180
This is fantastic.

76
00:04:03,180 --> 00:04:05,340
It is actually becoming more popular as we speak.

77
00:04:05,340 --> 00:04:08,380
A year ago possibly no one in this room would have heard of it.

78
00:04:08,380 --> 00:04:12,220
How many of you have used Z3?

79
00:04:12,220 --> 00:04:13,220
My work is done here.

80
00:04:13,220 --> 00:04:14,220
All right.

81
00:04:14,220 --> 00:04:16,380
You guys are ahead of the game.

82
00:04:16,380 --> 00:04:23,180
Then the next step up in complexity is can we combine all of those tools together and

83
00:04:23,180 --> 00:04:28,020
Monte Carlo tree search, convolutional neural networks, and reinforcement learnings to defeat

84
00:04:28,020 --> 00:04:30,940
human beings.

85
00:04:30,940 --> 00:04:37,540
So we'll talk about AlphaZero, which is an amazing, amazing accomplishment.

86
00:04:37,540 --> 00:04:44,060
So what to keep in mind as we explore is one, how little code is needed to express these

87
00:04:44,060 --> 00:04:45,100
ideas.

88
00:04:45,100 --> 00:04:48,180
Number two is how generic the tooling is.

89
00:04:48,180 --> 00:04:55,420
What is great about all of these problems is that the best solutions to these problems

90
00:04:55,420 --> 00:04:58,020
weren't custom designed for the problem.

91
00:04:58,060 --> 00:05:03,860
The custom designed solutions in the end got outclassed by the generic solutions.

92
00:05:03,860 --> 00:05:06,060
So keep that in mind as we go along.

93
00:05:06,060 --> 00:05:10,500
The generic tool is more powerful than the specific tool.

94
00:05:10,500 --> 00:05:16,300
Then also keep in mind, I'll show you fun toy problems, but these problems will be at

95
00:05:16,300 --> 00:05:21,700
the periphery of human capability, the outer limits of our ability to think, which is great

96
00:05:21,700 --> 00:05:25,860
because if we can take a computer that far by amping up the computational power, we can

97
00:05:25,860 --> 00:05:31,340
take it beyond our own abilities, achieving the goal that Spock had laid out for us.

98
00:05:31,340 --> 00:05:34,060
That said, that episode was a cautionary tale.

99
00:05:34,060 --> 00:05:37,780
We'll talk about that a little bit at the end to see where this all ends up.

100
00:05:37,780 --> 00:05:43,700
Do we all die or do we all reap the benefits of AI as we go along?

101
00:05:43,700 --> 00:05:45,300
We'll explore that at the end.

102
00:05:45,300 --> 00:05:46,300
All right.

103
00:05:46,300 --> 00:05:49,420
First thing, depth first search, breadth first search.

104
00:05:49,420 --> 00:05:52,340
Do those diagrams speak for themselves?

105
00:05:52,340 --> 00:05:54,340
Depth first, which way does it go first?

106
00:05:54,820 --> 00:05:55,820
Down or sideways?

107
00:05:55,820 --> 00:05:58,820
Down, which is why it's called?

108
00:05:58,820 --> 00:05:59,820
I see.

109
00:05:59,820 --> 00:06:00,820
Okay.

110
00:06:00,820 --> 00:06:01,820
Breadth first.

111
00:06:01,820 --> 00:06:02,820
Which way does it go?

112
00:06:02,820 --> 00:06:03,820
Okay.

113
00:06:03,820 --> 00:06:07,980
So different types of problems warrant one solution or the other.

114
00:06:07,980 --> 00:06:13,020
Often if you're trying to find the shortest path to a solution, you do breadth first search.

115
00:06:13,020 --> 00:06:17,300
However, you'll find the Monte Carlo tree search, the tools that were used in Alpha

116
00:06:17,300 --> 00:06:20,820
Zero for example, do a depth first search.

117
00:06:20,820 --> 00:06:26,980
They play out an entire game of chess several times and then go back and decide based on

118
00:06:26,980 --> 00:06:31,060
how the game turned out what move to make.

119
00:06:31,060 --> 00:06:36,380
What tool do you need in Python in order to implement a depth first search or breadth

120
00:06:36,380 --> 00:06:39,980
first search?

121
00:06:39,980 --> 00:06:41,700
Does anybody know?

122
00:06:41,700 --> 00:06:42,700
It's going to be kind of a search.

123
00:06:42,700 --> 00:06:45,340
I don't want to give any hints here at all.

124
00:06:45,340 --> 00:06:46,340
Okay.

125
00:06:46,340 --> 00:06:51,660
So collections deck is a tool that works really great for this.

126
00:06:51,660 --> 00:06:57,620
You decide whether new tasks should be prepended to the queue for depth first or appended to

127
00:06:57,620 --> 00:06:59,460
the queue for breadth first search.

128
00:06:59,460 --> 00:07:00,820
It's actually very easy code.

129
00:07:00,820 --> 00:07:04,940
By the way, everything I'm going to show you I'm giving you code for.

130
00:07:04,940 --> 00:07:09,860
When these slides go up, you can run all of the examples including the chess program.

131
00:07:09,860 --> 00:07:10,860
Sound good?

132
00:07:10,860 --> 00:07:11,860
All right.

133
00:07:11,860 --> 00:07:12,860
All right.

134
00:07:13,860 --> 00:07:17,860
Once upon a time, many years ago, I wrote a generic puzzle solver.

135
00:07:17,860 --> 00:07:20,980
It solves a broad class of puzzles.

136
00:07:20,980 --> 00:07:22,540
Here's the core idea.

137
00:07:22,540 --> 00:07:26,740
The puzzle solver doesn't know anything about the puzzle.

138
00:07:26,740 --> 00:07:29,220
All it knows is how to solve puzzles.

139
00:07:29,220 --> 00:07:36,380
So the puzzle solver, the way it's used is we subclass the solver and we add in some

140
00:07:36,380 --> 00:07:37,660
extra information.

141
00:07:37,660 --> 00:07:40,340
What is the initial position of the puzzle?

142
00:07:40,420 --> 00:07:43,760
What is a rule to generate all the possible moves from the next position?

143
00:07:43,760 --> 00:07:45,660
What moves can I make?

144
00:07:45,660 --> 00:07:47,180
And are we at the goal?

145
00:07:47,180 --> 00:07:50,740
Keep in mind the solver knows nothing about the nature of the game.

146
00:07:50,740 --> 00:07:52,520
It just says where do you start?

147
00:07:52,520 --> 00:07:53,660
What can you do?

148
00:07:53,660 --> 00:07:55,060
Where are you trying to get to?

149
00:07:55,060 --> 00:07:56,660
I'll take you there.

150
00:07:56,660 --> 00:07:58,540
That's fantastic.

151
00:07:58,540 --> 00:08:00,300
You can throw in some extras.

152
00:08:00,300 --> 00:08:06,440
A nice repper will make the output of the puzzle recognizable to us.

153
00:08:06,440 --> 00:08:12,160
Some problems have complementary explosion and that can be managed sometimes through

154
00:08:12,160 --> 00:08:14,000
exploiting symmetry.

155
00:08:14,000 --> 00:08:18,080
So there is a way to exploit some positions that are considered equivalent.

156
00:08:18,080 --> 00:08:22,920
For example, in Tic-Tac-Toe, if you start a game in the upper left corner, it's isomorphic

157
00:08:22,920 --> 00:08:26,480
to a game where you start in the lower right-hand corner.

158
00:08:26,480 --> 00:08:31,760
So we can teach the computer to recognize that those positions are the same.

159
00:08:31,760 --> 00:08:33,880
And that speeds up the solution.

160
00:08:33,880 --> 00:08:36,920
Neither of these two things are required to get a solution.

161
00:08:36,920 --> 00:08:40,640
They either just make it faster or they make it look prettier.

162
00:08:40,640 --> 00:08:44,280
So here's a classic simple problem.

163
00:08:44,280 --> 00:08:49,960
Given these two empty jugs with three and five liter capacities and a full liter jug

164
00:08:49,960 --> 00:08:55,320
with eight liters, find a sequence of pours so that you get four liters and the two largest

165
00:08:55,320 --> 00:08:56,320
jugs.

166
00:08:56,320 --> 00:08:59,740
The purpose of this example is to show how to use the solver.

167
00:08:59,740 --> 00:09:05,440
We import the puzzle, subclass the puzzle, and describe the problem.

168
00:09:05,440 --> 00:09:10,500
And so we give it an initial position, zero liters, zero liters, and eight liters.

169
00:09:10,500 --> 00:09:11,940
We put in some constraints.

170
00:09:11,940 --> 00:09:13,980
What's the capacity of each jug?

171
00:09:13,980 --> 00:09:14,980
And what's the goal?

172
00:09:14,980 --> 00:09:17,420
Four liters, four liters, and zero.

173
00:09:17,420 --> 00:09:19,740
The interesting part is the iterator here.

174
00:09:19,740 --> 00:09:24,460
It's not the clearest code I've ever written, but it gets the job done and it's short, sweet,

175
00:09:24,460 --> 00:09:26,000
and easy to test.

176
00:09:26,000 --> 00:09:31,480
So given a position, if you run the iterator, it generates for you what is the next possible

177
00:09:31,480 --> 00:09:33,600
position, what pours are possible.

178
00:09:33,600 --> 00:09:38,960
So from this initial position, you can pour the eight ounce jug into the five, leaving

179
00:09:38,960 --> 00:09:44,380
three, or you can pour the eight ounce into the three, leaving five.

180
00:09:44,380 --> 00:09:48,740
And so this generator generates those two possible positions.

181
00:09:48,740 --> 00:09:53,720
The interesting thing I think about this puzzle problem is this solver didn't know anything

182
00:09:53,720 --> 00:09:55,720
about this puzzle.

183
00:09:55,720 --> 00:10:01,120
When we tell it to run solve, it outputs the example.

184
00:10:01,120 --> 00:10:03,360
So here's how to run it.

185
00:10:03,360 --> 00:10:05,960
We make an instance of jug fill.

186
00:10:05,960 --> 00:10:13,120
We ask what is the initial position, is it the goal, and to loop over what are the possible

187
00:10:13,120 --> 00:10:14,120
moves.

188
00:10:14,120 --> 00:10:18,360
But if you run the solve method, it starts, picks one of those moves, and it finds the

189
00:10:18,360 --> 00:10:21,000
shortest path solution to that problem.

190
00:10:21,000 --> 00:10:22,480
Now this is an easy problem.

191
00:10:22,480 --> 00:10:26,040
This is the kind of problem you give to a fifth grader and let them toy out and learn

192
00:10:26,040 --> 00:10:27,320
a little bit of math.

193
00:10:27,320 --> 00:10:32,320
But if you start to throw 10, 20, 30 jugs in there, it becomes an enormously complex

194
00:10:32,320 --> 00:10:38,520
problem, isomorphic to the knapsack problem, a very hard problem, a problem that quickly

195
00:10:38,520 --> 00:10:42,660
exceeds the limits of human capability, and actually at some point exceeds the limits

196
00:10:42,660 --> 00:10:45,640
of our computational power as well.

197
00:10:45,640 --> 00:10:50,200
In other words, while this was a cute problem, when you scale it up to a harder problem,

198
00:10:50,200 --> 00:10:54,960
it becomes really interesting, such as optimizing a program.

199
00:10:54,960 --> 00:10:58,320
Everybody get the basic idea of how the generic puzzle solver works.

200
00:10:58,320 --> 00:11:02,000
Describe the puzzle, it gives you the answer, which is the theme.

201
00:11:02,000 --> 00:11:06,040
Describe the problem, and the solver solves it for you.

202
00:11:06,040 --> 00:11:11,540
So there's another interesting puzzle going back into my history here that also dates

203
00:11:11,540 --> 00:11:14,320
to about the time I saw that Star Trek episode.

204
00:11:14,320 --> 00:11:18,000
There was a puzzle that looked like this with different colored pieces at my grandfather's

205
00:11:18,000 --> 00:11:19,000
house.

206
00:11:19,000 --> 00:11:24,240
I called him Paw, so I have labeled this code the Paw Puzzle.

207
00:11:24,240 --> 00:11:29,560
What was interesting to me about this puzzle is not so much what the puzzle was itself.

208
00:11:29,560 --> 00:11:32,600
The puzzle was to slide the blocks around and take this big block.

209
00:11:32,600 --> 00:11:35,360
By the way, can you see my arrow?

210
00:11:35,360 --> 00:11:36,360
Yes.

211
00:11:36,360 --> 00:11:41,560
Take the big block and cause it to be in the lower left position, which sounds pretty easy.

212
00:11:41,560 --> 00:11:47,360
The fascinating thing to me about this puzzle is my grandfather was a fairly smart man,

213
00:11:47,360 --> 00:11:52,080
knew lots of other smart people who liked to come over to his house and they'd find

214
00:11:52,080 --> 00:11:54,240
the puzzle and all attempt to work it.

215
00:11:54,240 --> 00:11:59,920
I have never met another human being ever in my entire life who was able to solve this

216
00:11:59,920 --> 00:12:01,120
puzzle.

217
00:12:01,120 --> 00:12:06,360
The only person I've met in my entire life who was ever able to solve the puzzle was

218
00:12:06,360 --> 00:12:09,360
me.

219
00:12:09,360 --> 00:12:12,440
Would you like to know how I did it?

220
00:12:12,440 --> 00:12:13,680
I wrote a computer program.

221
00:12:14,120 --> 00:12:19,920
One of my first computer programs was written in BASIC that solved this puzzle in much the

222
00:12:19,920 --> 00:12:23,240
same way that I am solving it now.

223
00:12:23,240 --> 00:12:26,600
Only when I saw the solution did I realize why it was hard.

224
00:12:26,600 --> 00:12:31,000
The combinations spread out quite a bit, but they loop back to each other and it makes

225
00:12:31,000 --> 00:12:34,080
this very tight graph with one little exit door.

226
00:12:34,080 --> 00:12:37,520
If you don't know that you're at the exit door, you pass it up.

227
00:12:37,520 --> 00:12:42,360
If you go through that exit door, it opens up to another graph that has lots of positions

228
00:12:42,440 --> 00:12:46,240
that can cause you to go back to the original state, but it has an exit door.

229
00:12:46,240 --> 00:12:50,560
If you don't find it, you stay inside that little loop.

230
00:12:50,560 --> 00:12:52,960
Then there's another exit door on the other side.

231
00:12:52,960 --> 00:12:56,200
There's an enormous number of moves in the solution.

232
00:12:56,200 --> 00:13:01,320
Well, at least for a puzzle that looks as simple as surprising, the solution is about

233
00:13:01,320 --> 00:13:02,920
80 moves.

234
00:13:02,920 --> 00:13:08,080
Essentially, all I needed to do was to come up with a representation for the position.

235
00:13:08,120 --> 00:13:13,080
In this case, I've got a nice wrapper that will print this out in a block form so we

236
00:13:13,080 --> 00:13:16,800
could recognize the piece numbers of the puzzle.

237
00:13:16,800 --> 00:13:21,400
Then for the goal, I used a regular expression and said, if the one block ends up in this

238
00:13:21,400 --> 00:13:23,680
position, we've solved the puzzle.

239
00:13:23,680 --> 00:13:28,520
In other words, it needs to know where do I start, have I achieved my goal?

240
00:13:28,520 --> 00:13:30,920
The more interesting part is the iterator.

241
00:13:30,920 --> 00:13:36,080
Again, not the most beautiful code I've ever written, but this is about 15-year-old code

242
00:13:36,080 --> 00:13:37,920
for me.

243
00:13:37,920 --> 00:13:43,840
There's a couple updates that are inside, but mostly it was originally written.

244
00:13:43,840 --> 00:13:47,520
This tiny bit of code that describes the problem solves it.

245
00:13:47,520 --> 00:13:56,480
Let's see if I actually got this up here.

246
00:13:56,480 --> 00:14:01,080
You are running Python 3.8, are you not?

247
00:14:01,080 --> 00:14:02,080
It's out.

248
00:14:02,080 --> 00:14:05,000
Alpha, but you can run it now.

249
00:14:05,000 --> 00:14:10,720
This output was, it gave me from the initial position every possible move until you got

250
00:14:10,720 --> 00:14:11,720
to the end.

251
00:14:11,720 --> 00:14:13,360
It's not a particularly pretty output.

252
00:14:13,360 --> 00:14:16,600
That said, without the wrapper, each one of these would have been on one line.

253
00:14:16,600 --> 00:14:18,840
That was about 88 moves.

254
00:14:18,840 --> 00:14:24,120
It makes very short work of a problem that as far as I know, no smart human I've ever

255
00:14:24,120 --> 00:14:25,920
met has been able to solve this problem.

256
00:14:25,920 --> 00:14:29,760
You guys get the theme of where we're going, describe the problem, solver solves it.

257
00:14:30,760 --> 00:14:35,280
first search are amazingly powerful.

258
00:14:35,280 --> 00:14:39,920
Did the world get more interesting after tools like that came out?

259
00:14:39,920 --> 00:14:42,960
Yes, SAT solvers.

260
00:14:42,960 --> 00:14:46,920
Is it okay if I get technical at a technical conference?

261
00:14:46,920 --> 00:14:48,560
Can I get all technical on you?

262
00:14:48,560 --> 00:14:53,500
If I show you a little math that reminds you of your worst days in college, are you going

263
00:14:53,500 --> 00:14:56,000
to get up and leave?

264
00:14:56,000 --> 00:14:59,200
Here we go, a SAT solver.

265
00:14:59,200 --> 00:15:05,720
SAT is spelled in all caps, it's for satisfiability problems.

266
00:15:05,720 --> 00:15:10,520
The idea is it solves problems that are specified using propositional logic formulas.

267
00:15:10,520 --> 00:15:12,680
Most people start running at this point.

268
00:15:12,680 --> 00:15:17,240
The idea of a propositional logic formula is you take a problem statement.

269
00:15:17,240 --> 00:15:22,800
If our tire's flat when I remove it, then I will have to remove it and take it to the

270
00:15:22,800 --> 00:15:24,480
gas station.

271
00:15:24,480 --> 00:15:29,120
Our first step is to translate that into logic statements.

272
00:15:29,120 --> 00:15:35,920
So take each phrase and assign a letter to it, P, Q, and R for each of the predicates

273
00:15:35,920 --> 00:15:39,080
in the solution.

274
00:15:39,080 --> 00:15:41,360
Write it in symbolic form.

275
00:15:41,360 --> 00:15:43,040
This is not hard to do.

276
00:15:43,040 --> 00:15:44,600
Most of you have forgotten how to do it.

277
00:15:44,600 --> 00:15:49,180
But if you'd like to use these tools, you need to recover that knowledge.

278
00:15:49,180 --> 00:15:53,640
Use these slides as something that takes you through step by step and will let you reacquire

279
00:15:53,640 --> 00:15:55,400
the necessary knowledge.

280
00:15:55,400 --> 00:15:58,840
So here's the truth table for that.

281
00:15:58,840 --> 00:16:01,960
In these statements, is this one true?

282
00:16:01,960 --> 00:16:08,040
So in the truth table, our states are essentially these first three columns.

283
00:16:08,040 --> 00:16:11,800
Our output state is the last column.

284
00:16:11,800 --> 00:16:18,400
What SAT does is ask the question, on the right column, are any of the outputs a T?

285
00:16:18,400 --> 00:16:20,240
Are they true?

286
00:16:20,240 --> 00:16:25,920
And not all SAT solvers, but most of them, can give you an example of a row where a T

287
00:16:25,920 --> 00:16:28,280
is true.

288
00:16:28,280 --> 00:16:32,160
That doesn't sound particularly interesting because we could just loop over these and

289
00:16:32,160 --> 00:16:34,240
find a T and print it out.

290
00:16:34,240 --> 00:16:36,120
Does that sound powerful?

291
00:16:36,120 --> 00:16:38,400
It does not sound powerful.

292
00:16:38,400 --> 00:16:41,080
And this problem is not very interesting.

293
00:16:41,080 --> 00:16:45,520
Where it becomes interesting is these tables, the size of this is with three variables,

294
00:16:45,520 --> 00:16:48,620
we got two to the third power, eight rows.

295
00:16:48,620 --> 00:16:55,880
So if you have 10 variables, you're at two to the tenth, looking at about a million rows.

296
00:16:55,880 --> 00:17:00,960
If you have 20 variables, you start to go up again by square root of that again, and

297
00:17:00,960 --> 00:17:03,240
30 you're up into billions.

298
00:17:03,240 --> 00:17:04,800
So what if you had a thousand variables?

299
00:17:04,800 --> 00:17:07,760
Would the problem become complex?

300
00:17:07,760 --> 00:17:12,000
There are more states than there are atoms in the universe.

301
00:17:12,000 --> 00:17:15,000
Does that sound computationally tractable?

302
00:17:15,000 --> 00:17:17,000
It is an intractable problem.

303
00:17:17,000 --> 00:17:19,240
It is provable that it's intractable.

304
00:17:19,240 --> 00:17:23,440
But most real world problems have symmetries and patterns inside.

305
00:17:23,480 --> 00:17:25,800
And so we live in a great time.

306
00:17:25,800 --> 00:17:30,160
During the course of my lifetime, every year somebody has attacked this problem and said,

307
00:17:30,160 --> 00:17:34,560
are there little patterns inside that we can exploit in real world problems?

308
00:17:34,560 --> 00:17:38,300
And every year, SAT solvers have gotten smarter.

309
00:17:38,300 --> 00:17:40,800
Not a little smarter, a lot smarter.

310
00:17:40,800 --> 00:17:45,800
It is not uncommon now for people to run SAT problems with over a million variables and

311
00:17:45,800 --> 00:17:47,680
have it find a solution.

312
00:17:47,680 --> 00:17:48,680
This is astonishing.

313
00:17:49,160 --> 00:17:55,160
It reminds me of Asimov saying, any sufficiently advanced technology is indistinguishable from

314
00:17:55,160 --> 00:17:56,160
magic.

315
00:17:56,160 --> 00:18:01,120
It is magic that we can find answers to these problems.

316
00:18:01,120 --> 00:18:02,560
So why do we care?

317
00:18:02,560 --> 00:18:07,200
There's many otherwise really difficult problems that we can solve.

318
00:18:07,200 --> 00:18:13,320
Our amazing fact now is that this problem is now tractable for thousands or even millions

319
00:18:13,320 --> 00:18:14,720
of variables.

320
00:18:14,720 --> 00:18:17,800
So what do you need in order to do this in Python?

321
00:18:17,800 --> 00:18:22,320
There's a tool called Picosat and an interface to it in Python called Picosat.

322
00:18:22,320 --> 00:18:23,320
It's not the only solver.

323
00:18:23,320 --> 00:18:25,640
There's a number of them out there.

324
00:18:25,640 --> 00:18:29,960
And in order to use these tools, you have to sound like a mathematician.

325
00:18:29,960 --> 00:18:33,240
You have to say things like, conjunctive normal form with straight face.

326
00:18:33,240 --> 00:18:34,240
Try it all now.

327
00:18:34,240 --> 00:18:36,960
Without cracking a smile, say conjunctive normal form.

328
00:18:36,960 --> 00:18:37,960
Okay.

329
00:18:37,960 --> 00:18:42,960
Which just means a product of sums and and of r's.

330
00:18:42,960 --> 00:18:45,760
So here's an and, here's some r's.

331
00:18:45,760 --> 00:18:51,160
And so that was that original problem statement, the previous expression, rewritten in conjunctive

332
00:18:51,160 --> 00:18:54,440
normal form.

333
00:18:54,440 --> 00:19:02,200
In the SAT solvers, it's common to write the negative case, negative p, as a minus one

334
00:19:02,200 --> 00:19:06,960
and the positive case as a positive one.

335
00:19:06,960 --> 00:19:12,720
And in the second variable, this would be a positive two and this would be a negative

336
00:19:12,720 --> 00:19:15,040
one.

337
00:19:15,040 --> 00:19:20,800
So in Picosat, we describe this problem with this list.

338
00:19:20,800 --> 00:19:24,120
Minus one two and minus one three.

339
00:19:24,120 --> 00:19:25,480
Doesn't look very humanistic.

340
00:19:25,480 --> 00:19:29,680
And the output is this, which is the five true states.

341
00:19:29,680 --> 00:19:30,960
Fair enough?

342
00:19:30,960 --> 00:19:31,960
Okay.

343
00:19:31,960 --> 00:19:35,700
So all that did was you described the problem and it went through the output.

344
00:19:35,700 --> 00:19:37,720
That doesn't seem impressive.

345
00:19:37,720 --> 00:19:43,120
So our core challenge in working with this tool is to take things like this that are

346
00:19:43,120 --> 00:19:46,060
not humanistic and make them more humanistic.

347
00:19:46,060 --> 00:19:47,620
It doesn't ship with such a tool.

348
00:19:47,620 --> 00:19:50,460
So I wrote one and I'm giving it to you.

349
00:19:50,460 --> 00:19:55,700
It's not a lot of code, but essentially takes phrases that we can understand and translates

350
00:19:55,700 --> 00:19:58,200
them into this.

351
00:19:58,200 --> 00:20:04,540
In particular, if my translate function says let's rewrite that input as not p and q and

352
00:20:04,540 --> 00:20:07,080
not p and r.

353
00:20:07,080 --> 00:20:09,780
And it translates it into these numbers for you.

354
00:20:09,780 --> 00:20:13,080
Does that sound like an improvement?

355
00:20:14,080 --> 00:20:17,720
Interestingly, it's kind of difficult sometimes to get things into conjunctive normal form.

356
00:20:17,720 --> 00:20:20,600
We actually start normally with something like this.

357
00:20:20,600 --> 00:20:21,800
Disjunctive normal form.

358
00:20:21,800 --> 00:20:24,280
And turning one into another is an absolute pain.

359
00:20:24,280 --> 00:20:27,360
Wouldn't it be nice to have a computer do that for you?

360
00:20:27,360 --> 00:20:32,160
So I wrote a function called from DNF.

361
00:20:32,160 --> 00:20:36,240
That converts this one into this one.

362
00:20:36,240 --> 00:20:38,920
And then the translate turns it back into this number.

363
00:20:38,920 --> 00:20:42,440
In other words, it takes something you can understand and turns it into something the

364
00:20:42,440 --> 00:20:44,920
machine can understand.

365
00:20:44,920 --> 00:20:49,920
And so to make this all pico-sat readable, here's a problem input we can understand and

366
00:20:49,920 --> 00:20:52,960
an output we can understand.

367
00:20:52,960 --> 00:20:55,800
That said, it's better to not use variable names like p, q, and r.

368
00:20:55,800 --> 00:20:59,800
How about flat tire, need to remove, and go to gas station?

369
00:20:59,800 --> 00:21:01,960
And here's all of the true conditions.

370
00:21:01,960 --> 00:21:04,080
Is that a little bit better?

371
00:21:04,080 --> 00:21:05,320
So I'm giving you these tools.

372
00:21:05,320 --> 00:21:06,360
I hope you use them.

373
00:21:06,360 --> 00:21:08,440
You can run all of this code.

374
00:21:08,440 --> 00:21:12,260
So I wrote some higher level convenience functions.

375
00:21:12,260 --> 00:21:16,140
Some of says at least one of these is true.

376
00:21:16,140 --> 00:21:19,700
One of says exactly one of these is true.

377
00:21:19,700 --> 00:21:27,520
And a quantifier says the quantity of trues in this case is less than or equal to one.

378
00:21:27,520 --> 00:21:31,380
And it turns out that's a really nice input form because lots of problems fall into that

379
00:21:31,380 --> 00:21:33,300
format.

380
00:21:33,300 --> 00:21:40,780
So I think at every point people get curious about machine learning and solvers.

381
00:21:40,780 --> 00:21:42,980
At some point you write a Sudoku solver.

382
00:21:42,980 --> 00:21:44,340
It's not a difficult thing.

383
00:21:44,340 --> 00:21:46,140
Actually, I'd like to poll here.

384
00:21:46,140 --> 00:21:48,380
How many of you have written a Sudoku solver?

385
00:21:48,380 --> 00:21:49,380
Okay.

386
00:21:49,380 --> 00:21:50,380
Lots of you.

387
00:21:50,380 --> 00:21:51,960
And I wrote one a long time ago.

388
00:21:51,960 --> 00:21:54,820
This is not about that.

389
00:21:54,820 --> 00:21:58,020
I reject my earlier Sudoku solver.

390
00:21:58,020 --> 00:22:02,440
No matter how much effort I put into it, I cannot make it as good as this one.

391
00:22:02,440 --> 00:22:06,620
We have a generic solver that's been polished every year, year after year.

392
00:22:06,620 --> 00:22:10,540
There's conferences where people devote themselves to making small improvements to the underlying

393
00:22:10,540 --> 00:22:11,540
solver.

394
00:22:11,540 --> 00:22:17,460
And if I want to have a good solution to, let's say, a very complex Sudoku, 100 by 100,

395
00:22:17,460 --> 00:22:21,520
which is something that most of your solvers would fail on, all I need to do is describe

396
00:22:21,520 --> 00:22:27,600
the problem, hand it to a really bad-ass solver, and let it make short work of the problem.

397
00:22:27,600 --> 00:22:30,980
So the interesting part is not us writing a Sudoku solver.

398
00:22:30,980 --> 00:22:35,340
Our interesting problem is we describe it and the solver solves it for us.

399
00:22:35,340 --> 00:22:40,820
So this particular puzzle, we can enter it in row major order like this.

400
00:22:40,820 --> 00:22:42,620
That's just my representation.

401
00:22:42,620 --> 00:22:46,720
And our expectation is that the computer will solve it, and this is the answer that it actually

402
00:22:46,720 --> 00:22:47,720
gives.

403
00:22:47,720 --> 00:22:51,620
I think I have five such puzzles in here.

404
00:22:51,620 --> 00:22:55,100
Write down 3, 8.

405
00:22:55,100 --> 00:22:56,100
Sudoku.

406
00:22:56,100 --> 00:22:57,100
Bam.

407
00:22:57,100 --> 00:23:03,980
It takes five puzzles, and here's the input puzzle, and then here's the solution for

408
00:23:03,980 --> 00:23:04,980
it.

409
00:23:04,980 --> 00:23:08,180
I don't know all of the source code for that, but I didn't do any logic on this.

410
00:23:08,180 --> 00:23:13,220
I did none of the things that the rest of us did when we made Sudoku solvers.

411
00:23:13,220 --> 00:23:16,600
Instead, I merely described the problem.

412
00:23:16,600 --> 00:23:19,220
What does the grid look like?

413
00:23:19,220 --> 00:23:23,100
How do we fill it out?

414
00:23:23,100 --> 00:23:25,980
Establish facts about a given point.

415
00:23:25,980 --> 00:23:29,280
Most of this is just converting this input and showing how to output.

416
00:23:29,280 --> 00:23:31,460
This is the repr for it.

417
00:23:31,460 --> 00:23:35,260
So the logic part of it is basically this amount of code.

418
00:23:35,260 --> 00:23:39,860
For each point, we said every point is assigned one value.

419
00:23:39,860 --> 00:23:42,180
You can put one number in a box.

420
00:23:42,180 --> 00:23:45,200
Also, one number only goes in one box.

421
00:23:45,200 --> 00:23:49,460
This is a bijection, a one-to-one relationship.

422
00:23:49,460 --> 00:23:51,260
That describes the puzzle generically.

423
00:23:51,260 --> 00:23:53,860
We have an unconstrained puzzle.

424
00:23:53,860 --> 00:23:58,520
The constraint that we have is for a specific puzzle, we have some clues.

425
00:23:58,520 --> 00:24:02,240
What is it that we already know about this puzzle?

426
00:24:02,240 --> 00:24:03,560
Which numbers go where?

427
00:24:03,560 --> 00:24:07,360
So we established the basic fact.

428
00:24:07,360 --> 00:24:12,080
It takes basically five lines of code to completely describe what a Sudoku is.

429
00:24:12,080 --> 00:24:17,520
It takes another two lines to describe a specific Sudoku and then tell it to solve it is, solve

430
00:24:17,520 --> 00:24:18,520
it.

431
00:24:18,520 --> 00:24:19,520
How do you like that?

432
00:24:19,520 --> 00:24:23,880
Was that a little easier than the Sudoku solver that you wrote?

433
00:24:24,720 --> 00:24:28,320
Keep in mind, unlike the one you wrote and the one unlike the one I wrote, this one scales

434
00:24:28,320 --> 00:24:30,880
to enormously hard problems.

435
00:24:30,880 --> 00:24:34,720
So what's up next is the Einstein puzzle.

436
00:24:34,720 --> 00:24:37,600
Who made it?

437
00:24:37,600 --> 00:24:38,600
Who made this puzzle?

438
00:24:38,600 --> 00:24:39,600
Aha.

439
00:24:39,600 --> 00:24:43,240
None of you fell for it.

440
00:24:43,240 --> 00:24:46,800
Reportedly Albert Einstein made this puzzle, but it is not true.

441
00:24:46,800 --> 00:24:51,660
And reportedly he said less than 2% of the population can solve this puzzle.

442
00:24:51,740 --> 00:24:53,980
This is lore, neither fact is true.

443
00:24:53,980 --> 00:24:56,500
That said, it is a rather famous puzzle.

444
00:24:56,500 --> 00:24:57,860
And let's look at the description of it.

445
00:24:57,860 --> 00:25:00,140
There's five houses in unique colors.

446
00:25:00,140 --> 00:25:02,460
Each person has a unique nationality.

447
00:25:02,460 --> 00:25:04,060
Focus in on the word unique.

448
00:25:04,060 --> 00:25:08,780
That means we're going to use the one of function that we mentioned before.

449
00:25:08,780 --> 00:25:11,500
And there's going to be a bijection here like we did before.

450
00:25:11,500 --> 00:25:14,820
Each one of these values is uniquely assigned to a house.

451
00:25:14,820 --> 00:25:18,300
And so this describes the unconstrained problem.

452
00:25:18,300 --> 00:25:21,020
Now we get the constraints.

453
00:25:21,020 --> 00:25:22,340
The Brit lives in the red house.

454
00:25:22,340 --> 00:25:25,900
The Swede keeps dogs as pets.

455
00:25:25,900 --> 00:25:28,140
The greenhouse owner drinks coffee, et cetera.

456
00:25:28,140 --> 00:25:32,180
And the goal is who keeps the fish.

457
00:25:32,180 --> 00:25:34,980
So there's a really nice write up if you're interested in the problem on how to solve

458
00:25:34,980 --> 00:25:36,480
this problem manually.

459
00:25:36,480 --> 00:25:42,580
Something I'm profoundly uninterested in at this point.

460
00:25:42,580 --> 00:25:46,340
What I'm interested in is getting this answer to pop out automatically.

461
00:25:46,340 --> 00:25:48,760
And this is more than just the answer to this question.

462
00:25:48,760 --> 00:25:52,880
It says exactly where every value is assigned to every house.

463
00:25:52,880 --> 00:25:56,560
So the interesting thing, I think, is how we describe the puzzle.

464
00:25:56,560 --> 00:25:59,240
We say what are the house numbers?

465
00:25:59,240 --> 00:26:01,040
What are the various groups?

466
00:26:01,040 --> 00:26:08,420
You'll recognize that these lines correspond exactly to these lines in the problem description.

467
00:26:08,420 --> 00:26:12,160
All we're doing is translating a problem description into code.

468
00:26:12,160 --> 00:26:16,440
And the constraints, things like the Brit lives in a red house.

469
00:26:16,440 --> 00:26:17,440
That comes next.

470
00:26:17,440 --> 00:26:22,320
And we said same house, Brit in red.

471
00:26:22,320 --> 00:26:26,220
In consecutive house, the White House is after the Green House.

472
00:26:26,220 --> 00:26:29,840
And a specific fact, the milk is found at house three.

473
00:26:29,840 --> 00:26:31,960
Now solve it.

474
00:26:31,960 --> 00:26:33,760
There's really nothing more to it than that.

475
00:26:33,760 --> 00:26:35,720
Is that my first 10 or second 10?

476
00:26:35,720 --> 00:26:39,160
Is that my first 10 or second 10?

477
00:26:39,160 --> 00:26:41,320
Okay.

478
00:26:41,320 --> 00:26:43,320
Engage warp drive.

479
00:26:43,320 --> 00:26:45,220
All right.

480
00:26:45,220 --> 00:26:50,220
So I had to write a couple helper functions in order to do this.

481
00:26:50,220 --> 00:26:55,340
That just took my one of and from DNF that I mentioned before and gave them nice humanistic

482
00:26:55,340 --> 00:26:56,340
names.

483
00:26:56,340 --> 00:26:57,420
You should always do this.

484
00:26:57,420 --> 00:27:02,540
It isn't hard but it makes your life a lot easier than trying to talk to the tool directly.

485
00:27:02,540 --> 00:27:07,180
It means your problem descriptions are completely humanistic and you can explain the output.

486
00:27:07,180 --> 00:27:13,220
So the utilities you need for that, this is the code that I wrote for you so that you

487
00:27:13,220 --> 00:27:16,340
could write generic solvers.

488
00:27:16,340 --> 00:27:20,740
And if you use this, PicoSat becomes something you can use in the first few minutes.

489
00:27:20,740 --> 00:27:24,540
Otherwise you'll spend two days coding your problem into it and it would have been cheaper

490
00:27:24,540 --> 00:27:26,020
to solve it by hand.

491
00:27:26,020 --> 00:27:27,020
Fair enough?

492
00:27:27,020 --> 00:27:28,520
All right.

493
00:27:28,520 --> 00:27:30,220
We are done with SAT solvers.

494
00:27:30,220 --> 00:27:33,060
But before I leave, I should just say these are really bad ass.

495
00:27:33,060 --> 00:27:34,540
I showed you toy problems.

496
00:27:34,540 --> 00:27:36,860
These scale up to enormous problems.

497
00:27:36,860 --> 00:27:39,280
Imagine this problem with a million variables.

498
00:27:39,280 --> 00:27:41,220
And so where do these problems come up?

499
00:27:41,220 --> 00:27:45,380
So it's used in a conda.

500
00:27:45,380 --> 00:27:48,380
What's the installer?

501
00:27:48,380 --> 00:27:49,500
Conda.

502
00:27:49,500 --> 00:27:55,940
So in conda, conda has to make decisions about what packages conflict with one another and

503
00:27:55,940 --> 00:27:57,640
what their dependencies are.

504
00:27:57,640 --> 00:28:00,620
This is a complex problem when you have lots of packages.

505
00:28:00,620 --> 00:28:02,580
What tool do you think they use to solve it?

506
00:28:02,580 --> 00:28:06,820
It starts with a sat and ends with a ta, has three letters.

507
00:28:06,820 --> 00:28:07,900
They use PicoSat.

508
00:28:07,900 --> 00:28:12,020
They use exactly this technique for a fairly complex real world problem.

509
00:28:12,020 --> 00:28:14,540
Okay, pattern recognition and reinforcement learning.

510
00:28:14,540 --> 00:28:17,400
I can do this one fast.

511
00:28:17,400 --> 00:28:18,400
Problem statement.

512
00:28:18,400 --> 00:28:21,660
I need to get my son to eat broccoli.

513
00:28:21,660 --> 00:28:22,660
He's seven.

514
00:28:22,660 --> 00:28:25,740
It turns out he actually does eat broccoli so this is no longer a problem.

515
00:28:25,740 --> 00:28:26,740
I'm amazed by that.

516
00:28:26,740 --> 00:28:30,980
I didn't eat broccoli until I was my children.

517
00:28:30,980 --> 00:28:32,700
Strategies discussed between Rachel and I.

518
00:28:32,700 --> 00:28:33,940
One, acclimatization.

519
00:28:33,940 --> 00:28:36,980
We can serve it once a week until he gets used to it.

520
00:28:37,060 --> 00:28:38,340
A better alternative.

521
00:28:38,340 --> 00:28:40,660
You know, broccoli is better than spinach.

522
00:28:40,660 --> 00:28:42,540
Or I can entice him.

523
00:28:42,540 --> 00:28:43,540
You know what?

524
00:28:43,540 --> 00:28:46,420
We'll watch your favorite movie after you eat the broccoli.

525
00:28:46,420 --> 00:28:49,620
And if your parents have tried all of these strategies, trickery.

526
00:28:49,620 --> 00:28:51,340
Oh, eat the broccoli.

527
00:28:51,340 --> 00:28:52,340
It's candy.

528
00:28:52,340 --> 00:28:53,340
Testimonial.

529
00:28:53,340 --> 00:28:56,220
Oh, your best friend, Luna.

530
00:28:56,220 --> 00:28:57,440
She likes broccoli.

531
00:28:57,440 --> 00:28:58,440
You like Luna.

532
00:28:58,440 --> 00:29:02,980
Therefore, by the transitive law of likes, you like broccoli.

533
00:29:02,980 --> 00:29:03,980
Weighted up.

534
00:29:03,980 --> 00:29:06,540
Young man, we're not leaving this table until you've eaten your broccoli.

535
00:29:07,100 --> 00:29:09,100
Just try a little bite.

536
00:29:09,100 --> 00:29:10,100
No, not that little.

537
00:29:10,100 --> 00:29:12,100
I didn't know you could eat a bite that soft.

538
00:29:12,100 --> 00:29:13,100
And appeal to reason.

539
00:29:13,100 --> 00:29:15,380
You know, it's a great source of vitamins K and C.

540
00:29:15,380 --> 00:29:20,460
These are all strategies which raises the question, which strategy should we use?

541
00:29:20,460 --> 00:29:26,220
How about we randomly try a strategy and if it works, we choose that strategy more often.

542
00:29:26,220 --> 00:29:29,020
And if it stops working, we choose it less often.

543
00:29:29,020 --> 00:29:30,020
Easy enough?

544
00:29:30,020 --> 00:29:31,020
Aha.

545
00:29:31,020 --> 00:29:32,660
You're taking a picture of my screen.

546
00:29:32,660 --> 00:29:35,140
That means I did a great job making my slides.

547
00:29:35,140 --> 00:29:36,580
But did you know?

548
00:29:36,580 --> 00:29:38,780
I will give you these slides.

549
00:29:38,780 --> 00:29:40,940
All of them.

550
00:29:40,940 --> 00:29:42,540
And not in picture form.

551
00:29:42,540 --> 00:29:48,700
Like you can get, these slides will be in HTML so that you can run the code directly.

552
00:29:48,700 --> 00:29:49,700
That's it.

553
00:29:49,700 --> 00:29:50,700
I'll stand in front of it so you can take a picture later.

554
00:29:50,700 --> 00:29:51,700
There.

555
00:29:51,700 --> 00:29:52,700
You can go pose.

556
00:29:52,700 --> 00:29:53,700
All right.

557
00:29:53,700 --> 00:30:00,140
So I've given you a rock, paper, scissors game here instead of eating broccoli.

558
00:30:00,140 --> 00:30:03,580
We pick a strategy randomly, see if it works.

559
00:30:03,580 --> 00:30:07,820
And the interesting thing about this is I first saw this program in Creative Computing

560
00:30:07,820 --> 00:30:10,860
Magazine over 30 years ago.

561
00:30:10,860 --> 00:30:12,740
And I was amazed by it.

562
00:30:12,740 --> 00:30:15,820
Because rock, paper, scissors is an unwinnable game.

563
00:30:15,820 --> 00:30:17,720
It should just net out to zero.

564
00:30:17,720 --> 00:30:21,360
But what if you can anticipate what your opponent is going to do?

565
00:30:21,360 --> 00:30:24,620
You can do better than average.

566
00:30:24,620 --> 00:30:28,420
Which means you have to pattern match and figure out what has your opponent been doing.

567
00:30:28,420 --> 00:30:31,820
So this game is more interesting when we do repeat play.

568
00:30:31,820 --> 00:30:37,620
So I had some Python skills that I've listed in order to understand the code.

569
00:30:37,620 --> 00:30:39,060
We don't have time to go over them now.

570
00:30:39,060 --> 00:30:42,620
But this will teach you some Python that you might not have known.

571
00:30:42,620 --> 00:30:46,940
How to transpose keys and values.

572
00:30:46,940 --> 00:30:48,580
How to group pairs.

573
00:30:48,580 --> 00:30:53,060
How to use the new random choices function, et cetera.

574
00:30:53,060 --> 00:30:56,720
But essentially we define the game rock, paper, scissors.

575
00:30:57,720 --> 00:31:01,840
Paper beats rock is a one.

576
00:31:01,840 --> 00:31:04,060
And we come up with the ideal response.

577
00:31:04,060 --> 00:31:05,060
What is the winning response?

578
00:31:05,060 --> 00:31:08,200
And our options, what do we have to choose from?

579
00:31:08,200 --> 00:31:10,920
Our strategies are we can choose randomly.

580
00:31:10,920 --> 00:31:13,240
We can choose one thing proportionally.

581
00:31:13,240 --> 00:31:15,880
Let's say rock two thirds of the time.

582
00:31:15,880 --> 00:31:17,360
We can do digraphs.

583
00:31:17,360 --> 00:31:22,760
Whenever a person plays scissors, scissors, you know they're going to do rock next.

584
00:31:22,760 --> 00:31:24,640
So these are a series of strategies.

585
00:31:24,640 --> 00:31:26,720
It doesn't really matter what they are.

586
00:31:26,720 --> 00:31:28,480
You just need a set of them.

587
00:31:28,480 --> 00:31:33,280
The interesting thing is I make a list of them and the algorithm is roughly choose our

588
00:31:33,280 --> 00:31:34,280
move.

589
00:31:34,280 --> 00:31:35,280
How do we choose a move?

590
00:31:35,280 --> 00:31:40,680
We take our strategies and choose one strategy randomly according to the weights.

591
00:31:40,680 --> 00:31:44,400
And the initial weighting is everything is equal weighted.

592
00:31:44,400 --> 00:31:46,640
All strategies are equally good.

593
00:31:46,640 --> 00:31:48,860
Then we find out what the opponent's move does.

594
00:31:48,860 --> 00:31:52,160
So I chose telling my son that it was candy.

595
00:31:52,160 --> 00:31:55,280
And the opponent decides not to eat his broccoli.

596
00:31:55,280 --> 00:32:00,800
So what we need to do is update our move history and strategy weights and say I'm not going

597
00:32:00,800 --> 00:32:07,060
to try the candy trick as much anymore, but I never fully take it off of the list.

598
00:32:07,060 --> 00:32:11,360
This is the entire algorithm for reinforcement learning.

599
00:32:11,360 --> 00:32:12,640
Does it sound impressive?

600
00:32:12,640 --> 00:32:13,640
No.

601
00:32:13,640 --> 00:32:17,040
Anything that you can write in a few lines of code doesn't sound impressive, which is

602
00:32:17,040 --> 00:32:19,680
not to say that it isn't badass.

603
00:32:19,680 --> 00:32:24,280
This thing can learn and beat you at rock, paper, scissors over and over again.

604
00:32:24,280 --> 00:32:28,560
I defy you to do better than average on this.

605
00:32:28,560 --> 00:32:30,680
You will find it's not a fun game to play.

606
00:32:30,680 --> 00:32:33,380
It gets really boring because the computer is really quick.

607
00:32:33,380 --> 00:32:38,920
But you can do a hundred rounds in about five minutes and at the end of that you will find

608
00:32:38,920 --> 00:32:46,440
that as random as you try and be, this I have never seen a person defeat this thing ever.

609
00:32:46,440 --> 00:32:50,160
It will learn your random patterns and figure you out.

610
00:32:50,160 --> 00:32:58,520
Oh wait, Google and Facebook already do that to you.

611
00:32:58,520 --> 00:33:03,200
A lot of what we do now is trying to figure out what other people are going to do.

612
00:33:03,200 --> 00:33:08,360
So this is called a multi-armed branded approach.

613
00:33:08,360 --> 00:33:12,720
It scales to other games like this and it scales to more interesting games.

614
00:33:12,720 --> 00:33:15,380
Everybody got how that one works?

615
00:33:15,380 --> 00:33:20,580
So the next level after this is SMT solvers.

616
00:33:20,580 --> 00:33:26,100
So if you want to sound super technical, you need to know some lingo.

617
00:33:26,100 --> 00:33:32,180
If you know what SMT stands for, you're going to be very popular at Silicon Valley parties.

618
00:33:32,180 --> 00:33:34,900
You know it stands for Satisfiability Modulo Theories.

619
00:33:34,900 --> 00:33:37,740
You're like, wow, can I buy you a drink?

620
00:33:37,740 --> 00:33:39,980
All right, see how that goes.

621
00:33:39,980 --> 00:33:45,980
All right, so I say this is the next step up because we've gone up from a tree searcher

622
00:33:45,980 --> 00:33:47,240
and SAT solvers.

623
00:33:47,240 --> 00:33:51,820
Our state is now more complex than just a truth table and we're searching a graph instead

624
00:33:51,820 --> 00:33:54,700
of a tree and we're introducing temporal logic.

625
00:33:54,700 --> 00:33:57,200
How many of you know about temporal logic?

626
00:33:57,200 --> 00:34:00,420
It should be exactly the people who knew TLA+.

627
00:34:00,420 --> 00:34:02,460
I don't know why I had fewer hands go.

628
00:34:02,460 --> 00:34:05,400
TLA plus is all about temporal logic.

629
00:34:06,400 --> 00:34:08,640
I'm not evaluating my goal status.

630
00:34:08,640 --> 00:34:10,660
Did I get to a goal now?

631
00:34:10,660 --> 00:34:12,220
It's the succession of states.

632
00:34:12,220 --> 00:34:15,200
Do we get a series in a row?

633
00:34:15,200 --> 00:34:18,480
Did I get a chicken and then later did I get an egg?

634
00:34:18,480 --> 00:34:21,320
Did the two come one after another?

635
00:34:21,320 --> 00:34:28,560
So we have goals that say something is always true, something is eventually true, something

636
00:34:28,560 --> 00:34:35,360
is always eventually true and that says it's a reasoning about a succession of states.

637
00:34:35,360 --> 00:34:38,400
So a good example of this is the dining philosophers problem.

638
00:34:38,400 --> 00:34:41,440
How many of you are familiar with dining philosophers?

639
00:34:41,440 --> 00:34:46,560
This is great because my picture for it is not showing up on the screen, but it involves

640
00:34:46,560 --> 00:34:49,360
five philosophers and five chopsticks.

641
00:34:49,360 --> 00:34:52,840
You actually need ten chopsticks, they only have five.

642
00:34:52,840 --> 00:34:57,120
In order to eat food, you need to have two chopsticks.

643
00:34:57,120 --> 00:34:59,400
So the interesting thing is how to model it.

644
00:34:59,400 --> 00:35:02,840
It's very interesting, easy to do the unconstrained model.

645
00:35:02,840 --> 00:35:07,000
Every chopstick is either unused in the hand of the philosopher to the left or in the hand

646
00:35:07,000 --> 00:35:08,960
of the philosopher to the right.

647
00:35:08,960 --> 00:35:13,360
So you can get an entire state by describing it with just five letters.

648
00:35:13,360 --> 00:35:17,480
All five chopsticks are unused, this one is held by the left philosopher, this one is

649
00:35:17,480 --> 00:35:19,120
held by the right.

650
00:35:19,120 --> 00:35:21,680
The number of possible states is three to the fifth power.

651
00:35:21,680 --> 00:35:24,560
Does that sound like a big state space?

652
00:35:24,560 --> 00:35:28,240
It does not sound big, but we're not interested in the states.

653
00:35:28,240 --> 00:35:34,160
We're interested in all possible paths through the state tree.

654
00:35:34,160 --> 00:35:38,160
Now if you know this state, you have an implied state for the philosophers, the philosopher

655
00:35:38,160 --> 00:35:40,960
thinking, eating, or trying to eat.

656
00:35:40,960 --> 00:35:42,760
And so here's our transitions.

657
00:35:42,760 --> 00:35:47,320
If a chopstick is unused, it can be picked up by the left philosopher or by the right

658
00:35:47,320 --> 00:35:48,480
philosopher.

659
00:35:48,480 --> 00:35:50,940
If it's currently in use, it can become unused.

660
00:35:50,940 --> 00:35:55,240
So there are only four transitions out of each state.

661
00:35:55,240 --> 00:35:58,840
So this is like the Sudoku model before we have the clues.

662
00:35:58,840 --> 00:36:02,400
Now the clues are our strategies.

663
00:36:02,400 --> 00:36:07,320
The interesting thing about the dining philosopher problem is most people's first attempt to

664
00:36:07,320 --> 00:36:13,060
solve it always sounds correct but is actually wrong.

665
00:36:13,060 --> 00:36:17,820
It's very educational, and the reason we use it in education is it teaches people how hard

666
00:36:17,820 --> 00:36:21,480
it is to make correct multi-threaded code.

667
00:36:21,520 --> 00:36:27,880
So here is an obvious strategy, which is when you're hungry, pick up the left chopstick.

668
00:36:27,880 --> 00:36:30,800
When the right one becomes available, pick it up.

669
00:36:30,800 --> 00:36:32,920
After you eat, put them back down.

670
00:36:32,920 --> 00:36:36,740
I call this strategy D because it results in deadlock.

671
00:36:36,740 --> 00:36:38,460
This fails.

672
00:36:38,460 --> 00:36:43,440
Strategy S is a really terrible strategy, and it says the first philosopher picks up

673
00:36:43,440 --> 00:36:47,320
the left chopstick and never lets it go.

674
00:36:47,320 --> 00:36:50,700
This causes the person to his left to starve.

675
00:36:50,700 --> 00:36:52,180
Strategy S stands for starve.

676
00:36:52,180 --> 00:36:55,740
That person never eats, which is not a desirable outcome.

677
00:36:55,740 --> 00:36:58,020
Here is the happy strategy.

678
00:36:58,020 --> 00:37:00,040
You can make a request for a chopstick.

679
00:37:00,040 --> 00:37:04,700
This is not the best strategy, but it is one that works, which is when I want to eat, I

680
00:37:04,700 --> 00:37:09,580
put in a request to eat, and we keep a queue of who gets to eat next.

681
00:37:09,580 --> 00:37:13,820
And if you are not next in line, you wait.

682
00:37:13,820 --> 00:37:19,020
And then when your request becomes available, you acquire the left, acquire the right, and

683
00:37:19,020 --> 00:37:20,940
when you're done eating, release both.

684
00:37:20,940 --> 00:37:22,660
This strategy works.

685
00:37:22,660 --> 00:37:26,740
The interesting thing is it is not obvious which of these strategies works and which

686
00:37:26,740 --> 00:37:28,120
one fails.

687
00:37:28,120 --> 00:37:32,880
What we would like is a tool where we input our strategy and it tells us whether it succeeds

688
00:37:32,880 --> 00:37:36,260
all the time, and if it fails, gives us a failing test case.

689
00:37:36,260 --> 00:37:38,180
Does that sound useful?

690
00:37:38,180 --> 00:37:40,800
Have you ever written multithreaded code?

691
00:37:40,800 --> 00:37:41,800
Complex multithreaded code.

692
00:37:41,800 --> 00:37:48,380
How many of you have written complex multithreaded code that's correct?

693
00:37:48,380 --> 00:37:53,980
How many of you wrote complex multithreaded code that was correct and then somebody bypassed

694
00:37:53,980 --> 00:37:58,140
a lock and made it incorrect after the fact?

695
00:37:58,140 --> 00:38:01,220
So how many of you have ever written a complex multithreaded piece of code that you believe

696
00:38:01,220 --> 00:38:07,300
to be correct and has a test suite that can prove that it is always correct?

697
00:38:07,300 --> 00:38:10,460
Oh, then you have a use for this sort of thing.

698
00:38:10,460 --> 00:38:14,580
Because the kind of tool that can verify this for you can also generate all the test cases

699
00:38:14,740 --> 00:38:19,060
that shows all allowable state transitions and you can have your program inform you if

700
00:38:19,060 --> 00:38:22,980
it's ever going to not match the model.

701
00:38:22,980 --> 00:38:28,300
So the interesting thing about these solvers is they have transition graphs.

702
00:38:28,300 --> 00:38:30,820
They say they use temporal operators.

703
00:38:30,820 --> 00:38:35,660
A temporal operator says things like predicate P is eventually true.

704
00:38:35,660 --> 00:38:42,340
Our problem is a person with a left chopstick eventually gets a right one.

705
00:38:42,340 --> 00:38:47,340
Another one is that something is always eventually true.

706
00:38:47,340 --> 00:38:48,860
That is kind of different from the other one.

707
00:38:48,860 --> 00:38:54,620
It says after you eat that someday you might get to eat again.

708
00:38:54,620 --> 00:38:56,460
And more than once.

709
00:38:56,460 --> 00:38:58,220
So here's an example.

710
00:38:58,220 --> 00:39:02,560
The solvers we saw before would look at one of these states and say is this a goal state?

711
00:39:02,560 --> 00:39:04,060
We no longer care about this.

712
00:39:04,060 --> 00:39:05,540
We never actually stop.

713
00:39:05,540 --> 00:39:06,740
This thing doesn't terminate.

714
00:39:06,740 --> 00:39:09,540
The dining philosophers are always eating and thinking.

715
00:39:09,540 --> 00:39:14,620
What's more interesting is this person eats then eventually they get to eat again.

716
00:39:14,620 --> 00:39:19,260
So the temporal logic gets to express if you have this state at this point you get this

717
00:39:19,260 --> 00:39:20,260
other state at another.

718
00:39:20,260 --> 00:39:24,100
You get the time part of the invariant temporal.

719
00:39:24,100 --> 00:39:25,500
This thing was true at one point.

720
00:39:25,500 --> 00:39:27,220
It will become a true again.

721
00:39:27,220 --> 00:39:29,020
All of these things have happened before.

722
00:39:29,020 --> 00:39:31,620
All of these things will happen again.

723
00:39:31,620 --> 00:39:34,140
No Battlestar Galactica fans.

724
00:39:34,140 --> 00:39:35,760
All right.

725
00:39:35,760 --> 00:39:40,240
If you want to feel really mathy you should express it in TLA plus.

726
00:39:40,240 --> 00:39:41,940
It's incredibly mathy.

727
00:39:41,940 --> 00:39:46,100
This is a TLA plus description of the problem.

728
00:39:46,100 --> 00:39:49,700
I've given you a link to a nice write up on it to get started with it.

729
00:39:49,700 --> 00:39:55,260
And a link to how to get started with Microsoft Z3 that also makes short work of this problem.

730
00:39:55,260 --> 00:40:00,020
And what's great is the Z3 pie package lets you get there from Python.

731
00:40:00,020 --> 00:40:03,020
We learned something new.

732
00:40:03,020 --> 00:40:06,700
You're never going to write a complex multi-threaded piece of code ever again where you haven't

733
00:40:06,700 --> 00:40:12,140
model checked it and generated test cases to make sure that it always stays correct.

734
00:40:12,140 --> 00:40:14,280
Oh, so you learned something new and useful.

735
00:40:14,280 --> 00:40:15,280
This is good.

736
00:40:15,280 --> 00:40:16,820
All right.

737
00:40:16,820 --> 00:40:22,180
Next one up is a little bit harder problem.

738
00:40:22,180 --> 00:40:29,080
Learn to play the most complex games known to humans but the input is only the rules

739
00:40:29,080 --> 00:40:30,860
to the game.

740
00:40:30,860 --> 00:40:35,440
So how about I teach my son to play chess by showing him just the moves for the game

741
00:40:35,440 --> 00:40:37,080
and teach him nothing else.

742
00:40:37,080 --> 00:40:40,200
Is that a cruel way to teach a person chess?

743
00:40:40,200 --> 00:40:41,880
But I can use reinforcement learning.

744
00:40:41,880 --> 00:40:46,260
I can just beat him game after game after game.

745
00:40:46,260 --> 00:40:48,020
But my son is smart.

746
00:40:48,020 --> 00:40:52,980
He will observe what I'm doing and learn from his defeats and eventually beat his father.

747
00:40:52,980 --> 00:40:56,940
I know this is true because this is how I learned to play chess.

748
00:40:56,940 --> 00:41:05,020
My father showed me the moves in second grade and beat me game after game after game after

749
00:41:05,020 --> 00:41:08,260
game and I never gave up.

750
00:41:08,260 --> 00:41:14,740
And then in eighth grade, he encountered something he'd never encountered before, defeat.

751
00:41:14,740 --> 00:41:17,060
And it was repeatable.

752
00:41:17,060 --> 00:41:19,300
I got good at it.

753
00:41:19,300 --> 00:41:23,060
I got better than my dad.

754
00:41:23,060 --> 00:41:26,220
Did it take a long time between second grade and eighth grade?

755
00:41:26,220 --> 00:41:30,340
How would we like to compress six years into six hours?

756
00:41:30,340 --> 00:41:32,300
That's Alpha Go.

757
00:41:32,300 --> 00:41:33,900
Or Alpha Zero.

758
00:41:33,900 --> 00:41:36,100
Alpha Zero was kind of cool.

759
00:41:36,100 --> 00:41:41,740
What we proved is how generic it was by we gave it the rules for chess.

760
00:41:41,740 --> 00:41:46,220
Then we gave it the rules for Shogi, which is a computationally more complex game than

761
00:41:46,220 --> 00:41:47,220
chess.

762
00:41:47,220 --> 00:41:51,160
And we've got the lance piece that can move like a knight but an extra one forward.

763
00:41:51,160 --> 00:41:55,820
But also pieces that can switch sides after they're killed and can land anywhere on the

764
00:41:55,820 --> 00:41:57,100
board.

765
00:41:57,100 --> 00:42:03,900
And then Go, which all three of these games, the input to them was simply the rules of

766
00:42:03,900 --> 00:42:04,900
the game.

767
00:42:04,900 --> 00:42:12,340
And in each case, after six to eight hours of training, Alpha Zero learned to beat the

768
00:42:12,340 --> 00:42:17,160
best humans in the world but also the best computer programs in the world.

769
00:42:17,160 --> 00:42:21,440
The best computer programs in the world for chess were custom designed for chess.

770
00:42:21,440 --> 00:42:22,780
This one wasn't custom.

771
00:42:22,780 --> 00:42:24,700
All it knew was the rules.

772
00:42:24,700 --> 00:42:28,820
And it means that there's a broad class of problems that we can solve now simply by describing

773
00:42:28,820 --> 00:42:29,820
the problem.

774
00:42:29,820 --> 00:42:32,220
Keep in mind there was enormous computation power.

775
00:42:32,220 --> 00:42:36,740
Six hours is impressive until you know how much computation power they threw at it.

776
00:42:36,740 --> 00:42:38,460
They threw a lot at it.

777
00:42:38,460 --> 00:42:42,020
So this is a thing of beauty.

778
00:42:42,020 --> 00:42:43,620
This is a typical result.

779
00:42:43,620 --> 00:42:53,620
This is after a few hours, Alpha Zero destroying the best program in the world, which was Stockfish.

780
00:42:53,620 --> 00:42:55,180
It is nice to play this one out.

781
00:42:55,180 --> 00:42:59,540
If you're interested in chess, just move the pieces and you will see a thing of beauty,

782
00:42:59,540 --> 00:43:03,080
possibly the best game of chess ever played.

783
00:43:03,080 --> 00:43:06,060
It's a wonderful thing, which raises a question.

784
00:43:06,060 --> 00:43:08,340
What do we think about this?

785
00:43:08,340 --> 00:43:11,060
Here's two assessments.

786
00:43:11,060 --> 00:43:15,580
In the AlphaGo paper, which I've given you a link to, there's one behind a paywall at

787
00:43:15,580 --> 00:43:20,460
Science Magazine, but they've also got a preprint that's available for free.

788
00:43:20,780 --> 00:43:25,780
They said, our results demonstrate that a general purpose reinforcement learning program

789
00:43:25,780 --> 00:43:27,580
can learn tabula rasa.

790
00:43:27,580 --> 00:43:30,180
That means no inputs at all.

791
00:43:30,180 --> 00:43:37,340
No domain specific knowledge or human knowledge can succeed in multiple domains, many games,

792
00:43:37,340 --> 00:43:43,420
achieving super performance in multiple challenging games in a few hours.

793
00:43:43,420 --> 00:43:45,140
This is pretty badass.

794
00:43:45,140 --> 00:43:50,100
Gary Kasparov had what seems like a self-serving comment on the whole thing.

795
00:43:50,140 --> 00:43:51,820
I love its style of chess.

796
00:43:51,820 --> 00:43:55,340
It plays just like me.

797
00:43:55,340 --> 00:43:59,980
And that seems self-serving, except Gary Kasparov was pretty badass.

798
00:43:59,980 --> 00:44:03,300
And this thing learned to play like a human.

799
00:44:03,300 --> 00:44:06,100
It could set traps for people.

800
00:44:06,100 --> 00:44:07,260
All right.

801
00:44:07,260 --> 00:44:11,540
So I've got a stop sign, but my stop sign says I've got five minutes to stop, which

802
00:44:11,540 --> 00:44:12,540
is great.

803
00:44:12,540 --> 00:44:13,540
I'm actually on time.

804
00:44:13,540 --> 00:44:14,540
This is amazing.

805
00:44:14,540 --> 00:44:16,380
So code you can run.

806
00:44:16,380 --> 00:44:18,660
Is AlphaZero open source?

807
00:44:18,660 --> 00:44:19,660
No.

808
00:44:20,740 --> 00:44:23,220
But Lila chess is.

809
00:44:23,220 --> 00:44:27,140
And the install is using Python 3's Mesa, Mason.

810
00:44:27,140 --> 00:44:32,100
I would say this whole thing is Python 3, but Python is not fast enough.

811
00:44:32,100 --> 00:44:34,580
C is not fast enough.

812
00:44:34,580 --> 00:44:36,220
Can we do better?

813
00:44:36,220 --> 00:44:39,780
What it does is generate a code that runs on your GP.

814
00:44:39,780 --> 00:44:40,780
And this is great.

815
00:44:40,780 --> 00:44:46,300
And so you can go to this link, download it, and start playing chess against the best chess

816
00:44:46,340 --> 00:44:50,300
program in the world using exactly these techniques.

817
00:44:50,300 --> 00:44:52,380
So this is Monte Carlo tree search.

818
00:44:52,380 --> 00:44:55,060
It essentially says let's select a pattern.

819
00:44:55,060 --> 00:44:59,060
Let's run it out to the end of the game, determining a win-loss.

820
00:44:59,060 --> 00:45:04,140
Run multiple simulations, and then back propagate the results, waiting them along the way, saying

821
00:45:04,140 --> 00:45:05,980
this move ended up being a good move.

822
00:45:05,980 --> 00:45:07,740
This ended up being a bad move.

823
00:45:07,740 --> 00:45:11,580
This is almost exactly our reinforcement learning algorithm that I mentioned on the previous

824
00:45:11,580 --> 00:45:15,820
page, but with a tree.

825
00:45:15,900 --> 00:45:21,420
And if you want the full algorithm, this is basically it.

826
00:45:21,420 --> 00:45:26,860
And let's talk about the future.

827
00:45:26,860 --> 00:45:31,060
Where does all of this go?

828
00:45:31,060 --> 00:45:34,700
This is a risky page, because what did Master Yodas tell us?

829
00:45:34,700 --> 00:45:38,980
Difficult to predict the future is always in motion.

830
00:45:38,980 --> 00:45:43,020
That said, we have to ask ourself, does this end badly?

831
00:45:43,020 --> 00:45:49,780
How many of you think it's going to end badly?

832
00:45:49,780 --> 00:45:51,780
There is reason to think that is true.

833
00:45:51,780 --> 00:45:55,900
That however, there is a very deep thinker who has thought deeply about this problem,

834
00:45:55,900 --> 00:46:01,740
a person who has done battle with these machines, a person who has defeated machines initially,

835
00:46:01,740 --> 00:46:05,500
then defeated by one machine, and then routinely defeated by him.

836
00:46:05,500 --> 00:46:09,820
One of the smartest people in the entire world has thought carefully about this problem,

837
00:46:09,820 --> 00:46:11,580
and I love his book.

838
00:46:11,580 --> 00:46:14,620
Garry Kasparov doesn't think this is going to end badly.

839
00:46:14,620 --> 00:46:17,860
I highly recommend his book called Deep Thinking.

840
00:46:17,860 --> 00:46:19,260
It reads like a work of fiction.

841
00:46:19,260 --> 00:46:20,820
It's a real page turner.

842
00:46:20,820 --> 00:46:23,060
It will tell you a lot about AI.

843
00:46:23,060 --> 00:46:28,060
And keep in mind he was one of the brightest of human beings who early on did battle with

844
00:46:28,060 --> 00:46:32,340
a computer and eventually lost to the machine.

845
00:46:32,340 --> 00:46:36,460
And he's got some very deep thoughts on how we're going to interact with these machines

846
00:46:36,460 --> 00:46:38,300
in the future.

847
00:46:38,300 --> 00:46:39,740
Which of our jobs it's going to replace?

848
00:46:39,740 --> 00:46:41,100
How it will help us?

849
00:46:41,100 --> 00:46:42,100
How it will harm us?

850
00:46:42,100 --> 00:46:44,580
How it will adapt?

851
00:46:44,580 --> 00:46:49,860
I think it is a fascinating, wonderful, and great time to be alive.

852
00:46:49,860 --> 00:46:52,140
Thank you so much for coming to this talk.

853
00:46:52,140 --> 00:46:53,540
Please get these slides.

854
00:46:53,540 --> 00:46:55,340
Please run all of this code.

855
00:46:55,340 --> 00:47:00,060
This stuff is ready to use today, and it's not that hard.

856
00:47:00,060 --> 00:47:01,060
Live long and prosper.

857
00:47:01,060 --> 00:47:03,060
Thank you.

