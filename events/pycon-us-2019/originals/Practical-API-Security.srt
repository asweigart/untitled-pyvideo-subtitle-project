1
00:00:00,000 --> 00:00:08,160
Good morning everybody.

2
00:00:08,160 --> 00:00:14,240
Announcements.

3
00:00:14,240 --> 00:00:17,000
Break will be at 10 15 in the lobby.

4
00:00:17,000 --> 00:00:20,520
I have an alarm set for 8 10 so we don't miss it because you don't want to get out there

5
00:00:20,520 --> 00:00:23,160
before everything's gone.

6
00:00:23,160 --> 00:00:27,920
That happened to someone last year at a class and it's unpleasant.

7
00:00:27,920 --> 00:00:32,680
Bunch will be from 10 20 to 1 20 in the, I believe that's the Gerard ballroom AB.

8
00:00:32,680 --> 00:00:35,000
It's tough to read it.

9
00:00:35,000 --> 00:00:36,000
But it'll be in the ballroom.

10
00:00:36,000 --> 00:00:39,440
Just head towards the people.

11
00:00:39,440 --> 00:00:44,360
There's as much power as a PyCon could afford.

12
00:00:44,360 --> 00:00:46,240
Please share the power.

13
00:00:46,240 --> 00:00:48,000
There's like a few strips.

14
00:00:48,000 --> 00:00:53,880
So if you have a big block, try and use your extra cord.

15
00:00:53,880 --> 00:00:56,640
And they set up a SurveyMonkey for rating these things.

16
00:00:56,640 --> 00:01:00,360
This will be on again at the end.

17
00:01:00,360 --> 00:01:01,360
I'll talk about it more then.

18
00:01:01,360 --> 00:01:05,800
But please, please, please, please fill out the surveys because it helps me be better

19
00:01:05,800 --> 00:01:07,600
at what I do.

20
00:01:07,600 --> 00:01:10,000
It's nothing worse than sitting up here and talking to somebody for three hours and they

21
00:01:10,000 --> 00:01:11,960
hate what you're talking about.

22
00:01:11,960 --> 00:01:16,920
So I can always make it better and I love the input.

23
00:01:16,920 --> 00:01:20,640
First thing I want to do is set some expectations.

24
00:01:20,640 --> 00:01:22,760
So we have like three hours.

25
00:01:22,760 --> 00:01:25,320
It's a very large topic.

26
00:01:25,320 --> 00:01:31,640
What I hope to help you do in this time is identify what compromises securing an API.

27
00:01:31,640 --> 00:01:36,920
Give you some overview for some solutions and we will go through some code and try and get

28
00:01:36,920 --> 00:01:39,320
through all the pieces that were in there.

29
00:01:39,320 --> 00:01:42,320
Last year we got 95% of the way.

30
00:01:42,320 --> 00:01:48,320
It just depends on how well everybody did setting up before they came.

31
00:01:48,320 --> 00:01:50,680
So we'll see how that goes.

32
00:01:50,680 --> 00:01:54,920
Did anyone not get set up before they came to PyCon?

33
00:01:54,920 --> 00:01:55,920
It's okay to raise your hand.

34
00:01:55,920 --> 00:01:59,360
Because I can tell you where to go to get set up.

35
00:01:59,360 --> 00:02:00,360
Okay.

36
00:02:00,360 --> 00:02:01,360
Fantastic.

37
00:02:01,360 --> 00:02:06,400
And did anyone not get it running and didn't email me?

38
00:02:06,400 --> 00:02:07,400
Awesome.

39
00:02:07,400 --> 00:02:09,920
So this is going to go way faster than last year.

40
00:02:09,920 --> 00:02:15,560
Yay, the death of Python 2.7.

41
00:02:15,560 --> 00:02:17,360
So what are we protecting against?

42
00:02:17,360 --> 00:02:22,800
When securing anything it is super important to understand one thing above all else and

43
00:02:22,800 --> 00:02:27,680
that's who are you protecting yourself against?

44
00:02:27,680 --> 00:02:34,920
Adversaries can be hackers, competitors, organized crime, nation states, if you're a company

45
00:02:34,920 --> 00:02:40,880
like me, work at a company like I do, and most often internal employees.

46
00:02:40,880 --> 00:02:43,640
Understanding your adversary helps you make the right decisions on determining how much

47
00:02:43,640 --> 00:02:48,040
security is appropriate and what steps need to be made.

48
00:02:48,040 --> 00:02:52,000
You can bankrupt your company trying to protect against nation states when you don't have

49
00:02:52,000 --> 00:02:53,000
to.

50
00:02:53,000 --> 00:02:54,000
All right.

51
00:02:54,000 --> 00:02:58,160
So we may have a very complicated system because I do have to protect against nation states

52
00:02:58,160 --> 00:03:00,360
because I protect banks.

53
00:03:00,360 --> 00:03:04,840
If you have a site that has some marketing material and a form to fill in, you probably

54
00:03:04,840 --> 00:03:08,360
don't need to worry about nation states.

55
00:03:08,360 --> 00:03:10,600
So how do we provide that protection?

56
00:03:10,600 --> 00:03:15,040
And there's a lot of different answers, but the one answer that's always there is defense

57
00:03:15,040 --> 00:03:17,000
and depth.

58
00:03:17,000 --> 00:03:22,960
So defense and depth has been around for a long, long time, since before computers.

59
00:03:22,960 --> 00:03:29,480
One of the analogies I like to give for this is if you think of medieval castles, medieval

60
00:03:29,480 --> 00:03:31,880
castles were absolutely defense and depth.

61
00:03:31,880 --> 00:03:35,900
They had a lot of things that you had to get through.

62
00:03:35,900 --> 00:03:41,480
So when you first come up, there's a gigantic wall and a moat and a drawbridge, and if you

63
00:03:41,480 --> 00:03:43,440
can get across the moat, then there's a portcullis.

64
00:03:43,800 --> 00:03:48,200
If you can get through the portcullis, then you're basically in a small hallway where

65
00:03:48,200 --> 00:03:50,440
they dump hot oil and shoot arrows at you.

66
00:03:50,440 --> 00:03:52,880
And if you get through that, then there's another door and then there's people.

67
00:03:52,880 --> 00:03:56,480
And if you get through that, the important stuff is in the tall tower.

68
00:03:56,480 --> 00:04:00,400
The reason it's in the tall tower is because there's a gigantic door to get in and then

69
00:04:00,400 --> 00:04:04,440
you have to go up a single-person staircase that goes up and they can just start piling

70
00:04:04,440 --> 00:04:06,760
up dead bodies as you're trying to get over.

71
00:04:06,760 --> 00:04:09,860
So there's a lot of things as you go along the way that they've created to prevent you

72
00:04:09,860 --> 00:04:13,260
from getting where you need to go because there's the assumption that at least one

73
00:04:13,260 --> 00:04:15,680
of these things will fail.

74
00:04:15,680 --> 00:04:21,380
And when you're doing defense for applications and APIs, defense and depth is also there.

75
00:04:21,380 --> 00:04:24,640
There's a lot of things that you do to make sure that people can get there and how many

76
00:04:24,640 --> 00:04:27,700
of these things depends on how important it is.

77
00:04:27,700 --> 00:04:33,440
If you were protecting a $10 bill, you wouldn't protect it with the amount of money necessary

78
00:04:33,440 --> 00:04:36,140
to create a medieval castle.

79
00:04:36,140 --> 00:04:42,820
So understanding and then figure out how much defense is necessary.

80
00:04:42,820 --> 00:04:50,940
So for applications, defense and depth, especially APIs, which we're talking about here, there

81
00:04:50,940 --> 00:04:53,500
are layers that I would suggest that you use.

82
00:04:53,500 --> 00:04:54,740
They're fairly common.

83
00:04:54,740 --> 00:04:59,540
The transport layer security, TLS, used to be called SSL.

84
00:04:59,540 --> 00:05:01,820
Most people are familiar with it.

85
00:05:01,820 --> 00:05:08,700
Rate limiting and replay prevention, authentication, access control, data validation, data encryption,

86
00:05:08,700 --> 00:05:10,460
and then logging and tracing.

87
00:05:10,460 --> 00:05:14,340
Logging and tracing could really go along the side because it should happen at every

88
00:05:14,340 --> 00:05:16,020
level.

89
00:05:16,020 --> 00:05:20,820
You should be logging when people try to access your web server.

90
00:05:20,820 --> 00:05:24,780
And then you should be accessing what's going on with rate limiting and who's coming in

91
00:05:24,780 --> 00:05:29,580
and getting rate limited so that you can maybe shut them off so they don't destroy your system.

92
00:05:29,580 --> 00:05:33,700
But I put it at the bottom because it's had to have a place.

93
00:05:33,700 --> 00:05:37,620
So transport layer security used to be hard.

94
00:05:37,620 --> 00:05:41,380
Three or four years ago, it was expensive, especially if you had a lot of internal systems

95
00:05:41,380 --> 00:05:43,220
you wanted to protect.

96
00:05:43,220 --> 00:05:49,220
Today that's not necessarily the case due to a Linux Foundation project called Let's

97
00:05:49,220 --> 00:05:50,260
Encrypt.

98
00:05:50,260 --> 00:05:53,980
If you have a public API and you don't think you can afford, you know, you weren't able

99
00:05:53,980 --> 00:05:58,100
to afford to be able to protect it before, you absolutely can now.

100
00:05:58,100 --> 00:06:00,660
You can get your own cert, but this is free.

101
00:06:00,660 --> 00:06:04,060
There's some maintenance behind it because they only last for 90 days.

102
00:06:04,060 --> 00:06:08,220
And you have to get a different one for every single endpoint.

103
00:06:08,220 --> 00:06:13,860
I think they started doing some multi-domain certs, but again, they're free, so get as

104
00:06:13,860 --> 00:06:17,820
many as you like.

105
00:06:17,820 --> 00:06:21,220
There's a tool out there as well called Qualys SSL Labs.

106
00:06:21,220 --> 00:06:24,340
It'll tell you how good your protection is.

107
00:06:24,340 --> 00:06:29,100
And there's a lot of things that are expiring recently that are no longer good.

108
00:06:29,100 --> 00:06:37,380
So you should regularly be checking how good your security is with this tool.

109
00:06:37,380 --> 00:06:40,180
Some places, I think there's actually some scripts out there to actually run this and

110
00:06:40,180 --> 00:06:43,500
check it using a web scraper.

111
00:06:43,500 --> 00:06:47,340
It takes a little while to run the report, but just if you do this regularly or if you

112
00:06:47,340 --> 00:06:52,380
have some other tool that you can use to make sure that you're doing well with the headers

113
00:06:52,420 --> 00:06:58,660
that you're setting and the level of TLS you're using, this will be a super big help.

114
00:06:58,660 --> 00:07:01,860
It just makes sure you're not vulnerable to anything that's known out there because there

115
00:07:01,860 --> 00:07:03,540
are a lot of known vulnerabilities.

116
00:07:03,540 --> 00:07:07,700
If you have TLS 1.0 or 1.1 turned on, there's a known vulnerability.

117
00:07:07,700 --> 00:07:11,700
If you have RC4 turned on, known vulnerability.

118
00:07:11,700 --> 00:07:17,180
If you're using some of the different ciphers, they're not great because they do have problems.

119
00:07:17,180 --> 00:07:20,620
If someone's listening to your network, they can find out terrible, terrible things like

120
00:07:20,700 --> 00:07:25,900
your keys and guess your secrets.

121
00:07:25,900 --> 00:07:26,900
Always be checking this.

122
00:07:26,900 --> 00:07:27,900
It's a living thing.

123
00:07:27,900 --> 00:07:31,180
It's not something you check at once and you're good forever.

124
00:07:31,180 --> 00:07:36,980
It's constantly changing and new vulnerabilities are showing up on a regular basis.

125
00:07:36,980 --> 00:07:39,820
So rate limiting and replay prevention.

126
00:07:39,820 --> 00:07:42,980
So that's exactly what the phrase implies.

127
00:07:42,980 --> 00:07:49,940
You limit the number of calls that a particular user can make to your API or user's period

128
00:07:49,940 --> 00:07:55,660
because what you're trying to do is you're trying to prevent somebody from using up all

129
00:07:55,660 --> 00:08:01,300
the resources on your site and creating denial of service attacks.

130
00:08:01,300 --> 00:08:06,060
So replay prevention requires unique requests and that is the more difficult part of it

131
00:08:06,060 --> 00:08:10,700
is that you have to have a way to identify that this is a unique request because oftentimes

132
00:08:10,700 --> 00:08:11,700
that's your request.

133
00:08:12,620 --> 00:08:16,340
So if I'm doing a get to an endpoint, there's nothing unique about that.

134
00:08:16,340 --> 00:08:20,260
And what you'll find is most HTTP requests are very similar.

135
00:08:20,260 --> 00:08:23,700
They have just a couple things that are different.

136
00:08:23,700 --> 00:08:26,660
So there's a few things you can do with that and one of the things that you end up having

137
00:08:26,660 --> 00:08:29,060
to find out is a way to create uniqueness.

138
00:08:29,060 --> 00:08:33,260
So there's some different strategies to do that by adding nonces.

139
00:08:33,260 --> 00:08:34,260
That's the big one.

140
00:08:34,260 --> 00:08:37,660
A number that can only be used once.

141
00:08:37,660 --> 00:08:40,660
There are different strategies for doing this but somehow you're going to have to create

142
00:08:40,660 --> 00:08:42,380
that uniqueness.

143
00:08:42,380 --> 00:08:48,260
This one is just, you can just add a header called xnots to the header so that it's different.

144
00:08:48,260 --> 00:08:52,820
But when you want to do replay prevention, you're going to have to find some way to determine

145
00:08:52,820 --> 00:08:55,900
that this is a unique request.

146
00:08:55,900 --> 00:08:57,660
You can do that through some of the auth methods as well.

147
00:08:57,660 --> 00:08:59,020
They provide unique IDs.

148
00:08:59,020 --> 00:09:03,580
You're going to have to store that unique value in a data store so you can verify you

149
00:09:03,580 --> 00:09:04,580
don't see it again.

150
00:09:04,580 --> 00:09:09,460
It's very important I see this one so I don't want to see it again.

151
00:09:09,460 --> 00:09:12,780
The easiest way to do that is using some sort of cache solution, something that supports

152
00:09:12,780 --> 00:09:17,060
like a memcache interface where it has an add method.

153
00:09:17,060 --> 00:09:22,060
Add method makes sure that if I want to add this to the key store and when you try and

154
00:09:22,060 --> 00:09:25,980
add it, if it exists, it will return an error.

155
00:09:25,980 --> 00:09:26,980
And that prevents race conditions.

156
00:09:26,980 --> 00:09:31,220
What you don't want to do is you don't want to go do a get and say, hey, have I seen this

157
00:09:31,220 --> 00:09:32,220
key before?

158
00:09:32,220 --> 00:09:33,940
Oh, I have seen it.

159
00:09:33,940 --> 00:09:34,940
Great.

160
00:09:34,940 --> 00:09:35,940
I'm going to error no.

161
00:09:35,940 --> 00:09:36,940
I'm going to create it.

162
00:09:37,420 --> 00:09:39,140
So, you can see that the time it took you to make that decision, you've also gotten

163
00:09:39,140 --> 00:09:43,980
a thousand other requests from somebody who's doing simultaneous hits.

164
00:09:43,980 --> 00:09:46,420
You want to prevent that as much as you can.

165
00:09:46,420 --> 00:09:50,260
So this may be a little difficult to see in the back, but you'll be seeing it in the code

166
00:09:50,260 --> 00:09:53,700
examples so don't worry about it.

167
00:09:53,700 --> 00:09:57,020
And here's basically checking to see if you didn't get a token, whatever you're using

168
00:09:57,020 --> 00:10:00,420
to identify that uniqueness, you raise an error.

169
00:10:00,420 --> 00:10:05,780
Otherwise you do a cache add hash of something, whether that's the headers of your request

170
00:10:05,820 --> 00:10:09,540
or some value that you're going to be able to determine is unique.

171
00:10:09,540 --> 00:10:12,620
And then if it is, you throw an invalid request exception.

172
00:10:12,620 --> 00:10:14,020
Pretty easy to do.

173
00:10:14,020 --> 00:10:16,980
You can do this with relational databases.

174
00:10:16,980 --> 00:10:18,540
I don't suggest it.

175
00:10:18,540 --> 00:10:22,260
Relational databases are rarely ready for the kind of volume that you need to be able

176
00:10:22,260 --> 00:10:27,340
to do this kind of prevention and you're most likely going to take them down before your

177
00:10:27,340 --> 00:10:29,000
web server goes down.

178
00:10:29,000 --> 00:10:31,620
But if you need to, you can.

179
00:10:31,620 --> 00:10:35,020
You just need to insert a row with a unique index for that key.

180
00:10:35,420 --> 00:10:36,940
However that works for you.

181
00:10:38,660 --> 00:10:44,020
Rate limiting requires unique identifier for restriction as well.

182
00:10:44,020 --> 00:10:47,940
And rate limiting also requires that usually rate limiting is based on time.

183
00:10:47,940 --> 00:10:52,620
So one way that you can do that is by taking the information that you need to create this

184
00:10:52,620 --> 00:10:53,620
uniqueness.

185
00:10:53,620 --> 00:10:57,460
So often when you're usually when you're doing rate limiting, it's per account.

186
00:10:57,460 --> 00:11:01,620
So you're allowed to make 10 of these a minute or 100 of these a second, whatever that case

187
00:11:01,620 --> 00:11:04,500
may be.

188
00:11:04,500 --> 00:11:10,460
And so the way that you do that is you find their identifier for an account or a user.

189
00:11:10,460 --> 00:11:14,700
You find an identifier for the action that they're taking.

190
00:11:14,700 --> 00:11:20,060
And that could be just a standard name that you're going to be rate limiting or you could

191
00:11:20,060 --> 00:11:26,740
use something like the combination of the method and the URI.

192
00:11:26,740 --> 00:11:28,640
And a piece of time.

193
00:11:28,640 --> 00:11:29,640
So it's super important.

194
00:11:29,640 --> 00:11:33,380
It doesn't have to be, you know, it doesn't have to look like time.

195
00:11:33,380 --> 00:11:35,460
But you're also going to do a time segment because you're going to say that, oh, you

196
00:11:35,460 --> 00:11:40,180
can only do this one time per minute, one time per hour, one time per second.

197
00:11:40,180 --> 00:11:42,460
And you have to have that slice there.

198
00:11:42,460 --> 00:11:50,780
So one of the things I don't recommend is that you worry about an exact time.

199
00:11:50,780 --> 00:11:54,740
So if you're from the time you make the first one to the time you make the 10th one, you

200
00:11:54,740 --> 00:11:58,300
don't want to track that time because that's expensive because you're going to have to

201
00:11:58,300 --> 00:12:02,800
basically stick a bunch of things in with timings and then count them all.

202
00:12:02,920 --> 00:12:05,760
That's really expensive because that can go across multiple things.

203
00:12:05,760 --> 00:12:06,760
Right.

204
00:12:06,760 --> 00:12:09,040
So you have to pull down a bunch of data, which you don't want to do because that's

205
00:12:09,040 --> 00:12:12,240
expensive and then count it up, which is very expensive.

206
00:12:12,240 --> 00:12:15,860
What you want to do is you just want to create a just a time block.

207
00:12:15,860 --> 00:12:20,520
So if you're what you're trying to do is to prevent people from being able to attack your

208
00:12:20,520 --> 00:12:23,860
system or abuse your system.

209
00:12:23,860 --> 00:12:25,640
You shouldn't worry about the exact time.

210
00:12:25,640 --> 00:12:29,240
Just say during a five minute segments, let's say it's five minutes during this five minute

211
00:12:29,240 --> 00:12:32,960
segment, you can't make more than 100.

212
00:12:32,960 --> 00:12:36,440
Will they be able to make more than 100 in a five minute time period?

213
00:12:36,440 --> 00:12:38,560
Yes, the maximum is 200.

214
00:12:38,560 --> 00:12:43,000
But if you can live with that, then you're going to be OK because it's a much less expensive

215
00:12:43,000 --> 00:12:44,000
thing to do.

216
00:12:44,000 --> 00:12:48,520
You can create a single key to go in a key value store based on a time slice, an action

217
00:12:48,520 --> 00:12:49,800
and a user.

218
00:12:49,800 --> 00:12:54,680
The other way is you're having to add a bunch of data into databases and getting it by a

219
00:12:55,680 --> 00:12:59,640
everything beyond this time and then counting it all up, which is expensive and can't be

220
00:12:59,640 --> 00:13:01,860
done in like a memcache store.

221
00:13:01,860 --> 00:13:06,080
So when you're doing these types of things, at least at a very high level to protect yourself

222
00:13:06,080 --> 00:13:10,360
from attacks, do that once you determine it's not somebody attacking or abusing your system

223
00:13:10,360 --> 00:13:11,520
terribly.

224
00:13:11,520 --> 00:13:15,560
If you want to check to see if they've done any more calls in your database after that,

225
00:13:15,560 --> 00:13:17,040
that's something you can absolutely do.

226
00:13:17,040 --> 00:13:23,320
But that's more of a billing and an account validation than it is protecting from an attack.

227
00:13:23,320 --> 00:13:25,120
So this is protecting from an attack.

228
00:13:25,120 --> 00:13:27,840
And you want to use as few resources as you can.

229
00:13:27,840 --> 00:13:31,440
Because when you're trying to protect from a denial of service, the last thing you want

230
00:13:31,440 --> 00:13:37,560
to do is use up so many resources protecting it that you deny your users the service.

231
00:13:37,560 --> 00:13:42,680
Again, you want to use the add and increment functions of the cache to prevent the race

232
00:13:42,680 --> 00:13:43,680
conditions.

233
00:13:43,680 --> 00:13:48,040
So just like before, you would do an add.

234
00:13:48,040 --> 00:13:49,640
So here we're getting the time slice.

235
00:13:49,640 --> 00:13:51,440
We're getting a key based on the time slice.

236
00:13:52,240 --> 00:13:56,080
You're going to do an add of the key to say that it's zero.

237
00:13:56,080 --> 00:13:58,080
And then how long it should be there.

238
00:13:58,080 --> 00:14:01,280
So when you're using cache systems, they want to know how long is this before I invalidate

239
00:14:01,280 --> 00:14:03,200
this piece of the cache.

240
00:14:03,200 --> 00:14:04,400
And then you do an increment.

241
00:14:04,400 --> 00:14:07,600
So caches allow for an increment.

242
00:14:07,600 --> 00:14:09,440
So you add it.

243
00:14:09,440 --> 00:14:11,400
You don't care if it fails.

244
00:14:11,400 --> 00:14:13,000
You're not checking to see if it's cheated or not.

245
00:14:13,000 --> 00:14:14,480
Because if it's there already, that's good.

246
00:14:14,480 --> 00:14:16,480
You're just going to increment it anyway.

247
00:14:16,480 --> 00:14:18,680
And then you do the increment.

248
00:14:18,680 --> 00:14:19,960
And then it will return.

249
00:14:19,960 --> 00:14:21,280
The increment is an atomic thing.

250
00:14:21,280 --> 00:14:24,320
So when you do the increment, it returns the current value after it incremented.

251
00:14:24,320 --> 00:14:28,400
And you can determine if it's too high or not.

252
00:14:28,400 --> 00:14:30,720
You could do the same thing on an RDBMS.

253
00:14:30,720 --> 00:14:33,920
Again, I don't suggest this.

254
00:14:33,920 --> 00:14:38,880
If you don't want to set up a cache system to figure this out and the file-based caching

255
00:14:38,880 --> 00:14:42,080
stuff we're going to use today is a little too primitive and you want to mess around

256
00:14:42,080 --> 00:14:45,600
with it, you absolutely can.

257
00:14:45,600 --> 00:14:48,080
But it's kind of weird on how you do it.

258
00:14:48,080 --> 00:14:52,560
Some databases allow update returning.

259
00:14:52,560 --> 00:14:56,760
Not all databases do.

260
00:14:56,760 --> 00:14:59,440
So data stores can be done in three ways.

261
00:14:59,440 --> 00:15:06,000
So again, you're trying to protect against resource utilization.

262
00:15:06,000 --> 00:15:07,640
So there's a few ways that you can do that.

263
00:15:07,640 --> 00:15:10,360
So one is that you can use a local memory data store.

264
00:15:10,360 --> 00:15:14,680
That's a little tougher to do in Python unless you're using greenlets or something that has

265
00:15:14,680 --> 00:15:20,680
some sort of constantly persistent data stored memory that everything uses.

266
00:15:20,680 --> 00:15:21,800
Gets a little tougher.

267
00:15:21,800 --> 00:15:27,200
But you can do it, let's say if you're using what I'm familiar with as micro-whiskey, is

268
00:15:27,200 --> 00:15:30,340
you can have static things shared across your threads.

269
00:15:30,340 --> 00:15:33,520
And so you can have it make sure that as long as these threads haven't gone beyond a certain

270
00:15:33,520 --> 00:15:36,680
amount, I can look in memory because it's very cheap.

271
00:15:36,680 --> 00:15:42,320
I can very quickly just increment a value inside of that and see if it's too high for

272
00:15:42,320 --> 00:15:46,640
my key value, doing that in some sort of dictionary.

273
00:15:46,640 --> 00:15:49,720
The problem that comes with them in memory data stores, you don't want to have it use

274
00:15:49,720 --> 00:15:53,480
up all of your memory with everything of everybody going into it.

275
00:15:53,480 --> 00:15:58,120
So if you have a super, super high volume system, in memory data store is probably what

276
00:15:58,120 --> 00:15:59,160
you want to use.

277
00:15:59,160 --> 00:16:03,400
If you don't have a super high volume system, you probably don't have to figure it out.

278
00:16:03,400 --> 00:16:05,100
So local data store.

279
00:16:05,100 --> 00:16:11,960
So if you have a server and you can locally run something like memcache or one piece of

280
00:16:12,000 --> 00:16:19,120
a large scaled caching solution, memcache is super cheap as far as memory and utilization.

281
00:16:19,120 --> 00:16:21,840
So that's something that you can use.

282
00:16:21,840 --> 00:16:25,320
You can also, if you're doing containers, you can always sidecar on something else that's

283
00:16:25,320 --> 00:16:28,320
some sort of caching system into a container.

284
00:16:28,320 --> 00:16:34,440
That's a really nice new thing that everybody's doing with containers.

285
00:16:34,440 --> 00:16:37,680
And that's going to prevent you from using up network resources.

286
00:16:37,680 --> 00:16:44,200
So the local data store, or sorry, the memory data store is preventing from using as few

287
00:16:44,200 --> 00:16:48,000
CPU resources and server resources as possible.

288
00:16:48,000 --> 00:16:52,080
Local data store is preventing you from just using up all of your network.

289
00:16:52,080 --> 00:16:56,800
And then a global data store is something that's going to make sure that this, be able

290
00:16:56,800 --> 00:16:59,760
to track it across multiple instances of your servers.

291
00:16:59,760 --> 00:17:05,240
So if you're running a real time API that has uptime needs, then it's absolutely going

292
00:17:05,240 --> 00:17:12,440
to have at least two, hopefully three instances, maybe more, maybe hundreds, maybe thousands.

293
00:17:12,440 --> 00:17:18,520
You'll need to share that global data store to be able to prevent it along the way.

294
00:17:18,520 --> 00:17:22,120
To make sure that as the things are being spread across all of your servers, you don't

295
00:17:22,120 --> 00:17:26,120
have someone who's just sending out just millions of requests to all of your servers, because

296
00:17:26,120 --> 00:17:31,000
that's what people do on a DDoS attack.

297
00:17:31,000 --> 00:17:36,080
There's defense and depth, right, depending on where your needs come.

298
00:17:36,080 --> 00:17:42,080
You start with a global data store, a local data store is something you add on top, and

299
00:17:42,080 --> 00:17:47,320
then a memory data store if you have a high resource utilization system.

300
00:17:47,320 --> 00:17:51,920
And with the things that we're going to show today, you can actually just make one that

301
00:17:51,920 --> 00:17:55,600
checks all three, make sure locally it's fine, and then you can check on down and check on

302
00:17:55,600 --> 00:18:00,680
down to make sure things are getting incremented.

303
00:18:01,000 --> 00:18:04,200
The important thing is that you want to make sure that people aren't just trying to destroy

304
00:18:04,200 --> 00:18:06,720
your system with replay attacks.

305
00:18:06,720 --> 00:18:15,880
Authentication, most of us are probably reasonably familiar with that, at least that it exists.

306
00:18:15,880 --> 00:18:22,320
One of the things I've seen more in the SOAP world than I have in the XML world than I

307
00:18:22,320 --> 00:18:26,160
have in the JSON world, please don't make authentication part of your body.

308
00:18:26,160 --> 00:18:27,160
Yeah, question.

309
00:18:28,160 --> 00:18:32,160
Sure, ask questions.

310
00:18:48,160 --> 00:18:55,160
So the question is, for the replay attacks, are we talking about recording all the requests

311
00:18:55,160 --> 00:18:56,160
in a database?

312
00:18:56,160 --> 00:18:57,160
No.

313
00:18:57,160 --> 00:19:00,160
What you want to do is you want to find what creates uniqueness.

314
00:19:00,160 --> 00:19:09,160
So, when we're talking about user rate limiting, you're going to create that this user can

315
00:19:09,160 --> 00:19:12,160
only make this many requests in a particular amount of time.

316
00:19:12,160 --> 00:19:17,160
When you're talking about replay attacks, you're checking to see if this has ever been

317
00:19:17,160 --> 00:19:19,160
used before, whatever is unique about your request.

318
00:19:19,160 --> 00:19:23,160
You're putting one record in there that's going to, and again, if you're using something

319
00:19:23,160 --> 00:19:26,160
like memcache, it's just going to fall off at the end.

320
00:19:26,160 --> 00:19:28,160
So, you're not going to use up all of your resources.

321
00:19:28,160 --> 00:19:31,160
You're just going to stick it in there and say, have I ever seen this before?

322
00:19:31,160 --> 00:19:32,160
If I have, I've seen this.

323
00:19:32,160 --> 00:19:35,160
This is a replay attack because I've seen this request before.

324
00:19:39,160 --> 00:19:41,160
So, this one is for replay attack.

325
00:19:41,160 --> 00:19:45,160
This is unique to the request to make sure that someone doesn't.

326
00:19:45,160 --> 00:19:48,160
So, let me explain why this is important.

327
00:19:48,160 --> 00:19:55,160
So, today I can go and there are software out there that I can get that's used for testing.

328
00:19:55,160 --> 00:20:01,160
I use it locally for testing to see how many requests per minute your system can withstand.

329
00:20:02,160 --> 00:20:08,160
If I don't have to do anything different for a request, it costs me nothing to do that.

330
00:20:08,160 --> 00:20:13,160
I can just have it play the exact same request over and over again, split out to thousands

331
00:20:13,160 --> 00:20:19,160
of threads across hundreds of VMs and have it just do a massive volumetric attack

332
00:20:19,160 --> 00:20:25,160
because it costs me nothing except for network resource and some tiny bit of memory for each thread.

333
00:20:25,160 --> 00:20:31,160
If I have to generate a unique identifier for every request, that's expensive

334
00:20:31,160 --> 00:20:36,160
because I have to use CPU to generate that unique value, and it has to be unique

335
00:20:36,160 --> 00:20:40,160
so that I don't let you know that this is a volumetric attack coming at you.

336
00:20:40,160 --> 00:20:44,160
So, you're trying to always make it more expensive for the attacker.

337
00:20:44,160 --> 00:20:50,160
So, all of these solutions, the defensive depth, you're trying to make it more expensive for them to attack you

338
00:20:50,160 --> 00:20:55,160
and hopefully you get to a point where the amount it costs them to do it is way, way more

339
00:20:55,160 --> 00:20:59,160
than the value they'll get from whatever they get from attacking you.

340
00:20:59,160 --> 00:21:02,160
But sometimes they're not doing it for money.

341
00:21:02,160 --> 00:21:08,160
Hacktivists, if you work at a company that lives on one side of any particular issue or another,

342
00:21:08,160 --> 00:21:11,160
there's somebody who doesn't like you because you live on the other side.

343
00:21:11,160 --> 00:21:17,160
And the likelihood that if there's someone out there that wants to attack you is going to be reasonably high.

344
00:21:17,160 --> 00:21:22,160
And it doesn't matter who's right or wrong, they're just going to do it.

345
00:21:22,160 --> 00:21:25,160
Does that answer your question?

346
00:21:25,160 --> 00:21:28,160
Yes. Thank you very much.

347
00:21:28,160 --> 00:21:31,160
Oh, no worries. It's important for me to make sure everyone understands.

348
00:21:31,160 --> 00:21:34,160
How do you use the database to do that?

349
00:21:34,160 --> 00:21:38,160
So, the way that you use the database to do this is you're basically sticking things into,

350
00:21:38,160 --> 00:21:40,160
and I would just provide, don't use a database.

351
00:21:40,160 --> 00:21:45,160
You can use a database. Don't use a database. Very expensive.

352
00:21:45,160 --> 00:21:51,160
Use something like memcache, redis cache, some key value store that's not going to use indexing.

353
00:21:51,160 --> 00:21:54,160
It's going to be very quick and it will expire.

354
00:21:54,160 --> 00:21:58,160
It's important that when you're having these things is figure out, when you're using memcache,

355
00:21:58,160 --> 00:22:02,160
it will just keep filling it up and when it runs out of space, it drops the old ones off.

356
00:22:02,160 --> 00:22:05,160
It figures that out. It does garbage collection. That's not a problem.

357
00:22:05,160 --> 00:22:12,160
When you're doing things that are time-based, once that time window has lapsed, you no longer need that value.

358
00:22:12,160 --> 00:22:16,160
So, save some memory and tell it to expire after, if it's a 10-minute window,

359
00:22:16,160 --> 00:22:19,160
have it expire after 10 minutes because you don't care anymore.

360
00:22:19,160 --> 00:22:23,160
So, like I said, you can do it with a database. Don't do it with a database.

361
00:22:23,160 --> 00:22:28,160
If you want to make a proof of concept because that's what you have and that's all you have available,

362
00:22:28,160 --> 00:22:30,160
you can make it as a proof of concept.

363
00:22:30,160 --> 00:22:35,160
Doing the file-level caching can be very expensive for people who have slow file systems.

364
00:22:35,160 --> 00:22:41,160
And the file-level caching stuff we have in our example, if you put it in the wrong directory, it's going to crash.

365
00:22:41,160 --> 00:22:45,160
Because it's very dumb. It just goes, oh, let me look at all the things I'm supposed to expire.

366
00:22:45,160 --> 00:22:50,160
Oh, there's a .DS underscore store file. I can't read that. I blow up.

367
00:22:50,160 --> 00:22:56,160
It's a very dumb solution. But it's fine for our example, which is what we're going to do.

368
00:22:57,160 --> 00:23:01,160
But like I said, it's an expensive thing that you don't want to do.

369
00:23:01,160 --> 00:23:05,160
But again, if you want to make a proof of concept or something like that, you absolutely can start there.

370
00:23:05,160 --> 00:23:08,160
But don't use a database because you won't.

371
00:23:08,160 --> 00:23:12,160
The most expensive thing on most applications for time and resources is database.

372
00:23:12,160 --> 00:23:18,160
So you don't want to rely on the most expensive resource thing to reduce the amount of resources you're using.

373
00:23:18,160 --> 00:23:24,160
So next time, make sure I put it in a big red, do not do this. But this is an example.

374
00:23:24,160 --> 00:23:27,160
Unless you have an extremely fast database.

375
00:23:27,160 --> 00:23:30,160
So we actually do use our database for caching because it's a key value store.

376
00:23:30,160 --> 00:23:35,160
So we use Cassandra. And Cassandra was actually easier and faster than bring up a separate system.

377
00:23:35,160 --> 00:23:38,160
Because it does everything we need it to do anyway.

378
00:23:38,160 --> 00:23:43,160
So again, Cassandra is a very different thing. And most of you probably aren't using Cassandra.

379
00:23:43,160 --> 00:23:48,160
Because Cassandra actually has auto-expire. It has TTLs and all that kind of stuff.

380
00:23:48,160 --> 00:23:53,160
Okay.

381
00:23:53,160 --> 00:23:57,160
So modern world, not a big deal.

382
00:23:57,160 --> 00:24:02,160
But if you have a legacy system, right, that somebody built and went, oh, I don't understand authentication.

383
00:24:02,160 --> 00:24:07,160
I'm going to have some of the user pass and username and password across in the message.

384
00:24:07,160 --> 00:24:10,160
Don't do that.

385
00:24:11,160 --> 00:24:18,160
There's a, when you do that, you have to actually parse the body to determine if it's a valid user or not.

386
00:24:18,160 --> 00:24:23,160
Valid users are less likely to attack your system than invalid users.

387
00:24:23,160 --> 00:24:34,160
But so parsing the data, especially if you've got XML, there are things that you can do in XML that are known vulnerabilities for XML parsing.

388
00:24:34,160 --> 00:24:43,160
If you're using an old version of some XML libraries, an old version of Python, there are some nasty, nasty vulnerabilities in there.

389
00:24:43,160 --> 00:24:49,160
Especially when you tell it to, you can basically create a link that says, here's my data validation for this XML.

390
00:24:49,160 --> 00:24:51,160
It's going to go load stuff from a remote server.

391
00:24:51,160 --> 00:24:54,160
That's just part of XML. It's how it works.

392
00:24:54,160 --> 00:25:00,160
So you want to make sure it's a valid user first. It's a valid request first before you start parsing the body.

393
00:25:00,160 --> 00:25:07,160
There's also some stuff with JSON. If you make it large enough, you can do bad things to the system with buffer overruns, things like that.

394
00:25:07,160 --> 00:25:13,160
So you don't want to do that. You want to make sure it's a valid user before you start dealing with the data.

395
00:25:13,160 --> 00:25:17,160
Make sure it's from a trusted source before you start dealing with the actual data.

396
00:25:17,160 --> 00:25:21,160
So fortunately, there's an authorization header. It's part of the HTTP specification.

397
00:25:21,160 --> 00:25:27,160
If you're an API builder, you should be, and you're not super familiar with the HTTP specification, spend some time.

398
00:25:27,160 --> 00:25:34,160
It's kind of a pain. You have to learn how to read RFCs, and that's a special skill that I've had to learn is how to read RFCs.

399
00:25:34,160 --> 00:25:37,160
But there is the authorization header.

400
00:25:37,160 --> 00:25:41,160
So most of the world has seen basic authentication.

401
00:25:41,160 --> 00:25:44,160
Basic authentication is an authorization header.

402
00:25:44,160 --> 00:25:46,160
The type of authorization is basic.

403
00:25:46,160 --> 00:25:51,160
And then you have a hash of the username, colon, password.

404
00:25:51,160 --> 00:25:54,160
That's basic authentication.

405
00:25:54,160 --> 00:25:59,160
I don't know what, I'm assuming it's sending over the hash so that it becomes URL safe.

406
00:25:59,160 --> 00:26:03,160
It's basically, I'm sorry, it's basically foreign coded, not hash. It's basically foreign coded.

407
00:26:03,160 --> 00:26:08,160
Just that you can have binary password, I guess, if you wanted to do that.

408
00:26:08,160 --> 00:26:13,160
It's super common, but not really secure. The password is sent across the wire.

409
00:26:13,160 --> 00:26:20,160
So if you're sending it across using TLS, there's a bunch of ways that you can attack TLS, man-in-the-mill attacks, things like that,

410
00:26:20,160 --> 00:26:25,160
that people can go get that user's credentials that you don't want to do.

411
00:26:25,160 --> 00:26:31,160
Digest authentication, it has some really nice features, including a NUTS.

412
00:26:31,160 --> 00:26:41,160
So if you need to be able to create that single request identifier, digest authentication allows for that.

413
00:26:41,160 --> 00:26:45,160
What it doesn't do is protect the password. So it doesn't send the password across plain text.

414
00:26:45,160 --> 00:26:54,160
It sends it over either MD5 or SHA-1, which anyone with a decent HashCat machine can crack in very little time.

415
00:26:54,160 --> 00:27:02,160
So if they were to capture that information, if it was MD5 hashed, they could recreate the hash and figure out the password in minutes.

416
00:27:02,160 --> 00:27:14,160
If it was SHA-1, they could do it in days, depending on how many GPUs they had. Not super hard.

417
00:27:14,160 --> 00:27:20,160
So bearer authentication is becoming really popular. So if you've used OAuth or OpenID,

418
00:27:20,160 --> 00:27:28,160
or OpenID is based on, or OpenID Connect, I should say, is based on OAuth 2 with JSON Web Tokens.

419
00:27:28,160 --> 00:27:33,160
So bearer authentication is you're presented a token. I had to make it fit.

420
00:27:33,160 --> 00:27:36,160
That's actually something separated, it's three segments separated by periods,

421
00:27:36,160 --> 00:27:44,160
which is what JWT tokens look like when they are compact serialized.

422
00:27:44,160 --> 00:27:48,160
So these don't require passwords. So you're preventing credentials for a user.

423
00:27:48,160 --> 00:27:57,160
It's signed by the system that's presenting the tokens by your OAuth server or OpenID Connect server.

424
00:27:57,160 --> 00:28:02,160
If you've done social login, right, login with Facebook, login with Google, that's what it's doing.

425
00:28:02,160 --> 00:28:11,160
It's preventing a bearer token saying, hi, I'm Facebook, and I'm logging in for this user into your system.

426
00:28:11,160 --> 00:28:17,160
And this credential is good from this time to this time, and it's good for these systems.

427
00:28:17,160 --> 00:28:26,160
And here's my unique identifier for this token, so if that token ever gets revoked, you can know that this token was revoked.

428
00:28:26,160 --> 00:28:30,160
It's becoming popular. A lot of APIs, well, not a lot.

429
00:28:30,160 --> 00:28:35,160
There are a few APIs that I use externally that provide OAuth authentication.

430
00:28:35,160 --> 00:28:41,160
There's small problems, though, is it adds a level of complexity where you're going to have to go get the token and store it.

431
00:28:41,160 --> 00:28:51,160
If you don't do that, you might have to make two calls every time you make an API call to go get the OAuth token and then to make the actual request.

432
00:28:51,160 --> 00:28:54,160
If you have, otherwise you're having to store it somewhere.

433
00:28:54,160 --> 00:29:00,160
And in Python, most of the applications don't have a lot of places to store things that are used globally,

434
00:29:00,160 --> 00:29:06,160
unlike most of the stuff I think is being used probably by Java and .NET where you do have that.

435
00:29:06,160 --> 00:29:14,160
There are some places, if you really, really want it to, where you can stick that per server in your green unicorn or your micro-whiskey server.

436
00:29:14,160 --> 00:29:19,160
But that's a hard process. There's not a lot of good solutions out there.

437
00:29:19,160 --> 00:29:26,160
The other options to rule your own. A lot of APIs do this.

438
00:29:26,160 --> 00:29:34,160
Because they're trying to increase security but not add the complexity.

439
00:29:34,160 --> 00:29:37,160
Because when you make it too hard, nobody's going to want to do it.

440
00:29:37,160 --> 00:29:42,160
If someone has to make two requests to your system every time they want to do it, that's adding strain to your system.

441
00:29:42,160 --> 00:29:47,160
So they probably have the right reasons to do it.

442
00:29:47,160 --> 00:29:52,160
But you're always told never roll your own crypto.

443
00:29:52,160 --> 00:30:00,160
And that's for good reason. Because the people who are cryptographers who are attacking cryptography know it better than you do.

444
00:30:00,160 --> 00:30:04,160
Which creates a conundrum. Right?

445
00:30:04,160 --> 00:30:10,160
And fortunately, there's some middle ground. So there's single-use JSON Web Token.

446
00:30:10,160 --> 00:30:14,160
So this is something that I use in all of my APIs.

447
00:30:14,160 --> 00:30:19,160
Because it's using JSON Web Tokens, which are the basis of OAuth.

448
00:30:19,160 --> 00:30:24,160
But it has some advantages. There's no auth service required.

449
00:30:24,160 --> 00:30:28,160
So you don't have to go to a separate service to get the token.

450
00:30:28,160 --> 00:30:34,160
The system, you're generating your own token saying, hi, I'm your user. I'm allowed to access your system.

451
00:30:34,160 --> 00:30:37,160
Here are my credentials saying I'm allowed to access your system.

452
00:30:37,160 --> 00:30:42,160
But I'm only going to use this once.

453
00:30:42,160 --> 00:30:47,160
You can use existing JWT libraries to create and validate those tokens.

454
00:30:47,160 --> 00:30:55,160
So before we were using JSON Web Tokens, we were using, we were rolling our own, which was awful.

455
00:30:55,160 --> 00:31:03,160
If you've ever had to use the Twitter API using the old OAuth and had to add the extra headers in the right order

456
00:31:04,160 --> 00:31:11,160
and do all this crazy nonsense to actually create the hash, you'll understand the pain that people had trying to use our system.

457
00:31:11,160 --> 00:31:18,160
And it could be extended beyond auth to provide validation and man the middle protection.

458
00:31:18,160 --> 00:31:25,160
So JSON Web Token is just a piece of JSON that has a specific schema that's extensible.

459
00:31:25,160 --> 00:31:29,160
So there's things that are protected that can only mean a certain thing.

460
00:31:29,160 --> 00:31:31,160
And anything beyond that, you can use for whatever you want.

461
00:31:31,160 --> 00:31:36,160
So just like headers, you create an X dash header that's totally allowable because it's extensible.

462
00:31:36,160 --> 00:31:38,160
JSON Web Tokens are extensible as well.

463
00:31:38,160 --> 00:31:46,160
Once you get beyond their standard, it's considered a private value and you can do whatever you want.

464
00:31:46,160 --> 00:31:48,160
So that's what we did in our system.

465
00:31:48,160 --> 00:31:52,160
And we'll show this a little bit later.

466
00:31:52,160 --> 00:31:54,160
So access control.

467
00:31:54,160 --> 00:32:00,160
So access should be denied by default and programmatically enabled.

468
00:32:00,160 --> 00:32:03,160
So make sure that's one of the things.

469
00:32:03,160 --> 00:32:06,160
Anything with security, make sure it's off and then you allow for exceptions.

470
00:32:06,160 --> 00:32:16,160
If you have firewall rules, by default, nobody can access except for this IP, this IP, this IP, as opposed to enable this IP, disable people who are not these IPs.

471
00:32:16,160 --> 00:32:20,160
You want to make sure that by default, you just can't get in.

472
00:32:20,160 --> 00:32:23,160
Same thing with access control.

473
00:32:23,160 --> 00:32:28,160
Most of us are probably using something built into whatever framework that we're using to do this.

474
00:32:28,160 --> 00:32:32,160
So it just kind of happens.

475
00:32:32,160 --> 00:32:40,160
But if you can, if you're not using the things that are in there or it doesn't make sense to use the things that are in there based on how you're doing authentication,

476
00:32:40,160 --> 00:32:43,160
make sure it exists outside the controller logic.

477
00:32:43,160 --> 00:32:44,160
All right.

478
00:32:44,160 --> 00:32:47,160
Don't allow people to get inside of a bug.

479
00:32:47,160 --> 00:32:49,160
Find something outside.

480
00:32:49,160 --> 00:32:57,160
So if you're using some sort of middleware in front of your front controller, right, you want to make sure that you're doing that before you get into your code.

481
00:32:57,160 --> 00:33:04,160
So that you don't allow hackers into the juice of your code where your bugs are going to be and your vulnerabilities are going to exist.

482
00:33:04,160 --> 00:33:07,160
At least make sure it's somebody who's set up an account.

483
00:33:07,160 --> 00:33:11,160
Make it expensive for them.

484
00:33:11,160 --> 00:33:12,160
Data validation.

485
00:33:12,160 --> 00:33:17,160
So you should validate the data coming into your API.

486
00:33:17,160 --> 00:33:18,160
It seems pretty straightforward.

487
00:33:18,160 --> 00:33:21,160
Never trust anything from anyone ever.

488
00:33:21,160 --> 00:33:25,160
Even if it's your own application, never trust data from your own application.

489
00:33:25,160 --> 00:33:30,160
Because your own application can have bugs and send things that can do terrible things to your system.

490
00:33:30,160 --> 00:33:38,160
And if you have something that's external, there are things that are a man in the mill attacks that can happen.

491
00:33:38,160 --> 00:33:43,160
And I'm not just talking about data validation to the request itself, the JSON data.

492
00:33:43,160 --> 00:33:46,160
Validate that the request is valid in the header level.

493
00:33:46,160 --> 00:33:48,160
Make sure that the method is allowed.

494
00:33:48,160 --> 00:33:53,160
Do all this validation against the system to make sure that's what it says that it is.

495
00:33:54,160 --> 00:33:59,160
So as I said, message is something that needs to be message itself.

496
00:33:59,160 --> 00:34:03,160
Making sure that this is a valid request.

497
00:34:03,160 --> 00:34:06,160
And there's bad things that can happen when these things are compromised.

498
00:34:06,160 --> 00:34:09,160
We'll see examples in a second.

499
00:34:09,160 --> 00:34:13,160
So request data, really bad things can happen.

500
00:34:13,160 --> 00:34:18,160
So you take a very standard request.

501
00:34:18,160 --> 00:34:20,160
This could be the entire request.

502
00:34:20,160 --> 00:34:23,160
You're doing a get on a user record, right?

503
00:34:23,160 --> 00:34:26,160
Real standard rest stuff.

504
00:34:26,160 --> 00:34:33,160
But if I change that get to a delete in the middle, bad things happen.

505
00:34:33,160 --> 00:34:39,160
So you want to make sure that people can't modify requests on the way through a man in the mill attack.

506
00:34:39,160 --> 00:34:43,160
So that I can't modify the request.

507
00:34:43,160 --> 00:34:48,160
So let's say I get user ABC, totally valid.

508
00:34:48,160 --> 00:34:51,160
But in the middle I change it to a user that I want to see.

509
00:34:51,160 --> 00:34:53,160
I change it to user DEF.

510
00:34:53,160 --> 00:34:56,160
You don't want to allow that to happen.

511
00:34:58,160 --> 00:35:00,160
So let's say a patch request, right?

512
00:35:00,160 --> 00:35:02,160
Now we're talking about the body of the request.

513
00:35:02,160 --> 00:35:09,160
So in the body, I send a hey, change the email for this account to the valid user.

514
00:35:09,160 --> 00:35:11,160
And then, am I man in the mill attack?

515
00:35:11,160 --> 00:35:13,160
I change it to my email.

516
00:35:13,160 --> 00:35:15,160
So now I can take over their account.

517
00:35:15,160 --> 00:35:20,160
Because I have their email address associated with my email address.

518
00:35:20,160 --> 00:35:28,160
So you can see just small changes to an HTTP request across the path can do just terrible things.

519
00:35:28,160 --> 00:35:30,160
There's also response validation.

520
00:35:30,160 --> 00:35:36,160
So it's not necessarily happening on your API, but the consumers of your API,

521
00:35:36,160 --> 00:35:39,160
if there's a man in the mill attack, can have bad things happen.

522
00:35:39,160 --> 00:35:43,160
So you can have things.

523
00:35:43,160 --> 00:35:49,160
Basically, you can take this standard request with a 200 OK and make people think that the service isn't working.

524
00:35:49,160 --> 00:35:55,160
They'll think that I can't make proper valid requests just by changing the status code.

525
00:35:55,160 --> 00:36:00,160
You can basically create a null service situation because every client is going to blow up on a 400.

526
00:36:00,160 --> 00:36:05,160
It successfully worked, but the consumer doesn't know that it worked because they're constantly getting errors.

527
00:36:07,160 --> 00:36:10,160
One that's even worse, question.

528
00:36:10,160 --> 00:36:17,160
We are going to talk about how to protect against this.

529
00:36:17,160 --> 00:36:23,160
So I could change that to a 301 and have them get data from another system.

530
00:36:23,160 --> 00:36:25,160
And this is an issue with requests.

531
00:36:25,160 --> 00:36:30,160
I love the request library, but built in, it automatically files redirects.

532
00:36:30,160 --> 00:36:36,160
So be warned that if a man in the mill attack comes in and says, oh, this has moved to here,

533
00:36:36,160 --> 00:36:46,160
they'll go get whatever you wanted them to have, which could have something that's going to use a known vulnerability against whatever system they're using.

534
00:36:46,160 --> 00:36:55,160
So it could be something there's a known Python attack, there's a known attack against requests or beautiful soup or the XML library or something.

535
00:36:55,160 --> 00:37:01,160
The other thing is that cache control is another big one.

536
00:37:01,160 --> 00:37:07,160
So if there's something coming back, like I'm going to go say, is this going to get me the information for this user?

537
00:37:07,160 --> 00:37:10,160
And it says, great, they're active and they're OK and they're logged in.

538
00:37:10,160 --> 00:37:15,160
That's great. But I never want you to cache this because that can change at any point, anytime.

539
00:37:15,160 --> 00:37:24,160
And if I tell you to just store it forever, then I can deactivate my account and still keep using it because now you've cached it until your system runs out of cache.

540
00:37:26,160 --> 00:37:29,160
And the other thing that you can do is just modify the body.

541
00:37:29,160 --> 00:37:35,160
Right. So I'm not a valid user, active is false, but then I just change it along the way to true.

542
00:37:36,160 --> 00:37:38,160
Bad things happen.

543
00:37:39,160 --> 00:37:42,160
So the other piece is the validation of the request library.

544
00:37:42,160 --> 00:37:46,160
So there are a lot of existing libraries out there do this validation.

545
00:37:46,160 --> 00:37:48,160
Find the one that works best for you.

546
00:37:48,160 --> 00:37:50,160
My experience is don't use one.

547
00:37:50,160 --> 00:37:56,160
If you're using REST, you can absolutely send form data as part of REST for the input.

548
00:37:56,160 --> 00:38:01,160
If you're not sending form data and you're using JSON, you can use form validators.

549
00:38:01,160 --> 00:38:12,160
Don't. The messages are just weird and the way they react are funny because they're trying to create one response line as opposed to being able to give you telling you this feels bad, that feels bad.

550
00:38:13,160 --> 00:38:17,160
So find one that's specific to the type of data that you're receiving.

551
00:38:20,160 --> 00:38:21,160
Encryption.

552
00:38:21,160 --> 00:38:22,160
Encryption.

553
00:38:22,160 --> 00:38:25,160
So this is one of the more expensive things.

554
00:38:26,160 --> 00:38:38,160
And if you are doing business in the EU and possibly California here very soon and maybe Washington, you're going to have to protect your users privacy and the data that you have about that.

555
00:38:38,160 --> 00:38:39,160
And it may have to be encrypted.

556
00:38:39,160 --> 00:38:47,160
Even if you don't have payment card information in the EU, you have to encrypt PII to prevent people from being able to track users.

557
00:38:47,160 --> 00:38:52,160
And California is about to adopt or at least they're trying to adopt basically the same rules there.

558
00:38:52,160 --> 00:38:53,160
And so is Washington.

559
00:38:53,160 --> 00:38:57,160
So if you now if you do business in the US, you may also have to follow this.

560
00:38:57,160 --> 00:38:59,160
So encrypt data at rest.

561
00:38:59,160 --> 00:39:03,160
And this is a complicated thing that I did wrong for a lot of years.

562
00:39:04,160 --> 00:39:05,160
Right.

563
00:39:05,160 --> 00:39:07,160
How do I properly encrypt data at rest?

564
00:39:07,160 --> 00:39:08,160
And I usually do it wrong.

565
00:39:11,160 --> 00:39:18,160
So what I found is use a structured format that allows for in place key rotation and non storage.

566
00:39:18,160 --> 00:39:26,160
So one of the things that people do very wrong when they're doing this is you'll encrypt data and you'll just store the encrypted data in the database or in the file system.

567
00:39:27,160 --> 00:39:33,160
And since you're not storing the nonce with it, you're using a static initialization vector if you're using AES.

568
00:39:33,160 --> 00:39:36,160
Right. Or use some sort of static nonce, which means it's not a nonce.

569
00:39:36,160 --> 00:39:48,160
If you're using what's considered to be fairly good software, right, if you're using AES GCM, which in the AES world is considered the best crypto there and you reuse a nonce, it's completely crackable.

570
00:39:49,160 --> 00:39:50,160
That's bad.

571
00:39:52,160 --> 00:39:56,160
There are other problems with AES CBC as well.

572
00:39:56,160 --> 00:40:02,160
If you have the same nonce, right, you can start finding as far as I have a whole nother cryptography talk.

573
00:40:02,160 --> 00:40:05,160
But you can see patterns.

574
00:40:05,160 --> 00:40:17,160
If you don't have that nonce added in there or that random initialization vector, you can start seeing patterns and people can be more easily able to determine what your keys are just by determining what your data looks like.

575
00:40:17,160 --> 00:40:22,160
And you can do some heuristics against the data to determine very quickly what keys are.

576
00:40:23,160 --> 00:40:24,160
It's scary.

577
00:40:24,160 --> 00:40:32,160
If you want to be scared to death, go see someone do a talk about the CryptoPals hacking exercises and see how easy it is to hack modern cryptography.

578
00:40:32,160 --> 00:40:34,160
It is frightening.

579
00:40:36,160 --> 00:40:38,160
The other thing that you want to make sure that you can do is rotate keys.

580
00:40:38,160 --> 00:40:45,160
So if you were like me and you even if you put a nonce in another database field, you had a single key.

581
00:40:45,160 --> 00:40:51,160
And then when you had to go when we're like, oh, that key got stuck into somebody's code and it got checked in and everybody saw it.

582
00:40:51,160 --> 00:40:54,160
Or this person quit and they had all the keys.

583
00:40:54,160 --> 00:40:56,160
We now have to change the keys.

584
00:40:56,160 --> 00:40:59,160
You have to stop your whole system to re-encrypt your database.

585
00:40:59,160 --> 00:41:00,160
That's that's not good.

586
00:41:00,160 --> 00:41:07,160
So what you want to do is use some sort of structure that allows for in place key rotation and non-storage.

587
00:41:08,160 --> 00:41:10,160
One way to do that is through Cozay.

588
00:41:10,160 --> 00:41:15,160
So Cozay is the Seaborr object signing and encryption standard.

589
00:41:15,160 --> 00:41:19,160
And Seaborr is the concise binary object representation.

590
00:41:20,160 --> 00:41:22,160
There is no Python library for this.

591
00:41:22,160 --> 00:41:33,160
So it may not be your best option, but there's no reason that you can't get together with a few people and try to make one during sprints.

592
00:41:33,160 --> 00:41:35,160
Right. Yeah. Question.

593
00:41:40,160 --> 00:41:42,160
So you would have to re-encrypt everything.

594
00:41:42,160 --> 00:41:45,160
So the question is, wouldn't you have to re-encrypt everything if you changed your keys?

595
00:41:45,160 --> 00:41:47,160
Maybe.

596
00:41:47,160 --> 00:41:55,160
So just like passwords, right, if you if you're accessing it and you create a rotation window as you're accessing data, you can determine needs be re-encrypted and then re-encrypted.

597
00:41:56,160 --> 00:42:01,160
And then when you get past that window, it's like, OK, we've had in place go.

598
00:42:01,160 --> 00:42:03,160
Now we're just going to encrypt the whole database.

599
00:42:03,160 --> 00:42:11,160
Yeah, you have to re-encrypt everything, but you don't have to stop the system because when you have a single key, it either works or it doesn't.

600
00:42:11,160 --> 00:42:18,160
So you can't have when you change the key or when you change the data, one of them is not going to work until all the data has been changed.

601
00:42:18,160 --> 00:42:28,160
So if you have if you can tell if you store inside of your encrypted data, I'm using key number one or I'm using key number two while you're encrypting it,

602
00:42:28,160 --> 00:42:31,160
you're decrypting it for key number one and encrypting it for key number two.

603
00:42:31,160 --> 00:42:35,160
When you retrieve the data, your system can say, oh, this was encrypted with key number one.

604
00:42:35,160 --> 00:42:38,160
I'll use key number one to decrypt it or this is key number two.

605
00:42:38,160 --> 00:42:40,160
I'll use key number two to decrypt it.

606
00:42:40,160 --> 00:42:47,160
So you don't have to bring down your entire system for a weekend while you're re-encrypting your database because I've had to do that.

607
00:42:47,160 --> 00:42:51,160
It is painful and ugly and everybody's angry that they're losing money.

608
00:42:51,160 --> 00:42:59,160
So they said C-BOR is probably the best way to go about it because it's using a standard, which means, again, you're going to have standard libraries.

609
00:42:59,160 --> 00:43:01,160
Sorry, Cozay.

610
00:43:01,160 --> 00:43:03,160
Cozay is a standard and it's going to get more popular.

611
00:43:03,160 --> 00:43:06,160
And so I bring this up because it's coming.

612
00:43:06,160 --> 00:43:13,160
So if you've ever heard of WebAuthn or the Web Authorization Framework for doing multifactor authentication on the web,

613
00:43:13,160 --> 00:43:16,160
it's built into all of your browsers right now.

614
00:43:16,160 --> 00:43:24,160
It uses Cozay instead of Hosea because JSON Web Tokens are text and HTTP2 is binary.

615
00:43:24,160 --> 00:43:31,160
So it was built around the fact that we'll be all moving to HTTP2 soon, just like we all moved to IPv6, right?

616
00:43:31,160 --> 00:43:38,160
And it's cheaper to create the data binary and send it across binary so you don't have to take binary,

617
00:43:38,160 --> 00:43:43,160
turn it to Base64 encoding, and then convert that to binary so it's more efficient.

618
00:43:43,160 --> 00:43:45,160
The other option is to roll your own.

619
00:43:45,160 --> 00:43:52,160
So this is what I ended up doing in our database is I store the key ID, I store the nonce, and I store the encrypted data.

620
00:43:52,160 --> 00:43:58,160
So mine's going into binary, so I just use nulls in between.

621
00:43:58,160 --> 00:44:06,160
So I have the key ID, which is binary value with a null, the nonce with a null, and the encrypted data.

622
00:44:06,160 --> 00:44:13,160
And then I just literally do a regular expression and split it up by the first two null characters.

623
00:44:13,160 --> 00:44:17,160
It's super simple to do, and it worked really well for us.

624
00:44:17,160 --> 00:44:27,160
We don't have size limitations because it's kind of a key value data store, so there's no like table width and all that type of stuff.

625
00:44:27,160 --> 00:44:30,160
It's possible that you could do this inside of multiple keys in your database,

626
00:44:30,160 --> 00:44:35,160
but if you have a bunch of data that has to be encrypted to have, you know, to have social security number,

627
00:44:35,160 --> 00:44:41,160
social security number key ID, social security number, it gets unwieldy, and it's not really stored with the data,

628
00:44:41,160 --> 00:44:43,160
and you have to pull it all in.

629
00:44:43,160 --> 00:44:45,160
Either one will work.

630
00:44:45,160 --> 00:44:53,160
I found that this seems to work better because DBAs don't get angry for the extra stuff they have to stick in their databases.

631
00:44:53,160 --> 00:44:56,160
Encrypting data in transit.

632
00:44:56,160 --> 00:44:58,160
This is a hard one.

633
00:44:58,160 --> 00:45:10,160
But relying on TLS, if you're someone who has to protect important data, is not a good idea.

634
00:45:10,160 --> 00:45:17,160
So it's a fantastic opening gate, but if you've been doing this for more than a few years, you'll remember Heartbleed.

635
00:45:17,160 --> 00:45:19,160
You'll remember Cracked.

636
00:45:19,160 --> 00:45:25,160
You'll remember one of the, like there was a time there was a period of like a year where we had to rotate our keys

637
00:45:25,160 --> 00:45:30,160
and change our versions of our software every three months because there's a new OpenSSL vulnerability.

638
00:45:30,160 --> 00:45:37,160
Fortunately, there's been a lot more people providing time and resources to OpenSSL, so that's less of a problem,

639
00:45:37,160 --> 00:45:44,160
but most of your web servers are going to be using OpenSSL or some other variant that's open source and has vulnerabilities.

640
00:45:44,160 --> 00:45:46,160
Expect there to be a vulnerability.

641
00:45:46,160 --> 00:45:49,160
Be prepared for the fact there's going to be a vulnerability in TLS.

642
00:45:49,160 --> 00:45:50,160
It happens.

643
00:45:50,160 --> 00:45:52,160
It hasn't happened in a couple years.

644
00:45:52,160 --> 00:45:53,160
Not a really bad one.

645
00:45:53,160 --> 00:46:01,160
But Heartbleed basically said, great, I'm going to pass this value and this data in such a way to TLS that you're going to give me back the memory at this memory location,

646
00:46:01,160 --> 00:46:03,160
which by the way is your key.

647
00:46:03,160 --> 00:46:07,160
So be prepared.

648
00:46:07,160 --> 00:46:12,160
So what we normally do in stuff like this is what would someone else do?

649
00:46:12,160 --> 00:46:13,160
So you're like, what would Google do?

650
00:46:13,160 --> 00:46:14,160
What would Facebook do?

651
00:46:14,160 --> 00:46:18,160
What would some other company here that I trust that does things well?

652
00:46:18,160 --> 00:46:24,160
And at least we hope they do things well because they're a giant corporation that would lose a bunch of money if this wasn't good.

653
00:46:24,160 --> 00:46:28,160
And originally that's what I ended up doing, kind of going through that.

654
00:46:28,160 --> 00:46:34,160
They all have some weird way of doing it where you put the data in a particular format and do this kind of weird thing,

655
00:46:34,160 --> 00:46:38,160
and it's very specialized and they don't really open source their cryptography.

656
00:46:38,160 --> 00:46:42,160
They just, you know, they have you can use our SDKs, you can kind of copy what they do.

657
00:46:42,160 --> 00:46:50,160
But one of the things I did find is that they again, they require their own SDKs and they usually don't allow for key rotation.

658
00:46:50,160 --> 00:46:51,160
All right.

659
00:46:51,160 --> 00:46:53,160
So you have a shared secret.

660
00:46:53,160 --> 00:47:04,160
So if you have if you have an Amazon account or you have a Google account and you have an API key, right, that's a single value, which is the identifier and a single key.

661
00:47:04,160 --> 00:47:05,160
No key rotation.

662
00:47:05,160 --> 00:47:06,160
Right.

663
00:47:06,160 --> 00:47:07,160
It works or it doesn't.

664
00:47:07,160 --> 00:47:09,160
If that gets compromised, you want to change it.

665
00:47:09,160 --> 00:47:11,160
Your application doesn't work while it's being changed.

666
00:47:11,160 --> 00:47:12,160
It's not good.

667
00:47:12,160 --> 00:47:16,160
So what I use is JSON web encryption.

668
00:47:16,160 --> 00:47:22,160
So it's the it's in the whole Jose space, which is JSON web tokens and JSON web signatures.

669
00:47:22,160 --> 00:47:28,160
It's an open standard that provides for multiple encryption methodologies plus key rotation.

670
00:47:28,160 --> 00:47:32,160
And it also has libraries in most languages, including Python.

671
00:47:32,160 --> 00:47:37,160
There's two in Python, actually, with different results.

672
00:47:37,160 --> 00:47:50,160
And the nice thing about JSON web encryption on my side, right, is that I have customers that want I want the most security possible and have other customers like I just need something easy that works with my stuff.

673
00:47:50,160 --> 00:47:54,160
And if you roll kind of roll your own, you don't have that option.

674
00:47:54,160 --> 00:48:00,160
And you have to try and figure out how do I let this company use this and that company use that where JSON web encryption.

675
00:48:00,160 --> 00:48:04,160
So in JSON web encryption, there is a list of algorithms that you can use.

676
00:48:04,160 --> 00:48:08,160
And as an implementer, I describe which algorithms are allowed.

677
00:48:08,160 --> 00:48:13,160
So I say, yep, you can use AES and you can use RSA.

678
00:48:13,160 --> 00:48:15,160
So if you want to use RSA, that's fine.

679
00:48:15,160 --> 00:48:19,160
When he's a yes, you can you only use AES CBC with a shot to 56 hash.

680
00:48:19,160 --> 00:48:21,160
And I can specify that.

681
00:48:21,160 --> 00:48:32,160
And as new algorithms are added, I can just update my library or submit a pull request to the library, which is what we tend to do to support this new thing and then tell customers this is now available.

682
00:48:32,160 --> 00:48:34,160
You can now do elliptical curve encryption.

683
00:48:34,160 --> 00:48:35,160
Here you go.

684
00:48:35,160 --> 00:48:38,160
Have fun.

685
00:48:38,160 --> 00:48:45,160
It's worked out really, really, really well and reduce the amount of code that we had for encryption by 95 percent.

686
00:48:45,160 --> 00:48:51,160
Because when you when you add encryption to your systems, you have to make sure that it works and you have to make sure that it's working properly.

687
00:48:51,160 --> 00:48:54,160
And there's a lot of testing and there's a lot of code.

688
00:48:54,160 --> 00:49:01,160
There's a lot of knowledge that has to happen because you have to really understand how these things work to implement good encryption on your system.

689
00:49:01,160 --> 00:49:07,160
Or you can just use Jose and use JSON web encryption.

690
00:49:07,160 --> 00:49:09,160
And then lastly, is logging and tracing.

691
00:49:09,160 --> 00:49:10,160
Right.

692
00:49:10,160 --> 00:49:13,160
So the most important thing is log everything.

693
00:49:13,160 --> 00:49:16,160
Log as much as your systems can allow.

694
00:49:16,160 --> 00:49:20,160
Because when there's a problem, you'll need to know that.

695
00:49:20,160 --> 00:49:21,160
All right.

696
00:49:21,160 --> 00:49:30,160
The last thing you want is, oh, wow, there's something going on, but I have no visibility into it because we turned that log off because it was it seems erroneous.

697
00:49:30,160 --> 00:49:33,160
You don't want to have that to happen.

698
00:49:33,160 --> 00:49:34,160
Right.

699
00:49:34,160 --> 00:49:38,160
When I released live systems, the first thing I do is like, OK, where could there be problems?

700
00:49:38,160 --> 00:49:40,160
Let's make sure we're hitting logs.

701
00:49:40,160 --> 00:49:42,160
We're throwing stats like, you know, there's you have that weird key.

702
00:49:42,160 --> 00:49:43,160
It should never happen.

703
00:49:43,160 --> 00:49:45,160
Well, does it ever happen?

704
00:49:45,160 --> 00:49:46,160
Let's find out if it happens.

705
00:49:46,160 --> 00:49:56,160
Let's hit a stat or write something to a log file that I can go find out that it's actually happening and trace it and do things like that.

706
00:49:56,160 --> 00:50:01,160
One super important thing is log in a structured format for easier parsing.

707
00:50:01,160 --> 00:50:04,160
You don't want to manually parse your logs.

708
00:50:04,160 --> 00:50:05,160
All right.

709
00:50:05,160 --> 00:50:06,160
All right.

710
00:50:06,160 --> 00:50:13,160
Grep is fantastic, but it has a lot of false positives when you're looking for things, especially if it has a common word origin.

711
00:50:13,160 --> 00:50:16,160
You don't want to have to look for that.

712
00:50:16,160 --> 00:50:24,160
What you want is you want to have structured logs and something like JSON that you can upload to some server to be able to analyze your logs.

713
00:50:24,160 --> 00:50:31,160
And if you're super advanced, you can actually have stuff analyzing the logs that were loaded so that you can determine if bad things happen.

714
00:50:31,160 --> 00:50:34,160
But importantly, log all pertinent actions.

715
00:50:34,160 --> 00:50:41,160
So if something's important, make sure it's being logged so you can tell if it's happening, if it's working, if it's not working.

716
00:50:41,160 --> 00:50:44,160
Because when it's not working, you're going to have problems.

717
00:50:44,160 --> 00:50:49,160
Include all data regarding the state and anonymize sensitive data.

718
00:50:49,160 --> 00:50:56,160
The worst problem that I've ever had in application systems is there's something wrong, but I don't know how to recreate it.

719
00:50:56,160 --> 00:51:03,160
Somebody is managing to open the system wide up, but I don't know what they're doing to do that.

720
00:51:03,160 --> 00:51:06,160
I've got to recreate the request, but I have no information to do that.

721
00:51:06,160 --> 00:51:14,160
So include in a problem area, right, include all data regarding the state.

722
00:51:14,160 --> 00:51:18,160
Put it in your structured log.

723
00:51:18,160 --> 00:51:21,160
Include origin data to identify bad actors.

724
00:51:21,160 --> 00:51:26,160
If you're behind a firewall and you have a load balancer or you have a reverse proxy,

725
00:51:26,160 --> 00:51:33,160
make sure that you're allowing X forwarded for and putting that information in so that you can find out where this thing came from

726
00:51:33,160 --> 00:51:38,160
or every single request from a bad actor is going to look like it came from your firewall.

727
00:51:38,160 --> 00:51:44,160
Make sure you're recording that origin data, the IPs, because sometimes you just might say, this IP is attacking us.

728
00:51:44,160 --> 00:51:48,160
They haven't made one good request, one valid request.

729
00:51:48,160 --> 00:51:50,160
Please disallow it on the network.

730
00:51:50,160 --> 00:51:54,160
Sometimes that is the easiest way to get rid of a bad actor is you just blacklist them.

731
00:51:54,160 --> 00:51:58,160
But if you don't know who they are and you don't know where they're coming from, you won't be able to do it.

732
00:51:58,160 --> 00:52:01,160
A lot of times they're coming from a proxy, right?

733
00:52:01,160 --> 00:52:05,160
They're coming from an onion router somewhere, some sort of proxy on the dark web.

734
00:52:05,160 --> 00:52:10,160
You don't want those anyway, right, unless you have an API that's used by the dark web, then you have a whole other problem.

735
00:52:10,160 --> 00:52:14,160
But most of us, we don't want things coming from proxies on the dark web.

736
00:52:14,160 --> 00:52:19,160
So if we start getting a bunch of people trying to, if you start seeing a bunch of things in your log that say try to ask

737
00:52:19,160 --> 00:52:26,160
slash WP dash admin slash log in, right, that is someone scanning your system and it's possibly someone attacking your system.

738
00:52:26,160 --> 00:52:31,160
So you might want to just find out where those are coming from and disable that IP address.

739
00:52:31,160 --> 00:52:34,160
Oftentimes it's coming from Amazon, though.

740
00:52:34,160 --> 00:52:37,160
You can utilize open tracing tools to track all the pertinent things.

741
00:52:37,160 --> 00:52:41,160
So open tracing is a standard out there that's being utilized.

742
00:52:41,160 --> 00:52:47,160
Open, there's plugins for Flask, there's plugins for Pyramid, there's plugins for Django.

743
00:52:47,160 --> 00:52:54,160
To be able to send data, if you've ever used New Relic, right, it provides new relic type stuff,

744
00:52:54,160 --> 00:52:58,160
but you can host it locally or you can send it to third party providers.

745
00:52:58,160 --> 00:53:06,160
So you can kind of take the power back and also have some ability to not have to use a third party API.

746
00:53:06,160 --> 00:53:13,160
So if you want to add extra data to Datadog or New Relic or whatever you're using, you have to use their APIs to do that.

747
00:53:13,160 --> 00:53:20,160
If you use open tracing, you have something that you can transport from vendor to vendor and you can also use it internally

748
00:53:20,160 --> 00:53:25,160
if you're using one of the open source systems out there that provide that.

749
00:53:25,160 --> 00:53:30,160
Utilize tools like Elk or Greylog to aggregate your logs.

750
00:53:30,160 --> 00:53:32,160
So there are systems out there. There's also Splunk.

751
00:53:32,160 --> 00:53:35,160
I didn't mention them here because I don't know if they're good or not.

752
00:53:35,160 --> 00:53:43,160
I know a lot of the IT space uses Splunk, but it's expensive and I don't have any real experience with it.

753
00:53:43,160 --> 00:53:47,160
What I have used before, though, is I have used Greylog and Elk. I currently use Elk.

754
00:53:47,160 --> 00:53:53,160
And this is why your structured logs are so important because if you have to try and create a parser to parse the data,

755
00:53:53,160 --> 00:54:00,160
let's say you have a stack trace, right, if your stack trace is not included properly inside of a structured log,

756
00:54:00,160 --> 00:54:05,160
you're going to have a separate log line for every return on that stack trace and you're going to have to figure out

757
00:54:05,160 --> 00:54:11,160
how to put those logs back together because it's all going to look like you have one log in your access log or error log

758
00:54:11,160 --> 00:54:16,160
and it says, you know, this file, this method, this line number.

759
00:54:16,160 --> 00:54:17,160
Yeah, question?

760
00:54:17,160 --> 00:54:22,160
Just got to say with Elk and left and right and general, make sure you get authentication on there.

761
00:54:22,160 --> 00:54:23,160
Yes.

762
00:54:23,160 --> 00:54:24,160
Like that.

763
00:54:24,160 --> 00:54:28,160
Yes, by default, just like MongoDB, by default, no authentication.

764
00:54:28,160 --> 00:54:33,160
Unlike MongoDB, it doesn't have it built into it, so you have to add it on externally.

765
00:54:33,160 --> 00:54:39,160
But use these tools and you will find a wealth of knowledge.

766
00:54:39,160 --> 00:54:44,160
The other thing that we do is we just store application level logs in the same place.

767
00:54:44,160 --> 00:54:51,160
So and we also use the same ID, same request ID, so it can be important to do that.

768
00:54:51,160 --> 00:54:56,160
Determine anomalous conditions and alert on those conditions.

769
00:54:56,160 --> 00:55:01,160
So now that you have all of this data, it becomes an exercise.

770
00:55:01,160 --> 00:55:04,160
So what should never happen?

771
00:55:04,160 --> 00:55:06,160
And there's a lot more.

772
00:55:06,160 --> 00:55:09,160
You're building special applications, so you have to figure that out.

773
00:55:09,160 --> 00:55:13,160
But if you go to a security conference and they start talking about logging,

774
00:55:13,160 --> 00:55:18,160
they're going to start talking about here are the top 10 things on a Microsoft system you should never see one after the other

775
00:55:18,160 --> 00:55:21,160
because this is absolutely an attack.

776
00:55:21,160 --> 00:55:25,160
You should never see someone ask for a credential and then escalate a privilege.

777
00:55:25,160 --> 00:55:27,160
This should never happen.

778
00:55:27,160 --> 00:55:29,160
This is an absolute attack.

779
00:55:29,160 --> 00:55:32,160
So try and figure out what's an attack on your system.

780
00:55:32,160 --> 00:55:35,160
What are the things that should never happen in a particular order?

781
00:55:35,160 --> 00:55:42,160
And you can parse logs and determine, you can create a report to find it or some automation to run a check against it

782
00:55:42,160 --> 00:55:48,160
and say, hey, if I see this, I want to make sure someone knows what's going on because I have an attack going on.

783
00:55:48,160 --> 00:55:54,160
So this is a little more difficult and a little harder to get to.

784
00:55:54,160 --> 00:55:56,160
And it's a very advanced thing.

785
00:55:56,160 --> 00:56:04,160
But if you are like me and you have thousands of requests a minute and you have very sensitive data

786
00:56:04,160 --> 00:56:13,160
and you have very important customers who get very angry when things go wrong, this is something you need to do.

787
00:56:13,160 --> 00:56:17,160
And before we code, are there any questions?

788
00:56:17,160 --> 00:56:20,160
And we'll actually break because it's 10-10, I believe we're supposed to break.

789
00:56:20,160 --> 00:56:24,160
We'll make sure everybody's set up and get started and then we'll go break.

790
00:56:24,160 --> 00:56:27,160
Any questions? Question?

791
00:56:27,160 --> 00:56:32,160
Going back to the encryption and protecting keys, how do you protect the keys?

792
00:56:32,160 --> 00:56:36,160
So that's a whole other topic, protecting keys to the rest.

793
00:56:36,160 --> 00:56:37,160
Yeah.

794
00:56:37,160 --> 00:56:38,160
So there's a bunch of different things.

795
00:56:38,160 --> 00:56:45,160
So there's vaults that you can use where you can only access the key from the memory.

796
00:56:45,160 --> 00:56:48,160
How you get the keys into your system is a difficult thing.

797
00:56:48,160 --> 00:56:50,160
And there are a bunch of different strategies that you can use.

798
00:56:50,160 --> 00:56:52,160
And some of them are complicated.

799
00:56:52,160 --> 00:56:54,160
Some of them are expensive.

800
00:56:54,160 --> 00:56:59,160
But the important thing is that your data, there's their separation.

801
00:56:59,160 --> 00:57:04,160
So even if you're on your API server, the database doesn't sit there.

802
00:57:04,160 --> 00:57:08,160
So at least there's some separation of your database lives here and the data in it is encrypted

803
00:57:08,160 --> 00:57:11,160
and there's not enough information to decrypt it.

804
00:57:11,160 --> 00:57:14,160
And over here is your database that doesn't have the data.

805
00:57:14,160 --> 00:57:15,160
But it has the keys.

806
00:57:15,160 --> 00:57:17,160
So at least you're creating some separation.

807
00:57:17,160 --> 00:57:20,160
Even if you just store them on the file system where anybody can go get it,

808
00:57:20,160 --> 00:57:25,160
that's better than having data in your database that you think is safe

809
00:57:25,160 --> 00:57:28,160
because you're using a static nonce and you haven't changed.

810
00:57:28,160 --> 00:57:31,160
The data is five years old and you've never changed the keys.

811
00:57:31,160 --> 00:57:35,160
And 100 people have left your company with those keys.

812
00:57:35,160 --> 00:57:37,160
And they might have left with the data.

813
00:57:37,160 --> 00:57:38,160
No.

814
00:57:38,160 --> 00:57:43,160
So the application has access to keys,

815
00:57:43,160 --> 00:57:46,160
but there are only certain people who have access to that application server

816
00:57:46,160 --> 00:57:48,160
and they're not DBAs.

817
00:57:48,160 --> 00:57:50,160
So your DBAs have access to the data

818
00:57:50,160 --> 00:57:52,160
and people have access through other accounts to the database.

819
00:57:52,160 --> 00:57:57,160
There are non-servers that are accessing databases that are not access to the database.

820
00:57:57,160 --> 00:57:59,160
So you're not accessing the database.

821
00:57:59,160 --> 00:58:01,160
You're accessing the database.

822
00:58:01,160 --> 00:58:03,160
You're accessing the database.

823
00:58:03,160 --> 00:58:05,160
So you're accessing the database through other accounts to the database.

824
00:58:05,160 --> 00:58:09,160
There are non-servers that are accessing databases more often than not

825
00:58:09,160 --> 00:58:11,160
or some other application, right?

826
00:58:11,160 --> 00:58:13,160
Whether it's a reporting system or you have analysts

827
00:58:13,160 --> 00:58:16,160
that are making hard queries or whatever the case may be.

828
00:58:16,160 --> 00:58:22,160
What you don't want is an analyst or a manager who has database access

829
00:58:22,160 --> 00:58:25,160
being able to download all of your encrypted data

830
00:58:25,160 --> 00:58:28,160
and then realize that, oh, this is the same key that's been used for five years,

831
00:58:28,160 --> 00:58:31,160
which means it's probably using a really bad encryption

832
00:58:31,160 --> 00:58:35,160
and there's no non-stored anywhere, so it's probably a single nonce.

833
00:58:35,160 --> 00:58:38,160
Let me try and break it because there's tools that very easily identify

834
00:58:38,160 --> 00:58:42,160
what type of encryption you're using and then try and crack the key.

835
00:58:42,160 --> 00:58:44,160
So how does the key material get into the application

836
00:58:44,160 --> 00:58:47,160
if the application doesn't have access to the key?

837
00:58:47,160 --> 00:58:50,160
So the API application has access to the key.

838
00:58:50,160 --> 00:58:52,160
The database does not.

839
00:58:52,160 --> 00:58:55,160
Right, but if you compromise the application, you have access to the key.

840
00:58:55,160 --> 00:58:56,160
You do.

841
00:58:56,160 --> 00:59:01,160
So, I mean, in most ways that I've seen the application set up,

842
00:59:01,160 --> 00:59:06,160
the database is only accessible by the human or by the application.

843
00:59:06,160 --> 00:59:12,160
So it doesn't have external access, so your method of compromise is the app.

844
00:59:12,160 --> 00:59:13,160
Correct.

845
00:59:13,160 --> 00:59:20,160
So what he's saying is that, for people who can't hear because it's on video...

846
00:59:20,160 --> 00:59:23,160
Sorry. Oh, it's fine.

847
00:59:23,160 --> 00:59:27,160
If you have access to the key, the application server has access to the database

848
00:59:27,160 --> 00:59:30,160
and it has access to the key, and you're absolutely correct.

849
00:59:30,160 --> 00:59:33,160
And that is the security conundrum that you have to figure out for your application.

850
00:59:33,160 --> 00:59:37,160
So do you have a remote key store that only stores it in memory

851
00:59:37,160 --> 00:59:40,160
and you have to access it a separate way, so if you compromise the machine,

852
00:59:40,160 --> 00:59:42,160
there's some other information that you have to go find

853
00:59:42,160 --> 00:59:45,160
or have to know to be able to get the key.

854
00:59:45,160 --> 00:59:48,160
If you can access the memory, then you can go get it anyway.

855
00:59:48,160 --> 00:59:53,160
There's just no super safe way to manage that.

856
00:59:53,160 --> 00:59:54,160
Or how do I rephrase that?

857
00:59:54,160 --> 00:59:57,160
There's no completely safe way to manage that.

858
00:59:57,160 --> 01:00:01,160
There's just no way around that, which is why the most important person

859
01:00:01,160 --> 01:00:05,160
to protect against is your own employees.

860
01:00:05,160 --> 01:00:08,160
You want to make sure that you separate people that have access to keys,

861
01:00:08,160 --> 01:00:10,160
don't have access to the data, and the people who have access to data

862
01:00:10,160 --> 01:00:13,160
don't have access to the keys, and you create controls around that,

863
01:00:13,160 --> 01:00:15,160
but there's always somebody who has access to both.

864
01:00:15,160 --> 01:00:18,160
So you can never perfectly protect a system,

865
01:00:18,160 --> 01:00:21,160
but you can protect it as much as is reasonable,

866
01:00:21,160 --> 01:00:23,160
and that is the issue with security,

867
01:00:23,160 --> 01:00:25,160
is that certain people have to have access to the data,

868
01:00:25,160 --> 01:00:27,160
so you have to grant them access to the data,

869
01:00:27,160 --> 01:00:31,160
but you have to find ways to restrict them to only the data that they need.

870
01:00:31,160 --> 01:00:38,160
And if you're doing it for things like the EU protections

871
01:00:38,160 --> 01:00:44,160
or SOC compliance or PCI, you have to make reasonable efforts

872
01:00:44,160 --> 01:00:48,160
so that you're not liable for the information being acquired.

873
01:00:48,160 --> 01:00:54,160
And reasonable, there's not a lot of case law, so you have to do what is best.

874
01:00:54,160 --> 01:00:57,160
But that is a problem that I think everybody that ever deals with,

875
01:00:57,160 --> 01:00:59,160
especially if you're using containers.

876
01:00:59,160 --> 01:01:01,160
How do you put the keys inside the containers?

877
01:01:01,160 --> 01:01:03,160
Well, you can't put it in through memory, so it's probably in the file system,

878
01:01:03,160 --> 01:01:05,160
but now it's in the file system, so now it's accessible,

879
01:01:05,160 --> 01:01:08,160
and it's accessible where you get it from the file system before.

880
01:01:08,160 --> 01:01:12,160
So you're having to deal with things like vaults and key stores

881
01:01:12,160 --> 01:01:15,160
and accessing it through memory and APIs to pull it in,

882
01:01:15,160 --> 01:01:17,160
but then that adds to your latency.

883
01:01:17,160 --> 01:01:21,160
So there's a lot of pluses and minuses to every possible solution for doing that,

884
01:01:21,160 --> 01:01:23,160
and you just have to kind of wade through it

885
01:01:23,160 --> 01:01:25,160
and find whatever works for your particular system.

886
01:01:25,160 --> 01:01:29,160
But encrypted data with keys on an API server

887
01:01:29,160 --> 01:01:33,160
is way better than unencrypted data on a database that everybody has access to.

888
01:01:33,160 --> 01:01:39,160
So again, you're trying to increase the difficulty for access.

889
01:01:39,160 --> 01:01:41,160
You're trying to make it more difficult for an attack.

890
01:01:41,160 --> 01:01:43,160
You'll never make it perfect.

891
01:01:43,160 --> 01:01:45,160
And then you have to have...

892
01:01:45,160 --> 01:01:47,160
There are certain things you can do for that,

893
01:01:47,160 --> 01:01:50,160
is if you try... you can do things like honeypots, right?

894
01:01:50,160 --> 01:01:52,160
One of my favorite things is honeypots, where you say,

895
01:01:52,160 --> 01:01:58,160
great, I'm going to leave these keys that are in a directory called slash keys,

896
01:01:58,160 --> 01:02:01,160
and it'll access the database.

897
01:02:01,160 --> 01:02:04,160
It won't give you access to any data, but it'll access the database.

898
01:02:04,160 --> 01:02:07,160
And then when you do that, I'm going to know that you accessed it

899
01:02:07,160 --> 01:02:09,160
because it's going to tell me what IP address you were from,

900
01:02:09,160 --> 01:02:12,160
and I can start tracing you down because no one should ever use this to log in.

901
01:02:12,160 --> 01:02:17,160
It just seems sort of futile to keep the database keys right next to each other.

902
01:02:17,160 --> 01:02:18,160
Well, they're not right next to each other.

903
01:02:18,160 --> 01:02:22,160
Well, I mean, again, right, so oftentimes the database is in a different level, right?

904
01:02:22,160 --> 01:02:25,160
So your application server is touching the Internet.

905
01:02:25,160 --> 01:02:28,160
Your database server shouldn't be.

906
01:02:28,160 --> 01:02:32,160
But the vectors of attack are your application, or I'm an insider threat.

907
01:02:32,160 --> 01:02:34,160
If I'm an insider threat, the game is already over.

908
01:02:34,160 --> 01:02:39,160
If you're an insider threat, the game is only over if you have access to both systems.

909
01:02:39,160 --> 01:02:45,160
So again, you're creating separation, so it's better than having both together or unencrypted.

910
01:02:45,160 --> 01:02:51,160
And like I said, you can create absolute protection, but will your application be usable?

911
01:02:51,160 --> 01:02:57,160
So there's a give and take between security and usability that happens with every application,

912
01:02:57,160 --> 01:02:59,160
and it would happen to any system.

913
01:02:59,160 --> 01:03:02,160
You can make a system completely secure, creating error gap.

914
01:03:02,160 --> 01:03:07,160
You can make something totally secure as long as you strip search everywhere that goes in and out.

915
01:03:07,160 --> 01:03:09,160
You'd have to put them through metal detector.

916
01:03:09,160 --> 01:03:11,160
You error gap it with a Faraday cage.

917
01:03:11,160 --> 01:03:14,160
There are things that you can do, but that you can't put on the Internet, right?

918
01:03:14,160 --> 01:03:16,160
That's completely secure, but you can't put on the Internet.

919
01:03:16,160 --> 01:03:20,160
So with every piece of security, the reason you add all these layers, right,

920
01:03:20,160 --> 01:03:25,160
is you want to make sure that you're not having ridiculous stuff out there that anybody can pwn.

921
01:03:25,160 --> 01:03:29,160
You don't want to have something that's not using TLS, not using credentials,

922
01:03:29,160 --> 01:03:33,160
and not using encrypted data that's moving credit card information, right?

923
01:03:33,160 --> 01:03:37,160
Because not too long ago, three or four years ago, you might have felt comfortable

924
01:03:37,160 --> 01:03:42,160
or not known better than to put your credit card information into something that's not using a TLS cert, right?

925
01:03:42,160 --> 01:03:44,160
You didn't even think to look at it.

926
01:03:44,160 --> 01:03:46,160
Your browser didn't tell you it was a problem, right?

927
01:03:46,160 --> 01:03:48,160
Now your browser will go, that's a really bad idea.

928
01:03:48,160 --> 01:03:52,160
You're sending very secure sense of information over insecure lines.

929
01:03:52,160 --> 01:03:58,160
So it's just about making it better and making it better to a level to which you're comfortable with

930
01:03:58,160 --> 01:04:01,160
and your business can still survive and do what it has to do.

931
01:04:01,160 --> 01:04:03,160
There's no perfect solution.

932
01:04:03,160 --> 01:04:09,160
It's just you have to find, you know, you have to move that dial to more secure versus usable.

933
01:04:09,160 --> 01:04:18,160
Because I will tell you this, that the API that I have written and architected is nearly unusable by itself.

934
01:04:18,160 --> 01:04:22,160
It is extremely secure and requires SDKs.

935
01:04:22,160 --> 01:04:28,160
Because if you did not use our SDK, you would have a hard time being able to interact with it

936
01:04:28,160 --> 01:04:31,160
unless you were a security expert, right?

937
01:04:31,160 --> 01:04:37,160
Unless you already understood Jose, knew all about JWE, JWT, that you could create these things.

938
01:04:37,160 --> 01:04:43,160
I mean, having to manually create that stuff, you can't just like go into curl and interact with my API.

939
01:04:43,160 --> 01:04:46,160
There's just no way. It's impossible.

940
01:04:46,160 --> 01:04:48,160
But that's because it has to be super secure.

941
01:04:48,160 --> 01:04:52,160
So I go through the extra layer of, great, so I have to create SDKs for everything.

942
01:04:52,160 --> 01:04:57,160
And every time we make a change, we have to make a change to our three major SDKs, right?

943
01:04:57,160 --> 01:05:00,160
Which means I have to have a Python developer, Java developer, and a .NET developer.

944
01:05:00,160 --> 01:05:02,160
It's really fun.

945
01:05:02,160 --> 01:05:05,160
But like for my business, that is necessary, right?

946
01:05:05,160 --> 01:05:08,160
For a lot of APIs, it's not that important that you have that level.

947
01:05:08,160 --> 01:05:10,160
Question?

948
01:05:10,160 --> 01:05:13,160
Who uses your SDKs? These are implementers?

949
01:05:13,160 --> 01:05:15,160
Yes, these are implementers, subscribers.

950
01:05:15,160 --> 01:05:21,160
So they get the SDKs from GitHub. They're open source.

951
01:05:21,160 --> 01:05:25,160
They don't do anything special or secret. They're just hard.

952
01:05:25,160 --> 01:05:29,160
It's complicated to interact with our system because it uses public-private key pairs.

953
01:05:29,160 --> 01:05:32,160
Then you have the problem of security on the SDK.

954
01:05:32,160 --> 01:05:35,160
No, I don't care. Anybody can get my SDKs.

955
01:05:35,160 --> 01:05:43,160
So if your process of accessing your API needs to be secret, your API is probably not super secure.

956
01:05:43,160 --> 01:05:47,160
So our API, the documentation for our API is published. It's public.

957
01:05:47,160 --> 01:05:50,160
It's just hard.

958
01:05:50,160 --> 01:05:52,160
So we make it easier by providing SDKs.

959
01:05:52,160 --> 01:05:56,160
You can interact 100% with the Twitter API.

960
01:05:56,160 --> 01:05:59,160
Have you ever tried to write a client to interact with the Twitter API?

961
01:05:59,160 --> 01:06:03,160
It is painful. It is unpleasant.

962
01:06:03,160 --> 01:06:05,160
It's the same thing with Amazon.

963
01:06:05,160 --> 01:06:09,160
You could manually interact with the AWS API, but you've got to figure out how they do encryption,

964
01:06:09,160 --> 01:06:11,160
how they do signatures, all this stuff that they do.

965
01:06:11,160 --> 01:06:14,160
It's painful and hard, so they provide an SDK.

966
01:06:14,160 --> 01:06:18,160
So if you want things to be secure, it's going to be harder to interact with.

967
01:06:18,160 --> 01:06:22,160
You're going to have to be able to create, and we're going to do that in this class.

968
01:06:22,160 --> 01:06:25,160
You're going to have to be able to create JSON web-encrypted data,

969
01:06:25,160 --> 01:06:28,160
and you're going to have to be able to decrypt JSON web-encrypted data,

970
01:06:28,160 --> 01:06:32,160
which means you're going to have to have a library because doing that manually is, you could do it manually.

971
01:06:32,160 --> 01:06:40,160
It would take you 10 minutes or so to go get your key and base64 decode the data and get the structure

972
01:06:40,160 --> 01:06:42,160
and then pass it something to decrypt.

973
01:06:42,160 --> 01:06:49,160
I mean, it's a lot of work to do it, but that's one of the reasons that you write SDKs.

974
01:06:49,160 --> 01:06:55,160
So when we get to the actual coding part, we're going to start adding piece by piece by piece

975
01:06:55,160 --> 01:06:58,160
more and more stuff to make it harder.

976
01:06:58,160 --> 01:07:00,160
And when you get down to the last piece, hopefully we'll be able to get there.

977
01:07:00,160 --> 01:07:02,160
It depends on how quickly everybody goes through this stuff.

978
01:07:02,160 --> 01:07:08,160
We'll use that single-use JSON web token, which is also going to include inside of it the request data,

979
01:07:08,160 --> 01:07:14,160
which is the method and the path and the query parameters and a hash of the body

980
01:07:14,160 --> 01:07:17,160
to ensure that this header and this body go together,

981
01:07:17,160 --> 01:07:21,160
because that's the difficult part when you have the header piece that's secure and a body piece that's secure.

982
01:07:21,160 --> 01:07:24,160
How do you know that they actually are supposed to go together?

983
01:07:24,160 --> 01:07:28,160
So you basically include in the signature that data.

984
01:07:28,160 --> 01:07:31,160
So I said it's a complicated thing.

985
01:07:31,160 --> 01:07:35,160
That's why there's, if you've noticed in here, there's a client.py,

986
01:07:35,160 --> 01:07:41,160
because at some point it's going to be very difficult to interact with the API without a client.

987
01:07:41,160 --> 01:07:43,160
Question?

988
01:07:43,160 --> 01:07:47,160
Yes, data validation.

989
01:08:14,160 --> 01:08:19,160
Right, so the question here is, we talked about, when I talked about in the,

990
01:08:19,160 --> 01:08:23,160
right, well, so what he's talking about is when I said that you could go in here

991
01:08:23,160 --> 01:08:32,160
and you could go change a get to a delete.

992
01:08:32,160 --> 01:08:37,160
And that's not allowed because you can't change, you can't do a get or delete in a get method

993
01:08:37,160 --> 01:08:41,160
because your application like Flask will prevent that.

994
01:08:41,160 --> 01:08:48,160
Well, the thing is, is that Flask determines what route and what to prevent based on that header data.

995
01:08:48,160 --> 01:08:52,160
So it knows that this is a delete request because this is your actual HTTP request.

996
01:08:52,160 --> 01:08:58,160
Your HTTP request used to say, get this user, and now it says, delete this user.

997
01:08:58,160 --> 01:09:02,160
So it can't protect you from that because it's changed to a valid verb.

998
01:09:02,160 --> 01:09:06,160
If your API supports delete, it's using the delete verb.

999
01:09:06,160 --> 01:09:13,160
And so if you change your verb from get to delete, your API doesn't know it was changed, so it can't protect you.

1000
01:09:13,160 --> 01:09:20,160
Well, but that, but so if you take a look at rest, that is proper rest.

1001
01:09:20,160 --> 01:09:23,160
Yes, yes, yes. I'll let you go in like five minutes.

1002
01:09:23,160 --> 01:09:30,160
So in the way that rest works, right, is that you have, you have an entity, right, so representative state transfer.

1003
01:09:31,160 --> 01:09:35,160
Right. So that entity, ABC, if I do a get, it gets me information.

1004
01:09:35,160 --> 01:09:38,160
If I do a put, it replaces the data for that, for that entity.

1005
01:09:38,160 --> 01:09:40,160
If I get a patch, it updates the data for that entity.

1006
01:09:40,160 --> 01:09:43,160
If I do a post, it'll create data for that entity.

1007
01:09:43,160 --> 01:09:45,160
And if I do a delete, it will remove it.

1008
01:09:45,160 --> 01:09:50,160
So if your API supports delete, then it's going to be deleted.

1009
01:09:50,160 --> 01:09:52,160
And that's what you want to protect against.

1010
01:09:52,160 --> 01:09:55,160
You also want to protect against it changing that data.

1011
01:09:55,160 --> 01:10:02,160
Right. So if guarding against the verb is not important to you, don't guard against it.

1012
01:10:02,160 --> 01:10:04,160
For most of us, it's important.

1013
01:10:04,160 --> 01:10:07,160
Again, only guard against what's important to your application.

1014
01:10:07,160 --> 01:10:10,160
Find the pieces that are appropriate to guard against.

1015
01:10:10,160 --> 01:10:14,160
So the ones I went over are the ones that we actually care about, right.

1016
01:10:14,160 --> 01:10:22,160
Headers, caching, verbs, the method, the path, query parameters, those types of things are the things that I worry about,

1017
01:10:22,160 --> 01:10:26,160
because those are the things that my application allows and does things differently based on what you pass me.

1018
01:10:26,160 --> 01:10:30,160
So in your application, just determine what things in the request are important.

1019
01:10:30,160 --> 01:10:36,160
And if they were to change, someone will be able to do bad things and prevent that from happening.

1020
01:10:36,160 --> 01:10:40,160
So what would you change in the URL?

1021
01:10:40,160 --> 01:10:48,160
Either that you're going to change the URL, right, or you can change the request for the object, or the word type.

1022
01:10:48,160 --> 01:10:53,160
So again, so back here, so you can change the path, right.

1023
01:10:53,160 --> 01:10:55,160
So if I change that to that, I'm doing something bad too.

1024
01:10:55,160 --> 01:10:59,160
So you just need to protect the request and make sure this is what the user asked for,

1025
01:10:59,160 --> 01:11:02,160
not that an attacker between you and your user asked for this.

1026
01:11:02,160 --> 01:11:04,160
That's the thing that we're trying to protect.

1027
01:11:04,160 --> 01:11:07,160
And if it's not necessary in your application to protect against it, don't worry about it.

1028
01:11:07,160 --> 01:11:10,160
In my application, it's very important.

1029
01:11:10,160 --> 01:11:13,160
I need to make sure that people aren't trying to access things they're not supposed to access.

1030
01:11:13,160 --> 01:11:17,160
And you also need to know like, is this an attack or do I have a bug in my SDK?

1031
01:11:17,160 --> 01:11:19,160
That's another important thing to know, right.

1032
01:11:19,160 --> 01:11:24,160
Is that yes, this is not supposed to happen, but it's a valid request.

1033
01:11:24,160 --> 01:11:28,160
So someone went through all the work to make a valid request.

1034
01:11:28,160 --> 01:11:29,160
It's not a man-in-the-middle attack.

1035
01:11:29,160 --> 01:11:32,160
It's a different type of attack or it's a problem with my SDK.

1036
01:11:32,160 --> 01:11:36,160
Because the request was valid, it validated, it hasn't been modified.

1037
01:11:36,160 --> 01:11:38,160
It's just bad.

1038
01:11:38,160 --> 01:11:42,160
It's not, I'm still going to return a 400, but it hasn't been modified.

1039
01:11:42,160 --> 01:11:43,160
Question?

1040
01:11:43,160 --> 01:11:44,160
Question?

1041
01:11:50,160 --> 01:11:53,160
So encrypting data at rest absolutely prevents searching or filtering based on that data.

1042
01:11:53,160 --> 01:11:59,160
There are ways to get around that by using anonymous identifiers to map to that data.

1043
01:11:59,160 --> 01:12:05,160
So you just create like a, so if you have a social security number and you need to be able to map things by social security number,

1044
01:12:05,160 --> 01:12:11,160
you can just generate a unique token for that social security number and store that along with it.

1045
01:12:11,160 --> 01:12:14,160
So that you can say, great, we're going to match on this unique token across our data.

1046
01:12:14,160 --> 01:12:18,160
That's a much larger topic that we can't get into in three hours.

1047
01:12:18,160 --> 01:12:20,160
But there are ways, and that's a big problem, right.

1048
01:12:20,160 --> 01:12:26,160
Searchable data, searchable encryption, that's a huge problem that scholars struggle with right now.

1049
01:12:26,160 --> 01:12:32,160
Because the ones that are used aren't very good and the ones that are good aren't well used.

1050
01:12:32,160 --> 01:12:35,160
Because there's problems with creating deterministic encryption.

1051
01:12:36,160 --> 01:12:42,160
Your best bet is to anonymize that data in a manner so that you have an anonymous token associated with real data

1052
01:12:42,160 --> 01:12:46,160
and then you create your links across your database using that anonymous data.

1053
01:12:46,160 --> 01:12:49,160
So don't link by social security number, link by user ID.

1054
01:12:49,160 --> 01:12:54,160
All right, user ID is just some random value that has no use to anyone.

1055
01:12:54,160 --> 01:13:00,160
And if you need to search by social security number, that becomes an even greater problem.

1056
01:13:00,160 --> 01:13:05,160
That you can sometimes, I'm not an expert and I can't even tell you how to do that right.

1057
01:13:05,160 --> 01:13:09,160
I can tell you that just creating an MD5 is wrong.

1058
01:13:09,160 --> 01:13:11,160
Creating a SHA-1 is bad.

1059
01:13:11,160 --> 01:13:13,160
But there are things that you can do.

1060
01:13:13,160 --> 01:13:20,160
And there's a lot of information out there on searching for encrypted search.

1061
01:13:20,160 --> 01:13:25,160
It's just confusing because I don't understand it well.

1062
01:13:25,160 --> 01:13:27,160
Any other questions?

1063
01:13:28,160 --> 01:13:30,160
Awesome, so it's break time.

1064
01:13:30,160 --> 01:13:31,160
And we'll meet back here.

1065
01:13:31,160 --> 01:13:33,160
It doesn't even say how long it will be.

1066
01:13:33,160 --> 01:13:35,160
Fifteen minutes?

1067
01:13:57,160 --> 01:13:58,160
Okay.

1068
01:14:27,160 --> 01:14:29,160
Okay.

1069
01:14:57,160 --> 01:14:59,160
Okay.

1070
01:15:27,160 --> 01:15:29,160
Okay.

1071
01:15:57,160 --> 01:15:59,160
Okay.

1072
01:16:27,160 --> 01:16:29,160
Okay.

1073
01:16:57,160 --> 01:16:59,160
Okay.

1074
01:17:27,160 --> 01:17:29,160
Okay.

1075
01:17:57,160 --> 01:17:59,160
Okay.

1076
01:18:27,160 --> 01:18:29,160
Okay.

1077
01:18:57,160 --> 01:18:59,160
Okay.

1078
01:19:27,160 --> 01:19:29,160
Okay.

1079
01:19:57,160 --> 01:19:59,160
Okay.

1080
01:20:27,160 --> 01:20:29,160
Okay.

1081
01:20:57,160 --> 01:20:59,160
Okay.

1082
01:21:27,160 --> 01:21:29,160
Okay.

1083
01:21:57,160 --> 01:21:59,160
Okay.

1084
01:22:27,160 --> 01:22:29,160
Okay.

1085
01:22:57,160 --> 01:22:59,160
Okay.

1086
01:23:27,160 --> 01:23:29,160
Okay.

1087
01:23:57,160 --> 01:23:59,160
Okay.

1088
01:24:27,160 --> 01:24:29,160
Okay.

1089
01:24:57,160 --> 01:24:59,160
Okay.

1090
01:25:27,160 --> 01:25:29,160
Okay.

1091
01:25:57,160 --> 01:25:59,160
Okay.

1092
01:26:27,160 --> 01:26:29,160
Okay.

1093
01:26:57,160 --> 01:26:59,160
Okay.

1094
01:27:27,160 --> 01:27:29,160
Okay.

1095
01:27:57,160 --> 01:27:59,160
Okay.

1096
01:28:27,160 --> 01:28:29,160
Okay.

1097
01:28:57,160 --> 01:28:59,160
Okay.

1098
01:29:27,160 --> 01:29:28,160
Okay.

1099
01:29:28,160 --> 01:29:29,160
Okay.

1100
01:29:29,160 --> 01:29:30,160
Okay.

1101
01:29:30,160 --> 01:29:31,160
Okay.

1102
01:29:31,160 --> 01:29:32,160
Okay.

1103
01:29:32,160 --> 01:29:33,160
Okay.

1104
01:29:33,160 --> 01:29:34,160
Okay.

1105
01:29:37,160 --> 01:29:40,160
Don't feel pressured to rate it just yet.

1106
01:29:43,160 --> 01:29:46,160
I will put the rating thing back up later.

1107
01:29:46,160 --> 01:29:49,160
So don't feel pressured to do it before we've actually finished.

1108
01:29:49,160 --> 01:29:53,160
It's just a good thing to stick there when we're not doing anything.

1109
01:29:53,160 --> 01:29:54,160
Okay.

1110
01:29:54,160 --> 01:30:04,560
So hopefully, since everyone said that they were already set up, they have cloned the

1111
01:30:04,560 --> 01:30:08,960
repository and gotten it running.

1112
01:30:08,960 --> 01:30:12,160
And to verify that it works, that means their pip env is working.

1113
01:30:12,160 --> 01:30:19,160
They've got Python 3.6 or 3.7, which fortunately most people are moving away from 2.7.

1114
01:30:19,160 --> 01:30:21,160
That was some problems last year.

1115
01:30:21,160 --> 01:30:24,160
It absolutely does not work on our 2.7.

1116
01:30:26,160 --> 01:30:30,160
And so on master is where everything works.

1117
01:30:30,160 --> 01:30:34,160
Now, people get behind, and some things are more important than others, and you may not

1118
01:30:34,160 --> 01:30:35,160
want to do all the coding.

1119
01:30:35,160 --> 01:30:39,160
You may just want to follow along, and that's perfectly fine as well.

1120
01:30:40,160 --> 01:30:46,160
Let me make this a little bigger so people can see.

1121
01:30:46,160 --> 01:30:49,160
And maybe even bigger.

1122
01:30:49,160 --> 01:30:51,160
So people can, all right, come on.

1123
01:30:51,160 --> 01:30:53,160
Let's do this.

1124
01:30:53,160 --> 01:30:55,160
All right.

1125
01:30:55,160 --> 01:30:57,160
All right.

1126
01:30:57,160 --> 01:30:59,160
Can people see that in the back?

1127
01:30:59,160 --> 01:31:01,160
A lot of extraneous information.

1128
01:31:01,160 --> 01:31:07,160
So actually, the Wi-Fi here has been really, really nice.

1129
01:31:07,160 --> 01:31:09,160
I was not expecting that.

1130
01:31:09,160 --> 01:31:13,160
But there are branches here for catching up.

1131
01:31:13,160 --> 01:31:18,160
So if you fall behind or you just don't care and you want to move on to the next thing

1132
01:31:18,160 --> 01:31:23,160
and you want to start working on that piece, we can switch to the branches.

1133
01:31:23,160 --> 01:31:30,160
I'm going to check out start here, which is where I'm going to start from.

1134
01:31:30,160 --> 01:31:38,160
And that is basically a minimal stuff to start up.

1135
01:31:38,160 --> 01:31:42,160
It has an array of branches here.

1136
01:31:42,160 --> 01:31:48,160
It has a server.

1137
01:31:48,160 --> 01:31:52,160
It has a minimal hello world, which doesn't do much.

1138
01:31:52,160 --> 01:31:53,160
It just has error handling.

1139
01:31:53,160 --> 01:31:57,160
And if you notice that there's a bunch of unused imports, they're there to make it easier,

1140
01:31:57,160 --> 01:31:59,160
so I don't have to constantly do imports.

1141
01:31:59,160 --> 01:32:01,160
That's what will be there at the end as well.

1142
01:32:01,160 --> 01:32:06,160
And I'll have the code a lot more readable once I get into actually doing the coding part.

1143
01:32:06,160 --> 01:32:11,160
There's a piece that got added, which is the order signal handler, one of the bugs from last year

1144
01:32:11,160 --> 01:32:15,160
that I didn't know until I found out is that signal handlers execute in any order,

1145
01:32:15,160 --> 01:32:19,160
regardless of when you actually register signals.

1146
01:32:19,160 --> 01:32:23,160
So we're using Flask because Flask seems to be an easy thing for people to get up.

1147
01:32:23,160 --> 01:32:27,160
You can have everything in a single file, although signals are going to be in separate files

1148
01:32:27,160 --> 01:32:32,160
to make it easier to distinguish between those.

1149
01:32:32,160 --> 01:32:36,160
Signals, if you're wondering, I keep talking about signal, signal, signal, what does that mean?

1150
01:32:36,160 --> 01:32:41,160
So signals are basically the event bus on Flask.

1151
01:32:41,160 --> 01:32:48,160
So you had to install signals, which was part of the PIPM, so you would have done that.

1152
01:32:48,160 --> 01:32:54,160
And an ordered signal handler is basically just going to execute them in the order

1153
01:32:54,160 --> 01:33:01,160
in which you register them for the request started and request finished.

1154
01:33:01,160 --> 01:33:05,160
Because it gets problematic if it doesn't execute in the right order.

1155
01:33:05,160 --> 01:33:08,160
So you're getting these weird errors.

1156
01:33:08,160 --> 01:33:13,160
I couldn't create a My Box, but other people had it on theirs because their box executed them in a different order.

1157
01:33:13,160 --> 01:33:15,160
It was really weird.

1158
01:33:15,160 --> 01:33:17,160
But we figured out that that's what it was.

1159
01:33:17,160 --> 01:33:24,160
So we start off with the order signal handler so that we can have the stuff to get started.

1160
01:33:24,160 --> 01:33:26,160
Any questions about that?

1161
01:33:26,160 --> 01:33:32,160
Everybody was able to get it running from what they said earlier, so I'm going to take you at your word.

1162
01:33:32,160 --> 01:33:41,160
So now, on my end, there's also, I'll make this bigger.

1163
01:33:49,160 --> 01:33:50,160
Okay.

1164
01:33:50,160 --> 01:33:51,160
There's also a client.

1165
01:33:51,160 --> 01:33:59,160
And like I was saying before, the more secure you make things, the harder they are to use more often than not.

1166
01:33:59,160 --> 01:34:09,160
And as we go through these things using JSON Web Tokens and nonces and encryption and key rotation

1167
01:34:09,160 --> 01:34:18,160
and time-based security and encryption and signatures, it gets more and more complicated and more difficult to use.

1168
01:34:18,160 --> 01:34:22,160
So after probably the second piece, you won't be able to use curl anymore.

1169
01:34:22,160 --> 01:34:28,160
So what I've created is a client, and it will actually tell you everything that it's doing so it'll look kind of like curl.

1170
01:34:28,160 --> 01:34:38,160
If you're an API lover who likes to talk to things from the either Telnet or curl, it will look familiar to you.

1171
01:34:38,160 --> 01:34:43,160
But it's going to do all the complicated stuff in the background to talk to the server.

1172
01:34:43,160 --> 01:34:48,160
We're not going to worry about writing a client today because that's twice as much work for no real help.

1173
01:34:48,160 --> 01:34:51,160
So we're just going to talk about the server side.

1174
01:34:51,160 --> 01:34:54,160
This code is all, as you all know, is on GitHub.

1175
01:34:54,160 --> 01:34:57,160
So if you want to take a look at what it's doing, all kinds of nonsense, right?

1176
01:34:57,160 --> 01:35:04,160
That's right.

1177
01:35:04,160 --> 01:35:05,160
So start off.

1178
01:35:05,160 --> 01:35:08,160
Signals when it starts off.

1179
01:35:08,160 --> 01:35:11,160
Shouldn't have all this in here.

1180
01:35:11,160 --> 01:35:14,160
Why does it have all the data?

1181
01:35:14,160 --> 01:35:16,160
Did I not switch over?

1182
01:35:16,160 --> 01:35:18,160
Did I check out master?

1183
01:35:18,160 --> 01:35:26,160
Let me start here.

1184
01:35:26,160 --> 01:35:32,160
Interesting.

1185
01:35:32,160 --> 01:35:33,160
Oh, wrong place.

1186
01:35:33,160 --> 01:35:34,160
That's why.

1187
01:35:34,160 --> 01:35:35,160
Sorry.

1188
01:35:35,160 --> 01:35:37,160
This is me checking to make sure you didn't need network.

1189
01:35:37,160 --> 01:35:41,160
That's why it's the wrong place.

1190
01:35:41,160 --> 01:35:42,160
My bad.

1191
01:35:42,160 --> 01:35:51,160
I thought I was all prepared for everybody.

1192
01:35:51,160 --> 01:35:52,160
Okay.

1193
01:35:52,160 --> 01:35:59,160
So if everyone checks out start here, you should have, yay, you have a blank order signal handler,

1194
01:35:59,160 --> 01:36:05,160
which is basically just telling you that it's going to go through the signal handlers you pass to it in order

1195
01:36:05,160 --> 01:36:10,160
because in Python 3.6, well, I guess lists are always ordered.

1196
01:36:10,160 --> 01:36:13,160
These aren't dictionaries.

1197
01:36:13,160 --> 01:36:18,160
So it's just going to go through those and execute the handlers to make sure stuff gets done in order.

1198
01:36:18,160 --> 01:36:21,160
And then the server side, you'll just have a simple route.

1199
01:36:21,160 --> 01:36:26,160
And then the server handler, which is going to return JSON because it's an API, and I'm kind of,

1200
01:36:26,160 --> 01:36:31,160
I hate it when stuff doesn't return JSON when it's supposed to be JSON.

1201
01:36:31,160 --> 01:36:33,160
And that's it.

1202
01:36:33,160 --> 01:36:36,160
And again, the only thing we added to it is that we added the signal handler,

1203
01:36:36,160 --> 01:36:45,160
and we were connecting to request started and request finished to the thing in our order signal handler.

1204
01:36:45,160 --> 01:36:47,160
There's some extra exceptions.

1205
01:36:47,160 --> 01:36:52,160
So the cluster accepts an HTTP exception so that you can raise an HTTP exception with a code and a message,

1206
01:36:52,160 --> 01:36:57,160
and then the error handler will handle that and then return the proper code and the proper message.

1207
01:36:57,160 --> 01:36:59,160
So when we're handling things inside of our middleware,

1208
01:36:59,160 --> 01:37:04,160
so the things inside of signals will be basically middleware that happens before and after the request.

1209
01:37:04,160 --> 01:37:09,160
It can return an error that can then raise an exception that can be caught by the error handler

1210
01:37:09,160 --> 01:37:12,160
and return the right data, which is probably the best way to do it,

1211
01:37:12,160 --> 01:37:15,160
So I can tell you why the request was bad.

1212
01:37:15,160 --> 01:37:18,160
If there are certain errors you're going to encrypt and sign.

1213
01:37:18,160 --> 01:37:24,160
In my API, I encrypt 400 so that I can give you, I know that you're a valid user.

1214
01:37:24,160 --> 01:37:27,160
It was a valid user with valid credentials.

1215
01:37:27,160 --> 01:37:28,160
It's just your request was bad.

1216
01:37:28,160 --> 01:37:33,160
I can tell you why the request was bad with information I wouldn't want to tell an attacker.

1217
01:37:33,160 --> 01:37:38,160
So one of the reasons that I do it that way.

1218
01:37:38,160 --> 01:37:42,160
First thing we want to do here.

1219
01:37:42,160 --> 01:37:45,160
All right.

1220
01:37:45,160 --> 01:37:49,160
Now, first thing we want to do is we want to do replay prevention.

1221
01:37:49,160 --> 01:37:51,160
We talked about that, right?

1222
01:37:51,160 --> 01:37:57,160
So replay prevention means you have to have some way to uniquely identify the piece that you're doing.

1223
01:37:57,160 --> 01:38:01,160
And to make this easy, since we're going to be doing this a couple of different ways,

1224
01:38:01,160 --> 01:38:05,160
we're going to do this using the authorization header.

1225
01:38:05,160 --> 01:38:08,160
Authorization header is extensible.

1226
01:38:08,160 --> 01:38:13,160
There are defined methods for doing authorization.

1227
01:38:13,160 --> 01:38:16,160
And anything beyond that is open.

1228
01:38:16,160 --> 01:38:23,160
So inside of signals, go away.

1229
01:38:23,160 --> 01:38:27,160
We're going to add a new signal.

1230
01:38:27,160 --> 01:38:28,160
All right.

1231
01:38:28,160 --> 01:38:30,160
I'm going to call it the replay prevention.

1232
01:38:30,160 --> 01:38:35,160
Oh, man, if I can type today.

1233
01:38:35,160 --> 01:38:39,160
I can't type today.

1234
01:38:39,160 --> 01:38:47,160
So we'll call it the replay prevention signal handler.

1235
01:38:47,160 --> 01:38:53,160
And I've created an abstract just to make sure things do what they're supposed to do.

1236
01:38:53,160 --> 01:38:56,160
So it's going to extend the base signal handler.

1237
01:38:56,160 --> 01:39:03,160
We're going to create an init because it's going to need cache.

1238
01:39:03,160 --> 01:39:05,160
Let's implement the methods first.

1239
01:39:05,160 --> 01:39:08,160
Put in some stubs for that.

1240
01:39:08,160 --> 01:39:12,160
And we'll call it the replay, not resplay.

1241
01:39:12,160 --> 01:39:14,160
And we'll create an init.

1242
01:39:14,160 --> 01:39:18,160
So I'm a huge lover of dependency injection.

1243
01:39:18,160 --> 01:39:24,160
So the things that we're going to need is we're going to need cache, right?

1244
01:39:24,160 --> 01:39:26,160
So we talked about replay prevention.

1245
01:39:26,160 --> 01:39:27,160
We need cache.

1246
01:39:27,160 --> 01:39:35,160
We need some way to store a value, a nonce, and make sure we've never seen it before.

1247
01:39:35,160 --> 01:39:38,160
What I'm using is I'm using the...

1248
01:39:38,160 --> 01:39:40,160
Not typing is what I'm using.

1249
01:39:40,160 --> 01:39:47,160
So what I'm using is the cache that used to be part of Verksoig.

1250
01:39:47,160 --> 01:39:55,160
So if you're a flask aficionado, Verksoig is kind of the wisky abstraction layer inside of there.

1251
01:39:55,160 --> 01:39:56,160
It's no longer part of that.

1252
01:39:56,160 --> 01:40:01,160
It's now a separate piece of the Palettes project called libcache.

1253
01:40:01,160 --> 01:40:02,160
So we're using that.

1254
01:40:02,160 --> 01:40:04,160
It has a bunch of different cache implementations.

1255
01:40:04,160 --> 01:40:08,160
One of the reasons that I'm using is it has the simple cache, which is file system based.

1256
01:40:08,160 --> 01:40:13,160
It has problems, which if you put it in a directory where there's other types of files,

1257
01:40:13,160 --> 01:40:15,160
it will completely poop itself.

1258
01:40:15,160 --> 01:40:17,160
So be warned.

1259
01:40:17,160 --> 01:40:24,160
It will try and parse JSON out of a file that doesn't have JSON and blow up and crash your entire application.

1260
01:40:24,160 --> 01:40:26,160
It's unpleasant.

1261
01:40:26,160 --> 01:40:30,160
So just kind of be careful.

1262
01:40:30,160 --> 01:40:37,160
And so we'll set...

1263
01:40:37,160 --> 01:40:40,160
All right. So now we have a cache.

1264
01:40:40,160 --> 01:40:49,160
So the way these signals work is that you get a sender, which you're not really going to use,

1265
01:40:49,160 --> 01:40:53,160
so it might complain some stuff, because in flask, request is global.

1266
01:40:53,160 --> 01:40:59,160
Not one of my favorite things, but that's what it is.

1267
01:40:59,160 --> 01:41:09,160
So you take your global request, and you're going to get a header.

1268
01:41:09,160 --> 01:41:12,160
And you're going to get authorization.

1269
01:41:12,160 --> 01:41:17,160
There are other ways to access authorization.

1270
01:41:17,160 --> 01:41:20,160
And spell it correctly.

1271
01:41:20,160 --> 01:41:23,160
There are other ways to do that.

1272
01:41:23,160 --> 01:41:30,160
But if you actually want to get just your own value for the header, this is the only way to do it.

1273
01:41:30,160 --> 01:41:36,160
So the first thing you want to make sure is that you want to make sure that your knowledge was provided.

1274
01:41:36,160 --> 01:41:40,160
All right. So if you couldn't find the header, there's a problem.

1275
01:41:40,160 --> 01:41:43,160
So you want to tell them, hey, I was expecting authorization, right?

1276
01:41:43,160 --> 01:41:47,160
Because we're all expecting authorization here, because we're looking for the authorization header.

1277
01:41:47,160 --> 01:41:55,160
So we're going to raise that HTTP exception we created.

1278
01:41:55,160 --> 01:41:57,160
And typing is not a friend of mine.

1279
01:41:57,160 --> 01:42:01,160
And this is not because I'm nervous. This is because I can't type.

1280
01:42:01,160 --> 01:42:05,160
Just want to make sure everyone knows that, because my coworkers will see this video at one point.

1281
01:42:05,160 --> 01:42:08,160
And if I lie, they will call me out.

1282
01:42:08,160 --> 01:42:14,160
But I'm a horrible typer. And if it weren't for IDEs, I would not be able to have this job.

1283
01:42:14,160 --> 01:42:18,160
Because every time I try and learn to type, it gets bad.

1284
01:42:18,160 --> 01:42:20,160
It just gets slower.

1285
01:42:20,160 --> 01:42:24,160
And so the other thing you want to do is you want to make sure that you've never seen this token before.

1286
01:42:24,160 --> 01:42:34,160
All right. So you want to try and add it to the cache.

1287
01:42:34,160 --> 01:42:40,160
Now, we want to make sure that this is a value that's going to be unique and that it's a string,

1288
01:42:40,160 --> 01:42:42,160
because the key is required to be a string.

1289
01:42:42,160 --> 01:42:47,160
So if it gave you back an object, a dictionary, an array, we just want to hash it.

1290
01:42:47,160 --> 01:42:50,160
It doesn't really matter what that value is.

1291
01:42:50,160 --> 01:42:56,160
It's going to be authorization, space, whatever your authorization type is, colon, and then the value.

1292
01:42:56,160 --> 01:43:00,160
We're just going to make a hash of it so that we're not storing a lot of validation credentials in our cache.

1293
01:43:00,160 --> 01:43:04,160
Another important thing, don't store credentials in your cache.

1294
01:43:04,160 --> 01:43:08,160
Because we don't care what they are. We just want to make sure that it's hashed.

1295
01:43:08,160 --> 01:43:13,160
And we're going to do a SHA-512.

1296
01:43:13,160 --> 01:43:25,160
Don't let anybody tell you that SHA-256 is faster, because it's not since 64-bit processors came out.

1297
01:43:25,160 --> 01:43:31,160
So do a SHA-512 token.

1298
01:43:31,160 --> 01:43:36,160
And we're Python 3, so we have to encode everything, right?

1299
01:43:36,160 --> 01:43:39,160
This has been the hardest part for me for moving to Python 3.

1300
01:43:39,160 --> 01:43:42,160
So every time we do anything crypto, it gets hard.

1301
01:43:42,160 --> 01:43:50,160
So we're doing a SHA-512 of our UTF-8 encoded value, which we then have to get a digest of.

1302
01:43:50,160 --> 01:43:58,160
So basically, SHA-512 returns an object that is a hash object, and then you have to get the digest.

1303
01:43:58,160 --> 01:44:02,160
And then you want to actually set a value.

1304
01:44:02,160 --> 01:44:06,160
It doesn't matter what the value is. We're putting in one just because.

1305
01:44:06,160 --> 01:44:09,160
And that's a...

1306
01:44:09,160 --> 01:44:19,160
It's angry. If not self-cache add. That's correct.

1307
01:44:19,160 --> 01:44:22,160
This is all correct, right?

1308
01:44:22,160 --> 01:44:25,160
I'm not sure why it's angry.

1309
01:44:25,160 --> 01:44:32,160
So basically what this is saying is I want to add a value, a key with the value of 1 to my cache.

1310
01:44:32,160 --> 01:44:37,160
And this particular library, like memcache, returns false if it fails.

1311
01:44:37,160 --> 01:44:42,160
And so if I can't successfully add it, that means I've seen this token before.

1312
01:44:42,160 --> 01:44:50,160
So I want to raise another HTTP exception.

1313
01:44:50,160 --> 01:44:54,160
And this one is going to be...

1314
01:44:54,160 --> 01:45:00,160
Envelope request.

1315
01:45:00,160 --> 01:45:05,160
You probably wouldn't tell your users this.

1316
01:45:05,160 --> 01:45:11,160
You would probably come up with something very generic, or you would come up with just a random value.

1317
01:45:11,160 --> 01:45:16,160
When you're reporting errors to users and you don't want them to know what the error is necessarily for security reasons,

1318
01:45:16,160 --> 01:45:22,160
but you want to be able to troubleshoot it later, you can always just create some sort of random value

1319
01:45:22,160 --> 01:45:28,160
that you return back in there and put that in the logs so that you can look at it later.

1320
01:45:28,160 --> 01:45:33,160
I'm not getting that deep in here. I'm just going to return a 400 error.

1321
01:45:33,160 --> 01:45:39,160
All right. So right now, and we don't need a request finished handler

1322
01:45:39,160 --> 01:45:46,160
because we don't do anything afterwards in our middleware.

1323
01:45:46,160 --> 01:45:51,160
So this is our signal.

1324
01:45:51,160 --> 01:46:02,160
And now we have to actually modify our server to use the signal, which is really simple.

1325
01:46:03,160 --> 01:46:15,160
Just there.

1326
01:46:15,160 --> 01:46:19,160
Move over to the server.

1327
01:46:19,160 --> 01:46:27,160
And if you're wondering what I'm doing, I have a cheat sheet to make sure I don't screw it up, because I get ahead of myself sometimes.

1328
01:46:27,160 --> 01:46:35,160
Okay. So again, we've got a bunch of handlers here, so all we have to do right now is just add another signal handler.

1329
01:46:35,160 --> 01:46:39,160
So first thing we need is we created a cache, right?

1330
01:46:39,160 --> 01:46:54,160
So we need, oof, cache equals simple cache.

1331
01:46:54,160 --> 01:46:59,160
And let me change to master. There we go.

1332
01:46:59,160 --> 01:47:03,160
So we just need simple cache. That's it.

1333
01:47:03,160 --> 01:47:07,160
And then we create our replay prevention handler.

1334
01:47:07,160 --> 01:47:14,160
Replay prevention signal handler.

1335
01:47:14,160 --> 01:47:25,160
I use very long words. Equals replay prevention signal handler.

1336
01:47:25,160 --> 01:47:28,160
And we'll import it.

1337
01:47:28,160 --> 01:47:30,160
And it needs a cache, right?

1338
01:47:30,160 --> 01:47:35,160
Because we said the unit needed a cache.

1339
01:47:35,160 --> 01:47:42,160
And then we just have to send it over to our signal handler.

1340
01:47:42,160 --> 01:47:46,160
Let me get rid of that so you can actually see it.

1341
01:47:46,160 --> 01:47:52,160
All right. So we created our signal handler, which is our replay prevention signal handler.

1342
01:47:52,160 --> 01:47:59,160
It used cache to try and add a nonce value to cache.

1343
01:47:59,160 --> 01:48:02,160
We instantiated it with the cache.

1344
01:48:02,160 --> 01:48:10,160
And we're passing it to our order signal handler, which makes sure this works just like middleware, because you can't actually do middleware in Flask,

1345
01:48:10,160 --> 01:48:15,160
which I find troublesome, but it is how they built it.

1346
01:48:15,160 --> 01:48:20,160
It's a Verksoig issue, not necessarily a Flask issue.

1347
01:48:20,160 --> 01:48:28,160
There are ways that you can do it through blueprints, I'm told, but that's a little complicated for this particular type of discussion.

1348
01:48:28,160 --> 01:48:30,160
Any questions about that?

1349
01:48:30,160 --> 01:48:31,160
Okay.

1350
01:48:31,160 --> 01:48:42,160
So, first thing I will do is, since I did do this before, I will comment that out.

1351
01:48:42,160 --> 01:48:45,160
We'll go start our server.

1352
01:48:45,160 --> 01:48:56,160
So, I'll actually exit from this because it's pip-env.

1353
01:48:56,160 --> 01:49:05,160
So, is that too low?

1354
01:49:05,160 --> 01:49:08,160
Can everybody see it?

1355
01:49:08,160 --> 01:49:17,160
I'm just starting a pip-env shell, and then I will do the, because I already have the environment variable set up.

1356
01:49:17,160 --> 01:49:28,160
So, based on the README file, you have to pass some of these things in there, which I can never remember by hand.

1357
01:49:28,160 --> 01:49:37,160
So, it's the exports for the server, which one is the Flask app, what environment are you in, and tell it to run Flask.

1358
01:49:37,160 --> 01:49:38,160
All right.

1359
01:49:38,160 --> 01:49:55,160
And if I were to curl localhost, my thousand, turn off cap locks.

1360
01:49:55,160 --> 01:49:58,160
We get hello world results we're expecting because that's all that gets returned.

1361
01:49:58,160 --> 01:50:06,160
If I actually put in, you get headers back, everything looks good, right?

1362
01:50:06,160 --> 01:50:17,160
So, now we go and we turn on our replay prevention, and it should be angry.

1363
01:50:17,160 --> 01:50:20,160
I don't know if I have to restart or not.

1364
01:50:20,160 --> 01:50:22,160
Okay, it's fine.

1365
01:50:22,160 --> 01:50:27,160
Restart.

1366
01:50:27,160 --> 01:50:29,160
And it's happy.

1367
01:50:29,160 --> 01:50:33,160
It should be angry.

1368
01:50:33,160 --> 01:50:35,160
Make sure I'm in the right code base.

1369
01:50:35,160 --> 01:50:37,160
What's that?

1370
01:50:37,160 --> 01:50:40,160
I did, oh, I'm in the wrong directory again.

1371
01:50:40,160 --> 01:50:44,160
Damn it.

1372
01:50:44,160 --> 01:50:49,160
This is becoming problematic.

1373
01:50:49,160 --> 01:51:03,160
So, what happens when you have your code in two places?

1374
01:51:03,160 --> 01:51:06,160
Flask, oh, I have to do it again.

1375
01:51:06,160 --> 01:51:15,160
So, pip-env shell with the correct place.

1376
01:51:15,160 --> 01:51:17,160
And then Flask run.

1377
01:51:17,160 --> 01:51:20,160
And then, it should be angry.

1378
01:51:20,160 --> 01:51:21,160
Okay, yay.

1379
01:51:21,160 --> 01:51:23,160
So, oh, wow, you can't see that.

1380
01:51:23,160 --> 01:51:26,160
My bad.

1381
01:51:26,160 --> 01:51:30,160
So, this time we got a 401 unauthorized like we were expecting.

1382
01:51:30,160 --> 01:51:34,160
And we got our error from our error handler.

1383
01:51:34,160 --> 01:51:49,160
So, now if I provide a nots, so if I do my curl again and I provide a header,

1384
01:51:49,160 --> 01:52:04,160
authorization, x nots, authorization colon, that makes the header, x nots a,

1385
01:52:04,160 --> 01:52:07,160
I can't use more than once, right?

1386
01:52:07,160 --> 01:52:11,160
It's happy again because I provided my authorization.

1387
01:52:11,160 --> 01:52:15,160
But if I send the same data, it's angry again, right?

1388
01:52:15,160 --> 01:52:17,160
Because it can only see that value once.

1389
01:52:17,160 --> 01:52:20,160
So, all I have to do is just go change the nots value.

1390
01:52:20,160 --> 01:52:22,160
I mean, nots doesn't mean they should be fairly random.

1391
01:52:22,160 --> 01:52:23,160
This is not.

1392
01:52:23,160 --> 01:52:26,160
But this is just to show you, as long as I give it something new,

1393
01:52:26,160 --> 01:52:28,160
every time it's perfectly happy, all right?

1394
01:52:28,160 --> 01:52:31,160
So, if your authorization header includes something that has a nots,

1395
01:52:31,160 --> 01:52:38,160
like a JSON web token or digest authentication, you could just use that.

1396
01:52:38,160 --> 01:52:43,160
Hash all data together, it gives you a nice little unique value.

1397
01:52:43,160 --> 01:52:45,160
It all depends on what you're doing.

1398
01:52:45,160 --> 01:52:48,160
And this is going to mess me up, so I'm going to change this now.

1399
01:52:48,160 --> 01:52:50,160
I said this one's fairly simple.

1400
01:52:50,160 --> 01:52:54,160
Hopefully not a whole lot of questions about, any questions about that one?

1401
01:52:54,160 --> 01:52:56,160
Okay.

1402
01:52:56,160 --> 01:53:04,160
Let's get it in the right directory and the right shell.

1403
01:53:04,160 --> 01:53:06,160
Not flash.

1404
01:53:06,160 --> 01:53:10,160
Pipf.

1405
01:53:10,160 --> 01:53:15,160
So, you can also do that using the client.

1406
01:53:15,160 --> 01:53:25,160
So, if I do python client.py, and I'll use verbose.

1407
01:53:25,160 --> 01:53:28,160
All right, so this looks very similar to what we just did.

1408
01:53:28,160 --> 01:53:29,160
All right.

1409
01:53:29,160 --> 01:53:37,160
It did a get, HTTP 1.1, authorization, nots none, response, 200 okay.

1410
01:53:37,160 --> 01:53:42,160
It was okay because the nots was sent once.

1411
01:53:42,160 --> 01:53:46,160
I do it again, I get an error.

1412
01:53:46,160 --> 01:53:49,160
All right, so this time I got a bad request.

1413
01:53:49,160 --> 01:53:52,160
So, yes.

1414
01:53:52,160 --> 01:53:53,160
So, the file system.

1415
01:53:53,160 --> 01:53:59,160
So, if you actually, can't remember if it's under temp by default.

1416
01:53:59,160 --> 01:54:06,160
I don't think it's under temp because that wouldn't work.

1417
01:54:06,160 --> 01:54:07,160
Maybe it is.

1418
01:54:07,160 --> 01:54:09,160
I'm honestly not 100% sure we're storing it right now.

1419
01:54:09,160 --> 01:54:12,160
I can go look at the code and find out where it's storing it by default,

1420
01:54:12,160 --> 01:54:14,160
but I think it's actually storing it in temp.

1421
01:54:14,160 --> 01:54:17,160
Sometimes it gets problematic, but this is a fresh reboot,

1422
01:54:17,160 --> 01:54:19,160
and I don't have anything in temp that can't be parsed.

1423
01:54:19,160 --> 01:54:24,160
That directory.

1424
01:54:24,160 --> 01:54:34,160
Yeah.

1425
01:54:34,160 --> 01:54:38,160
No, so what you're trying to prevent, again, so you're having to generate a nonce.

1426
01:54:38,160 --> 01:54:42,160
Generating a truly random value is an expensive proposition.

1427
01:54:42,160 --> 01:54:45,160
Right, so what you're trying to do is you're trying to make it more expensive

1428
01:54:45,160 --> 01:54:52,160
than just go hit this URL, spawn up a thousand, you know,

1429
01:54:52,160 --> 01:54:58,160
the smallest image possible on Amazon, start up a load balance tester,

1430
01:54:58,160 --> 01:55:04,160
a load tester, and hit me with a thousand per instance of this request every second.

1431
01:55:04,160 --> 01:55:08,160
Right, because I can do that today, and it will cost me about $10.

1432
01:55:08,160 --> 01:55:13,160
Right, so in $10, I can take down any system out there that doesn't have any protection.

1433
01:55:13,160 --> 01:55:15,160
So, this is protecting from that.

1434
01:55:15,160 --> 01:55:19,160
So, I can't just go do this exact same request to everything.

1435
01:55:19,160 --> 01:55:23,160
I have to modify it, which means, and so you can't start with a file

1436
01:55:23,160 --> 01:55:27,160
because if you use the same file of values, that's not going to work.

1437
01:55:27,160 --> 01:55:31,160
So, you have to actually write code to produce random values in a particular place,

1438
01:55:31,160 --> 01:55:36,160
which, again, is doable, but it means that the attacker has to do something.

1439
01:55:36,160 --> 01:55:41,160
It requires them to invest where otherwise they didn't have to.

1440
01:55:41,160 --> 01:55:46,160
So, a lot of attackers will just walk away because sometimes they're doing it just to see if they can.

1441
01:55:46,160 --> 01:55:54,160
Right, there are novice researchers out there that are just trying to see what they can do on the web.

1442
01:55:54,160 --> 01:55:58,160
Right, trying to see if you're susceptible to this type of attack.

1443
01:55:58,160 --> 01:56:01,160
And if they can, what can they do to your site?

1444
01:56:01,160 --> 01:56:06,160
No, not necessarily any malicious intent, just, you know, they just don't care.

1445
01:56:06,160 --> 01:56:08,160
They're just trying to see what happens.

1446
01:56:08,160 --> 01:56:10,160
They think it's kind of cool they took down your site.

1447
01:56:10,160 --> 01:56:12,160
This prevents from that, right?

1448
01:56:12,160 --> 01:56:14,160
Someone doesn't know what they're doing.

1449
01:56:14,160 --> 01:56:16,160
Someone who does know what they're doing could actually do some work and get it to work.

1450
01:56:16,160 --> 01:56:17,160
Yeah?

1451
01:56:17,160 --> 01:56:22,160
Do you have any suggestions that this gets more complicated for the QA department

1452
01:56:22,160 --> 01:56:24,160
to be able to test stuff out?

1453
01:56:24,160 --> 01:56:26,160
Like, what's your personal experience with that?

1454
01:56:26,160 --> 01:56:30,160
Just give them a little compliance that you wrote yourself and that's what they test on?

1455
01:56:30,160 --> 01:56:32,160
Or do you say, hey...

1456
01:56:32,160 --> 01:56:38,160
So, my QA department, we do automated testing on most of it.

1457
01:56:38,160 --> 01:56:40,160
Everything else uses our SDK, which generates an ounce every time.

1458
01:56:40,160 --> 01:56:43,160
So, we provide our QA department the ability to do this stuff.

1459
01:56:43,160 --> 01:56:44,160
We also do load testing.

1460
01:56:44,160 --> 01:56:49,160
The load testing gets very hard because you have to actually have way more clients

1461
01:56:49,160 --> 01:56:52,160
than you are able to create requests because of the amount of...

1462
01:56:52,160 --> 01:56:58,160
It's just the sheer amount of computing power necessary to interact with my API.

1463
01:56:58,160 --> 01:57:04,160
We use just thousands of Docker containers just trying to hammer this thing.

1464
01:57:04,160 --> 01:57:07,160
But most places you're actually network bound.

1465
01:57:07,160 --> 01:57:10,160
For my SDK, you're CPU bound.

1466
01:57:10,160 --> 01:57:12,160
Because, again, you're trying to make it difficult, right?

1467
01:57:12,160 --> 01:57:16,160
Encryption, signatures, non-sys, they all use up CPU power.

1468
01:57:16,160 --> 01:57:19,160
And so, you're costing people money, right?

1469
01:57:19,160 --> 01:57:25,160
On the internet, when you're using something like AWS or Google or Microsoft or Azure, right?

1470
01:57:25,160 --> 01:57:26,160
Network doesn't cost you.

1471
01:57:26,160 --> 01:57:29,160
Outbound network doesn't cost you a penny.

1472
01:57:29,160 --> 01:57:31,160
It's CPU that costs you.

1473
01:57:31,160 --> 01:57:34,160
So, you're trying to use up their CPU.

1474
01:57:34,160 --> 01:57:35,160
Okay.

1475
01:57:35,160 --> 01:57:45,160
So, the next thing we do is we also wanted to do...

1476
01:57:45,160 --> 01:57:47,160
Where'd he go?

1477
01:57:47,160 --> 01:57:49,160
Or am I in the wrong place?

1478
01:57:49,160 --> 01:57:51,160
Nope, I'm in the right place.

1479
01:57:51,160 --> 01:57:54,160
Okay. So, the next thing we want to do is rate limiting.

1480
01:57:54,160 --> 01:57:55,160
All right.

1481
01:57:55,160 --> 01:58:04,160
So, rate limiting requires you to identify who the user is and what they're doing

1482
01:58:04,160 --> 01:58:06,160
and how many times they've done it.

1483
01:58:06,160 --> 01:58:12,160
So, the next thing we're going to do...

1484
01:58:12,160 --> 01:58:14,160
Just when you thought you were prepared.

1485
01:58:14,160 --> 01:58:15,160
Okay.

1486
01:58:15,160 --> 01:58:16,160
So, the next thing we do is rate limiting.

1487
01:58:16,160 --> 01:58:25,160
The first thing we do is we make a new signal.

1488
01:58:25,160 --> 01:58:33,160
The signal is going to be the rate limit.

1489
01:58:33,160 --> 01:58:34,160
Rate limiting.

1490
01:58:34,160 --> 01:58:37,160
I want to make sure it at least matches up with what you might move forward to

1491
01:58:37,160 --> 01:58:39,160
and not have a bunch of problems.

1492
01:58:39,160 --> 01:58:47,160
Rate limiting signal handler, not tear.

1493
01:58:47,160 --> 01:58:53,160
Limiting.

1494
01:58:53,160 --> 01:59:03,160
I'm not even kidding about this typing stuff.

1495
01:59:03,160 --> 01:59:08,160
And then we'll implement the abstracts.

1496
01:59:08,160 --> 01:59:12,160
And this also, like we talked about, uses cache.

1497
01:59:12,160 --> 01:59:13,160
All right.

1498
01:59:13,160 --> 01:59:24,160
So, we need to pass into it a cache object.

1499
01:59:24,160 --> 01:59:25,160
All right.

1500
01:59:25,160 --> 01:59:31,160
And again, we're using base cache.

1501
01:59:31,160 --> 01:59:34,160
Come on.

1502
01:59:34,160 --> 01:59:35,160
All right.

1503
01:59:35,160 --> 01:59:36,160
So, we have a cache.

1504
01:59:36,160 --> 01:59:40,160
I'm going to move it up so people can see it and get rid of this so it's easier.

1505
01:59:40,160 --> 01:59:41,160
Okay.

1506
01:59:41,160 --> 01:59:48,160
So, just like the other one, I mean, I guess I could create a base class for

1507
01:59:48,160 --> 01:59:52,160
cache implementing, but I hate using base classes for everything.

1508
01:59:52,160 --> 01:59:55,160
So, we have a rate limiting signal handler, and it's got a cache.

1509
01:59:55,160 --> 01:59:58,160
So, what we have to do is we need three things.

1510
01:59:58,160 --> 01:59:59,160
All right.

1511
01:59:59,160 --> 02:00:00,160
We need a time period.

1512
02:00:00,160 --> 02:00:04,160
We need to be able to figure out a time slice because we're limiting per period.

1513
02:00:04,160 --> 02:00:08,160
We need to figure out who it is.

1514
02:00:08,160 --> 02:00:15,160
And then the next thing we need to figure out is the count.

1515
02:00:15,160 --> 02:00:18,160
You need to be able to add in the count.

1516
02:00:18,160 --> 02:00:29,160
And so, we're going to start by figuring out the time chunk.

1517
02:00:29,160 --> 02:00:31,160
All right.

1518
02:00:31,160 --> 02:00:41,160
So, what I do is I figure out what time it is.

1519
02:00:41,160 --> 02:00:42,160
All right.

1520
02:00:42,160 --> 02:00:45,160
So, that's where that gets us, and I'm going to convert that into an integer.

1521
02:00:45,160 --> 02:00:47,160
So, oops.

1522
02:00:47,160 --> 02:00:49,160
Dot timestamp.

1523
02:00:49,160 --> 02:00:54,160
So, I got the current UTC time because it doesn't matter where the time is.

1524
02:00:54,160 --> 02:00:59,160
I just need a value for what time it is now, and it should always be the same

1525
02:00:59,160 --> 02:01:01,160
across any of my servers.

1526
02:01:01,160 --> 02:01:04,160
So, I've got that.

1527
02:01:04,160 --> 02:01:08,160
And converting it to an integer, which should already be anyway, but typing,

1528
02:01:08,160 --> 02:01:11,160
that kind of stuff.

1529
02:01:11,160 --> 02:01:13,160
And we're going to divide it by the rate seconds.

1530
02:01:13,160 --> 02:01:23,160
So, it also means I need to tell it how many seconds.

1531
02:01:23,160 --> 02:01:24,160
All right.

1532
02:01:24,160 --> 02:01:30,160
So, I'm going to do two things in here that I didn't add in before because I forgot.

1533
02:01:30,160 --> 02:01:36,160
So, rate count was an integer, and rate seconds in the constructor.

1534
02:01:36,160 --> 02:01:46,160
So, this way we can not hard code this stuff because I hate hard coding things.

1535
02:01:46,160 --> 02:01:48,160
So, now we have a signal handler that will...

1536
02:01:48,160 --> 02:01:52,160
The other thing you can do here as well is you can have multiple signal handlers.

1537
02:01:52,160 --> 02:01:56,160
So, I can say I can only do 10 per second.

1538
02:01:56,160 --> 02:01:58,160
I can do 100 in a minute.

1539
02:01:58,160 --> 02:02:00,160
I can do 1,000 in an hour.

1540
02:02:00,160 --> 02:02:07,160
So, hopefully this thing allows you to do that, and we'll store these things.

1541
02:02:07,160 --> 02:02:15,160
So, come on, type.

1542
02:02:15,160 --> 02:02:25,160
So, we got that.

1543
02:02:25,160 --> 02:02:32,160
And we've got rate seconds.

1544
02:02:32,160 --> 02:02:40,160
So, even though this is just kind of example code, you could actually use it whenever you wanted.

1545
02:02:40,160 --> 02:02:44,160
So, we've got our time chunk, which is the current time divided by the rate seconds.

1546
02:02:44,160 --> 02:02:45,160
So, that's going to...

1547
02:02:45,160 --> 02:02:48,160
And it's going to return an integer, right?

1548
02:02:48,160 --> 02:02:49,160
So, it's going to be that value.

1549
02:02:49,160 --> 02:02:54,160
So, if you have a time, you divide it by 60, right?

1550
02:02:54,160 --> 02:02:57,160
You're going to get the integer value of the divisor.

1551
02:02:57,160 --> 02:03:00,160
So, every time for that minute is always the same value.

1552
02:03:00,160 --> 02:03:05,160
If you do it by five seconds, every time of that five second period is going to be the same value.

1553
02:03:05,160 --> 02:03:08,160
So, really simple equation to get you a slice.

1554
02:03:08,160 --> 02:03:10,160
Again, we don't care if it's...

1555
02:03:10,160 --> 02:03:15,160
For this particular type of thing, I don't care if it's 100.

1556
02:03:15,160 --> 02:03:20,160
If you did 100 in the one second beforehand, the 100 the next second after,

1557
02:03:20,160 --> 02:03:23,160
I just want to keep you from doing 100 over five seconds,

1558
02:03:23,160 --> 02:03:30,160
because I'm trying to use the least amount of resources necessary to limit rates to what's acceptable.

1559
02:03:30,160 --> 02:03:33,160
So, when you do this, it really means that you can only...

1560
02:03:33,160 --> 02:03:37,160
The maximum value across a span is double what your rate is going to be,

1561
02:03:37,160 --> 02:03:40,160
because if they cross over two spans, they can have it twice, right?

1562
02:03:40,160 --> 02:03:42,160
So, that's something to think about if you're going to do it this way,

1563
02:03:42,160 --> 02:03:46,160
is that if most of your system could possibly handle with 10,000 a second,

1564
02:03:46,160 --> 02:03:49,160
you want to limit it to 5,000 a second,

1565
02:03:49,160 --> 02:03:53,160
because if they cross over that threshold during a second,

1566
02:03:53,160 --> 02:03:58,160
then you want to make sure that you've not allowed them to hit your max.

1567
02:03:58,160 --> 02:04:02,160
So, now that we have our time chunk, we need our key.

1568
02:04:02,160 --> 02:04:07,160
So, there's probably other ways to do it.

1569
02:04:07,160 --> 02:04:12,160
I just do a simple string format,

1570
02:04:18,160 --> 02:04:23,160
which is going to be the path.

1571
02:04:32,160 --> 02:04:41,160
Request.path. Request method. Man, typing is bad today.

1572
02:04:44,160 --> 02:04:47,160
And the time chunk.

1573
02:04:47,160 --> 02:04:51,160
If you had user information, which we don't yet, you would enter user information here.

1574
02:04:51,160 --> 02:04:58,160
So, this is a global filter. No one can have more than this many.

1575
02:04:58,160 --> 02:05:03,160
When authentication comes in, you could change that with an actual user coming in.

1576
02:05:03,160 --> 02:05:04,160
We don't have that right now.

1577
02:05:04,160 --> 02:05:06,160
But again, you would just add something to the key.

1578
02:05:06,160 --> 02:05:10,160
You add another value in here, and you put a username in there, right?

1579
02:05:10,160 --> 02:05:15,160
Whatever is going to uniquely identify a slice for an action for a period.

1580
02:05:15,160 --> 02:05:18,160
And if you say you can only do this action,

1581
02:05:18,160 --> 02:05:21,160
but there's like four different ways you could do it through four different methods,

1582
02:05:21,160 --> 02:05:26,160
you have to find some way to advise what that is.

1583
02:05:26,160 --> 02:05:30,160
But again, the other important thing is make sure these are happening in signals,

1584
02:05:30,160 --> 02:05:35,160
because this is happening before it even gets to the router inside of Flask.

1585
02:05:35,160 --> 02:05:40,160
So, if you're going to do it for Django, make sure you do it in the middleware, or in Pyramid.

1586
02:05:40,160 --> 02:05:42,160
Do it before you get to the middleware.

1587
02:05:42,160 --> 02:05:46,160
Don't even process data in that request until you know you should be processing it.

1588
02:05:46,160 --> 02:05:49,160
Stop it as soon as you possibly can.

1589
02:05:49,160 --> 02:05:53,160
And Flask, without having to create a...

1590
02:05:53,160 --> 02:05:56,160
You could do it with middleware in front of Verkzog,

1591
02:05:56,160 --> 02:06:00,160
but that's incredibly annoying and difficult to show.

1592
02:06:00,160 --> 02:06:01,160
So, that's something you could actually do.

1593
02:06:01,160 --> 02:06:06,160
You could actually put an actual WSGI middleware in front of it and handle it there

1594
02:06:06,160 --> 02:06:09,160
if you really, really, really want to get right in front of everything,

1595
02:06:09,160 --> 02:06:13,160
but it's difficult to deploy as an application that way.

1596
02:06:13,160 --> 02:06:16,160
Okay.

1597
02:06:16,160 --> 02:06:21,160
And then, once you've got the key, you want to try to do...

1598
02:06:21,160 --> 02:06:26,160
You want to increment the key

1599
02:06:26,160 --> 02:06:30,160
and determine if it's beyond what your rate count is, right?

1600
02:06:30,160 --> 02:06:37,160
So, you take your cache, and you tell it to increment.

1601
02:06:37,160 --> 02:06:40,160
So, fortunately, in this particular cache implementation,

1602
02:06:40,160 --> 02:06:43,160
you don't have to do the add and then increment.

1603
02:06:43,160 --> 02:06:47,160
It just does the increment, makes sure it's there, and it works.

1604
02:06:47,160 --> 02:06:50,160
It does whatever it has to do for whatever implementation you're doing.

1605
02:06:50,160 --> 02:06:55,160
So, we're going to take our key,

1606
02:06:55,160 --> 02:06:57,160
and we're going to re-increment the cache key,

1607
02:06:57,160 --> 02:06:59,160
because we don't care what the value is,

1608
02:06:59,160 --> 02:07:09,160
and we're going to see if it's greater than our rate count.

1609
02:07:09,160 --> 02:07:11,160
So, we've got our unique identifier.

1610
02:07:11,160 --> 02:07:12,160
We're going to increment the value.

1611
02:07:12,160 --> 02:07:17,160
If it exceeds our acceptable value, we're going to error.

1612
02:07:17,160 --> 02:07:32,160
And we're going to raise everyone's favorite, which is 429.

1613
02:07:32,160 --> 02:07:37,160
There are oftentimes debates on what error numbers should be raised.

1614
02:07:37,160 --> 02:07:39,160
My personal opinion is,

1615
02:07:39,160 --> 02:07:45,160
find a methodology that makes sense to you and be very consistent in your API.

1616
02:07:45,160 --> 02:07:48,160
Try and go through the HTTP spec,

1617
02:07:48,160 --> 02:07:51,160
find what error message makes sense for what you're trying to do, and raise it.

1618
02:07:51,160 --> 02:07:53,160
That's a big rest conundrum,

1619
02:07:53,160 --> 02:07:58,160
and it's almost a religious war when you talk to certain people.

1620
02:07:58,160 --> 02:08:05,160
But we do 429 so that we can differentiate it from anything else.

1621
02:08:05,160 --> 02:08:06,160
And that's it.

1622
02:08:06,160 --> 02:08:11,160
So now, it's going to see if you hit these things too often.

1623
02:08:11,160 --> 02:08:19,160
So, if I go Restart, that's a temp.

1624
02:08:19,160 --> 02:08:21,160
There we go.

1625
02:08:21,160 --> 02:08:26,160
So now, if I go again, it should be allowed.

1626
02:08:26,160 --> 02:08:30,160
Class terror.

1627
02:08:30,160 --> 02:08:34,160
Where did I do that?

1628
02:08:34,160 --> 02:08:39,160
I probably have to restart.

1629
02:08:39,160 --> 02:08:44,160
Signals.

1630
02:08:44,160 --> 02:08:47,160
I probably didn't, the server probably restarted before I got done.

1631
02:08:47,160 --> 02:08:51,160
So let me go here and restart.

1632
02:08:51,160 --> 02:08:52,160
Yeah.

1633
02:08:52,160 --> 02:08:54,160
Not sure how that happened, but I'm not going to worry about it.

1634
02:08:54,160 --> 02:08:58,160
All right.

1635
02:08:58,160 --> 02:09:01,160
So now it's perfectly happy.

1636
02:09:01,160 --> 02:09:04,160
Oh, it's going to be perfectly happy because I haven't added to the server.

1637
02:09:04,160 --> 02:09:05,160
Replay detected on that one.

1638
02:09:05,160 --> 02:09:14,160
But what I have to do is I actually have to tell it to be used on the server.

1639
02:09:14,160 --> 02:09:19,160
So we're going to go to Server,

1640
02:09:19,160 --> 02:09:29,160
and we're going to add in the rate limiting signal handler.

1641
02:09:49,160 --> 02:09:52,160
And it also needs cache.

1642
02:09:52,160 --> 02:10:05,160
And it needs the number of the account, which we're going to say you can do one every 10 seconds.

1643
02:10:05,160 --> 02:10:06,160
Right.

1644
02:10:06,160 --> 02:10:08,160
So we made our new signal handler.

1645
02:10:08,160 --> 02:10:11,160
The rate limit signal handler, we give it the cache.

1646
02:10:11,160 --> 02:10:15,160
We gave it the count and the time.

1647
02:10:15,160 --> 02:10:17,160
So every 10 seconds, you can send one.

1648
02:10:17,160 --> 02:10:21,160
And it has to be reasonable, but it has to actually be able to be aired.

1649
02:10:21,160 --> 02:10:25,160
And then we're going to add it into our signal handler.

1650
02:10:25,160 --> 02:10:30,160
So now we have replay and rate limiting.

1651
02:10:30,160 --> 02:10:38,160
So now I should upgrade the client.

1652
02:10:38,160 --> 02:10:42,160
So let me do that here.

1653
02:10:42,160 --> 02:10:44,160
My client isn't keeping up.

1654
02:10:44,160 --> 02:10:47,160
I know, on purpose, sorry.

1655
02:10:47,160 --> 02:10:49,160
Because I'm adding the code, but my client isn't keeping up.

1656
02:10:49,160 --> 02:10:50,160
So that actually gets weird.

1657
02:10:50,160 --> 02:10:53,160
I hadn't thought about that.

1658
02:10:53,160 --> 02:11:02,160
But since we're not changing that, we're going to add in replay prevention.

1659
02:11:02,160 --> 02:11:03,160
Yeah.

1660
02:11:03,160 --> 02:11:05,160
So you may want to...

1661
02:11:05,160 --> 02:11:07,160
I hadn't thought about that.

1662
02:11:07,160 --> 02:11:14,160
But you could, in theory, just copy the files anywhere you want.

1663
02:11:14,160 --> 02:11:15,160
We're in replay, right?

1664
02:11:15,160 --> 02:11:23,160
Rate limiting.

1665
02:11:23,160 --> 02:11:24,160
Limiting.

1666
02:11:24,160 --> 02:11:28,160
Edit.

1667
02:11:28,160 --> 02:11:38,160
And then...

1668
02:11:38,160 --> 02:11:42,160
Typing is unpleasant.

1669
02:11:42,160 --> 02:11:44,160
Get another show.

1670
02:11:44,160 --> 02:11:51,160
And then if I do the client...

1671
02:11:51,160 --> 02:11:52,160
Right. I didn't send any requests.

1672
02:11:52,160 --> 02:11:53,160
It was perfectly happy.

1673
02:11:53,160 --> 02:11:54,160
I sent it again.

1674
02:11:54,160 --> 02:11:55,160
It's rate limited.

1675
02:11:55,160 --> 02:11:56,160
It's been 10...

1676
02:11:56,160 --> 02:11:57,160
It's well within 10 seconds.

1677
02:11:57,160 --> 02:12:00,160
Now I just have to wait for that 10-second thing to elapse.

1678
02:12:00,160 --> 02:12:02,160
So let me change my clock.

1679
02:12:02,160 --> 02:12:04,160
I don't want to get there.

1680
02:12:04,160 --> 02:12:08,160
And now it should be fine.

1681
02:12:08,160 --> 02:12:10,160
Because I'm another 10-second slice.

1682
02:12:10,160 --> 02:12:11,160
I do it again.

1683
02:12:11,160 --> 02:12:13,160
Still in the 10-second slice.

1684
02:12:13,160 --> 02:12:15,160
Still in the 10-second slice.

1685
02:12:15,160 --> 02:12:17,160
Still in the 10-second slice.

1686
02:12:17,160 --> 02:12:20,160
But now it should be okay.

1687
02:12:20,160 --> 02:12:21,160
Right?

1688
02:12:21,160 --> 02:12:27,160
So it's a super simple operation to make sure that you don't exceed the maximum your system can allow.

1689
02:12:27,160 --> 02:12:30,160
You can also, again, do it by user.

1690
02:12:30,160 --> 02:12:36,160
And you may also need to do this again after authorization.

1691
02:12:36,160 --> 02:12:39,160
So one of the things that we do is we limit by user.

1692
02:12:39,160 --> 02:12:45,160
So we have a separate process, which is also in middleware, that once you've logged in, now I see how often you can hit it.

1693
02:12:45,160 --> 02:12:50,160
Because depending on what your subscription level is, you might be able to hit it one time a minute, or you might be able to hit it 100 times a minute.

1694
02:12:50,160 --> 02:12:53,160
So we actually add that in as well.

1695
02:12:53,160 --> 02:12:56,160
But it's the same basic process, the same functionality.

1696
02:12:56,160 --> 02:12:58,160
It's just user-based.

1697
02:12:58,160 --> 02:13:00,160
Any questions on that one?

1698
02:13:00,160 --> 02:13:05,160
Yeah, if you want to.

1699
02:13:05,160 --> 02:13:07,160
Yeah.

1700
02:13:07,160 --> 02:13:16,160
So something I didn't think about when we were doing this, as you can move forward and stuff, is that the client changes to add things in.

1701
02:13:16,160 --> 02:13:17,160
I thought that was clever.

1702
02:13:17,160 --> 02:13:20,160
Originally, it just had everything in there and was more difficult.

1703
02:13:20,160 --> 02:13:24,160
And you would have to turn things off because it wasn't expecting things to come a certain way.

1704
02:13:24,160 --> 02:13:31,160
So I started automatically turning those off so you didn't see a bunch of data that didn't matter to you and that the thing wouldn't understand, which made it more difficult.

1705
02:13:31,160 --> 02:13:46,160
So if you were to basically copy the directory somewhere else, the file system, check out the replay prevention branch or rate limiting branch, rate limiting added branch, then the client would actually work.

1706
02:13:46,160 --> 02:13:48,160
My apologies for that mess up.

1707
02:13:48,160 --> 02:13:52,160
I will fix that somehow.

1708
02:13:52,160 --> 02:13:55,160
I'm not sure how.

1709
02:13:55,160 --> 02:13:59,160
It may just have to have the same client put different configs, different things.

1710
02:13:59,160 --> 02:14:01,160
You can just change it really quickly.

1711
02:14:01,160 --> 02:14:13,160
But so once you've done the copy, you've checked out the right thing and you've done a PIPM shell to get to get Python running.

1712
02:14:13,160 --> 02:14:18,160
True.

1713
02:14:18,160 --> 02:14:22,160
But then when you actually, if you want to move forward, it's going to get you messed up.

1714
02:14:22,160 --> 02:14:24,160
Yeah.

1715
02:14:24,160 --> 02:14:30,160
If you're a git enthusiast, there are other ways to do it where you don't have to copy the directory.

1716
02:14:30,160 --> 02:14:34,160
But for simplicity, yeah.

1717
02:14:34,160 --> 02:14:37,160
But that's going to have to check the origin and then you have to have network connectivity.

1718
02:14:37,160 --> 02:14:42,160
So I tried to make it so you couldn't do any network stuff.

1719
02:14:42,160 --> 02:14:46,160
But you could also just do that, do the same thing through Coral if you wanted to.

1720
02:14:46,160 --> 02:14:48,160
Just have to increment your piece there.

1721
02:14:48,160 --> 02:14:54,160
Because you'll get the same thing.

1722
02:14:54,160 --> 02:14:55,160
Where's the Coral?

1723
02:14:55,160 --> 02:14:57,160
I thought I had Coral running somewhere.

1724
02:14:57,160 --> 02:14:58,160
There we go.

1725
02:14:58,160 --> 02:14:59,160
No?

1726
02:14:59,160 --> 02:15:01,160
All right.

1727
02:15:01,160 --> 02:15:07,160
But yeah, if you did it with Coral, do the same thing.

1728
02:15:07,160 --> 02:15:09,160
Stop caps.

1729
02:15:09,160 --> 02:15:12,160
It's not in there.

1730
02:15:12,160 --> 02:15:17,160
But once we get past this, Coral's not going to work so great.

1731
02:15:17,160 --> 02:15:22,160
So any other questions about the rate limiting?

1732
02:15:22,160 --> 02:15:24,160
Yeah, rate limiting that one.

1733
02:15:24,160 --> 02:15:25,160
Okay.

1734
02:15:25,160 --> 02:15:31,160
So next thing is going to be, what is next?

1735
02:15:31,160 --> 02:15:34,160
Let me look.

1736
02:15:34,160 --> 02:15:35,160
Rate limiting.

1737
02:15:35,160 --> 02:15:37,160
Encryption.

1738
02:15:37,160 --> 02:15:39,160
Encryption sounds difficult.

1739
02:15:39,160 --> 02:15:40,160
All right?

1740
02:15:40,160 --> 02:15:45,160
One of the advantages of JWE is it's not difficult.

1741
02:15:45,160 --> 02:15:48,160
It's actually pretty, pretty simple.

1742
02:15:48,160 --> 02:15:53,160
So the first thing you're going to need is an encryption signal handler.

1743
02:15:53,160 --> 02:15:57,160
So we go back into our signal handlers.

1744
02:16:23,160 --> 02:16:25,160
Interesting.

1745
02:16:25,160 --> 02:16:30,160
Did it not do that?

1746
02:16:30,160 --> 02:16:33,160
Oh, yeah, sorry.

1747
02:16:33,160 --> 02:16:36,160
Bad, bad, bad man.

1748
02:16:36,160 --> 02:16:40,160
You'd think I would be doing Python programming long enough I would know better.

1749
02:16:40,160 --> 02:16:46,160
So this is just making me type less.

1750
02:16:46,160 --> 02:16:50,160
And so it's going to need some stuff.

1751
02:16:50,160 --> 02:16:58,160
Like all the things that we talked about, there are specific needs.

1752
02:16:58,160 --> 02:17:00,160
All right, methods, and it.

1753
02:17:00,160 --> 02:17:02,160
Okay.

1754
02:17:02,160 --> 02:17:10,160
So in order to encrypt things, we're going to need keys.

1755
02:17:10,160 --> 02:17:15,160
I've made this as simple as possible, so we are doing symmetric encryption.

1756
02:17:15,160 --> 02:17:19,160
Symmetric encryption means you use the same key on both sides.

1757
02:17:19,160 --> 02:17:22,160
That makes life easier in this example.

1758
02:17:22,160 --> 02:17:25,160
It doesn't necessarily make it more secure.

1759
02:17:25,160 --> 02:17:29,160
There are asymmetric methods available in JSON web encryption.

1760
02:17:29,160 --> 02:17:34,160
And hopefully coming up very soon there will be some more modern stuff.

1761
02:17:34,160 --> 02:17:38,160
But right now it's basically AES and RSA.

1762
02:17:38,160 --> 02:17:43,160
And it actually has, if you don't understand cryptography, it's going to be way over your head.

1763
02:17:43,160 --> 02:17:44,160
Don't worry about it.

1764
02:17:44,160 --> 02:17:48,160
If you like cryptography, it actually provides a way for you to do RSA

1765
02:17:48,160 --> 02:17:52,160
beyond the key size bound by what it actually does.

1766
02:17:52,160 --> 02:17:54,160
It uses an AES algorithm to encrypt the data.

1767
02:17:54,160 --> 02:17:57,160
You select which algorithm to use.

1768
02:17:57,160 --> 02:18:04,160
To do that, it generates a random key, an initialization vector, and encrypts that key and IV using RSA.

1769
02:18:04,160 --> 02:18:12,160
So it's a really novel way to use RSA encryption, which is most cases more secure,

1770
02:18:12,160 --> 02:18:16,160
as long as you're using the correct padding, is more secure than AES

1771
02:18:16,160 --> 02:18:21,160
just because of key size and how hard it is to crack.

1772
02:18:21,160 --> 02:18:25,160
But get beyond the 2048s or beyond the key size limitation.

1773
02:18:25,160 --> 02:18:29,160
You can only encrypt things that are the same size or smaller than your key.

1774
02:18:29,160 --> 02:18:32,160
And the closer you get to the key size, the less entropy you get.

1775
02:18:32,160 --> 02:18:35,160
So you actually get worse encryption, the larger you get.

1776
02:18:35,160 --> 02:18:38,160
So they've actually gotten around that in a very novel manner.

1777
02:18:38,160 --> 02:18:43,160
But we're just doing asymmetric key encryption, or asymmetric key encryption, which is the same key.

1778
02:18:43,160 --> 02:18:48,160
So we have to pass in a list of keys.

1779
02:18:48,160 --> 02:18:52,160
So we have a list of key.

1780
02:18:52,160 --> 02:18:54,160
And this is a JWK EST key.

1781
02:18:54,160 --> 02:18:57,160
So we're using...

1782
02:18:57,160 --> 02:19:00,160
That should actually be keys.

1783
02:19:00,160 --> 02:19:03,160
So we're using a library that's what I use.

1784
02:19:03,160 --> 02:19:08,160
It's not super handy.

1785
02:19:08,160 --> 02:19:12,160
It does everything it should do in the most minimalist fashion possible.

1786
02:19:12,160 --> 02:19:15,160
So if you wanted to do nice stuff for you, you're in the wrong place.

1787
02:19:15,160 --> 02:19:19,160
But it works and it's accurate, which is important.

1788
02:19:19,160 --> 02:19:24,160
And encryption, not as big of a deal as it is when you start getting down to JSON Web Tokens.

1789
02:19:24,160 --> 02:19:27,160
There are other libraries out there that will validate the JSON Web Token for you

1790
02:19:27,160 --> 02:19:30,160
and do it in a sane manner without you having to write a bunch of code.

1791
02:19:30,160 --> 02:19:32,160
This will not.

1792
02:19:32,160 --> 02:19:36,160
But it does do JSON Web Tokens, JSON Web Signatures, and JSON Web Encryption,

1793
02:19:36,160 --> 02:19:41,160
which is why I personally use it, because I use all three.

1794
02:19:41,160 --> 02:19:44,160
So...

1795
02:19:44,160 --> 02:19:49,160
We want to make sure we store our keys.

1796
02:19:49,160 --> 02:19:52,160
So we've got our keys.

1797
02:19:52,160 --> 02:19:59,160
So in our request, we need to decrypt things if they're encrypted.

1798
02:19:59,160 --> 02:20:06,160
So for me, the best way to do that is to determine it by content type.

1799
02:20:06,160 --> 02:20:11,160
If you require encryption, you may want to do something different.

1800
02:20:18,160 --> 02:20:25,160
And...

1801
02:20:25,160 --> 02:20:28,160
And making sure that it's Unicode is important,

1802
02:20:28,160 --> 02:20:31,160
because a string going against Unicode is not equal.

1803
02:20:31,160 --> 02:20:35,160
So make sure you use Unicode.

1804
02:20:35,160 --> 02:20:37,160
So if the content type is...

1805
02:20:37,160 --> 02:20:40,160
Sorry, that should be Application Jose, not JSON.

1806
02:20:40,160 --> 02:20:46,160
If it's Application Jose, that means the data is Jose-encrypted.

1807
02:20:46,160 --> 02:20:50,160
There's not a great MIME type, but that's the best one I could find for what I do,

1808
02:20:50,160 --> 02:20:54,160
so I use Application Jose.

1809
02:20:54,160 --> 02:20:58,160
There's better ones for JSON Web Tokens, but we're not doing that.

1810
02:20:59,160 --> 02:21:07,160
So if this is encrypted, I need to implement a JWE.

1811
02:21:07,160 --> 02:21:09,160
Man.

1812
02:21:09,160 --> 02:21:13,160
So that's the JSON Web Encryption instance.

1813
02:21:13,160 --> 02:21:16,160
And then I need to decrypt the data.

1814
02:21:20,160 --> 02:21:24,160
Not yet. Sorry.

1815
02:21:24,160 --> 02:21:27,160
Yes, I do. Okay.

1816
02:21:39,160 --> 02:21:45,160
Now, this does something. I'm not super happy about the way that it does it.

1817
02:21:45,160 --> 02:21:51,160
And there may be a point where I care enough to actually do something about it.

1818
02:21:51,160 --> 02:21:55,160
But what it's going to do is you just pass the keys,

1819
02:21:55,160 --> 02:21:59,160
and it will try... it'll start decrypting the first one, second one, third one,

1820
02:21:59,160 --> 02:22:01,160
so by the time... if you have a large list of keys,

1821
02:22:01,160 --> 02:22:05,160
this could be computationally expensive using this library.

1822
02:22:05,160 --> 02:22:08,160
If you can look at the data, which you can do,

1823
02:22:08,160 --> 02:22:13,160
which we do on some of our pieces, I think we actually do the JSON Web Token,

1824
02:22:13,160 --> 02:22:17,160
the key ID, if you do this right, will actually be in the header of the JSON Web Encryption,

1825
02:22:17,160 --> 02:22:20,160
so you should be able to figure out which one it is and pass it in.

1826
02:22:20,160 --> 02:22:24,160
And then the second one, we're just passing in the raw keys and giving it that,

1827
02:22:24,160 --> 02:22:27,160
and it's going to decrypt the data.

1828
02:22:27,160 --> 02:22:32,160
And then we're going to do something naughty.

1829
02:22:32,160 --> 02:22:38,160
Because Flask does not support middleware,

1830
02:22:38,160 --> 02:22:43,160
I cannot send the next middleware a new request.

1831
02:22:43,160 --> 02:22:47,160
Request is a global object that I now have to modify.

1832
02:22:47,160 --> 02:22:51,160
It's ugly, it's painful, but it works.

1833
02:22:54,160 --> 02:22:59,160
I will be talking to the main manager of this project this week

1834
02:22:59,160 --> 02:23:02,160
to see if I can find a better way to do this.

1835
02:23:02,160 --> 02:23:05,160
There was not one last year.

1836
02:23:05,160 --> 02:23:07,160
I'm told you might be able to do this in Blueprint,

1837
02:23:07,160 --> 02:23:09,160
but I don't want to have to get into Blueprints.

1838
02:23:09,160 --> 02:23:13,160
That's a fairly advanced concept for just using Flask as a thing to test with.

1839
02:23:13,160 --> 02:23:18,160
But what I can do is I can say request.

1840
02:23:23,160 --> 02:23:27,160
And everybody should raise their hair, should be standing up on end.

1841
02:23:27,160 --> 02:23:30,160
So I'm going to ask cache data.

1842
02:23:32,160 --> 02:23:35,160
Equals decrypted.

1843
02:23:35,160 --> 02:23:40,160
And then, what's that?

1844
02:23:40,160 --> 02:23:43,160
Yeah.

1845
02:23:43,160 --> 02:23:47,160
I need to create the cache JSON first.

1846
02:23:47,160 --> 02:23:49,160
Because it gets used twice.

1847
02:23:49,160 --> 02:23:54,160
This was a change from Flask 0. to Flask 1. that broke my...

1848
02:23:54,160 --> 02:23:57,160
that broke this presentation.

1849
02:24:00,160 --> 02:24:03,160
JSON loads.

1850
02:24:10,160 --> 02:24:15,160
Now you probably want to put more validation around that,

1851
02:24:15,160 --> 02:24:17,160
but I'm not doing it at this point.

1852
02:24:17,160 --> 02:24:21,160
This is just moving the data, and then it can be validated afterwards.

1853
02:24:21,160 --> 02:24:25,160
And this requires a tuple of the exact same thing twice.

1854
02:24:25,160 --> 02:24:29,160
I'm not sure why. It just does.

1855
02:24:32,160 --> 02:24:35,160
Oh, cache JSON, sorry. Not cache data.

1856
02:24:36,160 --> 02:24:39,160
Yeah, so...

1857
02:24:39,160 --> 02:24:44,160
Yeah, cache JSON requires the tuple of the two versions of cache JSON.

1858
02:24:44,160 --> 02:24:46,160
I don't know why. It just does.

1859
02:24:46,160 --> 02:24:49,160
I knew why. I looked at it when this was broken,

1860
02:24:49,160 --> 02:24:52,160
when I upgraded to 1.0 or 1.x.

1861
02:24:52,160 --> 02:24:55,160
Couldn't figure out why. And then I looked at it, I was like, oh, okay.

1862
02:24:55,160 --> 02:24:57,160
I'll do that now.

1863
02:24:57,160 --> 02:25:01,160
So basically what we've ended up doing is we take the...

1864
02:25:01,160 --> 02:25:04,160
If a content type is encrypted,

1865
02:25:04,160 --> 02:25:07,160
we then decrypt it using the keys.

1866
02:25:07,160 --> 02:25:11,160
We then change the request to the unencrypted data.

1867
02:25:11,160 --> 02:25:14,160
And the next piece...

1868
02:25:14,160 --> 02:25:18,160
Oh, yes, yes, yes, yes. Sorry.

1869
02:25:18,160 --> 02:25:21,160
That's why it's angry. It's not a method.

1870
02:25:21,160 --> 02:25:24,160
Sorry. Sorry.

1871
02:25:24,160 --> 02:25:27,160
And then we're setting that.

1872
02:25:27,160 --> 02:25:30,160
We don't need to...

1873
02:25:30,160 --> 02:25:32,160
In other times you would...

1874
02:25:32,160 --> 02:25:35,160
In other frameworks you may have to set the content type

1875
02:25:35,160 --> 02:25:38,160
to text JSON or application JSON.

1876
02:25:38,160 --> 02:25:41,160
And Flash you don't have to, so I'm not going to bother.

1877
02:25:44,160 --> 02:25:47,160
Now, that's decrypting.

1878
02:25:47,160 --> 02:25:53,160
Now we need to encrypt the responses.

1879
02:25:53,160 --> 02:25:56,160
So this is the first time we do a request finished handler.

1880
02:25:56,160 --> 02:25:59,160
So after it's gone through your handler,

1881
02:25:59,160 --> 02:26:01,160
or controller or whatever you like to call it,

1882
02:26:01,160 --> 02:26:04,160
it's gone through your route inside of Flask.

1883
02:26:04,160 --> 02:26:06,160
You're going to get a response object,

1884
02:26:06,160 --> 02:26:09,160
and then they're going to call the request finished handler

1885
02:26:09,160 --> 02:26:11,160
on your signals.

1886
02:26:11,160 --> 02:26:13,160
So the event is raised for that,

1887
02:26:13,160 --> 02:26:16,160
which you get a copy of the response.

1888
02:26:16,160 --> 02:26:19,160
And again, I can't make a new response and return it.

1889
02:26:19,160 --> 02:26:21,160
I have to modify the existing response.

1890
02:26:21,160 --> 02:26:24,160
Not my favorite way of doing it, but that's just how things work

1891
02:26:24,160 --> 02:26:27,160
when you don't have real middleware.

1892
02:26:27,160 --> 02:26:30,160
And there's no way to make real middleware.

1893
02:26:30,160 --> 02:26:36,160
Okay, so first thing we want to do is make sure that it's not an error.

1894
02:26:36,160 --> 02:26:42,160
So make sure that our status code

1895
02:26:50,160 --> 02:26:54,160
is in the 200s, right?

1896
02:26:54,160 --> 02:26:57,160
Because if it's not a 200 response,

1897
02:26:57,160 --> 02:27:00,160
we don't want to actually encrypt it, because that's an error.

1898
02:27:00,160 --> 02:27:03,160
And one way that people can take down your system

1899
02:27:03,160 --> 02:27:05,160
is to send you a bunch of errors that you have to encrypt,

1900
02:27:05,160 --> 02:27:09,160
because encryption is a lot of CPU.

1901
02:27:09,160 --> 02:27:12,160
So don't let people take your system down.

1902
02:27:12,160 --> 02:27:15,160
We also need to make sure that we have content,

1903
02:27:15,160 --> 02:27:19,160
and that it's JSON.

1904
02:27:19,160 --> 02:27:24,160
If we're returning text, we don't want to encrypt that.

1905
02:27:24,160 --> 02:27:28,160
We just want to request our response content type.

1906
02:27:30,160 --> 02:27:42,160
And response content type equals application JSON,

1907
02:27:42,160 --> 02:27:46,160
because that's what Flask does.

1908
02:27:46,160 --> 02:27:50,160
So Flask will return application JSON for JSON encoded data.

1909
02:27:50,160 --> 02:27:54,160
Nope, response status code should be greater than or equal to 200

1910
02:27:54,160 --> 02:27:57,160
and less than 300.

1911
02:27:57,160 --> 02:28:00,160
That's the first comparison.

1912
02:28:00,160 --> 02:28:06,160
Doesn't need to be, because it's not actually coming in from the internet.

1913
02:28:06,160 --> 02:28:11,160
So,

1914
02:28:11,160 --> 02:28:16,160
so, yeah, so this is saying that 200 is less than or equal to the response status code.

1915
02:28:16,160 --> 02:28:20,160
It's basically an inline ternary operation.

1916
02:28:20,160 --> 02:28:23,160
And the response in the status code is less than 300.

1917
02:28:23,160 --> 02:28:26,160
So code is greater than or equal to 200, less than 300.

1918
02:28:26,160 --> 02:28:28,160
That means it's a 200 status code.

1919
02:28:28,160 --> 02:28:33,160
And if there is JSON data, we want to encrypt it.

1920
02:28:33,160 --> 02:28:34,160
You know what?

1921
02:28:34,160 --> 02:28:38,160
Let me do that so it's easier to see.

1922
02:28:38,160 --> 02:28:39,160
Let's get all pep8, right?

1923
02:28:39,160 --> 02:28:42,160
80 characters.

1924
02:28:42,160 --> 02:28:45,160
Okay.

1925
02:28:45,160 --> 02:28:48,160
Yeah, so let's indent that one more.

1926
02:28:48,160 --> 02:28:49,160
All right.

1927
02:28:49,160 --> 02:28:55,160
So if this is a happy response and the happy response is JSON,

1928
02:28:55,160 --> 02:28:57,160
we want to encrypt it.

1929
02:28:57,160 --> 02:29:01,160
So we want to get the response data.

1930
02:29:01,160 --> 02:29:03,160
And we want to encrypt it.

1931
02:29:03,160 --> 02:29:08,160
So we want to get the response data.

1932
02:29:13,160 --> 02:29:15,160
Get data.

1933
02:29:15,160 --> 02:29:18,160
Get data.

1934
02:29:18,160 --> 02:29:23,160
And we also want to make sure that we get it as text.

1935
02:29:23,160 --> 02:29:27,160
We don't want it to be returned as a dictionary.

1936
02:29:27,160 --> 02:29:30,160
Because we want to encrypt the actual data.

1937
02:29:33,160 --> 02:29:36,160
Okay, so that gives us our response data.

1938
02:29:36,160 --> 02:29:39,160
We make a JW instance.

1939
02:29:43,160 --> 02:29:45,160
I understand this is really worth it to decrypt it.

1940
02:29:45,160 --> 02:29:46,160
You pass it nothing.

1941
02:29:46,160 --> 02:29:48,160
To encrypt it, you pass it a bunch of stuff.

1942
02:29:48,160 --> 02:29:55,160
Not happy with the way PyJWK EST does objects, but it works.

1943
02:29:55,160 --> 02:29:56,160
So it needs the data.

1944
02:29:56,160 --> 02:29:59,160
We're going to give it an algorithm.

1945
02:29:59,160 --> 02:30:03,160
So the algorithm is A256KW.

1946
02:30:05,160 --> 02:30:13,160
So what this is saying is that it's AES256 key wrap.

1947
02:30:13,160 --> 02:30:16,160
So it's going to be key wrap with RSA.

1948
02:30:16,160 --> 02:30:21,160
And it's going to, oh, sorry, A256KW.

1949
02:30:21,160 --> 02:30:26,160
And it's going to be key wrapping AES256.

1950
02:30:26,160 --> 02:30:31,160
So the next thing we have to give it is we have to give it encryption.

1951
02:30:31,160 --> 02:30:34,160
What is it going to use to encrypt?

1952
02:30:34,160 --> 02:30:40,160
And the encryption is going to be a, I'm sorry, backup.

1953
02:30:40,160 --> 02:30:41,160
This is not my code.

1954
02:30:41,160 --> 02:30:44,160
It is using AES256 key wrap.

1955
02:30:44,160 --> 02:30:47,160
So I'm still using the key wrap stuff.

1956
02:30:47,160 --> 02:30:50,160
But it's actually just AES encryption over AES encryption.

1957
02:30:50,160 --> 02:30:52,160
Just to make it easier.

1958
02:30:52,160 --> 02:30:55,160
But I wanted to highlight the key wrap stuff.

1959
02:30:55,160 --> 02:30:57,160
Sorry if I confuse anyone.

1960
02:30:57,160 --> 02:31:06,160
And so it's doing A256, the encryption is A256CBC HS512.

1961
02:31:06,160 --> 02:31:10,160
Now it could be A256GCM.

1962
02:31:10,160 --> 02:31:16,160
I think they even allow none for testing.

1963
02:31:16,160 --> 02:31:17,160
Oh, sorry.

1964
02:31:17,160 --> 02:31:21,160
And then the other thing that we need, or do we need anything else?

1965
02:31:21,160 --> 02:31:22,160
And the content type.

1966
02:31:22,160 --> 02:31:28,160
So one of the nice things about this, if you've ever used anything else for

1967
02:31:28,160 --> 02:31:31,160
encryption, decryption, you're wondering, great, I've got this encrypted data.

1968
02:31:31,160 --> 02:31:33,160
What type of data is inside?

1969
02:31:33,160 --> 02:31:37,160
So part of the actual specification is that you can provide the content type of

1970
02:31:37,160 --> 02:31:39,160
the encrypted data.

1971
02:31:39,160 --> 02:31:40,160
So it might be XML.

1972
02:31:40,160 --> 02:31:41,160
It might be JSON.

1973
02:31:41,160 --> 02:31:45,160
So if someone says, I want this data in JSON, or I want this data in XML, you

1974
02:31:45,160 --> 02:31:48,160
can return it either way and encrypt it and they'll know it's proper.

1975
02:31:48,160 --> 02:31:51,160
So it's actually kind of a neat thing.

1976
02:31:51,160 --> 02:31:55,160
And the content type is application JSON.

1977
02:31:55,160 --> 02:32:02,160
Because we know that we're encrypting JSON data.

1978
02:32:02,160 --> 02:32:08,160
What about Unicode where?

1979
02:32:08,160 --> 02:32:15,160
So in the application JSON strings, you don't have to worry about Unicode

1980
02:32:15,160 --> 02:32:18,160
because you're taking the string value that you've got and you're going to

1981
02:32:18,160 --> 02:32:20,160
encrypt it.

1982
02:32:20,160 --> 02:32:21,160
So it can be binary.

1983
02:32:21,160 --> 02:32:22,160
It can be anything.

1984
02:32:22,160 --> 02:32:23,160
It doesn't matter.

1985
02:32:23,160 --> 02:32:25,160
It's just going to be encrypted.

1986
02:32:25,160 --> 02:32:31,160
And when you decrypt it, yeah, it's not telling you what it's encrypted as.

1987
02:32:31,160 --> 02:32:36,160
But JSON going across, I believe, I don't know if you can actually put Unicode

1988
02:32:36,160 --> 02:32:38,160
data into JSON, but I'm not 100% sure.

1989
02:32:38,160 --> 02:32:41,160
Actually, I know you can because our API accepts it.

1990
02:32:41,160 --> 02:32:45,160
So that's something you would have to define on what it's going to be as far as

1991
02:32:45,160 --> 02:32:48,160
your character encoding because it doesn't, the specification doesn't have

1992
02:32:48,160 --> 02:32:49,160
character encoding.

1993
02:32:49,160 --> 02:32:53,160
Although if you wanted to, you could add it to the header yourself.

1994
02:32:53,160 --> 02:32:56,160
It's a fairly simple task if that's something that you really needed.

1995
02:32:56,160 --> 02:32:59,160
Our API just assumes it's UTF-8.

1996
02:32:59,160 --> 02:33:02,160
Everything is UTF-8.

1997
02:33:02,160 --> 02:33:05,160
Okay, so we have our encryption object.

1998
02:33:05,160 --> 02:33:06,160
Right?

1999
02:33:06,160 --> 02:33:09,160
And then we're going to actually encrypt the data.

2000
02:33:09,160 --> 02:33:12,160
Right, we're going to pass the keys.

2001
02:33:12,160 --> 02:33:17,160
And we're going to pass it the key ID.

2002
02:33:17,160 --> 02:33:21,160
So which tells it which one to do?

2003
02:33:21,160 --> 02:33:26,160
Since there are no specific IDs for keys because these are all the same,

2004
02:33:26,160 --> 02:33:29,160
we're going to pass it the key ID.

2005
02:33:29,160 --> 02:33:32,160
So we're going to pass it the key ID.

2006
02:33:32,160 --> 02:33:37,160
So this is specifically telling it, I want you to encrypt using these keys,

2007
02:33:37,160 --> 02:33:40,160
but here's the key ID for the keys.

2008
02:33:40,160 --> 02:33:43,160
It always wants all the keys and tell it which one.

2009
02:33:43,160 --> 02:33:46,160
If you don't tell it which one, it will select one.

2010
02:33:46,160 --> 02:33:47,160
I don't remember which one.

2011
02:33:47,160 --> 02:33:50,160
And because I don't remember which one, I'm always going to use the key ID.

2012
02:33:50,160 --> 02:33:53,160
So I'm going to pass it the key ID.

2013
02:33:53,160 --> 02:33:56,160
And then I'm going to pass it the key ID.

2014
02:33:56,160 --> 02:34:01,160
So this is specifically telling it, I want you to encrypt using these keys,

2015
02:34:01,160 --> 02:34:02,160
but I don't remember which one.

2016
02:34:02,160 --> 02:34:06,160
I'm always going to tell it which one it is

2017
02:34:06,160 --> 02:34:08,160
because that's just the right way to do it.

2018
02:34:08,160 --> 02:34:13,160
Okay, so the next thing you have to do, now you've encrypted our data.

2019
02:34:13,160 --> 02:34:20,160
The next piece is going to be to modify the response.

2020
02:34:20,160 --> 02:34:27,160
So response content type is now application Jose.

2021
02:34:27,160 --> 02:34:33,160
And response data equals encrypted.

2022
02:34:33,160 --> 02:34:39,160
A lot easier because it just allows you to do that stuff.

2023
02:34:39,160 --> 02:34:43,160
And in theory, don't do that.

2024
02:34:43,160 --> 02:34:44,160
This should work.

2025
02:34:44,160 --> 02:34:47,160
So I need to add it to the server.

2026
02:34:47,160 --> 02:34:48,160
I'll do that real quick.

2027
02:34:48,160 --> 02:34:51,160
So you started off with a started handler.

2028
02:34:51,160 --> 02:34:55,160
So if the application data is encrypted, I'm going to decrypt it

2029
02:34:55,160 --> 02:34:58,160
and then replace it, replace the data inside the request

2030
02:34:58,160 --> 02:35:01,160
so that when my handlers get it, it's decrypted.

2031
02:35:01,160 --> 02:35:05,160
One of the super important things that I learned from the API that I work on

2032
02:35:05,160 --> 02:35:08,160
when I inherited it is it did all the encryption and decryption

2033
02:35:08,160 --> 02:35:11,160
inside the handlers with base handlers and things like that.

2034
02:35:11,160 --> 02:35:15,160
And that can be problematic because how do you encrypt errors?

2035
02:35:15,160 --> 02:35:19,160
There's a bunch of things that you have to take into account.

2036
02:35:19,160 --> 02:35:20,160
So you're way better off.

2037
02:35:20,160 --> 02:35:22,160
The other piece was in order to work on the handlers,

2038
02:35:22,160 --> 02:35:24,160
you had to understand encryption.

2039
02:35:24,160 --> 02:35:27,160
So you can't just have your average developer modifying your handlers

2040
02:35:27,160 --> 02:35:29,160
because they're doing encryption.

2041
02:35:29,160 --> 02:35:31,160
They're doing signature verification.

2042
02:35:31,160 --> 02:35:32,160
That's a difficult thing.

2043
02:35:32,160 --> 02:35:35,160
So you've now made it very difficult to use your handlers

2044
02:35:35,160 --> 02:35:36,160
or to work on your handlers.

2045
02:35:36,160 --> 02:35:41,160
So pulling it out into middleware, currently we're using Pyramid

2046
02:35:41,160 --> 02:35:43,160
where all that stuff happens in Pyramid middleware,

2047
02:35:43,160 --> 02:35:46,160
our controllers just go, oh, I've got data.

2048
02:35:46,160 --> 02:35:48,160
I don't know if it was encrypted before.

2049
02:35:48,160 --> 02:35:49,160
I don't know if it wasn't encrypted before.

2050
02:35:49,160 --> 02:35:51,160
I returned JSON data.

2051
02:35:51,160 --> 02:35:52,160
I don't know if it's going to be encrypted or not.

2052
02:35:52,160 --> 02:35:53,160
I don't care.

2053
02:35:53,160 --> 02:35:57,160
So you have very simple handlers that any developer who builds a web app

2054
02:35:57,160 --> 02:35:59,160
who's used to building web APIs can work with,

2055
02:35:59,160 --> 02:36:04,160
and the difficult stuff is in your middleware that people don't even like to look at.

2056
02:36:04,160 --> 02:36:08,160
But in reality, that's not a lot of code.

2057
02:36:08,160 --> 02:36:15,160
That's 15 lines to inline decrypt incoming data and encrypt outgoing data.

2058
02:36:15,160 --> 02:36:20,160
If you've ever had to do this manually, this is a monstrosity of a process.

2059
02:36:20,160 --> 02:36:23,160
If you didn't have a library that you could just have do it for you,

2060
02:36:23,160 --> 02:36:26,160
especially since the fact that it's kind of come out in an interesting format.

2061
02:36:26,160 --> 02:36:35,160
So if you take a look at what the response looks like.

2062
02:36:35,160 --> 02:36:40,160
So currently you're just getting application JSON back,

2063
02:36:40,160 --> 02:36:44,160
and you're getting back Hello World.

2064
02:36:44,160 --> 02:36:51,160
And what you're sending is you're sending content type application JSON,

2065
02:36:51,160 --> 02:36:53,160
and it's decrypted.

2066
02:36:53,160 --> 02:36:59,160
All right, so if I go add this to the server, I'd want to do that.

2067
02:36:59,160 --> 02:37:03,160
So now we go into our server, and we add our signal to our server.

2068
02:37:03,160 --> 02:37:05,160
Actually, I'm not going to type anymore.

2069
02:37:05,160 --> 02:37:07,160
I should learn from my mistakes.

2070
02:37:07,160 --> 02:37:13,160
There we go.

2071
02:37:13,160 --> 02:37:21,160
So we need an encryption.

2072
02:37:21,160 --> 02:37:24,160
I'm in the wrong place.

2073
02:37:24,160 --> 02:37:30,160
It needs to be before that.

2074
02:37:30,160 --> 02:37:33,160
Encryption signal handler.

2075
02:37:33,160 --> 02:37:35,160
It was encryption signal handler.

2076
02:37:35,160 --> 02:37:37,160
Much easier.

2077
02:37:37,160 --> 02:37:39,160
So the encryption signal handle needed some things.

2078
02:37:39,160 --> 02:37:45,160
So it needs a key.

2079
02:37:45,160 --> 02:37:49,160
And that key is a symmetric key, so it's something that's actually in here,

2080
02:37:49,160 --> 02:37:51,160
so we're going to build it here.

2081
02:37:51,160 --> 02:37:54,160
It actually needs a list of them, but we only have one anyway.

2082
02:37:54,160 --> 02:38:01,160
So we're going to tell it we're using SIM key, which is symmetric key.

2083
02:38:01,160 --> 02:38:10,160
And its use is going to be encryption as opposed to a signature key.

2084
02:38:10,160 --> 02:38:16,160
We're going to provide it a key ID for the first key.

2085
02:38:16,160 --> 02:38:19,160
Okay, ID.

2086
02:38:19,160 --> 02:38:29,160
We'll call it key one, and then we'll provide the key.

2087
02:38:29,160 --> 02:38:37,160
So this is just an RSA key.

2088
02:38:37,160 --> 02:38:41,160
And since we're trying really hard...

2089
02:38:41,160 --> 02:38:42,160
Oh, it's going to make it.

2090
02:38:42,160 --> 02:38:46,160
Yay, made it.

2091
02:38:46,160 --> 02:38:56,160
You can copy it.

2092
02:38:56,160 --> 02:39:00,160
So the key is...

2093
02:39:00,160 --> 02:39:01,160
It's this long.

2094
02:39:01,160 --> 02:39:05,160
The key is actually in the client as well.

2095
02:39:05,160 --> 02:39:07,160
I think it has a default key here.

2096
02:39:07,160 --> 02:39:09,160
There's your default key.

2097
02:39:09,160 --> 02:39:12,160
So if you want to copy it from the client, you can do that.

2098
02:39:12,160 --> 02:39:14,160
Or you can type it.

2099
02:39:14,160 --> 02:39:21,160
Or you can get it from GitHub repo on GitHub.

2100
02:39:21,160 --> 02:39:23,160
But they're not supposed to be easy to remember.

2101
02:39:23,160 --> 02:39:25,160
They're supposed to be random, right?

2102
02:39:25,160 --> 02:39:28,160
So when you make keys, please make sure they're random

2103
02:39:28,160 --> 02:39:32,160
so no one can figure out what they are.

2104
02:39:32,160 --> 02:39:35,160
All right, and the server's angry about something.

2105
02:39:35,160 --> 02:39:39,160
What's it angry about?

2106
02:39:39,160 --> 02:39:41,160
Oh, that's why.

2107
02:39:41,160 --> 02:39:45,160
Oh, that should be fine.

2108
02:39:45,160 --> 02:39:47,160
What is it angry about?

2109
02:39:47,160 --> 02:39:49,160
Oh, okay.

2110
02:39:49,160 --> 02:39:51,160
Get rid of that.

2111
02:39:51,160 --> 02:39:54,160
Okay.

2112
02:39:54,160 --> 02:39:57,160
So we're just passing it in an array of keys.

2113
02:39:57,160 --> 02:39:59,160
Probably not the cleanest way to specify an array of keys,

2114
02:39:59,160 --> 02:40:03,160
but let me get rid of that so you can see it.

2115
02:40:03,160 --> 02:40:05,160
All right, so we've got our encryption signal handler.

2116
02:40:05,160 --> 02:40:10,160
It's got our list of keys, which are symmetric keys,

2117
02:40:10,160 --> 02:40:11,160
getting passed to it.

2118
02:40:11,160 --> 02:40:12,160
So we only have one.

2119
02:40:12,160 --> 02:40:14,160
You can put in as many as you like, right?

2120
02:40:14,160 --> 02:40:15,160
It doesn't matter.

2121
02:40:15,160 --> 02:40:17,160
It's going to get the key information

2122
02:40:17,160 --> 02:40:20,160
and decrypt it based on the key that it wants,

2123
02:40:20,160 --> 02:40:21,160
and the server's going to check each one,

2124
02:40:21,160 --> 02:40:24,160
depending on which way it does it.

2125
02:40:24,160 --> 02:40:26,160
The idea is that you distribute these keys

2126
02:40:26,160 --> 02:40:31,160
into your client and use this kind of a list here.

2127
02:40:31,160 --> 02:40:34,160
So the idea for this is that you don't use symmetric key encryption

2128
02:40:34,160 --> 02:40:37,160
because it's a terrible way to move things around

2129
02:40:37,160 --> 02:40:39,160
unless these are internal APIs,

2130
02:40:39,160 --> 02:40:41,160
but this is the simplest thing for me to show you

2131
02:40:41,160 --> 02:40:44,160
because if I had to have a RSA public key

2132
02:40:44,160 --> 02:40:46,160
and have to explain how that stuff works,

2133
02:40:46,160 --> 02:40:47,160
that would be more complicated.

2134
02:40:47,160 --> 02:40:50,160
The reason that I did this is because it's easy to do.

2135
02:40:50,160 --> 02:40:53,160
Symmetric key encryption is the easiest one for people to grasp,

2136
02:40:53,160 --> 02:40:56,160
so I didn't want to have complex cryptography.

2137
02:40:56,160 --> 02:40:59,160
So my suggestion would be don't do this.

2138
02:40:59,160 --> 02:41:07,160
Use an RSA key wrap and use AES encryption in the back end,

2139
02:41:07,160 --> 02:41:08,160
but this was easy to show.

2140
02:41:08,160 --> 02:41:11,160
Okay, and then we're going to add it in,

2141
02:41:11,160 --> 02:41:17,160
which is our encryption signal handler.

2142
02:41:17,160 --> 02:41:23,160
And so now when I send data unencrypted,

2143
02:41:23,160 --> 02:41:25,160
actually what's it going to do now?

2144
02:41:25,160 --> 02:41:26,160
Yeah, because I'm sending it unencrypted.

2145
02:41:26,160 --> 02:41:29,160
Oh, angry.

2146
02:41:29,160 --> 02:41:30,160
I didn't restart.

2147
02:41:30,160 --> 02:41:31,160
I didn't have to.

2148
02:41:31,160 --> 02:41:32,160
I didn't?

2149
02:41:32,160 --> 02:41:34,160
I am a terrible person.

2150
02:41:34,160 --> 02:41:35,160
I thought I did.

2151
02:41:35,160 --> 02:41:37,160
Yeah, it's up there.

2152
02:41:37,160 --> 02:41:39,160
All right, well, you know what?

2153
02:41:39,160 --> 02:41:40,160
Let me restart.

2154
02:41:40,160 --> 02:41:56,160
Okay, so now I'm going to have to do a little bit of a

2155
02:41:56,160 --> 02:42:01,880
RSA lift.

2156
02:42:01,880 --> 02:42:04,880
This seems to happen like it just randomly restarts while I'm

2157
02:42:04,880 --> 02:42:06,880
typing things and then fails.

2158
02:42:06,880 --> 02:42:09,880
So, nope.

2159
02:42:09,880 --> 02:42:11,640
You did?

2160
02:42:11,640 --> 02:42:13,540
Okay, I did something wrong.

2161
02:42:13,540 --> 02:42:24,160
Ooh, it's so angry, so angry.

2162
02:42:24,160 --> 02:42:29,160
My signals?

2163
02:42:29,160 --> 02:42:34,160
Oh, I swatched it around.

2164
02:42:34,160 --> 02:42:39,160
All right.

2165
02:42:39,160 --> 02:42:44,160
Let me go back to my cheat sheet.

2166
02:42:44,160 --> 02:42:49,160
Encryption. You're right.

2167
02:42:49,160 --> 02:42:54,160
My bad.

2168
02:42:54,160 --> 02:42:59,160
So you should have gotten the key ID.

2169
02:42:59,160 --> 02:43:04,160
Was it .kid?

2170
02:43:04,160 --> 02:43:09,160
So I tried to actually convert that to a string.

2171
02:43:09,160 --> 02:43:14,160
So you want to tell it to encrypt the keys and give it the key ID so it gets the correct key.

2172
02:43:14,160 --> 02:43:19,160
I think it's the signature where it does it either way.

2173
02:43:19,160 --> 02:43:24,160
Here's the keys. Use this key ID.

2174
02:43:24,160 --> 02:43:29,160
And then restart this because it's going to be angry.

2175
02:43:29,160 --> 02:43:34,160
Clamp I.

2176
02:43:34,160 --> 02:43:39,160
And dash V.

2177
02:43:39,160 --> 02:43:44,160
Oh, man.

2178
02:43:44,160 --> 02:43:49,160
I did it right at the beginning of the 10 seconds, didn't I?

2179
02:43:49,160 --> 02:43:54,160
Okay. So what that did is I didn't send a request.

2180
02:43:54,160 --> 02:43:59,160
It's a get. And so it sent this data.

2181
02:43:59,160 --> 02:44:04,160
So this is Jose

2182
02:44:04,160 --> 02:44:09,160
Compact Serialization.

2183
02:44:09,160 --> 02:44:14,160
Its official name is base 62 URL encoded.

2184
02:44:14,160 --> 02:44:19,160
It's just like base 64 except it doesn't have, it swaps out to the things.

2185
02:44:19,160 --> 02:44:24,160
You don't have plus because plus is part of a URL.

2186
02:44:24,160 --> 02:44:29,160
Right? Because plus means space in an actual URL.

2187
02:44:29,160 --> 02:44:34,160
It doesn't have a dot because a dot could be something that goes bad.

2188
02:44:34,160 --> 02:44:39,160
Or no, sorry. That's the other one.

2189
02:44:39,160 --> 02:44:44,160
Slash. Sorry. Because slash means another part of the path.

2190
02:44:44,160 --> 02:44:49,160
So it doesn't have dot. Or it doesn't have plus. It doesn't have slash.

2191
02:44:49,160 --> 02:44:54,160
So that's base 62. Base 64 has plus and slash. So it's super confusing.

2192
02:44:54,160 --> 02:44:59,160
It's like padding.

2193
02:44:59,160 --> 02:45:04,160
So if you want to take a look at the data, if you're having problems,

2194
02:45:04,160 --> 02:45:09,160
it may be a problem because it doesn't tell you if it needs padding or not.

2195
02:45:09,160 --> 02:45:14,160
So that one needs padding.

2196
02:45:14,160 --> 02:45:19,160
Nope. Still needs padding. Base 64 encoding is really weird.

2197
02:45:19,160 --> 02:45:24,160
So here's a lot of information that you have.

2198
02:45:24,160 --> 02:45:29,160
So it's sending across in the data. My algorithm is AES 256 key wrap.

2199
02:45:29,160 --> 02:45:34,160
My content type is application JSON. My encryption is AES 256 CBC with HS 512 MAC.

2200
02:45:34,160 --> 02:45:39,160
I'll get into the MAC in just a second. And here's the key ID of the key that was used to encrypt the data.

2201
02:45:39,160 --> 02:45:44,160
So all that gets sent across in the header.

2202
02:45:44,160 --> 02:45:49,160
So the key in the second set

2203
02:45:49,160 --> 02:45:54,160
is going to be, I believe that's your key and your IV.

2204
02:45:54,160 --> 02:45:59,160
Nope.

2205
02:45:59,160 --> 02:46:04,160
Can't do that.

2206
02:46:04,160 --> 02:46:09,160
Which are binary.

2207
02:46:09,160 --> 02:46:14,160
Oh yeah, key and your IV are binary.

2208
02:46:14,160 --> 02:46:19,160
So basically what it ends up doing in the rest of the data is you have your key ID, which is encrypted

2209
02:46:19,160 --> 02:46:24,160
using the key wrap.

2210
02:46:24,160 --> 02:46:29,160
You have, I'm sorry, it's the key then the IV. And then you have your encrypted data,

2211
02:46:29,160 --> 02:46:34,160
which is going to be there.

2212
02:46:34,160 --> 02:46:39,160
So here you're actually going to have an auth tag.

2213
02:46:39,160 --> 02:46:44,160
So more modern encryption includes auth tags. But this is an auth tag ensuring the header didn't get modified.

2214
02:46:44,160 --> 02:46:49,160
So this is making sure that you know that based on the key that was supplied

2215
02:46:49,160 --> 02:46:54,160
and the IV is actually separated into two pieces. The first half is used for the encryption.

2216
02:46:54,160 --> 02:46:59,160
The second half is used for the auth tag.

2217
02:46:59,160 --> 02:47:04,160
So this is the signature here and that's what the 256,

2218
02:47:04,160 --> 02:47:09,160
where is it going? Oh, it was in here. Sorry.

2219
02:47:09,160 --> 02:47:14,160
So when we had, there it is,

2220
02:47:14,160 --> 02:47:19,160
ASA256, DBC, HS512. So this is telling you that the auth tag is in the HMAC with the SHOF512.

2221
02:47:19,160 --> 02:47:24,160
So the fifth part is the auth tag. So this data is very secure. It hasn't been modified

2222
02:47:24,160 --> 02:47:29,160
and the cryptographic could have been completely replaced.

2223
02:47:29,160 --> 02:47:34,160
Now if I...

2224
02:47:34,160 --> 02:47:39,160
check out...

2225
02:47:39,160 --> 02:47:44,160
right? Ah, of course typing.

2226
02:47:44,160 --> 02:47:49,160
So now if we do the client,

2227
02:47:49,160 --> 02:47:54,160
we'll also send the data

2228
02:47:54,160 --> 02:47:59,160
encrypted.

2229
02:47:59,160 --> 02:48:04,160
So here it basically, here's the unencrypted body and then here's the actual data that it sent.

2230
02:48:04,160 --> 02:48:09,160
So it said the content type was application Jose, which the server knows to decrypt. Here's all the encrypted data.

2231
02:48:09,160 --> 02:48:14,160
The response came back with encrypted data and here's the decrypted response.

2232
02:48:14,160 --> 02:48:19,160
So like 15 lines of code,

2233
02:48:19,160 --> 02:48:24,160
transparent encryption on your API. That's why I love

2234
02:48:24,160 --> 02:48:29,160
Jose. This stuff we did in our controllers, part of our requests,

2235
02:48:29,160 --> 02:48:34,160
like most APIs do, it was painful, it was terrible, difficult to debug,

2236
02:48:34,160 --> 02:48:39,160
difficult to troubleshoot. Customers always had problems because in our SDK,

2237
02:48:39,160 --> 02:48:44,160
at least 50% of our SDK code was around encryption and signatures.

2238
02:48:44,160 --> 02:48:49,160
Now it's like 10 lines. It's amazing.

2239
02:48:49,160 --> 02:48:54,160
And I hope I'm not gushing too much. But that's just, like this totally changed

2240
02:48:54,160 --> 02:48:59,160
my life. Because again,

2241
02:48:59,160 --> 02:49:04,160
this is very complicated stuff, right? We're doing encryption with key wrap and setting over your keys

2242
02:49:04,160 --> 02:49:09,160
and adding content type and all this type of stuff and adding an auth tag, which is the right thing to do in all

2243
02:49:09,160 --> 02:49:14,160
occasions. And it was that much code.

2244
02:49:14,160 --> 02:49:19,160
You have to make a couple decisions, right? What type of encryption

2245
02:49:19,160 --> 02:49:24,160
algorithm do you want to use? What type of encryption algorithms do you want to allow?

2246
02:49:24,160 --> 02:49:29,160
One of the things that we do is we actually take the encryption algorithm they send, verify that it's

2247
02:49:29,160 --> 02:49:34,160
out, and then we'll respond back with the encryption algorithm that they used.

2248
02:49:34,160 --> 02:49:39,160
So we allow RSA,

2249
02:49:39,160 --> 02:49:44,160
V1.5 and OAAP. We shouldn't allow 1.5,

2250
02:49:44,160 --> 02:49:49,160
but some of our clients have to have it because they don't have OAAP. We'll only respond

2251
02:49:49,160 --> 02:49:54,160
with 1.5 if they give us 1.5 because that's not secure. But hey,

2252
02:49:54,160 --> 02:49:59,160
if you want to be insecure, that's your problem.

2253
02:49:59,160 --> 02:50:04,160
But if you're smart or use the defaults, which we help make you smart, you're using OAAP

2254
02:50:04,160 --> 02:50:09,160
as the padding which doesn't have a padding oracle, at least a known one, and we'll respond back

2255
02:50:09,160 --> 02:50:14,160
with just as much security as you gave us. So it's given us a lot of ability

2256
02:50:14,160 --> 02:50:19,160
to provide the highest

2257
02:50:19,160 --> 02:50:24,160
level of security with the most level of compatibility. So if you want compatibility, you get

2258
02:50:24,160 --> 02:50:29,160
compatibility. If you want security, you get security. And that's a game changer for me.

2259
02:50:29,160 --> 02:50:34,160
When you start dealing with banks and security companies

2260
02:50:34,160 --> 02:50:39,160
and military, they all have a different idea on what's secure.

2261
02:50:39,160 --> 02:50:44,160
And now they all kind of can get whatever they want.

2262
02:50:44,160 --> 02:50:49,160
So that's about the encryption stuff. Yeah?

2263
02:50:49,160 --> 02:50:54,160
That one was just a mistake.

2264
02:50:54,160 --> 02:50:59,160
I think I did it when I made it. It doesn't matter.

2265
02:50:59,160 --> 02:51:04,160
Yeah, the signal handler just has a request started, request finished, and it raises an error

2266
02:51:04,160 --> 02:51:09,160
that hasn't been implemented. Because if you didn't have the request finished handler,

2267
02:51:09,160 --> 02:51:14,160
it would actually error when it tried to execute it.

2268
02:51:14,160 --> 02:51:19,160
I'd fix that in the code when I do that. But yeah, when I actually built it here I did.

2269
02:51:19,160 --> 02:51:24,160
But I didn't put two lines between these, which is a pep8 no-no.

2270
02:51:24,160 --> 02:51:29,160
Okay. The next part,

2271
02:51:29,160 --> 02:51:34,160
I want to talk about more than type because it is a ton of typing.

2272
02:51:34,160 --> 02:51:39,160
So the last thing that we talked about in authorization

2273
02:51:39,160 --> 02:51:44,160
is using a single use JSON Web Token.

2274
02:51:44,160 --> 02:51:49,160
The PyJWK EST library does not make JSON Web Tokens easy.

2275
02:51:49,160 --> 02:51:54,160
There's a lot of code. There doesn't have to be this much code,

2276
02:51:54,160 --> 02:51:59,160
but there's a lot of code. There are other JWT libraries. If you're not doing encryption,

2277
02:51:59,160 --> 02:52:04,160
I would say there are two other libraries. Find which one you like best.

2278
02:52:04,160 --> 02:52:09,160
Because the PyJWK EST library is not an easy library to use. It's a good library.

2279
02:52:09,160 --> 02:52:14,160
If you understand how all this works. If you know what you need to validate

2280
02:52:14,160 --> 02:52:19,160
inside of a JSON Web Token and you manually go through the process of doing that, it's perfectly fine.

2281
02:52:19,160 --> 02:52:24,160
If you're just using JSON Web Tokens, try one of the others and see how you like it.

2282
02:52:24,160 --> 02:52:29,160
I think that's all the libraries I've used that are perfectly fine. We just don't want to have

2283
02:52:29,160 --> 02:52:34,160
two libraries in our code.

2284
02:52:34,160 --> 02:52:39,160
Okay. So what I'm going to do now is I'm going to

2285
02:52:39,160 --> 02:52:44,160
hard reset.

2286
02:52:44,160 --> 02:52:49,160
I'm going to get all of the stuff I spent all this time typing.

2287
02:52:49,160 --> 02:52:54,160
And we're going to go to

2288
02:52:54,160 --> 02:52:59,160
the end. And we're going to talk.

2289
02:52:59,160 --> 02:53:04,160
Okay.

2290
02:53:04,160 --> 02:53:09,160
And then

2291
02:53:09,160 --> 02:53:14,160
in the wrong place, the right place there. I am in the wrong place there.

2292
02:53:14,160 --> 02:53:19,160
In the wrong place here.

2293
02:53:19,160 --> 02:53:24,160
So we will

2294
02:53:24,160 --> 02:53:29,160
be in the right place and we will pifm show.

2295
02:53:29,160 --> 02:53:34,160
By the way, congratulations to all of you for making it this far so fast.

2296
02:53:34,160 --> 02:53:39,160
Last time, this was like two minutes before the end of the

2297
02:53:39,160 --> 02:53:44,160
presentation because we had a lot of setup problems. Maybe we should all say thank you to the death of

2298
02:53:44,160 --> 02:53:49,160
Python 2.7. Regardless of what your opinions are on that, having only one

2299
02:53:49,160 --> 02:53:54,160
major version is really nice. And for those of you who don't know, it's dead

2300
02:53:54,160 --> 02:53:59,160
in December 31st. And I have a gigantic project to convert all of our 2.7 code to three that's going to

2301
02:53:59,160 --> 02:54:04,160
take three months because it finally got fast enough.

2302
02:54:04,160 --> 02:54:09,160
Okay. So we're in the right place.

2303
02:54:09,160 --> 02:54:14,160
So let's go look at code.

2304
02:54:14,160 --> 02:54:19,160
So this is a little more code.

2305
02:54:19,160 --> 02:54:24,160
But this is doing a lot of stuff.

2306
02:54:24,160 --> 02:54:29,160
So at the very end we talked about authorization using

2307
02:54:29,160 --> 02:54:34,160
single use JSON web token. We talked about verifying and validating your request and your

2308
02:54:34,160 --> 02:54:39,160
response. So what the token

2309
02:54:39,160 --> 02:54:44,160
signal handler is going to do is it's going to

2310
02:54:44,160 --> 02:54:49,160
ensure that the request coming in has not been modified

2311
02:54:49,160 --> 02:54:54,160
and has been used by a valid user and it's going to respond

2312
02:54:54,160 --> 02:54:59,160
and create that same verification that the client can then use.

2313
02:54:59,160 --> 02:55:04,160
So in JSON web tokens there's this concept of

2314
02:55:04,160 --> 02:55:09,160
leeway because it has time. And if you're dealing with servers that have

2315
02:55:09,160 --> 02:55:14,160
time shift, which every server does, you want to make sure that you don't

2316
02:55:14,160 --> 02:55:19,160
error out because you didn't allow for any time shift. When you said this is only good

2317
02:55:19,160 --> 02:55:24,160
from this time to this time, and what I will tell you is that a JSON web token for a single use

2318
02:55:24,160 --> 02:55:29,160
should expire immediately because it's only good for one use.

2319
02:55:29,160 --> 02:55:34,160
So you should expire it immediately but allow for a few seconds because if it takes half a millisecond

2320
02:55:34,160 --> 02:55:39,160
and it takes a half a second for the response to go back and you're now in a new

2321
02:55:39,160 --> 02:55:44,160
second, your token's invalid because it's no longer, it's expired.

2322
02:55:44,160 --> 02:55:49,160
So the concept of leeway comes in big with these tokens because you're dealing with time.

2323
02:55:49,160 --> 02:55:54,160
So you need to provide a leeway in seconds. You need to provide keys just like we did before.

2324
02:55:54,160 --> 02:55:59,160
We're using the same thing. We're using AES

2325
02:55:59,160 --> 02:56:04,160
and we're providing cache. I don't remember why

2326
02:56:04,160 --> 02:56:09,160
we're providing cache. We'll figure that out in a minute.

2327
02:56:09,160 --> 02:56:14,160
So the request JWT claims. So there's specific claims that are always going to be the same

2328
02:56:14,160 --> 02:56:19,160
that you should be able to give. So the issuer who's issuing the claim

2329
02:56:19,160 --> 02:56:24,160
is public. So that's coming from a user and the audience is the example app.

2330
02:56:24,160 --> 02:56:29,160
So the issuer, the person who's creating it is coming and the audience is the example app.

2331
02:56:29,160 --> 02:56:34,160
So when we verify the incoming token, it should be coming from the public

2332
02:56:34,160 --> 02:56:39,160
and the issuer should be the issuer. So that's the issue.

2333
02:56:39,160 --> 02:56:44,160
So the issuer can specify for me, which is example app.

2334
02:56:44,160 --> 02:56:49,160
Whatever identifiers you want to use, that's fine. We actually use,

2335
02:56:49,160 --> 02:56:54,160
this is a very simplified example. We actually have our user identifiers

2336
02:56:54,160 --> 02:56:59,160
that say I am this user and that's the issuer. And when the response comes back, the issuer comes back

2337
02:56:59,160 --> 02:57:04,160
authentication for another user. So we have hierarchical things.

2338
02:57:04,160 --> 02:57:09,160
So if you're an organization that has multiple users, you can use organization credentials and say,

2339
02:57:09,160 --> 02:57:14,160
hi, I'm this organization using my credentials for this user. That's kind of advanced

2340
02:57:14,160 --> 02:57:19,160
if you want to talk to me, talk about it later. And then the allowable hash algorithms.

2341
02:57:19,160 --> 02:57:24,160
So we're going to be hashing the body to ensure it hasn't changed and putting it inside the JSON web token

2342
02:57:24,160 --> 02:57:29,160
that we signed. It's not a necessary thing to do, but when we came up with this scheme,

2343
02:57:29,160 --> 02:57:34,160
we said great, we're going to use single use JSON web token and we're going to sign the request.

2344
02:57:34,160 --> 02:57:39,160
What we found was why are we signing two things? Because we're using JSON web signature for a header

2345
02:57:39,160 --> 02:57:44,160
that had signature of the data and then we had the credentials, but we couldn't make sure the credentials

2346
02:57:44,160 --> 02:57:49,160
were actually part of the request either. So we decided that we're going to put the body hash and all of the request

2347
02:57:49,160 --> 02:57:53,160
based on web tokens. So number one, we're only signing and hashing one thing. And number two,

2348
02:57:53,160 --> 02:57:58,160
we can be absolutely sure that every piece that matters to us matches.

2349
02:57:58,160 --> 02:58:03,160
So in the request started handler, the first thing we do is we get the authorization

2350
02:58:03,160 --> 02:58:08,160
header just like we did before and we default it to empty.

2351
02:58:08,160 --> 02:58:13,160
And then we get a regular expression and we try and find the header.

2352
02:58:13,160 --> 02:58:18,160
So for this example, our authorization scheme is EX JWT,

2353
02:58:18,160 --> 02:58:23,160
right? Example JWT. And the piece

2354
02:58:23,160 --> 02:58:28,160
after the scheme should be our token. That's going to be our JWT

2355
02:58:28,160 --> 02:58:33,160
token. We find it. If we don't find it,

2356
02:58:33,160 --> 02:58:38,160
the token is none. Otherwise, we get

2357
02:58:38,160 --> 02:58:43,160
the actual token value. So we make sure that the group dict,

2358
02:58:43,160 --> 02:58:48,160
that we have a group dictionary. This is defaulting it to make sure we don't blow up.

2359
02:58:48,160 --> 02:58:53,160
And then we get the token or the key token. And so that's going to be our actual token value.

2360
02:58:53,160 --> 02:58:58,160
Because the reason that you're using that is because we identified this token in there. You could actually just use place or whatever.

2361
02:58:58,160 --> 02:59:03,160
It doesn't matter. If there's no token, then we raise a 401

2362
02:59:03,160 --> 02:59:08,160
saying that we were expecting a token. What are you doing?

2363
02:59:08,160 --> 02:59:13,160
If we do get a token, we continue on and we verify

2364
02:59:13,160 --> 02:59:18,160
our token. So we have our keys that we got and

2365
02:59:18,160 --> 02:59:23,160
we use JSON Web Signature to verify the compact JSON.

2366
02:59:23,160 --> 02:59:28,160
So one thing about Jose is

2367
02:59:28,160 --> 02:59:33,160
it's a bunch of things built on a bunch of other things. So a JSON Web Token is actually a

2368
02:59:33,160 --> 02:59:38,160
JSON Web Signature where the body has a particular schema. That is all that it is.

2369
02:59:38,160 --> 02:59:43,160
So if you've seen JWS somewhere and people talk about JWTs,

2370
02:59:43,160 --> 02:59:48,160
it's kind of like square rectangle. A JWT is a JWS, but a JWS is not necessarily

2371
02:59:48,160 --> 02:59:53,160
a JWT. So we verify if we get an exception,

2372
02:59:53,160 --> 02:59:58,160
then we do a 401 because you provided us invalid

2373
02:59:58,160 --> 03:00:03,160
credentials. If the token itself

2374
03:00:03,160 --> 03:00:08,160
is valid, which means that it's valid through the signature, I get the current

2375
03:00:08,160 --> 03:00:13,160
time and now I have to start

2376
03:00:13,160 --> 03:00:18,160
going and verifying that things are correct. So

2377
03:00:18,160 --> 03:00:23,160
we make sure that the client is correct, we make sure that the issuer, the audience

2378
03:00:23,160 --> 03:00:28,160
is correct. I'm using JTI, so a JSON

2379
03:00:28,160 --> 03:00:33,160
Web Token Identifier. That's supposed to be unique

2380
03:00:33,160 --> 03:00:38,160
and since we're using it one time, I provide that to create our nonce. So when we're doing our replay attack,

2381
03:00:38,160 --> 03:00:43,160
this is our single thing that's going to be always different. You can make the same request for the same endpoint

2382
03:00:43,160 --> 03:00:48,160
and the same parameters, all the same data. In theory, the signature should change

2383
03:00:48,160 --> 03:00:53,160
from time to time because of the nonce, but the JTI is going to absolutely make sure it's going to be different every time.

2384
03:00:53,160 --> 03:00:58,160
So that prevents replay. And then we're going to add

2385
03:00:58,160 --> 03:01:03,160
the token ID to make sure that it's not there. So we're going to make sure that we haven't

2386
03:01:03,160 --> 03:01:08,160
seen this JTI as we're processing the request to make sure we've never seen it before. That's why we're using cache.

2387
03:01:08,160 --> 03:01:13,160
To make sure it's absolutely unique. And then we check to see that it's

2388
03:01:13,160 --> 03:01:18,160
valid in the time space. So there's three times that you worry about. There's not before,

2389
03:01:18,160 --> 03:01:23,160
issued at, and expires. So

2390
03:01:23,160 --> 03:01:28,160
in here we're making sure that it's not before the not before. That's a claim.

2391
03:01:28,160 --> 03:01:33,160
It's not valid before this time. Let's see if it's before that time.

2392
03:01:33,160 --> 03:01:38,160
So we're making sure that it included expires and that the expires hasn't expired.

2393
03:01:38,160 --> 03:01:43,160
This one's not caring about when it was issued at because issued at doesn't necessarily matter.

2394
03:01:43,160 --> 03:01:48,160
So now we have pieces that are the extension.

2395
03:01:48,160 --> 03:01:53,160
So we were extending JSON Web Token for our own purposes.

2396
03:01:53,160 --> 03:01:58,160
And that is to add request data to the JSON Web Token to be signed.

2397
03:01:58,160 --> 03:02:03,160
So we make sure the request is there, which is a dictionary because it's JSON.

2398
03:02:03,160 --> 03:02:08,160
And so we make sure the path is in the request data.

2399
03:02:08,160 --> 03:02:13,160
Because every request has a path.

2400
03:02:13,160 --> 03:02:18,160
We then verify that the path value

2401
03:02:18,160 --> 03:02:23,160
inside of our JSON Web Token matches the actual path value. Because we talked about that. Let's make sure they haven't changed the method,

2402
03:02:23,160 --> 03:02:27,160
haven't changed the path, haven't changed the body.

2403
03:02:27,160 --> 03:02:32,160
Next piece is we go check and make sure that the method is inside the claims and that the claim method

2404
03:02:32,160 --> 03:02:37,160
for the request matches the actual request method.

2405
03:02:37,160 --> 03:02:42,160
If the request content length is not none and greater than zero, which means we have a body,

2406
03:02:45,160 --> 03:02:50,160
then we make sure that the body hash algorithm is in the request

2407
03:02:50,160 --> 03:02:55,160
claims. Because if there's a body, then we need a body hash to make sure the body hasn't been changed.

2408
03:02:55,160 --> 03:03:00,160
We also need a body hash algorithm to know.

2409
03:03:00,160 --> 03:03:05,160
Because we want to make sure that if people, for whatever reason, this particular machine actually works faster at SHA-256,

2410
03:03:05,160 --> 03:03:10,160
they can do a SHA-256. Normal people can do a SHA-512.

2411
03:03:10,160 --> 03:03:15,160
Which is the things we also specified in the top two. So we have a body hash algorithm.

2412
03:03:15,160 --> 03:03:20,160
We actually go hash the body.

2413
03:03:20,160 --> 03:03:25,160
So based on the algorithm they provided us, we update with the request data,

2414
03:03:25,160 --> 03:03:30,160
which is the body itself. We get a digest of the actual data.

2415
03:03:35,160 --> 03:03:40,160
And then we assert that the value in the claim matches the actual body hash.

2416
03:03:40,160 --> 03:03:45,160
So when you sent the request to me, you gave me a body hash that you stuck inside of the claims.

2417
03:03:45,160 --> 03:03:50,160
I'm verifying that the data I got when I hashed it matches the claims.

2418
03:03:50,160 --> 03:03:55,160
So this is absolutely verifying that you did not change the method.

2419
03:03:55,160 --> 03:04:00,160
You did not change the location.

2420
03:04:00,160 --> 03:04:05,160
You also did not change the body. If there are other headers that matter to you, you could add those in as well.

2421
03:04:05,160 --> 03:04:10,160
This is how we solve this problem.

2422
03:04:10,160 --> 03:04:15,160
And again, it's a lot of typing.

2423
03:04:15,160 --> 03:04:20,160
So if I got any errors, so one thing I do is I just keep adding errors.

2424
03:04:20,160 --> 03:04:25,160
One thing I found is when you have a valid web token and you get a response back,

2425
03:04:25,160 --> 03:04:30,160
there could be 15 errors and people just hate it when I say, okay, I fixed that one and I've got that one.

2426
03:04:30,160 --> 03:04:35,160
So you can do that in a different scenario where it's a class and you want to find out what you did wrong.

2427
03:04:35,160 --> 03:04:40,160
So basically it says if I got any errors, then I just join all the possible errors that were problematic and return a 401.

2428
03:04:40,160 --> 03:04:45,160
I will be changing that because it's actually not correct.

2429
03:04:45,160 --> 03:04:50,160
It's an invalid request because 401 says that you need to authenticate.

2430
03:04:50,160 --> 03:04:55,160
Well, you did authenticate and I verified that you authenticated.

2431
03:04:55,160 --> 03:05:00,160
So your request is bad.

2432
03:05:00,160 --> 03:05:05,160
So I should be doing a 400 there.

2433
03:05:05,160 --> 03:05:10,160
And so that is how I verify you on an incoming request.

2434
03:05:10,160 --> 03:05:15,160
So again, this is a very simple one. You just provided a key and a key ID.

2435
03:05:15,160 --> 03:05:20,160
And the issuer is the same.

2436
03:05:20,160 --> 03:05:25,160
So if you have a request that is not an example that only had one user, right,

2437
03:05:25,160 --> 03:05:30,160
the issuer of the request claim would be that user identifier, whatever that is for your user.

2438
03:05:30,160 --> 03:05:35,160
And then they would sign the JSON Web Token using their secret, whether that's an RSA key,

2439
03:05:35,160 --> 03:05:40,160
whether that's some kind of key that you generate, whatever that might be, right, your API key.

2440
03:05:40,160 --> 03:05:45,160
That's what they're going to sign it with and you're going to verify the signature.

2441
03:05:45,160 --> 03:05:50,160
So they're not passing any secret data.

2442
03:05:50,160 --> 03:05:55,160
Super important. They're not passing any secret data.

2443
03:05:55,160 --> 03:06:00,160
If your user names are a problem, do what most API providers do and let them generate an API key,

2444
03:06:00,160 --> 03:06:05,160
which is just random. It doesn't necessarily associate with the user because that's going to be passed across clear text.

2445
03:06:05,160 --> 03:06:10,160
Assume that all TLS is breakable and that anyone can see this data.

2446
03:06:10,160 --> 03:06:15,160
So again, issuer is going to be their user identifier and then you're going to verify

2447
03:06:15,160 --> 03:06:20,160
that they are that user by verifying the signature they created using their secret.

2448
03:06:20,160 --> 03:06:25,160
Does anybody have any questions about that? I know signatures are a little advanced topic.

2449
03:06:25,160 --> 03:06:30,160
Awesome. So response.

2450
03:06:30,160 --> 03:06:35,160
Response is a little easier because you're just building stuff, not verifying stuff.

2451
03:06:35,160 --> 03:06:40,160
So the first thing you want to do is make sure that this wasn't an error.

2452
03:06:40,160 --> 03:06:45,160
And again, you may care if it's there, right?

2453
03:06:45,160 --> 03:06:50,160
If you return 301s, you're going to want to include that data, but it all depends on what you're doing.

2454
03:06:50,160 --> 03:06:55,160
But for this particular one, we don't do any 301s, don't do any 302s. All we care about are 200 calls.

2455
03:06:55,160 --> 03:07:00,160
So we're going to turn with the current time is and we're start building a claims dictionary.

2456
03:07:01,160 --> 03:07:06,160
So JTI, what I do, although we may change this,

2457
03:07:06,160 --> 03:07:11,160
is another way to validate that the response you're getting is for the request that you made,

2458
03:07:11,160 --> 03:07:16,160
is that you send over a unique value and you get that same unique value back in the response.

2459
03:07:16,160 --> 03:07:21,160
This breaks caching.

2460
03:07:21,160 --> 03:07:26,160
So we're actually going to have to stop doing this on certain calls because we don't want these calls.

2461
03:07:26,160 --> 03:07:31,160
To be cash busted all the time.

2462
03:07:31,160 --> 03:07:36,160
So we're going to send certain calls. We're actually not going to enforce that the JTIs return the same.

2463
03:07:36,160 --> 03:07:41,160
Because if you make a call to we have a call to go get the public key to start verifying our data.

2464
03:07:41,160 --> 03:07:46,160
Well, that public key never changes and we want to be able to cash out on the edge that public key

2465
03:07:46,160 --> 03:07:51,160
because everybody accesses it all the time.

2466
03:07:51,160 --> 03:07:56,160
So this is one of the things this JTI thing returning the same JTI is going to break things.

2467
03:07:56,160 --> 03:08:01,160
Now, one thing that you can do is you can if you're going to do that, you can always just generate a random one.

2468
03:08:01,160 --> 03:08:05,160
When you ship it back, just make sure you've never seen it before.

2469
03:08:05,160 --> 03:08:10,160
Make sure someone is not replaying data to you and a man in the middle.

2470
03:08:10,160 --> 03:08:15,160
So they can't just keep sending you the same response every time. Is this person logged in? Yes, this person is logged in.

2471
03:08:15,160 --> 03:08:20,160
Is this person logged in? Yes, this person logged in.

2472
03:08:20,160 --> 03:08:25,160
Although you're issued at and your expiration are going to help with that tremendously.

2473
03:08:25,160 --> 03:08:30,160
So issued at is when you're issuing the token. Not everything checks for that.

2474
03:08:30,160 --> 03:08:35,160
Not before is when it's valid. So it's valid. It's not valid before this time.

2475
03:08:35,160 --> 03:08:42,160
And then expires at this time. So again, immediately expiring because it's only valid for one call.

2476
03:08:42,160 --> 03:08:47,160
And your leeway has to allow for the fact that it could take it a second, two seconds to get back depending on where you're at.

2477
03:08:48,160 --> 03:08:56,160
We have customers that access our our API from Australia and sometimes it takes them a second and a half to get a response back.

2478
03:08:56,160 --> 03:09:00,160
So they have to be able to deal with leeway.

2479
03:09:00,160 --> 03:09:05,160
The issuer in the audience, which is basically the inversion of what you got the first time.

2480
03:09:05,160 --> 03:09:13,160
The people who made the request are your audience going back and the the people they sent it to is is the new issuer.

2481
03:09:13,160 --> 03:09:21,160
And then we add the response claim and add in the status code, the body hash algorithm and then the body hash.

2482
03:09:21,160 --> 03:09:25,160
I didn't add any of the header things like cash control, that type of stuff. This is just an example.

2483
03:09:25,160 --> 03:09:32,160
But again, anything in the response that is important to you, it is important that doesn't change.

2484
03:09:32,160 --> 03:09:38,160
You would add into this to ensure that it's signed and that you can validate it.

2485
03:09:38,160 --> 03:09:47,160
So you create a new JWS with the claims and the algorithm, which is an HMAC SHA-256.

2486
03:09:47,160 --> 03:09:56,160
You then sign using the compact JSON serialization, JSON Web Signature with the keys.

2487
03:09:56,160 --> 03:09:59,160
And then you add the response header XJWT.

2488
03:09:59,160 --> 03:10:05,160
So there is no authorization in response, so you have to put it in a header, some header.

2489
03:10:05,160 --> 03:10:13,160
So in ours, we just put actually ours is XIOV JWT in case anybody else is using XJWT.

2490
03:10:13,160 --> 03:10:19,160
One thing you don't want to do, I made this mistake, is some things freak out when you put it in an authorization header.

2491
03:10:19,160 --> 03:10:22,160
So you don't want to put it in the authorization header.

2492
03:10:22,160 --> 03:10:30,160
This is not part of standard HTTP, so I would I would absolutely advise to use an extension header, use an X dash,

2493
03:10:30,160 --> 03:10:35,160
so that nothing else tries to process it, because when you return this, nothing else is going to understand it.

2494
03:10:35,160 --> 03:10:38,160
So don't make it think that it does.

2495
03:10:38,160 --> 03:10:53,160
So now, this is going to be a lot of data now.

2496
03:10:53,160 --> 03:10:55,160
Oh, it's angry.

2497
03:10:55,160 --> 03:10:57,160
Oh, so I don't have it running.

2498
03:10:57,160 --> 03:11:03,160
That helps.

2499
03:11:03,160 --> 03:11:06,160
OK.

2500
03:11:06,160 --> 03:11:08,160
So a lot, a lot, a lot, a lot of data.

2501
03:11:08,160 --> 03:11:13,160
So when we make the request, we start off with our unencrypted body, right?

2502
03:11:13,160 --> 03:11:15,160
We're sending over post data.

2503
03:11:15,160 --> 03:11:17,160
We build our JWT claims.

2504
03:11:17,160 --> 03:11:23,160
So here's our unique identifier issued at not before expiration.

2505
03:11:23,160 --> 03:11:25,160
The issuer and the audience.

2506
03:11:25,160 --> 03:11:31,160
So the issuer is a valid client, audience is the API server.

2507
03:11:31,160 --> 03:11:32,160
So here are our request things.

2508
03:11:32,160 --> 03:11:36,160
We're saying the post, the method, and the path, body hash algorithm, and the body hash.

2509
03:11:36,160 --> 03:11:41,160
So the client has to do all this stuff, which is why my APIs are so hard, you need SDKs.

2510
03:11:41,160 --> 03:11:44,160
It does all of this, ships it off.

2511
03:11:44,160 --> 03:11:52,160
And the server receives it as a post, HTTP 1.1, content type application Jose, and here is authorization.

2512
03:11:52,160 --> 03:11:58,160
This giant thing here is a single header that includes a JSON web token.

2513
03:11:58,160 --> 03:12:00,160
So here's our authorization type.

2514
03:12:00,160 --> 03:12:02,160
Again, don't use bearer.

2515
03:12:02,160 --> 03:12:07,160
Even though it is a JSON web token, it's going to freak out because it doesn't understand who the issuer is.

2516
03:12:07,160 --> 03:12:11,160
It doesn't have all this information it needs to properly handle this stuff.

2517
03:12:11,160 --> 03:12:14,160
So you're going to have something special.

2518
03:12:14,160 --> 03:12:15,160
And again, this is the same thing.

2519
03:12:15,160 --> 03:12:16,160
Base 62, you're all encoded.

2520
03:12:16,160 --> 03:12:19,160
You could use the Base 64 decoder to decode it and take a look at it.

2521
03:12:19,160 --> 03:12:24,160
That's a great way to do troubleshooting when things aren't working the way that you expect.

2522
03:12:24,160 --> 03:12:31,160
But it has three segments, which are the header, which is not in there.

2523
03:12:31,160 --> 03:12:37,160
So the header has the key ID, the signature type, the algorithm used for the signature,

2524
03:12:37,160 --> 03:12:40,160
and the fact that it's a JSON web token.

2525
03:12:40,160 --> 03:12:46,160
And then you have the signature.

2526
03:12:46,160 --> 03:12:47,160
I'm sorry.

2527
03:12:47,160 --> 03:12:50,160
You have the body, which are your claims.

2528
03:12:50,160 --> 03:12:53,160
So that's this data right here.

2529
03:12:53,160 --> 03:12:55,160
This is that piece in there.

2530
03:12:55,160 --> 03:12:58,160
So that's going to be Base 62, you're all encoded.

2531
03:12:58,160 --> 03:13:01,160
And then the last piece is the actual signature.

2532
03:13:01,160 --> 03:13:07,160
So this is HMAC shot 256 or HMAC shot 512.

2533
03:13:07,160 --> 03:13:11,160
So it's always going to be the same size.

2534
03:13:11,160 --> 03:13:13,160
And then the body is your encrypted data.

2535
03:13:13,160 --> 03:13:17,160
So one of the things that we're actually doing is we're citing the encrypted data, right?

2536
03:13:17,160 --> 03:13:20,160
Because that's the data that's in the actual body.

2537
03:13:20,160 --> 03:13:23,160
We don't care if it's encrypted or not encrypted, right?

2538
03:13:23,160 --> 03:13:26,160
So again, we're creating another transparent layer.

2539
03:13:26,160 --> 03:13:28,160
I don't care what you're sending me.

2540
03:13:28,160 --> 03:13:30,160
I just need to verify that it's what I expect it to be.

2541
03:13:30,160 --> 03:13:34,160
So if it's unencrypted, I'm going to verify that it's correct when it's unencrypted.

2542
03:13:34,160 --> 03:13:36,160
When it's encrypted, same thing.

2543
03:13:36,160 --> 03:13:37,160
It doesn't care.

2544
03:13:37,160 --> 03:13:42,160
It's just another layer around everything else.

2545
03:13:42,160 --> 03:13:44,160
The response does the same thing.

2546
03:13:44,160 --> 03:13:48,160
So content type application Jose, and then here's our XJWT.

2547
03:13:48,160 --> 03:13:52,160
So here's the signing of the data going back.

2548
03:13:52,160 --> 03:13:55,160
And then here's the actual data.

2549
03:13:55,160 --> 03:13:56,160
So it's encrypted data.

2550
03:13:56,160 --> 03:14:00,160
And then here's the response claims that we verified.

2551
03:14:00,160 --> 03:14:04,160
So it has the status code and the body hash, and it verified the body hash.

2552
03:14:04,160 --> 03:14:05,160
Any questions?

2553
03:14:05,160 --> 03:14:09,160
We've got like six minutes.

2554
03:14:09,160 --> 03:14:12,160
This is super, super, super advanced, right?

2555
03:14:12,160 --> 03:14:14,160
Your API may or may not need it.

2556
03:14:14,160 --> 03:14:19,160
But if you do need things like this or you have been adding signature data into your body,

2557
03:14:19,160 --> 03:14:25,160
you may want to consider it because it made our APIs clean, easy.

2558
03:14:25,160 --> 03:14:29,160
We reduced all of our roll your own crypto code.

2559
03:14:29,160 --> 03:14:35,160
We separated authorization or we combined authorization and data validation for the actual HTTP request,

2560
03:14:35,160 --> 03:14:38,160
which made it actually easier for us.

2561
03:14:38,160 --> 03:14:44,160
So that we can verify all that information in a token that's signed using proper encryption

2562
03:14:44,160 --> 03:14:47,160
that we didn't have to come up with ourselves.

2563
03:14:47,160 --> 03:14:48,160
Yes?

2564
03:14:48,160 --> 03:15:02,160
So the question was, could this be very useful for a microservice?

2565
03:15:02,160 --> 03:15:07,160
That depends on how secure your microservice needs to be.

2566
03:15:07,160 --> 03:15:10,160
Like I said, we don't use the symmetric encryption.

2567
03:15:10,160 --> 03:15:12,160
We use the asymmetric encryption.

2568
03:15:12,160 --> 03:15:17,160
But again, it can be used however you want to use it.

2569
03:15:17,160 --> 03:15:20,160
And it can verify whatever data you need it to verify.

2570
03:15:20,160 --> 03:15:23,160
So it is very extensible.

2571
03:15:23,160 --> 03:15:30,160
Well, with that, remember though, microservices are expected to be very small and very fast.

2572
03:15:30,160 --> 03:15:35,160
If you're encrypting and signing data, that's going to add some overhead.

2573
03:15:35,160 --> 03:15:44,160
And how much data you're encrypting and what type of signatures you're doing can determine how much is going to slow it down.

2574
03:15:44,160 --> 03:15:49,160
So if you have a microservice that needs to be very secure, absolutely.

2575
03:15:49,160 --> 03:15:56,160
But make sure you do some performance testing to make sure you're not getting CPU star because you're doing all this crypto.

2576
03:15:56,160 --> 03:16:01,160
Most systems out there have AES accelerators built into them.

2577
03:16:01,160 --> 03:16:06,160
So if you're using AES encryption without the key wrap, you'd probably be safe.

2578
03:16:06,160 --> 03:16:10,160
But then you also have to watch out because of key rotation and nonce collisions.

2579
03:16:10,160 --> 03:16:13,160
And there's a bunch of crypto stuff you've got to worry about.

2580
03:16:13,160 --> 03:16:16,160
But if it's an internal service, the likelihood that you can rotate keys is probably very high.

2581
03:16:16,160 --> 03:16:19,160
Again, the system allows for key rotation.

2582
03:16:19,160 --> 03:16:25,160
So I would find something that works with what you're trying to do as far as speeds with microservices.

2583
03:16:25,160 --> 03:16:27,160
I'd be wary of that.

2584
03:16:27,160 --> 03:16:33,160
On our systems, we do a ton of performance testing to make sure that as we're changing these things,

2585
03:16:33,160 --> 03:16:38,160
because most applications in the real world in APIs, your number one problem is not CPU.

2586
03:16:38,160 --> 03:16:40,160
Your number one problem is I.O.

2587
03:16:40,160 --> 03:16:44,160
You're talking to microservices. You're talking to databases. You're talking to cache systems.

2588
03:16:44,160 --> 03:16:46,160
That's where all your time is being spent.

2589
03:16:46,160 --> 03:16:51,160
In a heavy crypto app, you start having to worry about how much CPU you have.

2590
03:16:51,160 --> 03:16:55,160
Everything can't be like a T1 micro.

2591
03:16:55,160 --> 03:17:00,160
You might have to actually have some CPU on that app server because you're doing a lot of crypto.

2592
03:17:00,160 --> 03:17:03,160
Any other questions?

2593
03:17:05,160 --> 03:17:14,160
All right. Well, I only have one request, and that is please rate this talk.

2594
03:17:14,160 --> 03:17:16,160
That's a very long URL.

2595
03:17:16,160 --> 03:17:20,160
Most phones nowadays support QR codes. That's a valid working QR code.

2596
03:17:20,160 --> 03:17:24,160
That has no spyware. I just made it myself.

2597
03:17:24,160 --> 03:17:29,160
To the lovely SurveyMonkey survey for this talk.

2598
03:17:29,160 --> 03:17:34,160
I'm like super awesome, amazed and impressed that everybody made it through all the way.

2599
03:17:34,160 --> 03:17:36,160
Way better than last year.

2600
03:17:36,160 --> 03:17:40,160
And if you have any questions, I think the class thing will still be open.

2601
03:17:40,160 --> 03:17:42,160
You can post it there.

2602
03:17:42,160 --> 03:17:46,160
If you have questions about the stuff, you have the GitHub URL. Do stuff there.

2603
03:17:46,160 --> 03:17:51,160
I think my Twitter thing is really small, but it's just my name with an underscore.

2604
03:17:51,160 --> 03:17:56,160
Hit me up there or in one of the Slack rooms for Python around.

2605
03:17:56,160 --> 03:18:00,160
I will be here all week, including all days of the sprints.

2606
03:18:00,160 --> 03:18:02,160
If you have stuff you'd like to chat about.

2607
03:18:02,160 --> 03:18:06,160
If you think doing stuff like this is something you might want to do, I will also be at the job fair.

2608
03:18:06,160 --> 03:18:09,160
Hint, hint.

2609
03:18:09,160 --> 03:18:11,160
Not that I'm promoting anything.

2610
03:18:11,160 --> 03:18:14,160
Just telling you, I'll be at the job fair if you catch me there.

2611
03:18:14,160 --> 03:18:16,160
Awesome. Thank you.

