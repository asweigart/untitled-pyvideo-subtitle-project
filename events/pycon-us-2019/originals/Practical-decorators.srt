1
00:00:00,000 --> 00:00:05,540
Ladies and gentlemen, we would like to start at this time, welcome to the first talk of

2
00:00:05,540 --> 00:00:06,880
the session.

3
00:00:06,880 --> 00:00:15,000
And please welcome Ruben Lerner, and he's going to be presenting Practical Decorators.

4
00:00:15,000 --> 00:00:21,000
Hey, everyone.

5
00:00:21,000 --> 00:00:22,260
Good morning.

6
00:00:22,260 --> 00:00:23,780
Welcome to PyCon.

7
00:00:23,780 --> 00:00:25,260
Pretty exciting stuff.

8
00:00:25,260 --> 00:00:28,860
So my name's Ruben, and I have a fantastic job.

9
00:00:28,860 --> 00:00:31,540
I help people get better at Python.

10
00:00:31,540 --> 00:00:32,740
I do that a few different ways.

11
00:00:32,740 --> 00:00:35,500
I have a newsletter that about 10,000 people get every week.

12
00:00:35,500 --> 00:00:37,220
I do corporate Python training.

13
00:00:37,220 --> 00:00:38,900
I go on site all around the world.

14
00:00:38,900 --> 00:00:41,500
I have a service called weekly Python exercise.

15
00:00:41,500 --> 00:00:43,100
I do online video courses.

16
00:00:43,100 --> 00:00:45,540
Earlier this week, my book was published by Manning.

17
00:00:45,540 --> 00:00:50,740
Note this is the first Manning book to have the author's picture on the cover.

18
00:00:50,740 --> 00:00:54,740
And this morning, the episode of talk Python with me was also released.

19
00:00:54,740 --> 00:00:57,880
So I can annoy you in all media all day.

20
00:00:57,880 --> 00:00:59,860
So we're going to talk about decorators.

21
00:00:59,860 --> 00:01:01,400
Let's decorate a function.

22
00:01:01,400 --> 00:01:02,800
Let's say I have this decorator here.

23
00:01:02,800 --> 00:01:03,800
So what do I have?

24
00:01:03,800 --> 00:01:04,800
I have at my deco.

25
00:01:04,800 --> 00:01:07,320
I should add, by the way, this is an advanced talk.

26
00:01:07,320 --> 00:01:11,520
So if things seem a little weird, hard, difficult, that's okay.

27
00:01:11,520 --> 00:01:15,400
After a little while, I promise within 20 years, it will make a lot of sense.

28
00:01:15,400 --> 00:01:19,280
So basically, if I want to decorate a function, I say at my deco, and then I'm going to say

29
00:01:19,280 --> 00:01:21,720
def add of a and b, return a plus b.

30
00:01:21,720 --> 00:01:22,720
Pretty reasonable.

31
00:01:22,720 --> 00:01:26,000
And this is the standard syntax we use for decorators in Python.

32
00:01:26,160 --> 00:01:30,380
When you see this on the left, you really need to be thinking something different.

33
00:01:30,380 --> 00:01:33,760
You need to be thinking, first, I'm defining my function.

34
00:01:33,760 --> 00:01:35,520
Now, what does def do in Python?

35
00:01:35,520 --> 00:01:37,640
It actually does two different things.

36
00:01:37,640 --> 00:01:45,240
It creates a function object, and it also assigns that object to the variable add, to

37
00:01:45,240 --> 00:01:46,240
the identifier add.

38
00:01:46,240 --> 00:01:49,240
So you always need to be thinking that's doing those two different things.

39
00:01:49,240 --> 00:01:54,040
Well, right after I define my function, that at my deco on the left does something really

40
00:01:54,040 --> 00:01:55,040
kind of wild.

41
00:01:55,080 --> 00:01:56,080
It does a reassignment.

42
00:01:56,080 --> 00:02:00,440
It says, actually, what we're going to do is we're going to call my deco with an argument

43
00:02:00,440 --> 00:02:04,560
of add, and we're going to assign the result back to the variable add.

44
00:02:04,560 --> 00:02:07,560
It's a little switcheroo there.

45
00:02:07,560 --> 00:02:11,080
This means that we could, if we really want to, write it like on the right.

46
00:02:11,080 --> 00:02:14,480
But that would be really annoying, because then I have to write the word add three different

47
00:02:14,480 --> 00:02:15,480
times.

48
00:02:15,480 --> 00:02:16,480
And no one wants to do that.

49
00:02:16,480 --> 00:02:17,480
That's just super annoying.

50
00:02:17,480 --> 00:02:19,280
If you mess it up even once, bad news.

51
00:02:19,280 --> 00:02:24,660
So while the left-hand side has perhaps more magic in it, and it's less explicit as to

52
00:02:24,660 --> 00:02:28,780
what's going on, it saves us time, it saves us energy, and it saves us from having to

53
00:02:28,780 --> 00:02:30,620
perhaps make those mistakes.

54
00:02:30,620 --> 00:02:35,780
The thing is, when we do this, we have three callables in this code.

55
00:02:35,780 --> 00:02:38,500
This seemingly simple code has three different callables.

56
00:02:38,500 --> 00:02:40,060
Now, what's a callable?

57
00:02:40,060 --> 00:02:43,300
Callables fancy Python speak for something we can execute.

58
00:02:43,300 --> 00:02:48,560
If you've ever tried to say, like, five parentheses in Python, what happens?

59
00:02:48,560 --> 00:02:51,180
There's no compiler to tell you, hey, you can't execute five.

60
00:02:51,180 --> 00:02:52,380
You can't execute integers.

61
00:02:52,900 --> 00:02:57,140
Instead, what happens is, at runtime, Python tries to execute, says, wait a second, integers

62
00:02:57,140 --> 00:02:58,420
are not callable.

63
00:02:58,420 --> 00:02:59,420
You can't do that.

64
00:02:59,420 --> 00:03:00,620
Well, how does it know?

65
00:03:00,620 --> 00:03:04,300
Well, certain things in Python are callable, and that's typically going to be functions

66
00:03:04,300 --> 00:03:05,780
and classes.

67
00:03:05,780 --> 00:03:08,740
So we actually have three callables, either functions or classes here.

68
00:03:08,740 --> 00:03:10,780
For most of this talk, I'm going to be talking about functions.

69
00:03:10,780 --> 00:03:13,060
Toward the end, we'll talk about classes as well.

70
00:03:13,060 --> 00:03:14,780
So where are these callables going to be?

71
00:03:14,780 --> 00:03:18,380
Well, first of all, we have the decorated function.

72
00:03:18,380 --> 00:03:20,600
That is our first callable, add.

73
00:03:20,600 --> 00:03:23,560
The second callable is the decorator itself.

74
00:03:23,560 --> 00:03:27,280
And the third callable, and here is where this syntax gets a little weird.

75
00:03:27,280 --> 00:03:30,880
The third callable, which is really the most important one, is actually invisible here.

76
00:03:30,880 --> 00:03:35,040
It's the one that's returned from when I call myDeco on add.

77
00:03:35,040 --> 00:03:38,100
And that callable is the one assigned back to add.

78
00:03:38,100 --> 00:03:41,320
And so when I call add, I'm not really calling my original add.

79
00:03:41,320 --> 00:03:48,020
I'm calling whatever was returned by myDeco add, which then is going to sort of hopefully

80
00:03:48,020 --> 00:03:49,300
call the original add.

81
00:03:49,300 --> 00:03:52,460
So this is how we have to think about our decorators when we use them.

82
00:03:52,460 --> 00:03:54,420
Well, what about when we want to find them then?

83
00:03:54,420 --> 00:03:56,260
We're going to have to deal with these three callables.

84
00:03:56,260 --> 00:04:03,380
And so a very typical way to write our decorator is as a function inside of another function.

85
00:04:03,380 --> 00:04:05,120
So I have here myDeco.

86
00:04:05,120 --> 00:04:06,120
That's my decorator.

87
00:04:06,120 --> 00:04:07,240
It's on the top level there.

88
00:04:07,240 --> 00:04:08,240
That's the function.

89
00:04:08,240 --> 00:04:09,240
And it's going to get a function.

90
00:04:09,240 --> 00:04:12,580
It's going to get our function here as an argument.

91
00:04:12,580 --> 00:04:16,700
The inside function here, which is often called wrapper, that's where a lot of the magic is

92
00:04:16,700 --> 00:04:17,700
happening.

93
00:04:17,700 --> 00:04:19,700
And it's going to actually be returned as we can see here.

94
00:04:19,700 --> 00:04:22,300
And notice that it has a funny sort of function signature.

95
00:04:22,300 --> 00:04:25,580
It's getting splat args and double splat kw args.

96
00:04:25,580 --> 00:04:26,660
Why am I doing that?

97
00:04:26,660 --> 00:04:29,400
Because I want to be able to decorate any function at all.

98
00:04:29,400 --> 00:04:32,620
And this way I can get any combination of arguments coming in.

99
00:04:32,620 --> 00:04:33,740
And then what am I going to do?

100
00:04:33,740 --> 00:04:36,300
I'm going to call the function, just pass those along.

101
00:04:36,300 --> 00:04:38,500
So whatever I get as input, I'm going to pass along to output.

102
00:04:38,500 --> 00:04:40,400
Now this decorator is pretty boring.

103
00:04:40,400 --> 00:04:42,760
All it does is it takes any function whatsoever.

104
00:04:42,760 --> 00:04:46,420
It calls that function, sticks the result of the function into a string, and then adds

105
00:04:46,540 --> 00:04:48,020
three exclamation points afterwards.

106
00:04:48,020 --> 00:04:51,580
OK, not the most exciting function in the world.

107
00:04:51,580 --> 00:04:52,660
So what's going on here?

108
00:04:52,660 --> 00:04:55,620
Let's once again talk about our three callables.

109
00:04:55,620 --> 00:04:57,960
We have our first callable, which is our decorated function.

110
00:04:57,960 --> 00:04:59,540
It becomes our argument.

111
00:04:59,540 --> 00:05:02,760
The second callable is our decorator that we are calling on it.

112
00:05:02,760 --> 00:05:06,340
And the third callable, that sort of mystery one at the end, that's wrapper.

113
00:05:06,340 --> 00:05:08,500
That's the internal function.

114
00:05:08,500 --> 00:05:13,820
Whatever is called a mydeco add, this function then returns and is assigned back to our original

115
00:05:13,820 --> 00:05:15,220
function name.

116
00:05:15,220 --> 00:05:17,700
And that's how the decorator sort of works.

117
00:05:17,700 --> 00:05:19,100
Here's another perspective on it.

118
00:05:19,100 --> 00:05:21,220
We can think about it in terms of time.

119
00:05:21,220 --> 00:05:25,660
We can say that at the beginning, when we decorate the function, this outside function

120
00:05:25,660 --> 00:05:26,660
is running.

121
00:05:26,660 --> 00:05:30,380
But the inside function runs once each time we run the function.

122
00:05:30,380 --> 00:05:33,260
So the outside one runs once only at set up time.

123
00:05:33,260 --> 00:05:36,940
And the inside one runs as many times as we need.

124
00:05:36,940 --> 00:05:37,940
That's pretty great.

125
00:05:37,940 --> 00:05:43,060
By the way, I should add, how is it that the internal function is having access to funk?

126
00:05:43,060 --> 00:05:46,100
Funk, after all, is a local variable in the external function.

127
00:05:46,100 --> 00:05:48,860
This is thanks to the magic of Python scoping.

128
00:05:48,860 --> 00:05:50,500
L-E-G-B.

129
00:05:50,500 --> 00:05:52,540
Local enclosing global built-ins.

130
00:05:52,540 --> 00:05:55,620
Basically what happens is that inside of wrapper, it looks for the name funk.

131
00:05:55,620 --> 00:05:57,620
It says, is there a local variable funk?

132
00:05:57,620 --> 00:05:58,620
There is not.

133
00:05:58,620 --> 00:05:59,620
So let's look in the enclosing function.

134
00:05:59,620 --> 00:06:00,620
Hey, what do you know?

135
00:06:00,620 --> 00:06:02,780
There's a local variable funk there.

136
00:06:02,780 --> 00:06:03,780
Let's use that.

137
00:06:03,780 --> 00:06:08,420
So we have access to that external function inside of the internal function.

138
00:06:08,420 --> 00:06:10,300
Well decorators are pretty cool then.

139
00:06:10,300 --> 00:06:11,300
That's pretty great.

140
00:06:11,540 --> 00:06:15,900
And for a long time I thought they were cool, but I also thought they were sort of a solution

141
00:06:15,900 --> 00:06:17,500
looking for a problem.

142
00:06:17,500 --> 00:06:21,580
Like okay, I can now twist my mind in all sorts of different ways, but really and truly

143
00:06:21,580 --> 00:06:22,580
where would I want to use them?

144
00:06:22,580 --> 00:06:25,260
Well it turns out they are actually useful.

145
00:06:25,260 --> 00:06:26,460
Shocking, right?

146
00:06:26,460 --> 00:06:28,340
They are actually useful.

147
00:06:28,340 --> 00:06:31,740
So I want to give you about five different examples of decorators and how we can use

148
00:06:31,740 --> 00:06:33,060
them, how we can think about them.

149
00:06:33,060 --> 00:06:37,220
And I want you not only then to understand how decorators work and how we can write them,

150
00:06:37,220 --> 00:06:41,040
but sort of the perspective that decorators give us on how things work in Python.

151
00:06:41,040 --> 00:06:45,400
And you'll start to see more and more opportunities to use them as you deepen your understanding.

152
00:06:45,400 --> 00:06:49,240
And so a classic example to start with decorators is timing.

153
00:06:49,240 --> 00:06:50,680
So how long does it take a function to run?

154
00:06:50,680 --> 00:06:52,440
Well I can do that in general.

155
00:06:52,440 --> 00:06:57,200
I can use time.time, get back the number of seconds since the 1st of January 1970.

156
00:06:57,200 --> 00:06:59,120
I can do that before I run the function.

157
00:06:59,120 --> 00:07:00,200
I can then run the function.

158
00:07:00,200 --> 00:07:02,120
Then I can run it again, run time.time.

159
00:07:02,120 --> 00:07:05,860
I can subtract the two numbers there and find out how long the function took to run.

160
00:07:05,860 --> 00:07:08,620
And indeed then I can do that in my decorator.

161
00:07:08,620 --> 00:07:09,620
So here's my decorator.

162
00:07:09,620 --> 00:07:12,300
I've got my outside function which I'm calling log time.

163
00:07:12,300 --> 00:07:14,280
It's going to take func as an argument.

164
00:07:14,280 --> 00:07:16,620
And my inside function, what's it going to do?

165
00:07:16,620 --> 00:07:20,120
Well the important thing here is going to be start time equals time.time.

166
00:07:20,120 --> 00:07:21,120
Right?

167
00:07:21,120 --> 00:07:22,120
So I'm going to time it.

168
00:07:22,120 --> 00:07:23,120
I'm then going to run the function.

169
00:07:23,120 --> 00:07:25,320
Notice I'm not doing anything to the function at all.

170
00:07:25,320 --> 00:07:26,320
It's running as per usual.

171
00:07:26,320 --> 00:07:28,020
I'm going to pass it all its arguments.

172
00:07:28,020 --> 00:07:29,020
It's going to return a result.

173
00:07:29,020 --> 00:07:30,020
Excuse me.

174
00:07:30,020 --> 00:07:34,080
I'm going to just put the result inside of the variable cleverly called result.

175
00:07:34,080 --> 00:07:37,260
And then afterwards I'm going to find out how much time has elapsed.

176
00:07:37,260 --> 00:07:39,300
Then I'm going to write it to a file.

177
00:07:39,300 --> 00:07:43,460
I'm going to say with open timing.txt and granted time log.txt.

178
00:07:43,460 --> 00:07:44,460
Granted here I'm hard coding the name.

179
00:07:44,460 --> 00:07:45,460
We don't need to do that.

180
00:07:45,460 --> 00:07:49,060
I'm using a to append it to append to the file as opposed to reset it each time.

181
00:07:49,060 --> 00:07:53,060
And I'm going to write what is the current time, what function name am I running, and

182
00:07:53,060 --> 00:07:55,100
how long did this function take to run.

183
00:07:55,100 --> 00:07:56,220
Fantastic.

184
00:07:56,220 --> 00:07:58,780
And if I do this, right, here's how I could apply it.

185
00:07:58,780 --> 00:08:00,340
So I could apply my decorator very easily.

186
00:08:00,340 --> 00:08:04,100
I could just say at log time to slow add and at log time to slow mo.

187
00:08:04,100 --> 00:08:07,180
And by the way, one of the beautiful things about decorators is I can add and remove their

188
00:08:07,180 --> 00:08:11,580
functionality to functions by not touching the function itself just by putting the decorator

189
00:08:11,580 --> 00:08:12,580
before it.

190
00:08:12,580 --> 00:08:16,980
So if I want to start timing a bunch of functions, I can just put at log time before their definitions.

191
00:08:16,980 --> 00:08:18,780
And when I'm done timing them, I can just remove that.

192
00:08:18,780 --> 00:08:20,460
I don't need to touch the functions themselves.

193
00:08:20,460 --> 00:08:22,220
They stay exactly the same.

194
00:08:22,220 --> 00:08:26,760
Well what happens when I run my function slow add and slow mo a couple of times?

195
00:08:26,760 --> 00:08:28,700
This is the sort of result I'm going to get in the file.

196
00:08:28,700 --> 00:08:30,780
I'm going to find out at what time each of the functions ran.

197
00:08:30,780 --> 00:08:32,500
I'm going to find out which function ran.

198
00:08:32,500 --> 00:08:34,460
I'm going to find out how long it ran for.

199
00:08:34,540 --> 00:08:38,700
So I can add this sort of logging of my functions with pretty great ease.

200
00:08:38,700 --> 00:08:43,580
OK, well what was going on here is of course I have my original decorated function.

201
00:08:43,580 --> 00:08:45,540
Still, I have my three callables.

202
00:08:45,540 --> 00:08:46,540
Something just fall.

203
00:08:46,540 --> 00:08:47,540
No worries, no worries.

204
00:08:47,540 --> 00:08:48,540
Yes.

205
00:08:48,540 --> 00:08:49,540
Ominous.

206
00:08:49,540 --> 00:08:50,540
All right.

207
00:08:50,540 --> 00:08:52,700
And then I've got log time.

208
00:08:52,700 --> 00:08:54,060
There's my decorator.

209
00:08:54,060 --> 00:08:58,340
And then I've got the return value from log time func is assigned back to func's name.

210
00:08:58,340 --> 00:08:59,340
Fantastic.

211
00:08:59,340 --> 00:09:02,300
OK, so that's a pretty simple decorator, but it demonstrates some of the ideas.

212
00:09:02,700 --> 00:09:04,580
So let's get a little more complicated.

213
00:09:04,580 --> 00:09:09,700
Let's say I have a function that's very expensive to run in terms of the resources it uses,

214
00:09:09,700 --> 00:09:12,880
in terms of the timing it takes, in terms of all sorts of different stuff.

215
00:09:12,880 --> 00:09:16,300
So maybe I want to make sure this function can only run once per minute.

216
00:09:16,300 --> 00:09:20,020
If it runs more than once per minute, then I want to get an exception back.

217
00:09:20,020 --> 00:09:21,460
So how am I going to do that?

218
00:09:21,460 --> 00:09:23,940
Well, here's a skeleton of my decorator.

219
00:09:23,940 --> 00:09:25,500
I'm going to call it once per minute.

220
00:09:25,500 --> 00:09:26,500
Very clever name.

221
00:09:26,500 --> 00:09:27,500
Right?

222
00:09:27,500 --> 00:09:28,500
And I'm going to have func be its argument.

223
00:09:28,500 --> 00:09:31,100
And so we see here once again I have my decorated function.

224
00:09:31,100 --> 00:09:33,020
I have the decorator, and we're going to return it.

225
00:09:33,020 --> 00:09:35,220
Ah, yeah, but what goes in the middle?

226
00:09:35,220 --> 00:09:37,180
OK, that's left as an exercise to the reader.

227
00:09:37,180 --> 00:09:38,260
OK, not at all.

228
00:09:38,260 --> 00:09:40,140
So basically, what are we going to do here?

229
00:09:40,140 --> 00:09:41,140
Well, think about it.

230
00:09:41,140 --> 00:09:44,900
Each time a function runs, it doesn't remember what happened in the previous runs.

231
00:09:44,900 --> 00:09:46,860
That's sort of the whole point of a function.

232
00:09:46,860 --> 00:09:51,780
And it's not like in some languages where we have, pardon the obscenity, static variables,

233
00:09:51,780 --> 00:09:55,580
where we would be able to carry these variables over from one run to another.

234
00:09:55,580 --> 00:09:56,740
So I can't really do that.

235
00:09:56,740 --> 00:10:01,080
Now I could use a global variable to keep track of this stuff, but then I'd feel super

236
00:10:01,080 --> 00:10:03,720
icky and have to shower each time I ran my code.

237
00:10:03,720 --> 00:10:06,760
So I've really got to find some other better way to do this.

238
00:10:06,760 --> 00:10:09,360
And what I'm going to do is I'm going to use nonlocal.

239
00:10:09,360 --> 00:10:14,760
I'm going to put the time, the last invoke time, in the outer function, the one that

240
00:10:14,760 --> 00:10:16,000
runs just once.

241
00:10:16,000 --> 00:10:19,080
And it's going to set up this variable once.

242
00:10:19,080 --> 00:10:20,320
Then I'm going to say nonlocal.

243
00:10:20,320 --> 00:10:21,520
Now what does nonlocal do?

244
00:10:21,520 --> 00:10:26,320
It says to Python, listen, normally when you assign to a variable inside of a function,

245
00:10:26,320 --> 00:10:29,520
you are either creating or updating a local variable.

246
00:10:29,520 --> 00:10:30,520
Not this time.

247
00:10:30,600 --> 00:10:36,400
So we're saying nonlocal, we say, I want you to update, change the variable in the external,

248
00:10:36,400 --> 00:10:38,480
in the enclosing scope.

249
00:10:38,480 --> 00:10:42,520
So now what's happening is that each time I run wrapper, my internal function, it's

250
00:10:42,520 --> 00:10:46,400
going to say nonlocal last invoked, and then it's going to say, I'm going to update that

251
00:10:46,400 --> 00:10:47,400
external variable.

252
00:10:47,400 --> 00:10:50,000
I'm going to update that enclosing variable.

253
00:10:50,000 --> 00:10:54,940
And this way we're able to carry this information across different runs of our function.

254
00:10:54,940 --> 00:10:55,940
Pretty great.

255
00:10:55,940 --> 00:10:56,940
Okay?

256
00:10:56,940 --> 00:10:57,940
Now I need that.

257
00:10:57,940 --> 00:11:00,620
So we're going to run nonlocal because this stuff is executing only once.

258
00:11:00,620 --> 00:11:04,460
We know that last invoked is only going to run once in our function, in our decorated

259
00:11:04,460 --> 00:11:08,260
function, whereas this stuff is going to be running again and again and again each time

260
00:11:08,260 --> 00:11:09,460
we run our function.

261
00:11:09,460 --> 00:11:10,460
And does this actually work?

262
00:11:10,460 --> 00:11:12,520
I sure hope so because I put it in my slides.

263
00:11:12,520 --> 00:11:16,820
So we're going to say add two plus two, and sure enough that's four, that's really mathematically

264
00:11:16,820 --> 00:11:17,820
not inclined.

265
00:11:17,820 --> 00:11:18,820
I'm giving you the answer here.

266
00:11:18,820 --> 00:11:22,580
But then if I say add of three and three, well, I ran that too often, called too often

267
00:11:22,580 --> 00:11:24,860
error, only four seconds have passed.

268
00:11:24,860 --> 00:11:25,860
Pretty great.

269
00:11:26,060 --> 00:11:28,580
Yeah, but who wants just once per minute?

270
00:11:28,580 --> 00:11:30,800
Let's generalize this to once per n.

271
00:11:30,800 --> 00:11:36,260
Now what I want to do is restrict people to run my function once per n seconds.

272
00:11:36,260 --> 00:11:39,220
So in order to understand what's going on here, we're going to have to go back to what

273
00:11:39,220 --> 00:11:40,360
happens with a decorator.

274
00:11:40,360 --> 00:11:45,060
So when I see this at once per minute on def add a and b return a plus b, remember, we

275
00:11:45,060 --> 00:11:46,780
should be thinking this.

276
00:11:46,780 --> 00:11:50,700
Def add of a and b return a plus b, our function is defined as per usual, but of course the

277
00:11:50,700 --> 00:11:53,980
rewrite means that on that last line what we're going to be doing is taking the decorator

278
00:11:53,980 --> 00:11:57,500
name once per minute, applying it to add and whatever we get back, we're going to

279
00:11:57,500 --> 00:11:59,000
put into add.

280
00:11:59,000 --> 00:12:02,220
So what happens when I add an argument to my decorator?

281
00:12:02,220 --> 00:12:05,860
Right now I'm saying at once per n of five, and then I do def add of a and b.

282
00:12:05,860 --> 00:12:07,300
So what do we need to be thinking?

283
00:12:07,300 --> 00:12:10,620
We need to be thinking, okay, I've got my function definition as before, and then I

284
00:12:10,620 --> 00:12:13,580
have this on the bottom line.

285
00:12:13,580 --> 00:12:14,580
So what am I doing?

286
00:12:14,580 --> 00:12:17,860
I'm going to call once per n with an argument of five.

287
00:12:17,860 --> 00:12:21,420
The result from that is then going to be applied to add.

288
00:12:21,460 --> 00:12:24,940
The result from that is then going to be assigned back to add.

289
00:12:24,940 --> 00:12:28,940
In other words, we have four callables running around here.

290
00:12:28,940 --> 00:12:29,940
So what do we have?

291
00:12:29,940 --> 00:12:32,380
We have our original decorated function.

292
00:12:32,380 --> 00:12:34,300
We have our decorator once per n.

293
00:12:34,300 --> 00:12:38,700
We have the result from calling once per n on five, because that's a callable, we can

294
00:12:38,700 --> 00:12:43,460
then invoke that on add, and then the result from once per n on five on add is assigned

295
00:12:43,460 --> 00:12:44,460
back to add.

296
00:12:44,460 --> 00:12:47,580
Well, that's great, but how are we going to actually implement this?

297
00:12:47,580 --> 00:12:48,580
That's right.

298
00:12:48,580 --> 00:12:51,660
We're going to have a function in a function in a function.

299
00:12:51,660 --> 00:12:54,580
So what's this going to look like?

300
00:12:54,580 --> 00:12:56,980
I'm going to have once per n on the outside there.

301
00:12:56,980 --> 00:12:58,580
That's going to be my top level function.

302
00:12:58,580 --> 00:13:00,580
That's what's going to get my argument.

303
00:13:00,580 --> 00:13:04,460
I'm then going to have a middle function, and that's going to get the actual function.

304
00:13:04,460 --> 00:13:07,980
You can think of these outer two functions as sort of splitting up the responsibilities

305
00:13:07,980 --> 00:13:10,180
of our original outer function before.

306
00:13:10,180 --> 00:13:12,420
And wrapper looks pretty much the same as before.

307
00:13:12,420 --> 00:13:14,700
In fact, we can see what we had before.

308
00:13:14,700 --> 00:13:18,500
We have last invoked equals zero, nonlocal last invoked, because once again, we want

309
00:13:18,500 --> 00:13:22,300
to update that variable in closing scope.

310
00:13:22,300 --> 00:13:24,220
So I'm doing basically the same thing as before.

311
00:13:24,220 --> 00:13:27,380
I've just switched things around a little bit so that the outer function becomes two

312
00:13:27,380 --> 00:13:28,640
different functions.

313
00:13:28,640 --> 00:13:29,800
And why do I want to do that?

314
00:13:29,800 --> 00:13:33,620
Because I need to have the decorated function here, not at the outer level, but in the middle

315
00:13:33,620 --> 00:13:37,860
level, and then I want to have the decorator itself there that takes the argument, and

316
00:13:37,860 --> 00:13:41,380
then I'm going to have the return values from each of my other functions.

317
00:13:41,380 --> 00:13:46,020
And the combination of the four different decorators here gives me exactly what I want.

318
00:13:46,020 --> 00:13:50,300
And we can think about this once again in terms of time, that this outer function, outermost

319
00:13:50,300 --> 00:13:52,500
function, runs once when we get the argument.

320
00:13:52,500 --> 00:13:55,700
The second function executes once when we decorate the function.

321
00:13:55,700 --> 00:14:00,060
And once again, our wrapper, our middle function, runs as many times as we want to invoke our

322
00:14:00,060 --> 00:14:01,140
function.

323
00:14:01,140 --> 00:14:03,640
And once we do this, well, does this work?

324
00:14:03,640 --> 00:14:04,800
Now I'm going to run it, right?

325
00:14:04,800 --> 00:14:07,580
Slow out of two and two and slow out of three and three, and I put a limit there of I think

326
00:14:07,580 --> 00:14:08,900
it was five seconds.

327
00:14:08,900 --> 00:14:10,100
So now I'm going to have four once again.

328
00:14:10,100 --> 00:14:13,800
And now once again, I'm going to get an error because too little time has passed.

329
00:14:13,800 --> 00:14:15,340
But now that timing is variable.

330
00:14:15,340 --> 00:14:19,380
So I can say this function can only run every minute, but that function can run every two

331
00:14:19,380 --> 00:14:22,980
minutes, and this function can run every 30 seconds, whatever I want.

332
00:14:22,980 --> 00:14:24,340
OK.

333
00:14:24,340 --> 00:14:25,340
Another example.

334
00:14:25,340 --> 00:14:29,260
Memo-ization, not memo-ization.

335
00:14:29,260 --> 00:14:31,140
That would be easy to spell and say.

336
00:14:31,140 --> 00:14:34,540
Instead it's memo-ization, which is one of these things you learn about a computer science

337
00:14:34,540 --> 00:14:38,660
class and then forget unless you're a nasty instructor like me.

338
00:14:38,660 --> 00:14:41,100
But memo-ization actually is not a new technique at all.

339
00:14:41,100 --> 00:14:42,300
I just looked it up to find out.

340
00:14:42,300 --> 00:14:44,320
It's more than 50 years old.

341
00:14:44,320 --> 00:14:50,220
And the idea is basically if I have a function whose arguments always lead to the same value,

342
00:14:50,220 --> 00:14:51,340
always lead to the same result.

343
00:14:51,340 --> 00:14:54,460
So think of basic mathematical functions, you know, adding and multiplying and dividing,

344
00:14:54,460 --> 00:14:55,460
all that.

345
00:14:55,460 --> 00:14:58,140
If I add two and two, the next time I add two and two, it would be better before once

346
00:14:58,140 --> 00:14:59,140
again.

347
00:14:59,140 --> 00:15:01,940
It's not going to change on me unless we've got some really big problems.

348
00:15:01,940 --> 00:15:05,820
So basically wouldn't it be nice if every time I would take a look at my arguments,

349
00:15:06,820 --> 00:15:09,500
And if I've seen these arguments before for this function, just return the cached value

350
00:15:09,500 --> 00:15:10,660
from the previous time.

351
00:15:10,660 --> 00:15:11,660
Why run the function?

352
00:15:11,660 --> 00:15:14,740
Now, it's pretty stupid to do this for addition and multiplication, I admit.

353
00:15:14,740 --> 00:15:17,700
But if you have something a little harder, a little longer, right, even take like, you

354
00:15:17,700 --> 00:15:21,420
know, SHA-1 or RSA or something like that, you know, then you might want to actually

355
00:15:21,420 --> 00:15:22,420
do this sort of caching.

356
00:15:22,420 --> 00:15:23,900
So how are we going to do this?

357
00:15:23,900 --> 00:15:26,220
Well, I'm going to define memoize.

358
00:15:26,220 --> 00:15:27,220
That's going to be my decorator.

359
00:15:27,220 --> 00:15:28,260
It's going to take a function.

360
00:15:28,260 --> 00:15:30,380
And right up there at the top, I'm going to define a cache.

361
00:15:30,380 --> 00:15:32,620
How are we going to cache something in Python?

362
00:15:32,620 --> 00:15:35,100
I'm going to use a dictionary because we love dictionaries and we'll use them wherever we

363
00:15:35,140 --> 00:15:37,260
possibly can.

364
00:15:37,260 --> 00:15:38,900
So basically what's going to happen here?

365
00:15:38,900 --> 00:15:40,900
I'm going to set up my cache to be a dictionary.

366
00:15:40,900 --> 00:15:43,300
I'm then going to take a look at splat args.

367
00:15:43,300 --> 00:15:45,660
Well, args is defined to be a tuple.

368
00:15:45,660 --> 00:15:47,700
And so I can say, hey, take a look at these arguments.

369
00:15:47,700 --> 00:15:49,780
Have we seen these arguments before?

370
00:15:49,780 --> 00:15:53,980
If not, let's run the function with all the arguments, take the results, stick it into

371
00:15:53,980 --> 00:15:54,980
our dictionary.

372
00:15:54,980 --> 00:15:59,460
And then I know after running this if statement, no matter what, I have the result from this

373
00:15:59,460 --> 00:16:00,460
function.

374
00:16:00,460 --> 00:16:01,820
Fancy, huh?

375
00:16:01,820 --> 00:16:03,740
So now I can take the decorated function.

376
00:16:03,740 --> 00:16:04,740
I've got the decorator.

377
00:16:04,780 --> 00:16:06,260
I'm returning it back.

378
00:16:06,260 --> 00:16:07,260
Everything is great.

379
00:16:07,260 --> 00:16:10,580
And indeed, if I want to think about it in terms of my timing thing, this is running

380
00:16:10,580 --> 00:16:12,580
once and this is running multiple times.

381
00:16:12,580 --> 00:16:17,100
You might be saying, wait a second, didn't he say we have to use nonlocal if we're accessing

382
00:16:17,100 --> 00:16:18,980
variables in the outer scope?

383
00:16:18,980 --> 00:16:21,860
And indeed, I did say that sort of kind of almost.

384
00:16:21,860 --> 00:16:25,860
Basically if I'm assigning to the variable in the external scope and in the closing scope,

385
00:16:25,860 --> 00:16:27,540
then I have to worry about it.

386
00:16:27,540 --> 00:16:31,660
But if I'm just saying cache square brackets, then I'm accessing the variable.

387
00:16:31,660 --> 00:16:32,660
I don't need to worry about it.

388
00:16:32,660 --> 00:16:35,260
So long as I'm not saying cache equals, I'm all set.

389
00:16:35,260 --> 00:16:36,860
I don't need to use nonlocal.

390
00:16:36,860 --> 00:16:38,660
So actually this works pretty well.

391
00:16:38,660 --> 00:16:40,220
Let's take a look just in case.

392
00:16:40,220 --> 00:16:41,860
So we'll do memoize of add.

393
00:16:41,860 --> 00:16:46,540
And notice here that my add and multiply, multiple functions are going to say when they're

394
00:16:46,540 --> 00:16:47,540
running, right?

395
00:16:47,540 --> 00:16:49,140
They're going to sort of declare to the world because that's what we want to do when we

396
00:16:49,140 --> 00:16:53,560
add numbers, find out the computer is adding numbers because it's a pretty rare operation.

397
00:16:53,560 --> 00:16:55,820
So now I'm going to say add of three and seven and multiple of three and seven.

398
00:16:55,820 --> 00:16:56,820
I'm going to do each of those twice.

399
00:16:56,820 --> 00:17:02,100
So the first time we're going to see then that when I add, look, memoize notices that

400
00:17:02,100 --> 00:17:04,660
I haven't gotten this back before, so I'd better run the function.

401
00:17:04,660 --> 00:17:07,740
Then I run the function and then I get the result back.

402
00:17:07,740 --> 00:17:10,500
And then moal once again, right, it's going to be the same sort of thing, caching the

403
00:17:10,500 --> 00:17:12,780
new value, running moal.

404
00:17:12,780 --> 00:17:16,380
And now the second time I run add, it's going to say, wait, I already have that result.

405
00:17:16,380 --> 00:17:18,100
I'm not going to run the function at all.

406
00:17:18,100 --> 00:17:20,020
So just sidesteps the function altogether.

407
00:17:20,020 --> 00:17:21,180
And the same thing is true for moal.

408
00:17:21,180 --> 00:17:25,820
And notice then even though I have exactly the same arguments here, because it's separate

409
00:17:25,820 --> 00:17:27,140
functions, they have different decorators.

410
00:17:27,140 --> 00:17:29,860
Different decorators means that their caches are completely separate from one another.

411
00:17:29,900 --> 00:17:32,740
I don't need to worry about them stepping on one another.

412
00:17:32,740 --> 00:17:33,740
That's pretty great.

413
00:17:33,740 --> 00:17:36,260
But some of you are probably saying, wait a second.

414
00:17:36,260 --> 00:17:38,820
What if ours contains a non-hashable value?

415
00:17:38,820 --> 00:17:39,820
And what about kwrgs?

416
00:17:39,820 --> 00:17:42,020
You just ignored it and that's hurting its feelings.

417
00:17:42,020 --> 00:17:44,340
And kwrgs does not take kindly to that.

418
00:17:44,340 --> 00:17:45,900
So what should I do about that?

419
00:17:45,900 --> 00:17:47,820
Well, I could cry.

420
00:17:47,820 --> 00:17:50,820
Or I could remember that we've got pickle.

421
00:17:50,820 --> 00:17:53,620
And pickle gets me out of this pickle, as it were.

422
00:17:53,620 --> 00:17:56,940
Pickle basically says, I'm going to take a Python data structure and turn it into a

423
00:17:56,940 --> 00:17:58,340
string or into a byte string.

424
00:17:58,380 --> 00:18:00,740
And byte strings are, of course, hashable.

425
00:18:00,740 --> 00:18:02,980
So what I'm going to do is I'm going to pickle args.

426
00:18:02,980 --> 00:18:03,980
I'm going to pickle kwrgs.

427
00:18:03,980 --> 00:18:07,140
I'm going to stick them into a tuple, because I can stick them into a tuple.

428
00:18:07,140 --> 00:18:09,900
And then I'm going to use those as my cache key.

429
00:18:09,900 --> 00:18:14,060
So now I'm going to take args and kwrgs, cache, put each of them in pickle, use that.

430
00:18:14,060 --> 00:18:15,860
And I'm going to say, hey, have we seen this before?

431
00:18:15,860 --> 00:18:19,620
And then every unique combination of args and kwrgs is being cached.

432
00:18:19,620 --> 00:18:20,900
And then I can check for that.

433
00:18:20,900 --> 00:18:24,260
And then we'll always return the caching of t.

434
00:18:24,260 --> 00:18:26,220
Last example, attributes.

435
00:18:26,220 --> 00:18:30,300
So attributes are, of course, what we have on all sorts of objects in Python, but especially

436
00:18:30,300 --> 00:18:32,780
when we're dealing with classes and objects.

437
00:18:32,780 --> 00:18:35,100
So methods are attributes in the class.

438
00:18:35,100 --> 00:18:37,900
And every time we create an instance, we have Dunder init.

439
00:18:37,900 --> 00:18:42,020
On Dunder init, I'm going to set all sorts of data there.

440
00:18:42,020 --> 00:18:46,900
What if I want to have a whole bunch of different classes that have the same attribute, especially

441
00:18:46,900 --> 00:18:47,900
the same method?

442
00:18:47,900 --> 00:18:50,620
Well, you might say, oh, well, obviously, then I should use inheritance.

443
00:18:50,620 --> 00:18:54,700
Yeah, but inheritance is only really appropriate when the objects are similar, when the classes

444
00:18:54,700 --> 00:18:56,100
are similar to one another.

445
00:18:56,140 --> 00:19:00,220
But if I have very distinct classes, but I still want them to have similar behavior,

446
00:19:00,220 --> 00:19:01,500
then it's not so easy.

447
00:19:01,500 --> 00:19:05,300
So I could do it with attributes.

448
00:19:05,300 --> 00:19:06,940
I could do it with inheritance.

449
00:19:06,940 --> 00:19:09,500
And I could even use multiple inheritance now.

450
00:19:09,500 --> 00:19:12,900
The only problem with multiple inheritance is, as you know, there are two opinions about

451
00:19:12,900 --> 00:19:14,340
multiple inheritance.

452
00:19:14,340 --> 00:19:15,980
Some people think that it's terrible.

453
00:19:15,980 --> 00:19:19,460
And some people think it's the worst thing ever created on earth.

454
00:19:19,460 --> 00:19:23,380
So no matter where you stand on this debate, I think we can sort of sidestep it and say,

455
00:19:23,380 --> 00:19:25,900
fine, let's just assume we're not going to use inheritance at all.

456
00:19:25,900 --> 00:19:29,260
How can I use a decorator to basically add this sort of thing?

457
00:19:29,260 --> 00:19:31,620
So here I have my better wrapper.

458
00:19:31,620 --> 00:19:36,860
And I must say, one of the things that I most love about data classes in Python 3.7 is that

459
00:19:36,860 --> 00:19:37,860
the wrapper is improved.

460
00:19:37,860 --> 00:19:38,940
So it's actually usable.

461
00:19:38,940 --> 00:19:41,340
The current wrapper is, well, not so great.

462
00:19:41,340 --> 00:19:43,620
So here I'm going to define fancy wrapper.

463
00:19:43,620 --> 00:19:47,420
And it's going to return a string that says, I'm a whatever, type self, with vars of varself.

464
00:19:47,420 --> 00:19:48,500
Fantastic.

465
00:19:48,500 --> 00:19:51,100
So how am I going to decorate my class then to get this?

466
00:19:51,100 --> 00:19:52,300
Well, I'm going to do this.

467
00:19:52,300 --> 00:19:55,060
I'm going to define better wrapper of C.

468
00:19:55,060 --> 00:19:56,500
And so C is going to be a class.

469
00:19:56,500 --> 00:19:58,820
Notice, now I'm decorating a class.

470
00:19:58,820 --> 00:20:00,260
But it's a callable, so who cares?

471
00:20:00,260 --> 00:20:01,260
It's fine.

472
00:20:01,260 --> 00:20:02,820
So here I've got my class.

473
00:20:02,820 --> 00:20:03,820
Here's my decorator.

474
00:20:03,820 --> 00:20:04,820
And what am I going to have inside?

475
00:20:04,820 --> 00:20:08,140
Well, I'm going to assign C.dunder wrapper equals fancy wrapper.

476
00:20:08,140 --> 00:20:10,700
I'm changing the method inside the class.

477
00:20:10,700 --> 00:20:11,700
Great.

478
00:20:11,700 --> 00:20:15,020
And of course, I'm going to return wrapper because I have to return a callable.

479
00:20:15,020 --> 00:20:17,620
But you might be thinking, wait a second, this wrapper is doing nothing.

480
00:20:17,620 --> 00:20:18,620
That's OK.

481
00:20:18,620 --> 00:20:21,060
There are lots of people who do nothing, and we don't complain about them too much.

482
00:20:21,060 --> 00:20:22,780
So basically, I've got wrapper here.

483
00:20:22,780 --> 00:20:24,220
And wrapper takes r's and k, w, r's.

484
00:20:24,260 --> 00:20:27,300
But all we do is then pass it along to the class and return it to the new object.

485
00:20:27,300 --> 00:20:28,980
Really what I can do is just this.

486
00:20:28,980 --> 00:20:30,260
I can define better wrapper.

487
00:20:30,260 --> 00:20:31,260
It'll take the class.

488
00:20:31,260 --> 00:20:32,940
I'll just add the new method to it.

489
00:20:32,940 --> 00:20:34,940
Then I'll just return the class.

490
00:20:34,940 --> 00:20:35,940
Nothing wrong with that.

491
00:20:35,940 --> 00:20:36,940
Indeed, that works just fine.

492
00:20:36,940 --> 00:20:37,940
Here's my decorated class.

493
00:20:37,940 --> 00:20:38,940
Here's my decorator.

494
00:20:38,940 --> 00:20:39,940
Here's my callable.

495
00:20:39,940 --> 00:20:40,940
I don't need a function there.

496
00:20:40,940 --> 00:20:41,940
And does this work?

497
00:20:41,940 --> 00:20:42,940
Yeah, this works great.

498
00:20:42,940 --> 00:20:45,540
Because now if I print f, what am I going to get?

499
00:20:45,540 --> 00:20:48,860
I'm a fool with vars x10 and y10 2030.

500
00:20:48,860 --> 00:20:49,860
Fantastic.

501
00:20:49,860 --> 00:20:53,540
Well, that was great for setting a class attribute like a method here.

502
00:20:53,540 --> 00:20:55,780
Can we do that for instances of course?

503
00:20:55,780 --> 00:20:57,860
Can we do that for object instances also?

504
00:20:57,860 --> 00:20:58,860
Of course we can.

505
00:20:58,860 --> 00:20:59,860
It's Python.

506
00:20:59,860 --> 00:21:01,700
We can do anything.

507
00:21:01,700 --> 00:21:03,620
The world is putty in our fingers.

508
00:21:03,620 --> 00:21:05,020
So basically, what can I do?

509
00:21:05,020 --> 00:21:08,180
I'm going to give every object, every new instance its own birthday.

510
00:21:08,180 --> 00:21:10,140
Everyone deserves a birthday, including objects.

511
00:21:10,140 --> 00:21:14,060
So when I use the object birthday decorator, I'm going to add a new attribute here to each

512
00:21:14,060 --> 00:21:15,060
and every instance.

513
00:21:15,060 --> 00:21:18,020
And it's just going to be the timestamp at which we created the object.

514
00:21:18,020 --> 00:21:19,020
So what's going to happen?

515
00:21:19,020 --> 00:21:22,300
Well, object birthday, that's going to be my decorator.

516
00:21:22,300 --> 00:21:24,340
Notice here I'm not doing anything to the class.

517
00:21:24,340 --> 00:21:26,300
I'm not modifying the class.

518
00:21:26,300 --> 00:21:29,300
When do we have an opportunity to touch the instance?

519
00:21:29,300 --> 00:21:31,860
Well, remember that a decorator runs in two different stages.

520
00:21:31,860 --> 00:21:35,180
It runs when we create, when we decorate the object.

521
00:21:35,180 --> 00:21:38,740
And the inside stuff wrapper runs every time we execute the callable.

522
00:21:38,740 --> 00:21:41,820
Well, every time I execute the class, that means every time I create a new instance of

523
00:21:41,820 --> 00:21:43,000
the class, right?

524
00:21:43,000 --> 00:21:45,880
So wrapper is going to run each time I have a new instance.

525
00:21:45,880 --> 00:21:48,900
And when we have a new instance, now I'm actually going to use that syntax that I had before.

526
00:21:48,900 --> 00:21:50,460
I'm going to call the class with args and kwrs.

527
00:21:50,460 --> 00:21:52,260
I'm going to get a new object back.

528
00:21:52,300 --> 00:21:55,380
Then I'm going to stick a new attribute onto that object.

529
00:21:55,380 --> 00:21:56,380
What's it going to be?

530
00:21:56,380 --> 00:21:57,900
It's going to be created at time.time.

531
00:21:57,900 --> 00:22:00,240
And then I'm going to return the object.

532
00:22:00,240 --> 00:22:01,700
And here I have my decorated class.

533
00:22:01,700 --> 00:22:02,700
Here I have my decorator.

534
00:22:02,700 --> 00:22:03,780
Here I have what I'm returning.

535
00:22:03,780 --> 00:22:04,780
All is great.

536
00:22:04,780 --> 00:22:08,980
And indeed, if I run it now, if I have object birthday with class full, printf, well, now

537
00:22:08,980 --> 00:22:10,900
I've got my original wrapper.

538
00:22:10,900 --> 00:22:13,020
And print the birthday created at, fantastic.

539
00:22:13,020 --> 00:22:17,620
I've got the number of seconds since the 1st of January 1970.

540
00:22:17,620 --> 00:22:18,940
Let's do both.

541
00:22:18,980 --> 00:22:23,140
I'm going to define here a decorator that modifies the class to take a new method and

542
00:22:23,140 --> 00:22:25,340
modifies the object to get a new attribute.

543
00:22:25,340 --> 00:22:27,260
And here I'm modifying the class.

544
00:22:27,260 --> 00:22:29,180
And here I'm modifying the object.

545
00:22:29,180 --> 00:22:33,620
And I can do both inside of the same decorator because we think of these two different stages

546
00:22:33,620 --> 00:22:35,580
at which things run.

547
00:22:35,580 --> 00:22:39,720
So decorators are pretty cool and pretty exciting.

548
00:22:39,720 --> 00:22:42,060
First of all, decorators let's dry up our callables.

549
00:22:42,060 --> 00:22:44,340
Dry is this idea, don't repeat yourself.

550
00:22:44,340 --> 00:22:48,740
You don't want the same code to be happening more than once in your software.

551
00:22:48,740 --> 00:22:52,740
And I don't know about you, but on several occasions, okay, many occasions, too many

552
00:22:52,740 --> 00:22:57,060
occasions in my software career, I'd be like, you know, I'm just going to copy this code.

553
00:22:57,060 --> 00:23:00,980
What are the chances that I'll have to modify it in both places down the road?

554
00:23:00,980 --> 00:23:04,140
I can tell you right now, 100%.

555
00:23:04,140 --> 00:23:08,020
There's a 100% chance you will end up modifying the code in both places.

556
00:23:08,020 --> 00:23:09,020
Don't do it.

557
00:23:09,020 --> 00:23:12,820
And so if I can take code out of multiple functions, multiple classes that's the same

558
00:23:12,820 --> 00:23:16,740
and put into a decorator, I will be saving myself time down the road.

559
00:23:16,940 --> 00:23:21,980
Also, understanding how callables work is really central to this and it allows us to

560
00:23:21,980 --> 00:23:24,820
see how this all works together.

561
00:23:24,820 --> 00:23:28,300
Understanding how many callables are involved in our decorators, it lets us pick apart the

562
00:23:28,300 --> 00:23:31,340
decorator and say, oh, I'm going to take advantage of this part versus this part versus this

563
00:23:31,340 --> 00:23:34,260
part and really play with it in different ways.

564
00:23:34,260 --> 00:23:38,100
Decorators make it dramatically easier to do all sorts of different things.

565
00:23:38,100 --> 00:23:43,420
Basically, it lowers the bar to messing around with our functions and our objects in all

566
00:23:43,420 --> 00:23:44,660
sorts of different ways.

567
00:23:45,060 --> 00:23:46,980
You could argue maybe that's a problem, right?

568
00:23:46,980 --> 00:23:49,420
But in Python, we like to give people opportunity to do things.

569
00:23:49,420 --> 00:23:53,620
And things that previously required all sorts of black magic like meta classes, now we can

570
00:23:53,620 --> 00:23:56,420
just do with decorators that are much more understandable.

571
00:23:56,420 --> 00:24:01,740
And all this depends on the fact that in Python, functions and classes are just plain old objects.

572
00:24:01,740 --> 00:24:03,140
They're objects that everyone can use.

573
00:24:03,140 --> 00:24:04,140
They can pass them around.

574
00:24:04,140 --> 00:24:06,100
They can be returned.

575
00:24:06,100 --> 00:24:10,020
And so that lends itself to this amazing, amazing sort of behavior that we can take

576
00:24:10,020 --> 00:24:12,700
advantage of in all sorts of different ways.

577
00:24:12,700 --> 00:24:16,180
If you want, thanks to the magic of the internet, I think this should now be working.

578
00:24:16,180 --> 00:24:19,460
You can go to practicaldecorators.com and get the code and the slides from this talk.

579
00:24:19,460 --> 00:24:22,340
I think we have a few minutes for questions as well.

580
00:24:22,340 --> 00:24:23,980
I have a booth here for weekly Python exercise.

581
00:24:23,980 --> 00:24:24,980
You can email me.

582
00:24:24,980 --> 00:24:25,980
You can get me on Twitter.

583
00:24:25,980 --> 00:24:29,300
I'd be happy to talk to you after this about this or anything else.

584
00:24:29,300 --> 00:24:30,300
Thanks very much.

585
00:24:30,300 --> 00:24:46,420
At this point, if you have any questions, please line up at the microphones and ask

586
00:24:46,420 --> 00:24:47,420
the questions.

587
00:24:47,420 --> 00:24:48,420
I can't hear you.

588
00:24:48,420 --> 00:24:49,420
I'm sorry.

589
00:24:49,420 --> 00:24:50,420
You're still good.

590
00:24:50,420 --> 00:24:51,420
Oh, we have five minutes.

591
00:24:51,420 --> 00:24:52,420
So we have five minutes for questions.

592
00:24:52,420 --> 00:24:57,900
So if people have questions, problems, personal problems they want to share, I'm open to it

593
00:24:57,900 --> 00:24:58,900
all.

594
00:24:58,900 --> 00:24:59,900
Yeah, please.

595
00:25:00,020 --> 00:25:06,580
So you were talking before about the enclosing scopes.

596
00:25:06,580 --> 00:25:11,660
How is the enclosing scopes different from the concept of closures in JavaScript and

597
00:25:11,660 --> 00:25:13,500
other programming languages?

598
00:25:13,500 --> 00:25:16,660
So it's basically the same idea.

599
00:25:16,660 --> 00:25:22,260
Basically the idea then that the enclosing function stack frame sticks around even when

600
00:25:22,260 --> 00:25:26,780
the enclosing function does not stick around is exactly what allows us to do this.

601
00:25:27,780 --> 00:25:32,340
Basically what I'm teaching this sort of stuff with inner functions, I'll be like, by the

602
00:25:32,340 --> 00:25:34,220
way, this is known as a closure.

603
00:25:34,220 --> 00:25:37,900
And you'll have like a third of the people go, oh, and the other people say, huh?

604
00:25:37,900 --> 00:25:39,820
So it sort of depends on who learned this and who did not.

605
00:25:39,820 --> 00:25:40,820
So it's 100% the same?

606
00:25:40,820 --> 00:25:41,820
It should be.

607
00:25:41,820 --> 00:25:42,820
As far as I know, it's 100% the same.

608
00:25:42,820 --> 00:25:43,820
Yeah, absolutely.

609
00:25:43,820 --> 00:25:44,820
Thank you.

610
00:25:44,820 --> 00:25:45,820
Yeah, please.

611
00:25:45,820 --> 00:25:46,820
Hi.

612
00:25:46,820 --> 00:25:48,220
Thank you for the wonderful talk.

613
00:25:48,220 --> 00:25:53,220
I wanted to ask if you have any tips or gotchas when it comes to writing tests for decorators.

614
00:25:54,020 --> 00:25:56,900
Oh, I'm sure I do, and I can't think of any offhand.

615
00:25:56,900 --> 00:25:57,900
Let's go ahead.

616
00:25:57,900 --> 00:25:58,900
Thank you.

617
00:25:58,900 --> 00:25:59,900
Sorry.

618
00:25:59,900 --> 00:26:00,900
Yeah.

619
00:26:00,900 --> 00:26:05,300
When have you found it beneficial or detrimental to use functools.wraps?

620
00:26:05,300 --> 00:26:10,260
Oh, so as you might be able to tell, I'm a dinosaur.

621
00:26:10,260 --> 00:26:15,380
And so that's actually very, like basically every software I'm like, oh, I should probably

622
00:26:15,380 --> 00:26:19,340
use functools.wraps because it does a lot of this stuff sort of for you that you don't

623
00:26:19,340 --> 00:26:20,340
need to play with it.

624
00:26:20,340 --> 00:26:24,220
I must admit that I'm not as familiar with it as I should be, but the idea is basically

625
00:26:24,220 --> 00:26:28,180
to lower the bar even more and make it easier to do some of this stuff so you don't need

626
00:26:28,180 --> 00:26:29,740
to be thinking in all these different scopes.

627
00:26:29,740 --> 00:26:31,180
Yeah, please.

628
00:26:31,180 --> 00:26:32,180
Hi.

629
00:26:32,180 --> 00:26:35,260
So from the Zen of Python, flat is better than nested.

630
00:26:35,260 --> 00:26:40,660
And from like the three nested functions, that sort of goes against it.

631
00:26:40,660 --> 00:26:46,140
Do you have any thoughts about using functools partial to sort of get rid of those nests,

632
00:26:46,140 --> 00:26:47,860
or have you experimented with that?

633
00:26:47,860 --> 00:26:51,140
So I'll tell you, I really like the idea of functools partial.

634
00:26:51,140 --> 00:26:56,980
It's super cool and fun, and yet I find that for many people, it's just like extra confusing.

635
00:26:56,980 --> 00:27:00,500
Like it adds another layer of, wait, what do you mean partial function?

636
00:27:00,500 --> 00:27:02,300
Like some of it works and some of it doesn't.

637
00:27:02,300 --> 00:27:07,580
I'll tell you, sometimes when I introduce decorators, I use not multiple functions, but

638
00:27:07,580 --> 00:27:10,260
I use classes because then you can have init.

639
00:27:10,260 --> 00:27:13,860
Init is sort of like the outer function, and call, under call is the inner function.

640
00:27:13,860 --> 00:27:15,860
And then you have this very clear separation.

641
00:27:15,860 --> 00:27:19,780
It's not nested, but you're like, oh, this happens once, this happens many times.

642
00:27:19,780 --> 00:27:24,700
The problem is you can't use class decorators to decorate certain things like methods.

643
00:27:24,700 --> 00:27:28,140
So I'm, shall we say, partial on functools partial.

644
00:27:28,140 --> 00:27:29,140
Thank you.

645
00:27:29,140 --> 00:27:30,140
All right.

646
00:27:30,140 --> 00:27:31,140
Yeah.

647
00:27:31,140 --> 00:27:35,540
You had some pretty harsh things to say about static variables, but it's unclear to me how

648
00:27:35,540 --> 00:27:41,260
sort of the variables embedded at the one time execution step are going to avoid any

649
00:27:41,260 --> 00:27:44,020
of the pitfalls of static variables.

650
00:27:44,020 --> 00:27:49,100
And I think a similar thing could be applied to multiple annotation versus multiple inheritance.

651
00:27:49,100 --> 00:27:50,100
All right.

652
00:27:50,100 --> 00:27:53,780
So first of all, I actually have nothing against static variables.

653
00:27:53,780 --> 00:27:56,780
Some of my best friends are static variables.

654
00:27:56,780 --> 00:27:57,780
No.

655
00:27:57,780 --> 00:28:01,500
It's just that in Python we tend to think it's a dynamic language, so the word static tends

656
00:28:01,500 --> 00:28:03,300
to be something that I shy away from.

657
00:28:03,300 --> 00:28:06,860
I actually think that it would be nice and useful to have something like that available

658
00:28:06,860 --> 00:28:08,980
to us, but it doesn't exist.

659
00:28:08,980 --> 00:28:12,140
The best we can do is the enclosing function sort of thing.

660
00:28:12,140 --> 00:28:13,140
Yeah.

661
00:28:13,140 --> 00:28:14,140
Yeah.

662
00:28:14,140 --> 00:28:16,980
So, wait, is this working?

663
00:28:16,980 --> 00:28:22,700
When you're writing class decorators, how do you decide between modifying attributes

664
00:28:22,700 --> 00:28:29,020
after they're created, modifying instances after they're created versus wrapping functions

665
00:28:29,020 --> 00:28:31,100
on the class like init?

666
00:28:31,100 --> 00:28:35,220
In particular, it stood out to me that you get less efficient attribute access if you're

667
00:28:35,220 --> 00:28:38,420
adding attributes after init has completed.

668
00:28:38,420 --> 00:28:42,420
I couldn't tell you about the efficiency of it.

669
00:28:42,420 --> 00:28:43,980
Good thinking idea.

670
00:28:43,980 --> 00:28:47,820
I really had never thought about the idea of decorating init so that you don't have

671
00:28:47,820 --> 00:28:49,180
to add the attributes there.

672
00:28:49,180 --> 00:28:54,260
Again, I don't have a good answer for you, but that's excellent food for thought.

673
00:28:54,260 --> 00:28:57,260
No more questions?

674
00:28:57,260 --> 00:28:58,260
Ha!

675
00:28:58,260 --> 00:28:59,260
I must not be in Israel.

676
00:28:59,260 --> 00:29:00,260
All right.

677
00:29:00,260 --> 00:29:04,940
Well, if people have more questions or comments, I'm happy to talk to you afterwards, and thanks

678
00:29:04,940 --> 00:29:05,940
very much.

679
00:29:05,940 --> 00:29:07,300
Thank you very much.

