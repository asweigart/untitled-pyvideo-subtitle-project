1
00:00:00,000 --> 00:00:15,160
Okay. Thanks for coming to this tutorial. Python by immersion at PyCon 2019. The survey

2
00:00:15,160 --> 00:00:21,120
link is here. Please fill it out afterwards. And the Jupyter Notebook link is there. It's

3
00:00:21,120 --> 00:00:24,240
a set of Jupyter Notebooks. I'll be running them individually because the one that has

4
00:00:24,240 --> 00:00:32,160
all the Jupyter Notebooks combined is really big and slow. I'm going to give you lots of

5
00:00:32,160 --> 00:00:36,000
information in three hours. You're not going to understand all of it. You're not going

6
00:00:36,000 --> 00:00:41,600
to remember all of it. You might start to feel bad because I'm going so fast and think

7
00:00:41,600 --> 00:00:49,560
that I should slow down. But my goal is, my thinking is, I would like learning a language

8
00:00:49,560 --> 00:00:56,560
by immersion. I'm just going to show you lots of things. And my theory is, and I hope this

9
00:00:56,920 --> 00:01:01,640
is true for you, is that in a few weeks or a couple months when you're doing something

10
00:01:01,640 --> 00:01:05,200
and you go, oh, yeah, I wonder if there's a function that, there's got to be a function

11
00:01:05,200 --> 00:01:08,560
that does and then you'll be thinking of some problem you're trying to solve. And the reason

12
00:01:08,560 --> 00:01:13,240
you'll know that is because you saw it and kind of got a sense for the language today

13
00:01:14,240 --> 00:01:19,000
in over a thousand lines of Python code that I'm going to show you. Okay? So this is a

14
00:01:19,000 --> 00:01:24,440
broad overview. Don't write down the details. They're in the notebook. You can look at them.

15
00:01:24,440 --> 00:01:29,320
The pattern is I will show you. I'll lecture and demonstrate some of the code and talk

16
00:01:29,320 --> 00:01:33,640
about some things and then I'll let you do some exercises. Most of you won't finish the

17
00:01:33,640 --> 00:01:40,640
exercises. I will stop and move on when maybe half of you have finished in general. And

18
00:01:40,640 --> 00:01:43,520
you can go back and look at them. But I'm not just going to skip past. I'll actually

19
00:01:43,520 --> 00:01:49,760
go through the exercises and show you what to look for. When you're doing the exercises,

20
00:01:49,760 --> 00:01:55,920
you'll find that the ones later on, they sort of ramp up sometimes in complexity and difficulty

21
00:01:55,920 --> 00:01:59,900
because I want everyone to sort of, even those who are really fast with that, to still be

22
00:01:59,900 --> 00:02:05,080
engaged and not just sit there twiddling their thumbs. When you do the exercises, and I'll

23
00:02:05,080 --> 00:02:10,600
remind you of this later, don't just hit shift enter to see what it does. The point is, you

24
00:02:10,680 --> 00:02:15,720
know, I want to help you learn to think about how Python is working. Because if you understand

25
00:02:15,720 --> 00:02:20,920
that layer, then where you're working in Python, whenever you're working in any layer of abstraction,

26
00:02:20,920 --> 00:02:24,400
understanding what's going on sort of the layer below is really helpful. You know, if

27
00:02:24,400 --> 00:02:27,440
you're riding a bike and you've done your own maintenance on it, it's just going to

28
00:02:27,440 --> 00:02:34,440
work better. Same for other, you know, cars, et cetera. I'm running Python 3.6. If you're

29
00:02:35,440 --> 00:02:41,520
running 2.7, you'll see a few weird things. I think that's all. Oh, and the last thing

30
00:02:41,520 --> 00:02:48,080
is I will, the first 10 to 15 minutes, some of you will, might want to leave because it's

31
00:02:48,080 --> 00:02:53,160
going so slow and it's so boring and you already know it. It's going to get faster, okay? And

32
00:02:53,160 --> 00:02:57,680
I do that first part really slow intentionally because I want to, especially those of you

33
00:02:57,680 --> 00:03:02,000
coming from a different language, I want to change your way of thinking about how Python

34
00:03:02,000 --> 00:03:08,120
works from what it probably is even if you don't know it, or at least it may be. All

35
00:03:08,120 --> 00:03:15,120
right, so let's get started with the actual stuff, the actual content here. So, objects,

36
00:03:17,280 --> 00:03:24,280
let's just first see what version I'm running, Anaconda 368. Okay, so here's the first really

37
00:03:24,360 --> 00:03:31,000
slow boring part. What happens when you type one, hit the one on your keyboard and then

38
00:03:31,000 --> 00:03:36,720
hit shift enter in Jupyter Notebook or JupyterLab or you hit enter at the REPL, the read, eval,

39
00:03:36,720 --> 00:03:43,720
print loop, which guess what it does? It reads what you typed, it eval, it evaluates it,

40
00:03:44,200 --> 00:03:47,400
it prints it out for you, the value of the expression, and it does that over and over

41
00:03:47,400 --> 00:03:52,400
again. That's why it's called the read, eval, print loop. It's the REPL. So, when you hit

42
00:03:52,400 --> 00:03:58,840
type one and hit enter, what happens is Python, and I'm going to show you this picture over

43
00:03:58,840 --> 00:04:03,280
here. Python goes over here in memory, and I'll sort of use this side of the room. This

44
00:04:03,280 --> 00:04:07,680
is like memory where Python has all its objects. It goes off here and it allocates a chunk

45
00:04:07,680 --> 00:04:12,960
of memory and it, well first of all, it parses that and says, oh, okay, I know what that

46
00:04:12,960 --> 00:04:17,080
is. That's an integer literal, meaning it represents an integer and it's literally,

47
00:04:17,080 --> 00:04:23,980
it's typed as an integer. It goes off and either finds or creates an object that represents

48
00:04:23,980 --> 00:04:29,020
the integer one. I put a hundred here, but the point is it represents an integer, right?

49
00:04:29,020 --> 00:04:34,340
And that integer is not just 64 bits in length or depending on whatever hardware you're running.

50
00:04:34,340 --> 00:04:39,620
It's actually bigger because it's got some pointers to some other things. It's got a

51
00:04:39,620 --> 00:04:46,620
pointer here down to the type int, and it's got something over here which is a, which

52
00:04:47,500 --> 00:04:54,500
has a one, which is the ref count, how many names are bound to that object. And I don't

53
00:04:54,700 --> 00:04:57,740
know exactly what's in there. I haven't looked, but the point is it's got a few more things,

54
00:04:57,740 --> 00:05:04,740
and these are the two that we'll care about. Then it's done. It created the object. Everything

55
00:05:07,700 --> 00:05:12,620
in Python is an object. It created the object, and because it's the read eval print loop,

56
00:05:12,620 --> 00:05:19,620
it prints the value of that object. And so what you get back on the output is a one,

57
00:05:19,620 --> 00:05:24,700
right? So that one right there where it says cell three, that's the, in Jupyter Notebook

58
00:05:24,700 --> 00:05:29,260
by the way, in case you're not used to it, the in is cell three and out, so the input,

59
00:05:29,260 --> 00:05:33,220
what you typed in, what you get back out. What you get back out is a visual representation

60
00:05:33,220 --> 00:05:38,220
of the object or the expression, the value of the expression, which is always an object,

61
00:05:38,220 --> 00:05:45,220
okay? So when we see 3.14, that's a float literal, I want you to think of all those

62
00:05:46,140 --> 00:05:52,900
things that just happened, okay? Any questions about that? Okay. So you create objects in

63
00:05:52,900 --> 00:05:59,900
Python. You can do them with literals like ints and floats and strings and lists and

64
00:06:00,340 --> 00:06:07,340
tuples. Those are some of the basic types, not all of them. Everything in Python at run

65
00:06:07,980 --> 00:06:14,340
time is an object, and it has a single value, it has a single type, it has some number of

66
00:06:14,340 --> 00:06:19,380
attributes, one or more base classes, a single ID, and it has some names. So let's look at

67
00:06:19,380 --> 00:06:24,020
those and I'll start to speed up a little bit. So I'll go a little faster, but I'm

68
00:06:24,020 --> 00:06:28,380
going to slow down occasionally again. Oh, look, I'm going to slow down here. So type

69
00:06:28,380 --> 00:06:35,380
one, what happens here is Python sees the name type and it looks in something that's

70
00:06:35,380 --> 00:06:42,060
a lot like a dictionary with key value pairs. And the keys are the names, like somewhere

71
00:06:42,060 --> 00:06:49,060
in here it looks for the word type, the t-y-p-e, the string, and if it finds it, then it dereferences

72
00:06:49,420 --> 00:06:54,540
it, there's the value, it goes and looks for the object which the name type is bound

73
00:06:54,540 --> 00:06:59,860
to and then it takes that object, it goes and sees the one and says, oh, I've got to

74
00:06:59,860 --> 00:07:05,220
go create or maybe reuse an integer literal, an integer one. So it goes off and creates,

75
00:07:05,220 --> 00:07:07,820
maybe it creates another one even though it threw, because it might have thrown the

76
00:07:07,820 --> 00:07:13,500
earlier one away, and then it takes, then it calls the type object which is callable,

77
00:07:13,500 --> 00:07:19,540
it's like a function, and it passes a reference, like the arrow part, off to that type function

78
00:07:19,540 --> 00:07:25,100
and type does something and then it returns a new object or an object. And that object

79
00:07:25,100 --> 00:07:30,700
that gets returned is then displayed, that's the print part, okay? So what happens there

80
00:07:30,700 --> 00:07:37,140
is we get the letters i-n-t, okay? Well that's because i-n-t happens to be a name that Python

81
00:07:37,140 --> 00:07:41,420
knows about and so it shows it to you as the name. So it doesn't, can't show you the bits

82
00:07:41,420 --> 00:07:48,420
in here, it shows you the name that it knows, okay? Alright. So we can check the type and

83
00:07:50,820 --> 00:07:56,300
what type does in this case, you pass an object, it returns what type the object is, right?

84
00:07:56,300 --> 00:08:01,220
So some people say Python is not a strongly typed language, it's not typed at all, it

85
00:08:01,220 --> 00:08:04,860
actually is strongly typed, very strongly typed and it's dynamically typed which means

86
00:08:04,860 --> 00:08:11,220
we don't declare upfront what the type is associated with a name, instead we create

87
00:08:11,220 --> 00:08:16,540
objects and those objects know their own type and then we just bind a name to the object.

88
00:08:16,540 --> 00:08:20,820
So the name has no type information stored in it, the name only refers to the object,

89
00:08:20,820 --> 00:08:25,860
the object has the type information, okay? Name binding which I've shown here as sort

90
00:08:25,860 --> 00:08:32,300
of the way it's implemented, a good way to think about that is post-its, right? So you

91
00:08:32,300 --> 00:08:38,260
can call me teacher, there's a post-it that says teacher, right? My kids call me dad,

92
00:08:38,260 --> 00:08:43,180
there's a post-it that says dad, right? My wife calls me husband or spouse or partner

93
00:08:43,180 --> 00:08:48,140
or steward or whatever, I mean the point is I've got lots of labels on me and some of

94
00:08:48,140 --> 00:08:54,020
you are probably dads and your kids call you dad, they don't call me dad so the same name

95
00:08:54,020 --> 00:09:01,020
can be reused as long as the context tells you how it distinguishes it, makes it unambiguous.

96
00:09:01,020 --> 00:09:08,020
Okay, so let's look at the type of the string spam, it's str, list, tuple. Objects have

97
00:09:10,340 --> 00:09:16,580
attributes, here's some examples, right? So attributes, in this case true is a built-in

98
00:09:16,580 --> 00:09:22,260
name that references an object and that object has a dunder doc attribute, double underscore

99
00:09:22,260 --> 00:09:27,700
doc double underscore is pronounced dunder doc, so if you haven't heard that, that's

100
00:09:27,700 --> 00:09:33,860
what I'm saying, that's what it refers to. So I can access the attribute of an object

101
00:09:33,860 --> 00:09:40,860
just by putting a dot and another name. So just like I have global names like true and

102
00:09:43,860 --> 00:09:48,780
print and type and then we'll see how to create our own later, an object has its own

103
00:09:48,820 --> 00:09:55,260
set of names, right? So imagine a table like this in an object, so dunder doc is one of

104
00:09:55,260 --> 00:10:02,260
the names inside the object, right? So that's a long string with some new lines in it looks

105
00:10:02,740 --> 00:10:08,260
like, I can actually print that thing and you get the documentation. So when you look

106
00:10:08,260 --> 00:10:13,780
in the documentation in your editor and say show me the documentation for this object,

107
00:10:13,780 --> 00:10:17,820
it's going to go and ask the object and display it to you. So the documentation for a python

108
00:10:17,820 --> 00:10:20,780
object is built into the runtime.

109
00:10:20,780 --> 00:10:27,780
Alright, there's another attribute, spam dot upper, here we got a less than functions

110
00:10:28,260 --> 00:10:35,260
str dot upper greater than, those angle brackets are the way python, it's the convention that

111
00:10:35,660 --> 00:10:42,660
python uses to display an object where you can't type it back in, right? So this string,

112
00:10:43,660 --> 00:10:50,660
you could put that back into the repl and you would create a new string object. The

113
00:10:53,620 --> 00:10:58,940
type tuple, the type of that tuple is tuple, you could type tuple and it refers to the

114
00:10:58,940 --> 00:11:05,940
object in the repl so it works. The function, sorry, the function str dot upper, you can't

115
00:11:06,620 --> 00:11:12,740
type that function in, it can't easily represent that function because it's implemented in

116
00:11:12,740 --> 00:11:16,500
C in a way that you could type it back in and make it work. So it puts the angle brackets

117
00:11:16,500 --> 00:11:20,080
around it, so that's what those mean.

118
00:11:20,080 --> 00:11:27,080
So this one is callable, alright, so what's going on here? Alright, so python sees the

119
00:11:27,820 --> 00:11:33,740
string literal, goes off and creates a string object, it uses the dot, the dot tells it

120
00:11:33,780 --> 00:11:37,180
I want to get the upper attribute of it so it goes ask the object for that attribute,

121
00:11:37,180 --> 00:11:43,220
then it takes the object, it gets back, looks up callable to find an object, passes a reference

122
00:11:43,220 --> 00:11:49,260
to that object, the upper function, off to the callable function and it returns a new

123
00:11:49,260 --> 00:11:54,100
object, right? All this stuff is happening every time you do a simple expression, okay?

124
00:11:54,100 --> 00:12:01,100
And callable is yes or no? Can I call this thing? The answer is yes, so let's try to

125
00:12:01,100 --> 00:12:08,100
call it and what happened there is the function returned a new object, the upper function

126
00:12:09,340 --> 00:12:15,100
which is actually called a method because it's a call on an object and it returns a

127
00:12:15,100 --> 00:12:20,540
new string, right? It didn't actually change the string SPAM to capital SPAM, that old

128
00:12:20,540 --> 00:12:24,780
one still exists or could, it creates a new string, okay?

129
00:12:24,780 --> 00:12:31,780
By the way, SPAM and eggs are sort of the standard junk variable names or variable names

130
00:12:31,820 --> 00:12:38,180
and I'll use them in here because of Monty Python. Objects have base classes, this is

131
00:12:38,180 --> 00:12:45,180
the boring part, we're about halfway through it, how many people think I'm going too slow?

132
00:12:46,260 --> 00:12:52,020
How many people think I'm going too fast? Okay, and I'll revisit some of this, you

133
00:12:52,020 --> 00:12:56,740
don't have to memorize all this stuff, I'll remind you, maybe more than you want. Objects

134
00:12:56,740 --> 00:13:01,500
have base classes, so let's import the inspect module, we'll talk about what that does later

135
00:13:01,500 --> 00:13:06,620
and we'll take the SPAM string and pass it off to type to get the type, pass it off to

136
00:13:06,620 --> 00:13:12,140
the get MRO function in the inspect module, right? So I'm reading it backwards because

137
00:13:12,140 --> 00:13:16,020
that's sort of how it gets evaluated. Get MRO means get the method resolution order.

138
00:13:16,020 --> 00:13:21,100
In other words, show me if I call a method on an object of this type, what super classes

139
00:13:21,180 --> 00:13:24,580
is it going to go look in to see if I can find it? Well that tells us what the class

140
00:13:24,580 --> 00:13:30,740
hierarchy is for this object and the answer is type of SPAM is STR, STR is a subclass

141
00:13:30,740 --> 00:13:35,940
of object. Object is the name that refers to the object in Python that every other object

142
00:13:35,940 --> 00:13:41,460
in the Python runtime when you're running it is a subclass of eventually, okay? So it's

143
00:13:41,460 --> 00:13:48,460
the parent, the top of the tree of all the objects. Here's a more interesting one. Boole,

144
00:13:49,460 --> 00:13:56,460
so true is a type of type bool which is a subclass of int which is a subclass of object.

145
00:13:56,460 --> 00:14:01,300
How many of you don't know what I'm saying when I say subclass? Everyone knows about

146
00:14:01,300 --> 00:14:07,340
object oriented at least a little bit, excellent, at least a little bit. Okay, every object

147
00:14:07,340 --> 00:14:13,260
has an ID. In CPython, I'm running CPython because it's written in C, it's called CPython.

148
00:14:13,260 --> 00:14:17,980
There are other versions of Python like iron Python written in C sharp that works well

149
00:14:17,980 --> 00:14:24,980
in the CLR or DLR space on .NET and Windows. There's Jython written in Java that is a little

150
00:14:25,180 --> 00:14:29,340
bit stale, still I haven't gotten to three, I don't know if they ever will. That's written

151
00:14:29,340 --> 00:14:36,340
in Java and works with, like it compiles to the JVM. There's PyPy which is a Python written,

152
00:14:39,340 --> 00:14:44,460
a lot of it in Python. That's a very interesting project that a lot of people use and then

153
00:14:44,460 --> 00:14:49,020
there's a few others, stackless, et cetera. Lots of implementations, oh, MicroPython, I'm

154
00:14:49,020 --> 00:14:54,020
sure I've only named half of them but those are the big ones I can remember. Anyway, CPython

155
00:14:54,020 --> 00:15:01,020
written in C, when you ask Python to show the unique ID of an object, it shows us the

156
00:15:01,900 --> 00:15:07,340
memory address which is an easy way to make it unique. So it's not guaranteed to be the

157
00:15:07,340 --> 00:15:12,700
memory address in every version of Python and I don't think any, I've never used this

158
00:15:12,700 --> 00:15:15,580
because I've never, the only reason you would need to know the memory address is if you're

159
00:15:15,580 --> 00:15:20,500
writing an extension probably that's written in C for example and you need to pass pointers

160
00:15:20,500 --> 00:15:24,020
around. But usually Python handles all that so we don't need to worry about it. We just

161
00:15:24,020 --> 00:15:30,540
know it's a unique ID. The only other thing that's kind of interesting is look at those

162
00:15:30,540 --> 00:15:37,260
numbers. You notice how the ID of three is relatively small compared to the ID of the

163
00:15:37,260 --> 00:15:42,380
other two? That gives us a hint about where it might be stored in memory and we'll touch

164
00:15:42,420 --> 00:15:49,420
on that briefly later. Okay. So usually we create or access existing objects by calling

165
00:15:52,460 --> 00:15:59,020
something else. So here are some examples. Here's the ABS is a function which returns

166
00:15:59,020 --> 00:16:06,020
the absolute value. It is callable. If we call it with minus three, it gives us three.

167
00:16:07,020 --> 00:16:14,020
Int is callable. If I call it pass it a float, it truncates it. Okay. Okay. Don't look at

168
00:16:16,420 --> 00:16:23,420
this code. You don't need to know what it does. But I need to load it because it's the

169
00:16:24,300 --> 00:16:31,300
only way I could figure out, sorry, to show you this easily. Okay. So what are the current

170
00:16:31,780 --> 00:16:38,780
names in my namespace? Nothing. So name, value, ID. The only reason I'm showing you the ID

171
00:16:39,180 --> 00:16:45,740
is because I want you to see that sometimes if two names refer to objects that have the

172
00:16:45,740 --> 00:16:50,740
same ID, well they're actually the same object. So that's why I'm showing you the ID as well.

173
00:16:50,740 --> 00:16:57,740
All right. I'm going to slow down here again a little bit. So the way you've learned that

174
00:16:57,740 --> 00:17:04,740
computer programming languages work, many of you, not all of you, is that you name something

175
00:17:07,740 --> 00:17:14,300
like an I. You say, okay, I want to use a variable I and I want it to represent an integer.

176
00:17:14,300 --> 00:17:18,340
And so the compiler says, okay, every time they use I it's an integer. And I will remember

177
00:17:18,340 --> 00:17:25,340
that. It then creates a box big enough to hold an integer. Then when we say, okay, I

178
00:17:27,900 --> 00:17:33,940
want to use a or a, let's probably use a instead of I. Anyway, if we take that I, then there's

179
00:17:33,940 --> 00:17:38,860
an assignment statement. So I can see you'd say int I equals one. Then what the compiler

180
00:17:38,860 --> 00:17:44,500
does is it puts, it makes it such that when the code is running there is a box that has

181
00:17:44,500 --> 00:17:49,220
the one in it. And if you later say I equals two, it takes the one out of the box, it overwrites

182
00:17:49,220 --> 00:17:54,980
the memory and puts two in instead. And when you say I plus one, it issues a machine instruction

183
00:17:55,060 --> 00:17:58,760
which is an integer add which is different than a float add because the computer needs

184
00:17:58,760 --> 00:18:02,380
to know there's just bits in this box, what should I do with it? Because adding floats

185
00:18:02,380 --> 00:18:08,020
and adding ints are very different parts of the CPU and treat those bits very differently.

186
00:18:08,020 --> 00:18:11,660
So it has to remember what's in the box so it knows how to do things like add. Python

187
00:18:11,660 --> 00:18:17,220
doesn't do that. Python, the object remembers what type it is and it knows how to add itself

188
00:18:17,220 --> 00:18:21,740
to a float or vice versa. It doesn't do it very quickly because it's not compiled, but

189
00:18:21,740 --> 00:18:28,100
it does it quick enough. So in Python what happens is A equals 300, well guess what gets

190
00:18:28,100 --> 00:18:33,940
evaluated first? The 300. And you know what I'm going to say. Python goes off and creates

191
00:18:33,940 --> 00:18:40,940
an object in memory that represents the integer 300. It has a link to the type int. And then

192
00:18:40,940 --> 00:18:47,500
it sees the A equal and that is not, I am not going to use the term assigning a value

193
00:18:47,500 --> 00:18:52,780
to a variable. At a high level of abstraction mathematically a variable is a good word and

194
00:18:52,780 --> 00:18:57,500
you can use it all the time, just not today. Today you're going to use the words I am using

195
00:18:57,500 --> 00:19:01,700
because I want you to start thinking that way. Because then by making you think that

196
00:19:01,700 --> 00:19:05,980
way a whole bunch of other things become much clearer. And then you can go back to using

197
00:19:05,980 --> 00:19:10,740
variable later tomorrow, but you'll have that different understanding slightly of how things

198
00:19:10,740 --> 00:19:15,260
are working and that saves you a lot of pain when you're using Python. So what Python does

199
00:19:15,260 --> 00:19:22,260
is it sees the A equal and when it sees name equal that's a name assignment. That's a name

200
00:19:22,980 --> 00:19:27,940
binding operation. It changes the namespace. So it's not changing the 300, it's not changing

201
00:19:27,940 --> 00:19:34,060
anything in memory because the 300 already got created. So what it does is it adds the

202
00:19:34,060 --> 00:19:40,180
A to the current namespace and it remembers that A has a pointer or a reference to that

203
00:19:40,580 --> 00:19:47,580
object in memory. Assignment operator in Python is a namespace change. It's putting a post

204
00:19:48,300 --> 00:19:54,820
it on the object and then later I can use that to go look it up. So let's do that. This

205
00:19:54,820 --> 00:20:01,820
is monumentous. We're actually going to change the namespace. That's what happened.

206
00:20:02,700 --> 00:20:07,980
So let's see, let's show what my current names are. Let me back up. The reason I'm using

207
00:20:07,980 --> 00:20:14,980
this complicated code, usually I would use dir, it gives you dozens and dozens of variable

208
00:20:15,620 --> 00:20:22,620
because the Jupyter Notebook has lots and lots of names. So that's why I'm using this

209
00:20:22,940 --> 00:20:29,940
underscore vars IDs. So let's see what's in our namespace. I've got a new name A and

210
00:20:30,780 --> 00:20:37,780
it's got the value 300 and it's got that ID. So now when I type in the name, it's

211
00:20:37,980 --> 00:20:43,500
not a string literal, it's not an int, it's not a float, it's not a list, it's not a

212
00:20:43,500 --> 00:20:46,860
tuple, it's not any of those other things, but it is a valid identifier because it starts

213
00:20:46,860 --> 00:20:50,820
with a letter and has nothing but letters and numbers and underscores after it with

214
00:20:50,820 --> 00:20:57,820
no spaces. So it goes and looks up this, goes and finds this object and then throws away

215
00:20:59,420 --> 00:21:06,100
the A in a sense. So now Python has this object which represents the integer 300 and it prints

216
00:21:06,140 --> 00:21:12,260
the value of it. So by the time it goes to print the 300, it doesn't know that it was

217
00:21:12,260 --> 00:21:18,100
called A and in fact it can't ask. Python can't know what the names of that object are

218
00:21:18,100 --> 00:21:22,820
by asking the object. The object does not store its own name. So nowhere in here is

219
00:21:22,820 --> 00:21:27,340
a reference back to the word A or the identifier A. So that's another thing that's helpful

220
00:21:27,340 --> 00:21:34,340
to understand. Let's see if it works. It did. So, it's a reference back to the identifier

221
00:21:36,420 --> 00:21:43,420
A. Let's do it again. Still there, same one. Oh, no it's not the same one. Look at that.

222
00:21:46,420 --> 00:21:52,820
It moved. Well, no it didn't move. So what happened is once I did the A equals 300, so

223
00:21:52,820 --> 00:21:58,700
I assigned it here, it saw the A equals 300, it went off and created a new object, 300.

224
00:21:58,700 --> 00:22:03,620
That's not guaranteed to happen. It's up to Python what it does. Ints are immutable, they

225
00:22:03,620 --> 00:22:07,780
can't be changed. So whether it creates a new one every time or reuses one that exists

226
00:22:07,780 --> 00:22:13,020
doesn't change what you're doing with your programming. So we'll sort of think about

227
00:22:13,020 --> 00:22:19,020
that to help us understand the layer below, but it doesn't really matter. So, let's keep

228
00:22:19,020 --> 00:22:23,700
going here. So now we can access A and it's going to show us 300 looks like the other

229
00:22:23,700 --> 00:22:30,700
300 did. And again, at the level we're programming in, they are the same, they are equal. So

230
00:22:30,740 --> 00:22:37,740
what if I try to access this? Those of you new to programming and even some of you not

231
00:22:40,620 --> 00:22:45,540
are used to ignoring errors, I know this from helping people who are learning programming

232
00:22:45,540 --> 00:22:49,820
at my workplace and you just ignore the error and try to figure it out some other way. Read

233
00:22:49,820 --> 00:22:55,020
the error message. Trust me, after you read the tenth one, they'll start to make sense

234
00:22:55,020 --> 00:23:02,020
and it will benefit you a lot. So the error is a name error. So the capital N, capital

235
00:23:02,020 --> 00:23:06,780
E, camel case name error, that's the name of the exception that Python raised. It gives

236
00:23:06,780 --> 00:23:10,180
you a trace back which is very boring when you're working in the REPL because usually

237
00:23:10,180 --> 00:23:13,380
it would tell you this function in this file called this function and that file called

238
00:23:13,380 --> 00:23:16,220
this function. Well, here it's just there's no file, it's just the console and there's

239
00:23:16,220 --> 00:23:21,820
just one line. And then it actually shows you, tells you what happened. Well, the name

240
00:23:21,820 --> 00:23:26,420
B is not defined and it shows you where in the line it failed as well which again you

241
00:23:26,420 --> 00:23:33,420
can't even see that there if it's even there, I think it is. Okay. So what's going to happen

242
00:23:38,300 --> 00:23:45,300
when I hit shift enter here? Anybody want to try? You'll get it wrong because I'm

243
00:23:45,820 --> 00:23:50,420
awful in terms of I want to use exactly the right language. Say again, louder so others

244
00:23:50,420 --> 00:23:57,420
can hear. Close, very close. He said a new object 400 will be attached to the name A.

245
00:24:01,220 --> 00:24:05,740
I would say an object representing 400 will get created. It might be new, it might exist

246
00:24:05,740 --> 00:24:10,540
already. We don't know. That's a Python implementation detail that isn't our problem or business.

247
00:24:10,540 --> 00:24:15,940
And the name A is attached to the object 400, not the other way around is the better way

248
00:24:15,940 --> 00:24:20,940
to think about it. So the post-it is put onto the object. The letter A, take that post-it

249
00:24:20,940 --> 00:24:24,660
note and stick it on here. And then when Python has an index of the post-it note, so when

250
00:24:24,660 --> 00:24:31,660
you say give me A, it can find it quickly. But the object doesn't know its own name.

251
00:24:33,660 --> 00:24:40,660
Great. And it did it. And there we go, 400. Now we can access it. What about this? What

252
00:24:41,420 --> 00:24:47,780
is B equal A going to do? Well, it's going to look up the A first and get back an object

253
00:24:47,780 --> 00:24:53,340
reference. And then it's going to do a name assignment, B equal, which is a namespace

254
00:24:53,340 --> 00:25:00,340
operation. It's going to add a B. And what the B is going to refer to is that object

255
00:25:00,340 --> 00:25:07,340
because that's what it got back from the A lookup. Right? So there we go. And now B

256
00:25:13,220 --> 00:25:20,220
is 400, A is 400. I'm going to use is. You should almost never use is. If you're writing

257
00:25:22,020 --> 00:25:25,820
linked lists and you really need to know have I come around like a circular list and I need

258
00:25:25,820 --> 00:25:29,580
to know have I got back to the beginning, then you would need is maybe because you might

259
00:25:29,580 --> 00:25:32,860
not, they might be duplicates in the list. And so you can't tell if equality if you've

260
00:25:32,860 --> 00:25:37,940
gotten back to the same one. You should use is. You'll often see is in a function when

261
00:25:37,940 --> 00:25:44,940
there's a default parameter, which is none, and you'll see if parameter one is none, then

262
00:25:44,940 --> 00:25:49,700
that's okay. Otherwise, don't use is. What you should be using is equal. Okay? Equals,

263
00:25:49,700 --> 00:25:54,740
because all you care about is like there were two 300s earlier, right? Do I care that if

264
00:25:54,780 --> 00:25:59,980
I say is that 300 the same as that 300 when you mean to say are they the same value, you're

265
00:25:59,980 --> 00:26:05,420
going to write code that's incorrect. Right? But I'm going to use it here because what

266
00:26:05,420 --> 00:26:10,220
it does mean is is is an operator that you give it two object references and it just

267
00:26:10,220 --> 00:26:14,060
checks their IDs to see if they're the same. And if they are, it's the same object. Right?

268
00:26:14,060 --> 00:26:21,060
So in this case, is this going to be true or false? Cool. I got both answers. So A lookup

269
00:26:24,740 --> 00:26:31,740
gets a reference to that object. B lookup gets a reference. Well, here's the ambiguous

270
00:26:32,460 --> 00:26:37,700
way to I could think of it this way. Well, A refers to an object that represents 400

271
00:26:37,700 --> 00:26:41,140
and B refers to an object that represents 400, but I don't know if they're the same

272
00:26:41,140 --> 00:26:47,540
object. However, because I said B equals A, I actually do know because I got the object

273
00:26:47,540 --> 00:26:52,020
reference back and then added a new value. So here I know that B and A are the same object,

274
00:26:52,020 --> 00:26:59,020
i.e. they are two names for the same object. Okay? Oh, good. And we can see that if we

275
00:27:00,140 --> 00:27:07,140
look at the IDs. Right? They are the same address. How about C equals 400? Can anyone

276
00:27:09,640 --> 00:27:14,480
tell me that if A is C, it's going to be true or false? No, that's not my question. Can

277
00:27:14,480 --> 00:27:19,740
anyone tell me? No, no one can tell me what the answer is. I can't tell you what the answer

278
00:27:19,740 --> 00:27:26,260
is because I don't know what Python is going to do. Right? It turned out in this case it

279
00:27:26,260 --> 00:27:32,500
allocated a new one, but it might not have. Right? So again, Python has freedom to implement

280
00:27:32,500 --> 00:27:37,540
how it wants. You have freedom to work within the contract that Python has given you. The

281
00:27:37,540 --> 00:27:43,620
contract is insurmutable. So it doesn't matter if it makes multiple ones because it doesn't

282
00:27:43,620 --> 00:27:50,620
use ID. Well, that's enough. Okay, so let's look and see. Right? Okay. And you can see

283
00:27:53,580 --> 00:27:58,020
this again. It's just the ID is how I'm getting those. That's what's printing out there.

284
00:27:58,020 --> 00:28:05,020
All right. Now, A is an int. Right? And I'm going to put string in a box that was designed

285
00:28:05,020 --> 00:28:12,020
for an int. No, that's not right. A is a name. So if I say A equals ABC, not a problem.

286
00:28:17,260 --> 00:28:24,260
It goes off and creates a string object down here that represents the string ABC. And here,

287
00:28:24,420 --> 00:28:30,260
instead of adding a name to the namespace, it overwrites this value in that key value

288
00:28:30,260 --> 00:28:34,220
pair. It's kind of like a dictionary. Right? And so I'm going to say please take the Post-It

289
00:28:34,220 --> 00:28:39,480
off of the other object and put it on this new string object that got created. Okay?

290
00:28:39,480 --> 00:28:42,940
So that's not a problem. So the notion that it's a variable and it can only have one type,

291
00:28:42,940 --> 00:28:45,620
well, that's meaningless in Python because it's just a name referring to an object. The

292
00:28:45,620 --> 00:28:51,740
object knows its type. Right? Okay. And again, most of this you know, but now you know why

293
00:28:51,740 --> 00:28:58,740
you know it. Right. And B is still 400. We look at this thing. We see. Okay. All right.

294
00:28:58,740 --> 00:29:05,740
Del A is a namespace operation. It is not a request to Python to delete an object. Python

295
00:29:12,620 --> 00:29:17,180
does delete objects when it can. And when it can is when the reference count goes down

296
00:29:17,180 --> 00:29:24,180
to zero, then it can clean it up using garbage collection. But Del A in this context, Del

297
00:29:24,220 --> 00:29:31,220
space and a name says please remove A from the namespace. So cross this off. Right? And

298
00:29:34,100 --> 00:29:39,340
can anyone tell me if the object that A was referring to got deleted? No, none of you

299
00:29:39,340 --> 00:29:46,340
can tell me that. That's the right answer. Right? Now we might be able to. I'm wrong.

300
00:29:47,340 --> 00:29:54,340
Did I say A and B are the same? No, hang on. A, no, B and C. Right. So before when A and

301
00:29:59,700 --> 00:30:06,700
B were the same, this diagram which is further up, if I had done a Del A then, you could

302
00:30:06,820 --> 00:30:11,580
have told me no, this didn't get deleted because there's still a name that's bound to it.

303
00:30:11,580 --> 00:30:18,580
Then I put the A equals ABC. Thank you. Okay. All right. So what's Del A? Oh, wait. I did

304
00:30:20,820 --> 00:30:27,820
that. Where am I? Del B. Let's get rid of that name and let's get rid of the C name.

305
00:30:29,380 --> 00:30:33,540
So it probably cleaned up those things but can't be guaranteed. All right. So here's

306
00:30:33,540 --> 00:30:37,380
how you're supposed to do it. Right? Let's say use equality. Use double equal to check

307
00:30:37,380 --> 00:30:44,380
equality. So let's, let me just demonstrate something here. I equals 10, J equals 10,

308
00:30:44,380 --> 00:30:51,380
I equals J. We know that's true. Is I the same object as J? We don't know. Turns out

309
00:30:51,460 --> 00:30:56,940
it is in this case. And I can sort of do both of those at the same time. If you put a comma

310
00:30:56,940 --> 00:31:01,900
between two expressions in the REPL or in Python, it creates a tuple without the parentheses

311
00:31:01,900 --> 00:31:08,020
and then it returns. And in creating that retuple, sorry, it's a tuple with the value

312
00:31:08,020 --> 00:31:15,020
of each expression and then it prints it so you see it prints it as a tuple. And you can

313
00:31:15,300 --> 00:31:21,340
see that those are at the same address. What if I do I equals J equals 500? So this is

314
00:31:21,340 --> 00:31:28,340
not C where J equals 500 is an assignment expression. It's not that. Meaning assignment

315
00:31:28,780 --> 00:31:35,780
statements in Python do not have a value. So if you say A equals 3, that expression

316
00:31:35,780 --> 00:31:40,940
doesn't have a value that you can then do something else with. But you do, are allowed

317
00:31:40,940 --> 00:31:44,180
the convenience of saying I equals J equals 500 if you want to give two names to the same

318
00:31:44,180 --> 00:31:48,740
object up front. So we'll do that. Give two names to the same object up front. And you

319
00:31:48,740 --> 00:31:52,060
can see that they have the same value of course and they are the same object because I just

320
00:31:52,060 --> 00:31:57,460
gave two names to the same object. All right. So we're saying similar to this, the A, B

321
00:31:57,460 --> 00:32:03,460
point to the same one. We've got those there. Same there. What if I do an I equals 500,

322
00:32:03,460 --> 00:32:10,460
J equals 500? There they're different. All right. So in case you're curious why that

323
00:32:10,460 --> 00:32:16,260
is, you can watch videos of my epiphanies course which is more advanced where basically

324
00:32:16,260 --> 00:32:23,260
Python preallocates certain integers close to zero for efficiency. That's why some are

325
00:32:24,220 --> 00:32:29,940
sometimes it recreates them because there's lots of zeros and ones and fives floating

326
00:32:29,940 --> 00:32:36,940
around in the runtime. Let's save a little memory. Okay. All right. So if I type this,

327
00:32:45,500 --> 00:32:50,940
is it going to work or not? You can't really tell, right? I know that abs worked and callable

328
00:32:50,940 --> 00:32:55,300
worked and true worked. So there are some names that I haven't shown you that are built

329
00:32:55,300 --> 00:33:02,300
in names that aren't visible when you look with vars or with dir as a call, dir open,

330
00:33:02,300 --> 00:33:09,300
close, print. I keep saying that. What I mean is this. If you do that, it shows you the

331
00:33:10,020 --> 00:33:14,700
current names, the names in the current namespace and this is lots of them. That's why I don't

332
00:33:14,700 --> 00:33:20,580
use that. So if you do a dir, you won't see abs but abs is available. So there's the

333
00:33:20,580 --> 00:33:24,460
names you create. There's the built ins that are sort of hiding in the background. Then

334
00:33:24,460 --> 00:33:28,660
there's the ones that don't, they're in the standard library is another one. So math

335
00:33:28,660 --> 00:33:35,660
is a standard library module in Python. So if I access it, I get exactly the same error

336
00:33:37,740 --> 00:33:44,180
as I did back up when I tried to access the name b before I had added it to the namespace.

337
00:33:44,180 --> 00:33:49,900
So math is not defined. I can define it as in tell Python to go get the library and import

338
00:33:49,900 --> 00:33:54,500
it and put the math name in the current namespace by doing an import which we'll talk about

339
00:33:54,500 --> 00:34:01,340
a little bit later. So again, it's got that little angle brackets around it. I can look

340
00:34:01,340 --> 00:34:08,340
at the attributes of the math module and there are some dir attributes that are sort of implementationy

341
00:34:09,180 --> 00:34:16,180
things and then a whole bunch of functions and some constants. One of which is math.nan,

342
00:34:16,460 --> 00:34:23,460
not a number. And its type is a float. So just as another example of don't trust is,

343
00:34:27,980 --> 00:34:34,980
math.nan is math.nan. That's going to be true because it has to be true because this

344
00:34:35,060 --> 00:34:39,900
is, I'm asking Python, do these two names refer to the same object? Well, they're the

345
00:34:39,900 --> 00:34:43,020
same name. They have to refer to the same object, right? They're the same complete

346
00:34:43,020 --> 00:34:50,020
name, right? Like math.nan and spam.nan might not be the same. Math.nan and math.nan are.

347
00:34:50,860 --> 00:34:55,680
So it's going to be true as the second value but the first value is math.nan equal to itself

348
00:34:55,680 --> 00:35:00,340
and the answer is no. And I'm not going to tell you why that's for another tutorial.

349
00:35:00,340 --> 00:35:03,860
It has to do with, there are good reasons why that thing exists. It's not a number.

350
00:35:03,860 --> 00:35:08,860
It represents not a number. And it's useful in scientific programming, other kinds of

351
00:35:08,860 --> 00:35:14,860
stuff. Okay. So that's the end of the lecture, the first part. Now what I'm going to do

352
00:35:14,860 --> 00:35:21,220
is let you do the exercises. Remember when you look at this, don't just hit shift enter.

353
00:35:21,220 --> 00:35:25,540
Think about what it's going to do. Try to predict what it's going to do. Write it down

354
00:35:25,540 --> 00:35:31,380
if you want to, whatever. And then hit shift enter and see what it actually does. And ideally,

355
00:35:31,380 --> 00:35:34,260
it will always do exactly what you think. I'm pretty sure I've put enough weird things

356
00:35:34,260 --> 00:35:37,900
in here that you're not going to be able to do that. You'll be surprised sometimes.

357
00:35:37,900 --> 00:35:42,860
There are approximately 50 to 100 errors in this intentionally. So you will see error

358
00:35:42,860 --> 00:35:46,820
messages. It's because I want you to see the error message. I'd like you to maybe think

359
00:35:46,820 --> 00:35:50,260
that, so sometimes you'll figure out ahead of time, well this might not work. Sometimes

360
00:35:50,260 --> 00:35:53,700
you won't. And then I want you to think about why did this raise the error message. And

361
00:35:53,700 --> 00:35:56,980
then we'll talk about it as a group. I will go through it. So you don't need to, don't

362
00:35:56,980 --> 00:35:59,980
worry about understanding all of it. Okay. Question?

363
00:35:59,980 --> 00:36:06,980
Sort of. It's a function that I wrote and I put in the notebook. And I put it in the

364
00:36:12,220 --> 00:36:17,620
notebook with a write file, which means if you execute this cell, it will write it and

365
00:36:17,620 --> 00:36:22,260
then I loaded it back in because I want to actually evaluate it. And then I clicked back

366
00:36:22,260 --> 00:36:26,940
in that cell and hit shift enter to evaluate it after I loaded it. So it's kind of my hack

367
00:36:26,940 --> 00:36:29,900
so that you can get it too without me shipping all those files. Although I did in the zip.

368
00:36:29,900 --> 00:36:36,900
You have it there as well, the VARS ID. So load VARS ID, that percent load is, which

369
00:36:37,660 --> 00:36:42,260
once it does it, it comments it out, is the magic that puts it in that name space, in

370
00:36:42,260 --> 00:36:45,380
the current name space. And I didn't just do an import because it actually has to do

371
00:36:45,380 --> 00:36:50,380
some weird stuff with the names to try to, yeah. If anyone has a better way to do it,

372
00:36:50,380 --> 00:36:57,380
I'd love to hear it. Okay. So your turn to do exercises. And yeah, so there's not too

373
00:36:58,380 --> 00:37:01,380
many. So I'll give you about, this one I'll give you lots of time. I'll give you a good

374
00:37:01,380 --> 00:37:04,380
five minutes. And I'll wander around and ask you questions and then we'll go through it

375
00:37:04,380 --> 00:37:11,380
together.

376
00:37:27,380 --> 00:37:34,380
Okay.

377
00:37:57,380 --> 00:38:04,380
Okay.

378
00:38:27,380 --> 00:38:34,380
Okay.

379
00:38:57,380 --> 00:39:04,380
Okay.

380
00:39:27,380 --> 00:39:34,380
Okay.

381
00:39:57,380 --> 00:40:04,380
Okay.

382
00:40:27,380 --> 00:40:34,380
Okay.

383
00:40:57,380 --> 00:41:04,380
Okay.

384
00:41:27,380 --> 00:41:34,380
Okay.

385
00:41:57,380 --> 00:42:04,380
Okay.

386
00:42:04,380 --> 00:42:11,380
Okay.

387
00:42:11,380 --> 00:42:18,380
Okay.

388
00:42:18,380 --> 00:42:25,380
Okay.

389
00:42:49,380 --> 00:42:56,380
So, no surprises here. Now that my mic is on, I'll just repeat that. These are all fairly

390
00:43:01,940 --> 00:43:07,940
straightforward. You've seen the pieces of this. We just put them together there. M is

391
00:43:07,940 --> 00:43:14,940
N? It is because I said M equals N equals N. M equals N equals whatever. So I told Python

392
00:43:15,260 --> 00:43:22,260
I want two names for the same object. So this one, I said earlier if you have name equal

393
00:43:25,020 --> 00:43:30,100
and something, it's a namespace operation. This is not name equals something. This is

394
00:43:30,100 --> 00:43:36,340
name square bracket something square bracket equal. So this instead is a request to the

395
00:43:36,340 --> 00:43:43,340
object that M is bound to. And the request is to change its element at index one. And

396
00:43:45,740 --> 00:43:52,180
Python starts counting at zero to be something else. And so you can see it changed it. And

397
00:43:52,180 --> 00:43:59,180
of course because N and M are bound to the same one, it changed. They both changed. There's

398
00:44:00,020 --> 00:44:07,020
only one and it changed. Okay. Okay. Well, let's go a little faster and just explore

399
00:44:07,740 --> 00:44:14,740
numbers for time. So numbers. So numbers are the numbers that are bound to the same object.

400
00:44:15,260 --> 00:44:18,860
There's another error. Syntax error. It shows you exactly where with the little hat there.

401
00:44:18,860 --> 00:44:23,540
So it's showing you it's just after or at. It got done reading the minus and didn't know

402
00:44:23,540 --> 00:44:27,380
what to do with that. Obviously something like one minus two would work, but one minus

403
00:44:27,380 --> 00:44:34,380
by itself isn't going to work. One equals two. Syntax error. Can't assign to a literal.

404
00:44:34,620 --> 00:44:41,620
Good. That would be strange. True and false values coming from equal and not equal. Less

405
00:44:41,620 --> 00:44:48,620
than, less than or equal to. Multiplication works. Addition works. Division works. Or

406
00:44:53,860 --> 00:44:59,860
you can use floor division, which always returns an integer. And that's what Python 2's slash

407
00:44:59,860 --> 00:45:05,860
did. That was one of the big changes between Python 2 and Python 3. Clock or modular division.

408
00:45:05,860 --> 00:45:12,860
Right? Like if it's 9 o'clock, what's in 14 hours from now? It'll be 11 o'clock, right?

409
00:45:14,140 --> 00:45:18,940
Because 14, it's two hours after 9 in a sense. That's why we call it clock division. So all

410
00:45:18,940 --> 00:45:24,660
of these are available to you. It's remainder is what it is. Sorry. This is the remainder.

411
00:45:24,660 --> 00:45:31,100
Nine divides three cleanly with nothing left over. Here's the int we saw earlier. We know

412
00:45:31,100 --> 00:45:35,220
it's callable. Let's try calling it a few times. So we call it pass it a two. It just

413
00:45:35,220 --> 00:45:42,220
gives us back a two. Maybe the same one, maybe a different one. If we give it a float, does

414
00:45:43,260 --> 00:45:50,260
it round it or truncate it? It truncates it. If I give it a string, it will convert it

415
00:45:51,340 --> 00:45:58,340
from a string. It'll take the string and derive an integer from it. If I give it a float that

416
00:45:58,340 --> 00:46:05,340
looks like a string, it says, no, that sounds like a bug to me. Tell me exactly what you

417
00:46:05,420 --> 00:46:09,780
want if you really want to do that. Here we get another. We got value error now. So value

418
00:46:09,780 --> 00:46:14,380
error is any time there's something wrong with a value. This is one you might commonly

419
00:46:14,380 --> 00:46:18,580
use. If you're writing code and someone gives you a value that's not good, raise a value

420
00:46:18,580 --> 00:46:25,580
error and give it a different argument. Right? So you're reading the error message, right?

421
00:46:26,580 --> 00:46:29,580
Because I told you you got to read the error message. Anything interesting about this error

422
00:46:29,580 --> 00:46:36,580
message? Yeah, what's that about base 10? Invalid literal for int with base 10. Why

423
00:46:40,780 --> 00:46:45,420
is it telling us about base 10? Well, it's because there are other bases. So that's a

424
00:46:45,420 --> 00:46:50,420
clue actually. And it cannot read your mind. So int four is obviously going to fail with

425
00:46:50,420 --> 00:46:57,420
it. Float. So float we can use on 2.9 and it knows what to do and allows it. This is

426
00:46:59,620 --> 00:47:06,620
going to do what? Raise an exception. So it throws or raises an exception and that's the

427
00:47:07,100 --> 00:47:12,780
zero division error. So there's a new one. Can we add types that are different? Yeah,

428
00:47:12,780 --> 00:47:17,740
it'll coerce. So it creates a new one. So I just used the word coerce and I didn't want

429
00:47:17,740 --> 00:47:23,500
to do that because coerce usually in statically compiled languages coerce usually means I

430
00:47:23,500 --> 00:47:28,460
told you compiler that that I represents an integer but I want you to actually start treating

431
00:47:28,460 --> 00:47:32,740
the contents of that box as a float instead or something like that. That's what coerce

432
00:47:32,740 --> 00:47:39,740
usually means. That's what coerce often means in statically compiled languages. So here

433
00:47:39,740 --> 00:47:42,860
what it's doing is just saying well yeah, basically what this really is going on here

434
00:47:42,860 --> 00:47:48,580
is the integer object if you pass it, if you call its add method, it's actually its

435
00:47:48,580 --> 00:47:53,660
thunder add method and you pass it an object which is a float, the integer object knows

436
00:47:53,660 --> 00:48:00,660
how to add those two together. And it says oh I can do that and I'll return a float.

437
00:48:00,980 --> 00:48:04,980
Okay and I don't need to do that because I already, oh yeah I do because it's a new notebook.

438
00:48:04,980 --> 00:48:10,020
The reason I put this in every notebook is because you have to reload it. Those of you

439
00:48:10,060 --> 00:48:17,060
who are not using Jupyter Notebook just use DUR instead is my suggestion. Right. Okay.

440
00:48:24,020 --> 00:48:31,020
A plus one. That should just give me a new two. It does. But why didn't it change it?

441
00:48:31,100 --> 00:48:36,620
Well because I didn't change it. Right. I just, like by the time Python had the two

442
00:48:36,620 --> 00:48:42,020
it didn't even know that I named it A or used the name A earlier. If I do B equals

443
00:48:42,020 --> 00:48:44,820
A plus one though, well that's going to do it on a regular assignment so it's adding

444
00:48:44,820 --> 00:48:51,820
a new name to the namespace based on the value two. We got the two and we got the one. Okay.

445
00:48:51,820 --> 00:48:58,820
A plus equal one. That's valid Python. And what it looks like it does is the same thing

446
00:48:59,460 --> 00:49:05,820
as A equals A plus one and that's sometimes true but not always. So plus equal is actually,

447
00:49:05,820 --> 00:49:09,700
and again if you don't remember this this is fine, plus equal is actually an operator

448
00:49:09,700 --> 00:49:14,980
in Python that calls not the Dunder add method, it calls the Dunder i add method. And Dunder

449
00:49:14,980 --> 00:49:19,740
i add is supposed to try to change itself but if it can't like an int which is immutable

450
00:49:19,740 --> 00:49:24,620
then it just falls back on turning it into A equals A plus one. So that's kind of some

451
00:49:24,620 --> 00:49:30,380
interesting stuff. I think we see some of that later if I remember correctly. A plus

452
00:49:30,380 --> 00:49:37,380
plus, sorry not allowed. Some of you won't like that. All right. Okay. Abs, abs, yeah.

453
00:49:41,340 --> 00:49:48,340
What's this one going to do? What? It's going to fail. How is it going to fail? What exception

454
00:49:53,700 --> 00:49:58,900
is it going to raise? A name error. Right. So it's going to say I don't know about that

455
00:49:58,900 --> 00:50:05,900
name. Name error. Name sign is not defined. So I import math because again I imported

456
00:50:06,460 --> 00:50:09,780
it earlier but that was the earlier notebook. I've switched notebooks so I've lost all

457
00:50:09,780 --> 00:50:16,780
that history. So I import math and I can see the math modules in there and so now what's

458
00:50:18,100 --> 00:50:25,100
sign going to, pi over two going to do? Okay. So that's the first one. So what's the second

459
00:50:28,900 --> 00:50:35,180
one? It's going to fail because look at the names in my namespace. I got A and I got B

460
00:50:35,180 --> 00:50:38,460
and I got math but I don't have sign and I don't have pi. Right. So that's different

461
00:50:38,460 --> 00:50:43,060
than some languages. Some languages you import the module all the names come in. Python,

462
00:50:43,060 --> 00:50:47,900
just the module name comes in unless you do something different. Okay. So let's see. Oh

463
00:50:47,900 --> 00:50:52,940
I was right. So but math is there, right. Math is there and there's the module and I

464
00:50:52,940 --> 00:50:56,620
can look at what's in the math module. There are the attributes of it which includes sign

465
00:50:56,620 --> 00:51:03,620
and pi and et cetera. So I can do this math dot sign math dot pi and this is actually

466
00:51:04,940 --> 00:51:11,940
the recommended way to do it. Right. And the reason for that is when like for a short

467
00:51:13,300 --> 00:51:18,140
module name math dot sign math well again usually the recommended way to do it. So you

468
00:51:18,140 --> 00:51:22,380
could just import the names you want from modules. It's recommended good style is to

469
00:51:22,380 --> 00:51:25,620
just import the name of the module and then it's clear to the reader of the code who's

470
00:51:25,620 --> 00:51:29,820
never seen the code before. Oh you mean the sign in the math module as opposed to the

471
00:51:29,820 --> 00:51:36,340
sign in the num pi module. Right. Like because the names do show up other places. There are

472
00:51:36,340 --> 00:51:39,980
exceptions where it's a really long module name you can shorten it but usually spell

473
00:51:39,980 --> 00:51:42,860
them out. It takes a little more time to type but you're going to read your code a lot more

474
00:51:42,860 --> 00:51:45,860
than you're going to write it and other people are going to read your code after it's written.

475
00:51:45,860 --> 00:51:52,620
All right. Get off that soap box. There we go. But you can do a from math import sign

476
00:51:52,660 --> 00:51:55,860
to pi and obviously if you just write in code I need this script I'll throw it away after

477
00:51:55,860 --> 00:52:01,540
this afternoon. Do whatever you want. Do a so you can do that. You can even do from math

478
00:52:01,540 --> 00:52:06,540
import star and it'll just bring them all in. So good when you're exploring but not

479
00:52:06,540 --> 00:52:10,740
when you're writing code that's going to be around for a while. Okay. So then sign pi

480
00:52:10,740 --> 00:52:17,740
over 2 works. What do you think this is going to do? Can you can you do that? Can you do

481
00:52:22,620 --> 00:52:29,620
tell me what this is going to do? Referring to the same object. Yup. So do these two names

482
00:52:32,700 --> 00:52:39,700
refer to the same object? Can you reliably answer that question? You actually can unless

483
00:52:41,180 --> 00:52:45,500
python unless something weird has gone on with the imports. Normally when python imports

484
00:52:45,500 --> 00:52:50,500
a module it only imports it once. And so when I do even though I imported math and then

485
00:52:50,500 --> 00:52:55,460
I did from math import sign it didn't go reload a new module object and then go grab

486
00:52:55,460 --> 00:53:01,460
something from inside it. It reused all that. So there are some weird edge cases with like

487
00:53:01,460 --> 00:53:05,900
the way pi test works for example where if you've done things wrong you might get to

488
00:53:05,900 --> 00:53:10,100
but that's a bigger problem. So yeah this is reliably going to be true. What we've

489
00:53:10,100 --> 00:53:17,100
done so far it's the same. So those are just two names for the same object. Okay. You can

490
00:53:18,100 --> 00:53:21,980
use help as a built in function by the way that lets you just look at stuff right in

491
00:53:21,980 --> 00:53:27,780
the and in the jupiter in ipython which is what jupiter is running you can also do it

492
00:53:27,780 --> 00:53:34,780
this way or this way and depending on like jupiter brings up this little window down

493
00:53:35,140 --> 00:53:40,620
below which you can then hit escape to close. You can do other things too by the way like

494
00:53:40,620 --> 00:53:46,220
you can hit tab and it will bring up completions for you. There are a few things that jupiter

495
00:53:46,260 --> 00:53:51,740
notebook does. Okay. So that was a little faster. We'll go faster yet. You like drinking

496
00:53:51,740 --> 00:53:58,740
from a fire hose soon. So go play for a little bit see what these do.

497
00:54:16,220 --> 00:54:23,220
Okay.

498
00:54:46,220 --> 00:54:53,220
Okay.

499
00:55:16,220 --> 00:55:23,220
Okay.

500
00:55:46,220 --> 00:55:53,220
Okay.

501
00:55:53,220 --> 00:56:00,220
Okay.

502
00:56:00,220 --> 00:56:07,220
Okay.

503
00:56:07,220 --> 00:56:14,220
Okay.

504
00:56:16,220 --> 00:56:20,220
Okay. So I'm going to go through these the ones you didn't finish. You can see what I'm

505
00:56:20,220 --> 00:56:25,220
doing. You can do them yourself later. And again don't memorize all this stuff. This

506
00:56:25,220 --> 00:56:29,220
is just let it wash over you and you'll absorb it and you'll remember parts of it later and

507
00:56:29,220 --> 00:56:34,220
you'll get a sense for how python works and that will give you more value than memorizing

508
00:56:34,220 --> 00:56:41,220
less of the things. Okay. So integers all these are fairly straightforward. Order of

509
00:56:42,220 --> 00:56:46,220
precedence. Well you can look it up or you can add parentheses to make it more clear

510
00:56:46,220 --> 00:56:50,220
for your reader who might also not remember them exactly. You can do this one's kind

511
00:56:50,220 --> 00:56:57,220
of nice. You can actually check the less than and have three values or more. It just instead

512
00:56:57,220 --> 00:57:04,220
of putting in the ands. Exponentiation. What if we go over our 64 bit architecture? Python

513
00:57:05,220 --> 00:57:12,220
doesn't care. It slows down but it works. Rounds. Makes sense. Let's create a third.

514
00:57:18,220 --> 00:57:25,220
And if we round it. No surprises there. Now this looks like an error doesn't it? Round

515
00:57:27,540 --> 00:57:32,620
with a minus one. There are a lot of cases in python where there are sort of edge cases

516
00:57:32,620 --> 00:57:35,620
that it's like oh yeah we can't use that. Oh but there's something neat we could do

517
00:57:35,620 --> 00:57:40,620
that with that that would be really useful. Like let's move the decimal plates the other

518
00:57:40,620 --> 00:57:44,620
direction. Okay. So look for those and you'll see there's lots of little things. I keep

519
00:57:44,620 --> 00:57:49,620
running into them occasionally. And then our advanced exercises. That's exciting. Type

520
00:57:49,620 --> 00:57:55,620
int callable int help callable. What else? Int. If you call int with no arguments it

521
00:57:55,620 --> 00:58:01,620
gives you back a zero and of course it's equal to zero. Type of int is type. Type of one

522
00:58:01,620 --> 00:58:08,620
is int. Type of int is type. Interesting. So what I'm calling as a function is actually

523
00:58:09,300 --> 00:58:16,300
a class or a type or again the lines between a class and an object if it's callable that's

524
00:58:16,540 --> 00:58:23,540
what matters and I can call it. It acts like a function. Okay. And of course type of zero

525
00:58:24,020 --> 00:58:31,020
is int. Okay. Int four three. What else? We did this before. You saw it. You saw it. You

526
00:58:31,620 --> 00:58:38,620
saw it already. Int z same thing but if I pass a second argument. Right. So this is

527
00:58:40,220 --> 00:58:45,020
an optional argument. Python has optional arguments that you can put in sometimes. You

528
00:58:45,020 --> 00:58:50,740
don't have to. And here's an example of and so they add lots of richness and power to

529
00:58:50,740 --> 00:58:54,860
the functions you're calling is that you know int converts from ints. Oh but it also converts

530
00:58:55,180 --> 00:59:02,180
from ints using different base cases for example. Okay. Let's move on to strings. That's a string

531
00:59:05,260 --> 00:59:11,780
of four characters. That's a string of one character. There is no character type in Python.

532
00:59:11,780 --> 00:59:17,540
There are only strings and they have zero, one or more characters. Okay. Like that is

533
00:59:17,540 --> 00:59:23,660
four like that is one. The types of these are the same because they're both type str.

534
00:59:23,660 --> 00:59:27,500
You can use single quotes or double quotes which is convenient because if you want to

535
00:59:27,500 --> 00:59:33,460
put a quote in the middle it ain't going to work. Right. I've got a quote and then a quote.

536
00:59:33,460 --> 00:59:37,620
So that's a string and then Python sees the rest and says I don't know what to do with

537
00:59:37,620 --> 00:59:43,380
that. So I could escape it with a backslash to say don't escape. The backslash says don't

538
00:59:43,380 --> 00:59:47,420
treat the following character the way you usually would. So in this case it means don't

539
00:59:47,420 --> 00:59:51,540
treat it like the end of the string. Just put it in the string. Right. So that works

540
00:59:51,620 --> 00:59:55,580
and you notice it comes back and puts quotes with a single quote in the middle. Double

541
00:59:55,580 --> 00:59:59,820
quotes on the outside. That's sort of a clue that if you want to put a single quote in

542
00:59:59,820 --> 01:00:02,500
a string use double quotes. If you want to put a double quote in a string use single

543
01:00:02,500 --> 01:00:09,100
quotes. That's convenient. Here's another example. What if I want to have a string that

544
01:00:09,100 --> 01:00:14,020
goes over multiple lines? Well it can't work unless you put triple quotes. So Python lets

545
01:00:14,020 --> 01:00:18,020
you put triple quotes and then it does work. You notice that the new line got inserted

546
01:00:18,020 --> 01:00:23,380
here as the escaped end which means put a new line character in here. Not a backslash

547
01:00:23,380 --> 01:00:27,900
and an end. So put in a single character. Right. There are cases that won't quite work.

548
01:00:27,900 --> 01:00:33,420
Like here I've got four quotes in a row. Yeah. It doesn't know what to do. So I use triple

549
01:00:33,420 --> 01:00:39,180
single quotes instead. You don't need to have the triple quotes. You can actually put the

550
01:00:39,180 --> 01:00:44,260
backslash end directly like that. In is an operator in Python that says is something

551
01:00:44,460 --> 01:00:49,300
in something else? In this case it means for strings is this string in the other string?

552
01:00:49,300 --> 01:00:54,420
Is it a substring of that string? The answer there is yes. And if you put a not in front

553
01:00:54,420 --> 01:01:01,420
of any expression it will reverse it. You can also use not in. Two words, one operator.

554
01:01:01,440 --> 01:01:07,740
Which just makes it read easier. So that's kind of convenient. Square bracket zero. We

555
01:01:07,740 --> 01:01:12,740
saw it earlier when we assigned M sub one equal quote B. Here we're going to access

556
01:01:13,140 --> 01:01:17,140
this. So we're going to say give me the first element of that iterable or that sequence.

557
01:01:17,140 --> 01:01:24,140
Not iterable. Sorry. That sequence. So sequence types, tuple, dict, string, list and other

558
01:01:24,860 --> 01:01:29,780
ones that people have written. So this says get me out that element. And it gives you

559
01:01:29,780 --> 01:01:33,620
back in this case you ask a string for its first character you get back a string of one

560
01:01:33,620 --> 01:01:40,620
character. I think this is the last time I'm going to use this thing. The vars ID. Put

561
01:01:41,020 --> 01:01:48,020
it in there. All right. So S equals T equals hello. Right. And these. We can look at both

562
01:01:48,660 --> 01:01:55,660
its values. Yes. Why what? Why do I have to do what? Oh, so the load loads it into the

563
01:02:00,460 --> 01:02:04,260
cell and then I have to go back in the cell and hit shift and shift to evaluate the cell.

564
01:02:04,260 --> 01:02:09,900
And it's a hack to make it not normal but it works because I want to do stuff with it.

565
01:02:09,900 --> 01:02:13,620
The reason I have to do it that way is because of this stuff here with the global. That's

566
01:02:13,620 --> 01:02:20,620
what the percent load. Percent load loads the contents of a file into a cell. It does

567
01:02:21,660 --> 01:02:28,660
not execute it. Okay. So there's the S and the T which are two names for the same object

568
01:02:29,260 --> 01:02:36,260
kind of like that. Right. So if we do this, S is now a name that is bound to or refers

569
01:02:37,260 --> 01:02:44,260
to a string jello because plus does concatenation. And what about T? Yeah. So S equal. This is

570
01:02:51,540 --> 01:02:58,540
a namespace operation. So I changed S. I didn't change T. Right. So T is still going to be

571
01:02:58,540 --> 01:03:05,540
hello. How about if I do it this way? Okay. So I'm going to do this. I'm going to do this.

572
01:03:07,260 --> 01:03:14,260
Strings are immutable. It's not going to let me do this. It does not support item assignment.

573
01:03:14,260 --> 01:03:21,260
Right. I can access the j that I put in this string but I can't change it. And you can

574
01:03:22,500 --> 01:03:29,500
see that S is still of course jello. Okay. How about this? M equals N equals 1, 2, 3.

575
01:03:30,300 --> 01:03:37,300
Right. So there we could change what was in there. Lists are mutable. Strings are not.

576
01:03:37,860 --> 01:03:44,860
So this didn't give me an error. All right. How about B1 equals B quote. So there are

577
01:03:49,060 --> 01:03:52,740
a number of things you can put right in front of the quote, a string literal. A string literal

578
01:03:52,740 --> 01:03:57,420
is the beginning quote, end quote and the characters inside. A B in front changes it

579
01:03:57,420 --> 01:04:02,340
slightly. There's B for bytes. There's an R for raw. There's U for Unicode which isn't

580
01:04:02,340 --> 01:04:09,340
needed in Python 3 because they're all Unicode. And I think OF which we'll see later. So B

581
01:04:10,140 --> 01:04:17,140
is the way we ask Python to give me a binary representation of something. And when I do

582
01:04:20,180 --> 01:04:27,180
that, what's B made of? The answer is, it's a binary representation of something. And

583
01:04:27,940 --> 01:04:34,940
it's made of numbers. Right? And I can, it's a sequence of numbers and I can iterate over

584
01:04:35,380 --> 01:04:39,820
it. Oh, bytes is another one I forgot to mention. I can iterate over it. So if I pass it to

585
01:04:39,820 --> 01:04:44,740
list, list will take whatever you give it and try to iterate over it and it will then

586
01:04:44,740 --> 01:04:51,740
create a list of those values. So when I look at it that way, you can see that hello. So

587
01:04:51,860 --> 01:04:56,680
it's convenience that lets, I'm harping on this because character encoding is really

588
01:04:56,680 --> 01:05:00,340
difficult to get right and it's really hard to think about partly because it's so ingrained

589
01:05:00,340 --> 01:05:04,520
in our way of, like it's abstracted away so well by our tools that it's hard to see what's

590
01:05:04,520 --> 01:05:10,200
really going on. Debugging, at least twice a year I'm helping some team decode some,

591
01:05:10,200 --> 01:05:14,840
sorry, debug, diagnose a character encoding problem and they're always confused. And

592
01:05:14,840 --> 01:05:17,600
so then I start explaining it to them and I start getting confused because it's just

593
01:05:17,600 --> 01:05:23,400
a really confusing thing. So my hint to you here which I'll credit to Doug McNeil who

594
01:05:23,400 --> 01:05:27,960
showed me this pointed out the fact is that the fact that Python lets you type a string

595
01:05:27,960 --> 01:05:34,080
to create a bytes is a little bit misleading. Worse than that maybe is the fact that it

596
01:05:34,080 --> 01:05:38,480
shows it to you as what looks a lot like a string. It's not a string. It's just a bunch

597
01:05:38,480 --> 01:05:45,480
of numbers that for convenience sake it will show you what they represent in ASCII. Okay.

598
01:05:45,600 --> 01:05:52,600
If you remember that it'll help a little bit in terms of not getting confused about Unicode.

599
01:05:53,400 --> 01:06:00,400
Sorry, character encoding generally. All right. So it's 2 equal to 2.0. I could probably do

600
01:06:08,200 --> 01:06:14,240
a poll and figure out who the real mathematicians are in the room. All right. Sure it is. 2.0

601
01:06:14,240 --> 01:06:20,920
is a floating point representation of the number 2. Exactly. Exactly 2. You can write

602
01:06:20,920 --> 01:06:25,160
your own language and do it differently but this is what Python decided. I actually don't

603
01:06:25,160 --> 01:06:31,040
know. I think that's probably generally true in languages isn't it? I don't know. Anyway,

604
01:06:31,040 --> 01:06:38,040
B1 and S1, are they the same? Absolutely not. Why? Because if they made this the same like

605
01:06:38,960 --> 01:06:45,720
in Python 2 it makes you write bugs more easily. So Python 2 had lots of good support for character

606
01:06:45,720 --> 01:06:50,360
encoding and Unicode. Python 3 just tightened up some areas to make you think about it and

607
01:06:50,360 --> 01:06:57,360
force you not to just do it without intentionally thinking what you're doing. If I decode it,

608
01:06:58,080 --> 01:07:04,960
so bytes I can decode it and then it will turn it into a string. So string in Python

609
01:07:04,960 --> 01:07:11,960
is a high level, an abstraction representing characters. It may be stored as numbers. I'm

610
01:07:12,600 --> 01:07:16,460
sure it's stored as numbers. Everything is in a computer but it's representing characters.

611
01:07:16,460 --> 01:07:20,500
When you get a file from someone else, they should tell you what the encoding is. You

612
01:07:20,500 --> 01:07:24,700
can read it, decoding it into characters and then when you're ready to do something with

613
01:07:24,700 --> 01:07:27,940
it like send it to someone else or send it over the wireshed then you can encode it in

614
01:07:27,940 --> 01:07:33,620
a particular encoding and you should always say which one. As recently as last year I

615
01:07:33,620 --> 01:07:38,180
think I told people in an audience like this that the default encoding for Python is UTF-8.

616
01:07:38,180 --> 01:07:42,180
I was wrong. It's actually, see it's easy to get wrong. It's actually dependent on the

617
01:07:42,180 --> 01:07:46,420
platform. So if you write code on one platform and your encoding files as in writing a code

618
01:07:46,660 --> 01:07:50,980
a string to disk and you don't specify the encoding and you move it to another operating

619
01:07:50,980 --> 01:07:54,380
system and run the same code, it may produce a different result. You have to think about

620
01:07:54,380 --> 01:07:57,380
these things. All right, I'll get off my soapbox. You got a question?

621
01:07:57,380 --> 01:07:58,380
Yeah.

622
01:07:58,380 --> 01:08:05,380
Ah, yes. I used, this is comparison, equal equal and some other people may have missed

623
01:08:07,020 --> 01:08:12,020
that too. Thank you. So I used equal equal. That's why it's true. If I'd done is, absolutely

624
01:08:12,020 --> 01:08:19,020
false. Okay. So what does decode do? Well, it does stuff and it's interesting and you

625
01:08:20,820 --> 01:08:27,660
can look at it later. I have an advanced exercise at the end of this and one of the later notebooks

626
01:08:27,660 --> 01:08:31,180
which we almost certainly won't get to which lets you play around with encoding. I encourage

627
01:08:31,180 --> 01:08:35,980
you to do that to understand it better. Okay. Your turn to do some stuff with strings for

628
01:08:35,980 --> 01:08:43,020
a few minutes. Who thinks I'm going too fast? Too slow? Okay.

629
01:09:35,980 --> 01:09:42,980
Okay.

630
01:10:05,980 --> 01:10:12,980
Okay. I'm going to move us along. I'll go through these and then break in about five

631
01:10:20,900 --> 01:10:27,900
minutes. So this is exploring the raw string, the R you put in front of it. So if you put

632
01:10:28,900 --> 01:10:35,900
an R in front of a string that has an escape character in it, it changes what happens,

633
01:10:35,900 --> 01:10:41,900
right? So it says don't, the raw string says a slash is just a slash. Don't use it to escape

634
01:10:41,900 --> 01:10:46,900
characters. Useful in regular expressions, some other cases. And you can see these, you

635
01:10:46,900 --> 01:10:53,900
can sort of figure out that, oh yeah, those are different. The backslash N is that one

636
01:10:54,900 --> 01:11:00,900
or two characters. It depends on whether you've used, how you've done it. Right, expression

637
01:11:00,900 --> 01:11:05,900
of value. I'm going to skip that because we're close to the break. You can do math with strings

638
01:11:05,900 --> 01:11:11,900
which means multiple concatenations. You can't concatenate ints and strings. Oh, new error,

639
01:11:11,900 --> 01:11:18,140
type error, unsupported operand types for plus int and str. Okay. Not much interesting there.

640
01:11:18,140 --> 01:11:21,220
Later on we'll see the same type error and the same error message and it will give you

641
01:11:21,220 --> 01:11:27,780
some clues about something you can do. I can add strings together though. Interestingly,

642
01:11:27,780 --> 01:11:33,660
I can even add them together without an add. So in source code in Python, if there are

643
01:11:33,660 --> 01:11:37,460
two string literals next to each other, it will combine them and that's convenient for

644
01:11:37,460 --> 01:11:42,020
certain cases. Especially if you're trying to have a single string go across lots of

645
01:11:42,020 --> 01:11:49,020
lines for example. Okay, we'll do a little bit more with encoding here. Here's a backslash

646
01:11:49,340 --> 01:11:55,340
U says give me code point 24 from Unicode and turn that into the abstraction of code

647
01:11:55,340 --> 01:12:02,140
point 24. And this one says don't give me code point 24, give me the Unicode character

648
01:12:02,140 --> 01:12:08,940
that is named dollar sign and they're all the same. Okay, so just, again the advanced

649
01:12:08,940 --> 01:12:14,500
exercises that you'll do on your own at the end are interesting. Okay, so strings have

650
01:12:14,500 --> 01:12:19,180
functions and methods, lots of them. Again, this will just be a blur. Don't remember

651
01:12:19,180 --> 01:12:22,500
them, just remember that oh yeah, you can do stuff like that with strings and that will

652
01:12:22,500 --> 01:12:29,220
be helpful. Length is a function that takes any iterable and figures out how long it is

653
01:12:29,220 --> 01:12:33,980
or asks it how long it is depending on whether or not it's supplied the Dunderland function.

654
01:12:33,980 --> 01:12:40,980
It depends on how it implements that. But regardless it'll, I think I might be wrong

655
01:12:40,980 --> 01:12:45,420
here. No, I think I'm right that it will take any iterable and consume it but I'm

656
01:12:45,420 --> 01:12:52,420
not sure now. Okay, min is a function that same thing, max. All right, so what it did

657
01:12:53,020 --> 01:12:57,340
like takes spam, iterates over it into the separate characters as strings and then returns

658
01:12:57,340 --> 01:13:04,340
the one that's the smallest. Sorted, right, always returns a list of whatever you iterate

659
01:13:04,340 --> 01:13:11,340
over. Does it start with S? Yep, does it start with SP? Does it end with M? Give me

660
01:13:12,580 --> 01:13:17,580
an uppercase version of that, give me a lowercase version of that. Strip spaces from the front

661
01:13:17,580 --> 01:13:23,580
and the back, strip spaces only from the right side, spaces, whitespace, sorry not spaces,

662
01:13:23,580 --> 01:13:30,100
tab, probably vertical tab, maybe form feed but basically tab space are the ones you'll,

663
01:13:30,100 --> 01:13:37,100
oh and new line, of course. Or only from the left side, right. This is misleading. Doesn't

664
01:13:38,100 --> 01:13:45,100
that look a lot like it's the right way to remove the extension from a file name? Well,

665
01:13:45,100 --> 01:13:51,980
it's not. See, the strip functions take a string and interpret that string as a set

666
01:13:51,980 --> 01:13:55,940
of characters that it should remove. So it will remove any of those characters until

667
01:13:55,940 --> 01:13:59,780
it gets from the right side in this case, until it gets to a character that's not in

668
01:13:59,780 --> 01:14:06,780
that set and then it stops. And this is easy bug to write and there's good proof of it,

669
01:14:07,420 --> 01:14:14,420
right? It's going to just keep going until it gets to the dot. As long as it's in, no

670
01:14:16,620 --> 01:14:23,020
sorry, until it consumes the last dot because it says any dots, C's, S's or V's just chew

671
01:14:23,020 --> 01:14:26,580
them all up and when you run out of those then stop and so it stops just before the

672
01:14:26,580 --> 01:14:33,580
E. Oh sorry, stops. Yeah, there's OS path, has a bunch of functions and there's a newer

673
01:14:34,180 --> 01:14:41,180
path lib module. If you're doing file names, so if what you want to do is work with file

674
01:14:42,300 --> 01:14:48,020
names and remove extensions, use path lib or the older OS path. Path lib is nice, nicer

675
01:14:48,020 --> 01:14:54,420
in many ways. A split is a method called on a string which returns a list of strings split

676
01:14:54,420 --> 01:15:00,780
on white space by default, not just one but could be multiple white spaces or if you give

677
01:15:00,780 --> 01:15:05,060
it a specific string it will split on that specific string. So if you give it a space

678
01:15:05,060 --> 01:15:11,560
character, it won't split on tabs or new lines. New lines it might not, I can't remember.

679
01:15:11,560 --> 01:15:15,140
So here it will actually split on that exact one and it throws away the other piece, right?

680
01:15:15,140 --> 01:15:20,800
So it throws away the space dash space and just gives it a list of three strings. Type

681
01:15:20,800 --> 01:15:27,800
of spam, here all the function, let me just, lots of functions there, let me print them

682
01:15:28,440 --> 01:15:33,000
on one page there. So all the Dunder functions you could ignore for now and then here all

683
01:15:33,000 --> 01:15:37,400
the other ones, case, capitalized, case, center, count, encode, lots and lots of stuff. Anything

684
01:15:37,400 --> 01:15:41,280
you might think you would want to do with the string it's probably already in there

685
01:15:41,280 --> 01:15:48,280
and if not stack overload. All right, yeah that doesn't matter. I'm going to, okay,

686
01:15:49,280 --> 01:15:56,280
you can look for the offset, find in spam, P A and you find it at character offset one.

687
01:15:58,960 --> 01:16:03,920
If you look for something that's not in there it raises a value error. Find is just like

688
01:16:03,920 --> 01:16:10,920
index except instead of raising a value error it returns minus one. Choose the one you want.

689
01:16:11,200 --> 01:16:18,200
Break time, I'm almost done. Find, right, so we can find those things. You can replace

690
01:16:18,280 --> 01:16:25,280
all the E's with 3's or just one of them, optional, optional argument there, say just

691
01:16:25,680 --> 01:16:30,520
for first one. All right, so I will stop there. You can do exercises now and then go for break

692
01:16:30,520 --> 01:16:37,520
or vice versa. We will start, come back from break in, well, break is 20 minutes so I'll

693
01:16:37,880 --> 01:16:42,880
give you 25 or 22, whatever, so you have time to do the exercises before or after, whichever

694
01:16:42,880 --> 01:16:49,880
you prefer.

695
01:33:42,880 --> 01:33:49,880
Break over, 10-15 to 10-35, what's that? It's 20 minutes, 10-15, so 10-35, so we're done.

696
01:33:49,880 --> 01:33:56,880
All right, I'll turn my microphone on soon.

697
01:34:19,880 --> 01:34:26,880
Okay, welcome back from the break. I will go through these exercises. All right, so

698
01:34:41,880 --> 01:34:48,880
we saw this order before, reverse equals true and optional argument. If we do reversed it

699
01:34:49,120 --> 01:34:54,040
gives us back a reversed object which is kind of interesting. Basically it's lazy evaluation

700
01:34:54,040 --> 01:34:58,840
so it will iterate over that later when you actually try to iterate over it if needed

701
01:34:58,840 --> 01:35:03,920
and you can force that. Easy way you can iterate over an iterator is just pass it off to list.

702
01:35:03,920 --> 01:35:08,720
List tries to iterate over whatever you can do it and then it will return a list of whatever

703
01:35:08,720 --> 01:35:15,720
it iterated over of those elements. Upper is upper, there's a whole bunch of these,

704
01:35:16,280 --> 01:35:23,280
title is title. Remember these are returning new strings, which reminds me, one of the

705
01:35:25,800 --> 01:35:32,040
questions someone asked is how did this work? How did it change the string? It didn't change

706
01:35:32,040 --> 01:35:37,760
the string, it gave us back a new string which was a copy of the old string changed. Python

707
01:35:37,760 --> 01:35:42,800
is allowed to change strings, like it basically copied the string and created a new string

708
01:35:42,800 --> 01:35:49,800
and it did that in code written in C so it's pretty fast. Going back down here though,

709
01:35:52,240 --> 01:35:59,240
so here's title and here's an example where we take, where we do what's called method

710
01:35:59,520 --> 01:36:05,000
chaining. So in method chaining what happens is, so the method is called on the object

711
01:36:05,000 --> 01:36:09,000
and it returns a new string, that string object that then you can imagine replacing this,

712
01:36:09,000 --> 01:36:16,000
the swap case method is called on that new string and it returns yet another new string.

713
01:36:16,000 --> 01:36:23,000
So you get that title case reversed kind of. Here's the in you saw earlier. So the six,

714
01:36:23,000 --> 01:36:30,000
the optional argument to find says start looking at a particular offset. All right, so what

715
01:36:42,280 --> 01:36:49,280
is s.index zero, s.index space? Anyone figure that out? Looks for what? S.index zero, s.index

716
01:36:53,320 --> 01:37:00,320
zero. That's right, it looks for the, I would say it looks for the first o after the first

717
01:37:00,760 --> 01:37:07,760
space. And there you can see how that worked. So how about an expression to check for more

718
01:37:07,760 --> 01:37:14,760
spaces than non-spaces in a string? Well this is going to be part of it right? How many

719
01:37:30,440 --> 01:37:37,440
spaces are there in the string? Is that more than, what's that? So that's the, that's

720
01:37:37,960 --> 01:37:44,960
the, so I heard some people took the length of the string and divided it by two. That's

721
01:37:48,600 --> 01:37:55,600
an option. What's that? Yeah, okay, so what you said, so you have to, yeah, so that's

722
01:37:58,280 --> 01:38:02,960
one way to do something like that. I may have the point is that's the gist of it, you can

723
01:38:02,960 --> 01:38:09,960
figure out the details. Another is something like that. Again, I'm not saying that's the

724
01:38:12,120 --> 01:38:15,960
right answer, but that's the way to figure out how many are non-spaces in a string. Well

725
01:38:15,960 --> 01:38:18,880
you could take the length, what would be the length of it, wouldn't it be? You can take

726
01:38:18,880 --> 01:38:25,880
the length of it if you got rid of the spaces. Right, and again I may need an extra half

727
01:38:26,360 --> 01:38:29,360
for something like that. I'm not worrying about the details, I'll let you worry about

728
01:38:30,080 --> 01:38:37,080
that. Okay, any questions before we go on? Alright, string formatting. Well you remember

729
01:38:41,520 --> 01:38:48,520
what three does. If you put a three on a line by itself in a Python script or program and

730
01:38:49,760 --> 01:38:53,200
you run it, you will not see the value three printed to standard output. You would need

731
01:38:53,200 --> 01:38:57,040
to use the print function, okay. The reason we're seeing it here is because it's the

732
01:38:57,040 --> 01:39:02,960
read eval print loop, it's the P in REPL. Right, so print is an easy way to get stuff

733
01:39:02,960 --> 01:39:09,640
out to standard output. You can print multiple objects, it puts spaces between them, not

734
01:39:09,640 --> 01:39:16,640
between the objects but between their string representations that it prints, right. And

735
01:39:16,760 --> 01:39:22,600
if you print, it might be hard to see there, but if we print, there you can see if you

736
01:39:22,600 --> 01:39:28,800
put new lines it prints multiple lines in there like that. You can use this, those of

737
01:39:28,800 --> 01:39:35,000
you who are sad that plus plus didn't work, well at least you got this. This was the print

738
01:39:35,000 --> 01:39:40,160
formatting, the string formatting operator in Python until, I can't remember when they

739
01:39:40,160 --> 01:39:47,160
added dot format 26 or 27. And most people I think find, I certainly anyway find the

740
01:39:47,320 --> 01:39:54,320
dot format method on string more powerful than the percent operator, sorry this percent

741
01:39:54,920 --> 01:39:59,240
operator which obviously, well which we saw earlier as modulo, it's also, it's here, it's

742
01:39:59,240 --> 01:40:02,720
used to say interpolate, basically take that three and stick it in where the percent D

743
01:40:02,720 --> 01:40:03,720
is. Question?

744
01:40:03,720 --> 01:40:10,720
No, or so if there are two string, the question is why is it different with string literals?

745
01:40:26,360 --> 01:40:30,200
If Python sees two string literals, and these are the quote marks, with only white space

746
01:40:30,240 --> 01:40:34,520
between them or even a new line that's still a valid expression like in parentheses, it

747
01:40:34,520 --> 01:40:39,560
will just create one string literal, it will create one string object from the two of them.

748
01:40:39,560 --> 01:40:43,840
So that's part of the syntax of reading the Python code. Print takes whatever objects

749
01:40:43,840 --> 01:40:48,480
you give to it and asks them for their string representations and then prints them out with

750
01:40:48,480 --> 01:40:54,600
a space between each of those.

751
01:40:54,600 --> 01:41:01,600
So dot format, basically it looks for curly braces in the string and the technical term

752
01:41:03,440 --> 01:41:10,440
is interpolates or inserts the value of three as a string into that location, you get three

753
01:41:10,520 --> 01:41:16,160
good reasons. You can pass it arguments that aren't used and that's okay and occasionally

754
01:41:16,160 --> 01:41:23,160
that's handy. So here's, and you can have a string that doesn't have any arguments and

755
01:41:23,960 --> 01:41:30,960
doesn't have any curly braces, it just says okay, I'll give you the string back. So there's

756
01:41:32,000 --> 01:41:35,920
another example of an argument that's not used. Here's an example of an argument that's

757
01:41:35,920 --> 01:41:40,200
missing and we get an index error, a tuple index at a range. Kind of an odd error but

758
01:41:40,200 --> 01:41:45,080
it's because of how it's implemented. So it couldn't find, it said okay, I'm supposed

759
01:41:45,080 --> 01:41:52,080
to substitute something but I can't find anything. So here, hello class, hello class,

760
01:41:53,800 --> 01:41:58,700
so here you can do multiple ones and it counts, so the H goes in the first place, et cetera.

761
01:41:58,700 --> 01:42:05,700
You can use numbers if you want which is handy if you, here's a bad case of using it, that's

762
01:42:06,920 --> 01:42:10,160
just confusing but this one is actually useful, right, because I wanted to repeat one of them,

763
01:42:10,160 --> 01:42:14,680
I didn't want to put it in over here a second time. So it does, zero gets to high and the

764
01:42:14,680 --> 01:42:21,080
zero here also goes to high whereas the one goes to class. Lots of stuff here, you can

765
01:42:21,080 --> 01:42:28,080
see the format. So if you see a colon D, so curly brace and then maybe a zero or a name

766
01:42:28,440 --> 01:42:32,000
we'll see later and then you have colon and then some format specifiers and there's a

767
01:42:32,000 --> 01:42:36,280
whole mini language, format specification language but it lets you do tons of stuff.

768
01:42:36,280 --> 01:42:42,720
Like you can, D is, you know, show me this number, a line, this decimal, a line, left,

769
01:42:42,720 --> 01:42:49,720
right, centered, put a plus in front of it otherwise it's only for negative. I'm not

770
01:42:49,720 --> 01:42:53,280
going to explain all these things. So here are the left, right and center. So you can

771
01:42:53,280 --> 01:42:59,320
look at these later or go look at the format mini language spec. This one's centered I

772
01:42:59,320 --> 01:43:06,320
think and uses a different character. How many decimals after the decimal point? Truncate

773
01:43:09,160 --> 01:43:15,400
a string, like say, show me the string S, S means string but limited to eight characters.

774
01:43:15,400 --> 01:43:19,800
More interestingly you can put in names, right, so you can say greet who and have placeholders

775
01:43:19,800 --> 01:43:26,800
that are easier to read like that. Let me just remind myself, I converted this from

776
01:43:28,800 --> 01:43:35,800
a different format recently. The edit, I'll remind me later to clean that up a little

777
01:43:37,800 --> 01:43:43,720
bit. Which reminds me, part of why this is as good as it is, which hopefully is good

778
01:43:43,720 --> 01:43:47,040
for you, is because other people have given me feedback in the past saying, oh, maybe

779
01:43:47,040 --> 01:43:51,680
you could do that differently. So at the end in the survey if you have comments saying

780
01:43:51,680 --> 01:43:55,480
this part was more confusing than that part, anything you can do to give me feedback I

781
01:43:55,480 --> 01:44:00,120
can improve this for future uses. And you can thank all the people that gave me feedback

782
01:44:00,120 --> 01:44:04,560
in the past for what you're seeing because I've learned lots of stuff teaching this

783
01:44:04,560 --> 01:44:10,000
class, especially when people point out mistakes. That's the great thing about learning is

784
01:44:10,000 --> 01:44:15,520
it really makes you think hard about what you're teaching. Anyway, so you can also

785
01:44:15,520 --> 01:44:21,480
do this. So here I'm going to have a method, sorry, an M. I'm going to have M bound to

786
01:44:21,480 --> 01:44:28,480
this list of those two strings and then in here I'm going to say zero and zero. So I'm

787
01:44:28,520 --> 01:44:35,040
accessing the zeroth, in both cases the zeroth argument which is M, that list and I'm going

788
01:44:35,040 --> 01:44:42,040
to use square bracket zero and square bracket one. And so I get the high and the class put

789
01:44:42,040 --> 01:44:49,040
in there. You can also use dot. So here is one way, this doesn't use dot, it just says

790
01:44:49,880 --> 01:44:56,880
P is trues under doc attribute or I could just pass P equals true and then use P dot

791
01:44:57,880 --> 01:45:04,880
under doc here. Right, so you can do some of the syntax inside the string. Python 3.6 added

792
01:45:06,800 --> 01:45:13,800
F strings which are really nice, make code much easier to read. And what they do is when

793
01:45:15,680 --> 01:45:22,000
the F string literal is, when it's compiled it saves the string and then when it's executed,

794
01:45:22,000 --> 01:45:29,000
when it actually runs the F string, when it's actually used in this code, I might be not

795
01:45:29,400 --> 01:45:35,320
quite saying that precisely enough. Then it looks in the local namespace, it looks in

796
01:45:35,320 --> 01:45:40,640
the names, current namespace to find the names. So greet, it will go look outside of this

797
01:45:40,640 --> 01:45:45,640
statement into are there any names that I can use to do that substitution. So that's

798
01:45:45,640 --> 01:45:52,640
it. F strings don't just do name substitutions though, they do lots of expressions. Right,

799
01:45:56,000 --> 01:46:03,000
so we could do that or we could do that. So here I'm showing you the difference. This

800
01:46:04,440 --> 01:46:11,440
is a regular string, not an F string and it just prints that out. This is a regular string

801
01:46:11,440 --> 01:46:18,440
with curly braces and it just puts in the curly braces. This is an F string and it has

802
01:46:20,680 --> 01:46:25,680
curly braces and because it's an F string it looks at the curly braces and does something

803
01:46:25,680 --> 01:46:32,680
which is it evaluates this and basically it does the code work of going to find abs and

804
01:46:32,960 --> 01:46:37,040
calling it and getting back the 3 and it puts the 3 in. Okay, so you see the difference

805
01:46:37,040 --> 01:46:44,040
here, not an F string, not an F string, is an F string. Okay. Hang on, make a note. I

806
01:46:48,480 --> 01:46:53,920
didn't like that delivery as well as that changed that and I'm not totally happy with

807
01:46:53,920 --> 01:47:00,240
how it went. Here's another example, right. So here the dot upper is inside, so here's

808
01:47:00,240 --> 01:47:07,240
the F string that starts with the quote and ends with the quote. Inside the curly braces

809
01:47:07,240 --> 01:47:14,240
I have a string dot upper, so this expression gets evaluated. Again, that's kind of confusing.

810
01:47:14,280 --> 01:47:17,240
I'm not sure I would write code like that because it's got the quotes and the F string

811
01:47:17,240 --> 01:47:24,240
and everything else, like a quote inside there. Here's an example of one with a new line and

812
01:47:25,440 --> 01:47:30,160
F string expression part cannot include a backslash. So there are some limitations. You can't put

813
01:47:30,160 --> 01:47:35,400
arbitrary code inside an F string, but you can do some pretty crazy things. So don't.

814
01:47:35,400 --> 01:47:39,720
Doing crazy things is not good. It's easy to be too clever with Python. Make the code

815
01:47:39,720 --> 01:47:46,720
easy to read for future readers. Your turn to do some exercises.

816
01:48:00,160 --> 01:48:07,160
Okay.

817
01:48:30,160 --> 01:48:37,160
Okay.

818
01:49:00,160 --> 01:49:07,160
Okay.

819
01:49:30,160 --> 01:49:37,160
Okay. I'm going to go ahead and go through this quickly. There's not a lot of new stuff

820
01:49:37,160 --> 01:49:44,160
here. Well, lots of little details, but the core, there's no big new ideas, I don't think.

821
01:49:44,160 --> 01:49:51,160
So I can change by default print adds a new line. I can change the line size. I can change

822
01:50:15,160 --> 01:50:20,420
what it prints. I can change that to print something else, like a space and a less than

823
01:50:20,420 --> 01:50:24,560
and a dash dash and a new line. Suppose I don't want to print a new line at all. You

824
01:50:24,560 --> 01:50:29,620
would think that saying n equals none would do that, but it doesn't. And the reason is

825
01:50:29,620 --> 01:50:36,620
n equals none is how it was written when the function was written, the print function,

826
01:50:36,680 --> 01:50:43,200
if you don't pass an optional argument, Python passes none. So this is a gotcha you need to

827
01:50:43,200 --> 01:50:47,480
watch out for. So in a case like that where you actually want something that's kind of

828
01:50:47,480 --> 01:50:51,200
like none, well, what I want is an empty string. What string should I put at the end? This

829
01:50:51,200 --> 01:50:57,560
is the way you get that. Right? Is end it with an empty string as opposed to ending

830
01:50:57,560 --> 01:51:01,880
it with the default is sort of the way you can read the difference between these two.

831
01:51:01,880 --> 01:51:08,880
Okay? So that's a little bit tricky. Nothing surprising here. Nothing too surprising here.

832
01:51:09,880 --> 01:51:16,880
Right? It's just doing various values. Colon B is how you do stuff in binary if you want

833
01:51:19,640 --> 01:51:26,640
to do some binary math or colon X for hex or O for octal. Percent will do both the math

834
01:51:30,280 --> 01:51:35,080
for you to make it 3, 3 point instead of .33 and add the percent. And you can say, here's

835
01:51:35,080 --> 01:51:41,600
how much of it I want. Right? And it puts the percent character on as well. This one's

836
01:51:41,600 --> 01:51:46,880
kind of cool. So sometimes you don't know maybe this digits here, like here I know I

837
01:51:46,880 --> 01:51:52,600
want 5.2. I want 5 wide and 2 decimal points. But maybe you don't know until it's some

838
01:51:52,600 --> 01:51:57,000
configuration file or they entered it, someone entered it in your application as part of

839
01:51:57,000 --> 01:52:03,480
the run. Or it changes depending on the type. So you can put the curly braces here and it

840
01:52:03,480 --> 01:52:10,480
interpolates that as well. Right? And there are the .format method can be implemented

841
01:52:14,880 --> 01:52:19,400
on other types. There aren't very many that have. Date time is one of them. Here's some

842
01:52:19,400 --> 01:52:26,400
other examples where we're doing a dot and again a more complicated expression. Okay.

843
01:52:26,400 --> 01:52:53,280
I didn't get ahead on this. Okay. So moving on to tuples and

844
01:52:53,600 --> 01:53:14,600
lists. Any questions? All right. Lists. Nothing new here. The list is 1, 2, 3. So what's

845
01:53:14,600 --> 01:53:21,600
m sub 3 going to give us? Index error. List out of range. Okay. Length of m? 3. Okay.

846
01:53:31,400 --> 01:53:36,520
So what if I want the last element? Well, I need to do some math. Or thank goodness

847
01:53:36,520 --> 01:53:40,600
there's the minus 1 option in Python that says give me the last one. So minus means

848
01:53:40,600 --> 01:53:47,040
start counting from the end. Minus 1 is the last character. Minus 2, minus 3. So I'm getting

849
01:53:47,040 --> 01:53:54,040
the 3, the 2, the 1. If I try minus 4, I'll get an index error. Tuple, very similar. You

850
01:53:55,000 --> 01:53:59,600
can pass the tuple to a list. I'll give you that list. Let's see what else is here. This

851
01:53:59,600 --> 01:54:06,320
should all look familiar. Right? Just sort of refreshing those little gray cells. I can

852
01:54:06,320 --> 01:54:10,800
take a list and pass it to a tuple and it'll create such a thing. So a tuple is immutable.

853
01:54:10,800 --> 01:54:15,120
It doesn't mean it's homogenous, right? Or homogeneous. You can still have mixed data

854
01:54:15,120 --> 01:54:22,120
types in a tuple. And that's very common. So let's look at that tuple. Oops. All right.

855
01:54:22,360 --> 01:54:29,360
There it is. And tuples are immutable. Therefore, this will fail. Tuple object does not support

856
01:54:29,640 --> 01:54:35,640
item assignment. We saw that similar. Same message with string, I think it was. So if

857
01:54:35,680 --> 01:54:42,680
I want to create one like that, I could though. And I can see it. So if M is a list 1, B, and

858
01:54:45,680 --> 01:54:52,680
3, and I do M plus 4, adding lists together does that. Creates a new list from the two

859
01:54:55,680 --> 01:55:02,680
lists that got added together. And if I look at M, what does M bound to? Is it going to

860
01:55:03,680 --> 01:55:10,680
be 1, B, 3, 4 or 1, B, 3? Yeah, I didn't change it. All right. How about a tuple? Let's say

861
01:55:13,800 --> 01:55:20,800
tuple. And if I add 4 to that, what's this going to do? Read the error message. It can

862
01:55:20,800 --> 01:55:35,800
only concatenate tuple, not int, to tuple. That's giving me a hint. Always read the

863
01:55:35,800 --> 01:55:40,920
error messages. Getting that habit. Right? So let's try doing that. Because earlier

864
01:55:40,920 --> 01:55:46,240
I did M plus square bracket 4. Here I just did T plus 4. Here I'm going to do T plus

865
01:55:46,240 --> 01:55:53,240
round bracket 4 because tuples always show up as round brackets. And I still get the

866
01:55:53,240 --> 01:55:59,480
not int. So it can only concatenate tuple, not int to tuple. So in other words, this

867
01:55:59,480 --> 01:56:04,560
got evaluated as an int. Parentheses are used for tuples. They're also used for math. So

868
01:56:04,560 --> 01:56:09,000
in Python and mathy things like grouping things together. So Python saw the parentheses around

869
01:56:09,000 --> 01:56:16,000
the 4 and threw them away. Right? What does this do? That worked. And it's going to be

870
01:56:16,240 --> 01:56:23,240
a tuple. Right? So I can create an empty tuple like that, but this doesn't work for an empty

871
01:56:23,760 --> 01:56:30,760
tuple. And obviously adding more parentheses won't help. Well, I actually don't know that.

872
01:56:31,960 --> 01:56:38,960
Adding up to 3 more parentheses won't help. I haven't tried more. I can do this. No. Int

873
01:56:38,960 --> 01:56:44,760
object is not iterable. So I have to pass tuple an object which is iterable. Okay. Let's

874
01:56:44,760 --> 01:56:51,320
try passing an object that is iterable. That works. So here's the answer. If you need a

875
01:56:51,320 --> 01:56:58,320
tuple of one item, you need a comma or something. So that's sort of this weird edge between

876
01:56:58,800 --> 01:57:03,840
two different uses of parentheses in a language. So now that we have that, okay, that's good.

877
01:57:03,840 --> 01:57:10,840
Now I can do that. And I get back 1, B, 3, 4. And T will now have 1, B, 3. Right? Because

878
01:57:11,640 --> 01:57:17,720
we can't change the tuple. Can I do math like I did with strings as in multiply? Can I use

879
01:57:17,720 --> 01:57:24,720
the star to do something? Yes. Right. And that's actually quite handy. For example,

880
01:57:33,280 --> 01:57:40,280
what's easier to read? That. Oops, sorry. Okay. So that's a good one. So I can do that.

881
01:57:40,840 --> 01:57:47,840
Or this. Right? So that's the rare case when I've actually used star with strings is I

882
01:57:53,720 --> 01:57:59,080
need a certain number of spaces. There are other ways to do it too. But anyway, call

883
01:57:59,080 --> 01:58:04,280
tuple like all the data types. You call it with no arguments and it returns sort of the

884
01:58:04,280 --> 01:58:11,280
empty version of it. And the type of that is tuple. Okay. Let's do some stuff with lists.

885
01:58:11,280 --> 01:58:18,280
There's the BCDF. It's got a length. It's got a min. It's got a max. I can call sorted.

886
01:58:19,760 --> 01:58:26,760
I can call reversed. It's the same as before with string. I can pass it off the list to

887
01:58:27,240 --> 01:58:31,280
actually instantiate the, or to actually do the iteration and pull them out and then turn

888
01:58:31,280 --> 01:58:38,280
them into a list. M is BCDF. Insert 0, a says please insert an a into this list at element

889
01:58:44,280 --> 01:58:51,280
0. Okay. Lists are mutable. You can change them so you can do that. So what's m.insert-1

890
01:58:52,640 --> 01:58:59,640
going to do? Remember what minus 1 does? It refers to the last element. So if I want to

891
01:59:00,600 --> 01:59:07,600
insert before the last element is what this means as opposed to insert at the end of the

892
01:59:07,680 --> 01:59:14,680
list. All right. So there's that. Look at all those E's. Okay. Three E's there. So if

893
01:59:19,280 --> 01:59:26,280
I do remove E, it removed 1 or 3? Well, if it removed 3, it removed 1. So it's going

894
01:59:29,640 --> 01:59:32,640
to say remove 3, then when I do this, it will give me an error. So I think it just

895
01:59:32,640 --> 01:59:39,640
removed 1. So every time. So remove doesn't ask. It's looking for, remove doesn't say

896
01:59:39,880 --> 01:59:43,640
remove from the, it's not an integer offset into the list. It's saying just remove the

897
01:59:43,640 --> 01:59:50,360
element that matches that, that's equal to that. Okay. Pop. Again, just to remind you,

898
01:59:50,360 --> 01:59:56,360
this is just, here's an overview of all the things you can do with lists. Very, very handy.

899
01:59:57,160 --> 02:00:02,640
It takes, removes the last element and returns it as opposed to these others. Remove returns

900
02:00:02,640 --> 02:00:09,640
nothing. Insert returns nothing. None specifically. All right. Okay. Tuples, you can do assignments.

901
02:00:12,800 --> 02:00:19,800
Name binding, namespace operation with tuples. Right? So that's a way to assign I1 and J2.

902
02:00:19,800 --> 02:00:26,800
I can't believe I said assign. To bind the name I to the object 1 and et cetera. Right?

903
02:00:28,800 --> 02:00:35,800
Of course, you don't need the parentheses. You can just do it that way. So here, for

904
02:00:36,800 --> 02:00:41,720
example, there's a tuple and there's a tuple. Right? So you don't need the round brackets

905
02:00:41,720 --> 02:00:46,720
for tuples. In most cases. Sometimes you do. Depends on if it's confusing syntax basically.

906
02:00:47,520 --> 02:00:54,520
T1 is equal to T2. That's interesting. Right? So T1 I created a tuple. T2 I created a tuple.

907
02:00:59,000 --> 02:01:05,920
Are they equal? What does that mean? Well, the answer is two tuples are equal if they,

908
02:01:05,920 --> 02:01:11,560
if their elements are all equal. So it marches through the two, both of those tuples and

909
02:01:11,560 --> 02:01:15,600
does a compare on each one. And if it gets to the end of them and it's been true all

910
02:01:15,600 --> 02:01:19,760
along, then it says, yep, these are the same. They are equal. Sorry. These are equal. These

911
02:01:19,760 --> 02:01:26,760
two tuples are equal because their elements are equal. Okay? Is T1 the same object? No.

912
02:01:29,440 --> 02:01:36,440
I can do count. I can do index. These familiar from string? Yep.

913
02:01:41,040 --> 02:01:44,940
I think it would be possible to change Python's implementation to do that without breaking

914
02:01:44,940 --> 02:01:51,940
any existing code. So Python could optimize that, I think. No, no. It is. This is to use

915
02:01:57,700 --> 02:02:04,100
my earlier language. And I forgot to repeat the question. Could it be that this could

916
02:02:04,100 --> 02:02:11,100
have, that is, could have returned true? Yes. I'm pretty sure my understanding of the Python

917
02:02:11,420 --> 02:02:16,700
language that they could have, they could implement, maybe in Python 3.8, they will

918
02:02:16,700 --> 02:02:23,200
implement an optimization where tuples that are the same should save memory. I doubt they're

919
02:02:23,200 --> 02:02:27,160
going to because it would take a long time to figure that out. It would slow down Python.

920
02:02:27,160 --> 02:02:34,160
But I think that no existing code would break if you did that. In practice, this implementation

921
02:02:35,160 --> 02:02:41,160
doesn't. It stores them separately. Is the one that's in this tuple and the one that's

922
02:02:41,160 --> 02:02:48,160
in that tuple the same? Yeah, they are in this current version. Okay. Count index. Okay.

923
02:02:49,160 --> 02:02:53,200
This is pretty cool. See that star there? I've got one, two, three, four things on the right.

924
02:02:53,200 --> 02:03:00,200
And I've got not just ing, but I have n3, n4, and star rest. What happens here is Python

925
02:03:00,200 --> 02:03:05,720
does the assignment. This is called tuple unpacking, I think, or iterable unpacking.

926
02:03:05,720 --> 02:03:09,280
I can't remember the name. Sorry. And now if I look at those, you can see that I've

927
02:03:09,280 --> 02:03:14,280
got a tuple. And the reason it's a tuple is because I just entered it as a tuple, right?

928
02:03:14,280 --> 02:03:19,440
So I put n3, n4, rest. So that's why it's showing it as a tuple. The point is it's

929
02:03:19,440 --> 02:03:23,920
just three names. I'm just showing three names. What's interesting is the five, six got put

930
02:03:23,920 --> 02:03:30,920
into a list, right? So this is a tuple. So the n3 is three, the n4 is four, and the rest

931
02:03:32,440 --> 02:03:39,440
is the list five, six. And that would be clear if I did it as three lines. Okay. See what

932
02:03:46,520 --> 02:03:53,520
happened there? And how about here? What do you think will happen here? Okay. So this

933
02:03:53,920 --> 02:04:00,920
could be an empty list or could be an error. It's an empty list, right? Which kind of makes

934
02:04:04,240 --> 02:04:11,240
sense. Star, our intuition might be star means zero or more. Okay. So this is very handy

935
02:04:12,600 --> 02:04:19,600
when you need it. And you can put the stars in the middle. The star, sorry, in the middle

936
02:04:19,600 --> 02:04:25,800
of the list. Obviously if you don't use star and you, yeah, it's going to fail. Okay. Your

937
02:04:25,800 --> 02:04:32,800
turn to do exercises. I'll give you about, wow, this is a long one. But there's so much

938
02:04:35,120 --> 02:04:42,120
other good stuff. I'll give you like three minutes probably for this one. Okay. So this

939
02:07:50,600 --> 02:07:57,600
is a very long list. Okay. I'm going to start going through these already. Did anybody finish?

940
02:07:57,600 --> 02:08:04,600
Okay. Yeah. Good one. Darn. I didn't start. I know it's kind of frustrating that I'm

941
02:08:04,600 --> 02:08:11,600
pushing so hard, but there's a lot of stuff. This is just, I'll take time later and go

942
02:08:27,240 --> 02:08:34,240
through it. So what I did a lot in the first half was let's understand the time. I'm going

943
02:08:34,600 --> 02:08:37,600
to go through the time and how stuff's working behind the scenes. And now I'm sort of doing

944
02:08:37,600 --> 02:08:41,680
a lot more. Let's just explore and see all the stuff that's out there with some areas

945
02:08:41,680 --> 02:08:44,600
where I'm going back and saying, okay, but here's something you've got to watch out for.

946
02:08:44,600 --> 02:08:51,600
And we'll see a couple of those in this section. So there's a list. M plus equal. Okay. Int

947
02:08:53,240 --> 02:09:00,240
object is not iterable. That tells me that if it was, I bet I could do something. So

948
02:09:00,560 --> 02:09:07,560
let's try to give it an iterable. All right. So plus equal. Again, this acts a lot like

949
02:09:10,160 --> 02:09:14,680
M equals M plus four or five. It's like a rebinding. Although it actually doesn't do

950
02:09:14,680 --> 02:09:18,520
it through a rebinding. It does it because the plus equal I mentioned before, the Dunder

951
02:09:18,520 --> 02:09:24,560
I add method actually changed the list. So this is the, basically this becomes, this

952
02:09:24,560 --> 02:09:30,680
plus equal becomes a request to the list. Please take this iterable and add these elements,

953
02:09:30,680 --> 02:09:37,680
the four and the five, to the end of yourself is what's going on there. Okay. And it says

954
02:09:38,040 --> 02:09:45,040
iterable. It doesn't say list. So that should work. And that should work. And they do. Right?

955
02:09:47,240 --> 02:09:54,240
Append is how you would add a single element to a list. And that's the list. And then you

956
02:09:54,960 --> 02:10:00,080
add a single element. And it only takes a single argument. So if I want to add three

957
02:10:00,080 --> 02:10:07,080
elements to a list, that will do it. But maybe not quite the way you thought. Right? Append

958
02:10:09,360 --> 02:10:14,040
takes exactly one argument and it appends that argument to the list. It did exactly

959
02:10:14,040 --> 02:10:21,040
what we told it. Right? So it appended that single argument to the list. Del M square

960
02:10:22,000 --> 02:10:29,000
bracket minus one. Is this a namespace operation? Not in this case. This is a request to the

961
02:10:29,560 --> 02:10:33,760
list to the object that M is referring to, which in this case is a list. It's a request

962
02:10:33,760 --> 02:10:39,480
to that list. Please delete your last argument. Sorry, your last element. So change yourself

963
02:10:39,480 --> 02:10:45,360
in that way. Right? And now I've got the M maybe. And if I want to pass call, I can call

964
02:10:45,520 --> 02:10:52,520
M extend and it will iterate over whatever I pass it and add those elements to the list.

965
02:10:55,520 --> 02:10:59,320
Lists take time to get to know them. Strings, yeah, if you're using lots of string stuff

966
02:10:59,320 --> 02:11:03,000
do. Lists you can use all over the place in Python. Dicts you can use all over the place

967
02:11:03,000 --> 02:11:07,280
in Python. So get to know them. I encourage you two months from now, put a note on your

968
02:11:07,280 --> 02:11:12,200
calendar, go read the section on dict in the standard library module and spend an hour

969
02:11:12,200 --> 02:11:19,200
and you'll go, you can do that too. There's all this stuff you'll find. Okay. See that

970
02:11:22,120 --> 02:11:29,120
list, one through seven and A through J. Is 10 in M? No. Then we saw the not in versus

971
02:11:30,800 --> 02:11:36,400
not 10 in. Either of those works. Are five and six in M? Well, that's not actually what

972
02:11:36,400 --> 02:11:43,400
I asked. I asked is the list five, six in M? Right? What if I pin the list five, six

973
02:11:48,400 --> 02:11:55,400
and look at M? Now is five, six in M? Yeah. What about this? Okay. There's a couple ways

974
02:11:55,400 --> 02:12:02,400
I could have gone. I find this interesting because it's checking the type and the contents

975
02:12:11,040 --> 02:12:16,040
to see if that thing is in there. So in is kind of doing equality. Anyway, there's M.

976
02:12:16,040 --> 02:12:21,040
Okay. So let's keep going here. So now I've got M which is one, two, three, four, blah,

977
02:12:21,960 --> 02:12:27,640
blah, blah, blah, blah and I've got N which is one, two and four. So what will this do

978
02:12:27,640 --> 02:12:34,640
you think? You'd think it might give us an error, right? Because the list is the wrong

979
02:12:35,360 --> 02:12:38,640
length. But I'm not asking if they're equal. If I were asking if they're equal, it's going

980
02:12:38,640 --> 02:12:43,160
to say no. But I'm not asking if they're equal. I'm saying is M less than N? What Python does

981
02:12:43,160 --> 02:12:50,160
is oh, yeah, I'll check. I'll do what I can. I will check. Is one less than one? Sorry.

982
02:12:50,720 --> 02:12:54,880
Is one less than one? No. Okay. Well, I'll keep going because I haven't answered the

983
02:12:54,880 --> 02:13:01,320
question is M less than N? Check the two. Is three less than four? Yes. Oh, therefore

984
02:13:01,320 --> 02:13:07,800
M is less than N. Okay. So you can do comparison of list. That's how less than works on list

985
02:13:07,800 --> 02:13:14,480
and similar things. Okay. Sort of like string. Doesn't have to be the same length. Okay.

986
02:13:14,480 --> 02:13:20,120
List we saw. That's kind of fun. You can do a swap without a temp in between. We saw

987
02:13:20,120 --> 02:13:27,120
all these. I'll let you do the rest of those on your own. Splits I showed you. I didn't

988
02:13:30,360 --> 02:13:35,000
show you join though. Join I don't think is a method on string that basically takes all

989
02:13:35,000 --> 02:13:39,700
the elements of whatever you pass it and puts them together with a space in this case or

990
02:13:39,700 --> 02:13:45,900
with a comma space or with a whatever you want or with nothing. If you just want to

991
02:13:45,900 --> 02:13:50,620
concatenate a string, this is the fastest way to do it. Fast as in performance. Okay.

992
02:13:50,620 --> 02:13:53,540
You can build them up but it's creating a new string every time whereas this one doesn't.

993
02:13:53,540 --> 02:13:57,820
It goes down to the C level where Python implemented this and goes oh, I can take that list in

994
02:13:57,820 --> 02:14:04,820
memory and just stick it in very fast into a single string. Okay. Sort is a method on

995
02:14:04,820 --> 02:14:11,820
list and some other objects. It returns none but it asks the list to sort itself and it

996
02:14:17,620 --> 02:14:24,620
does. Reverse is also a method. Returns none. Asks the list to sort itself. Okay. If I take

997
02:14:24,620 --> 02:14:31,620
that list and I call sort on it with reverse equal true. Okay. So this probably looks similar

998
02:14:36,460 --> 02:14:42,540
to sorted and reversed with an ED on the end but they're not. These are methods on list.

999
02:14:42,540 --> 02:14:48,300
Sort and reverse. Sorted and reversed are functions that you pass an iterable to and

1000
02:14:48,300 --> 02:14:53,060
they return something either a list or something that can be turned into a list, an iterable.

1001
02:14:53,060 --> 02:15:00,060
In this case we're calling methods on the list. So if I do this, what's that going to

1002
02:15:02,620 --> 02:15:09,620
do? This string will get passed off the list. Sort will be called on the list and sort does

1003
02:15:10,020 --> 02:15:17,020
what? Sorts the list. Asks the list to sort itself and what does sort return? None. And

1004
02:15:17,500 --> 02:15:23,500
none. Does none have a reverse? That's right. So let's see if the error says that. None

1005
02:15:23,500 --> 02:15:28,580
type has no attribute reverse. And these are intentionally, the behavior is done this way

1006
02:15:28,580 --> 02:15:35,580
to make sure you don't mix them up. Whereas sorted, the function is not a method. So there's

1007
02:15:36,020 --> 02:15:42,240
a sorted function. It's not a method on list. But it is a function that you can pass any

1008
02:15:42,240 --> 02:15:46,620
iterable to and it sorts it. It gives you back a list which is sorted, the sorted elements

1009
02:15:46,620 --> 02:15:53,620
of whatever you pass to it. Okay. And that works. So here's months. Months zero. Try

1010
02:15:59,340 --> 02:16:06,340
it again. Here's months. Months sub zero is March. Three is June. Minus one, minus two.

1011
02:16:06,340 --> 02:16:13,340
This is called a slice. This specifically is a slice. Python actually sees that and

1012
02:16:20,060 --> 02:16:23,620
creates a slice object. You can create them yourselves with the slice function which is

1013
02:16:23,620 --> 02:16:29,860
handy occasionally. And what it does is it says please return me a list containing the

1014
02:16:30,340 --> 02:16:37,340
elements starting at zero and stopping before you get to one. So this is going to return

1015
02:16:38,660 --> 02:16:45,660
me a list of how many elements? One. And it's going to return me a list or just a string?

1016
02:16:47,700 --> 02:16:53,300
Returns me a list. Or stop before you get to two. Element two. So March, April but not

1017
02:16:53,980 --> 02:17:00,980
the third one. I should start that with January. So what will this one do? Remember the list

1018
02:17:08,660 --> 02:17:15,660
is March, April, May, June, July. So it's going to give me March, April, May, June and

1019
02:17:16,620 --> 02:17:23,620
stop before July because months minus one is July. And what's this one going to do?

1020
02:17:26,100 --> 02:17:33,100
Who thinks error? Come on. Who thinks it will give me a whole list? It could go either way.

1021
02:17:35,860 --> 02:17:41,020
This is what it does. Again, what I'm showing you these things for is not to say, isn't

1022
02:17:41,020 --> 02:17:46,220
Python weird? Python shows this way of working. And once you get to know Python, there's

1023
02:17:46,220 --> 02:17:50,740
a lot of consistency in lots of places. So once you've seen this and a few of the other

1024
02:17:50,740 --> 02:17:53,340
things, then I can show you other codes. Say what do you think this is going to do? You

1025
02:17:53,340 --> 02:17:56,220
say, oh, well, given what I've seen before, it's going to do that. So it's consistent

1026
02:17:56,220 --> 02:18:00,660
in the way it treats things. There's lots of empty cases and optional arguments, et

1027
02:18:00,660 --> 02:18:06,340
cetera. So what's this one going to do? I didn't say stop before minus one. So it's

1028
02:18:06,340 --> 02:18:11,020
going to go all the way to the end just like this one did. Oh, by the way, again, if you

1029
02:18:11,020 --> 02:18:16,180
read this as start at element zero and stop before you get to 100, then it feels okay

1030
02:18:16,180 --> 02:18:20,220
because it did. It stopped before 100. It stopped at the end of the list. Okay, so this

1031
02:18:20,220 --> 02:18:24,780
one is just going to return a copy of the list. Not the same list, a copy of it. That's

1032
02:18:24,780 --> 02:18:29,740
one of the three ways you can copy a list are that, that and that. So if you need a

1033
02:18:29,740 --> 02:18:36,740
copy of a list, any one of those works. Oh, look, copy works on tuple too. Where does

1034
02:18:45,460 --> 02:18:50,460
it work? It actually works on byte array, dict, frozen set, list and set. Those are

1035
02:18:50,460 --> 02:18:57,460
the built-ins that have a copy method. Okay. March, April, May, June, July, Mon, July,

1036
02:18:59,740 --> 02:19:06,740
Months, two. Is Months two equal to Months? Yes. Are they the same? No. All right. Remember,

1037
02:19:08,620 --> 02:19:14,180
let's delete Months zero and of course Months sub zero. We're going to drop March from

1038
02:19:14,180 --> 02:19:21,180
Months and Months two, it changed the list Months, right? But Months two is a different

1039
02:19:22,260 --> 02:19:29,260
list. So this should all be pretty clear. Okay. So this is the list. So this is the

1040
02:19:29,740 --> 02:19:36,740
list. I can do this. All right. I can change elements in the list using, just like I used

1041
02:19:41,900 --> 02:19:48,900
Dell and equal before. I can append August. If I want to change August based on what it

1042
02:19:49,100 --> 02:19:54,220
is currently, I have to do this, right? I have to pull it out, create a new string which

1043
02:19:54,220 --> 02:20:01,220
is capitalized, put it back in. Okay. Yep. No. I'm almost, no it's not. I'm 99% sure.

1044
02:20:12,140 --> 02:20:19,140
No, I'm sure. Prove me wrong. Okay. I did that already. So Dell Months two, this is

1045
02:20:20,140 --> 02:20:27,140
how you delete an object at an offset in a list as opposed to remove. Remember remove

1046
02:20:27,220 --> 02:20:31,660
says go search for that and pull it out, drop it from the list. This one says go find element

1047
02:20:31,660 --> 02:20:36,780
at index two and delete it and it just sticks back together. Lists are very efficient in

1048
02:20:36,780 --> 02:20:41,380
Python or a wide range of use cases. So they're good for short ones, long ones. They sort

1049
02:20:41,380 --> 02:20:44,780
of, when they get to a certain point and you have to grow them, they sort of grow a lot

1050
02:20:44,780 --> 02:20:49,060
as opposed to growing a little bit at a time. So they work well in lots of situations.

1051
02:20:49,700 --> 02:20:56,700
There's a nested list, a list of two lists and you can access the elements that way.

1052
02:20:56,700 --> 02:21:00,380
You don't see that very often, especially because it's places where you would want

1053
02:21:00,380 --> 02:21:05,380
to do lots of nesting of big lists. You're probably using NumPy or Pandas or something.

1054
02:21:05,380 --> 02:21:12,380
Alright. Here are exercises. I think I'm going to, I think I'm going to go back to the

1055
02:21:19,060 --> 02:21:26,380
give you one minute for it. Yeah, because only the first one is really that interesting.

1056
02:21:49,060 --> 02:21:56,060
Okay.

1057
02:22:19,060 --> 02:22:26,060
Okay.

1058
02:22:49,060 --> 02:22:56,060
So, these exercises are, teach you one new thing here. M sub one equals 10, 20. We've

1059
02:22:56,060 --> 02:23:03,060
seen that before. We said change the element, you know, list, please change your element

1060
02:23:04,060 --> 02:23:11,060
at index one. Replace it with the following object. So this is going to create a list

1061
02:23:13,540 --> 02:23:20,540
within a list. Okay. So, if you're using NumPy, you're going to be using NumPy, and

1062
02:23:21,660 --> 02:23:28,660
you're going to say, well, what is this? I'm going to say, well, this is a list. So,

1063
02:23:29,260 --> 02:23:36,260
this is going to create a list within a list. Alright. So, let's put it back to zero, one,

1064
02:23:36,260 --> 02:23:42,780
two. So, you can do slices and assignment. This says change the elements of the list

1065
02:23:42,780 --> 02:23:47,540
starting at one and ending before you get to two, which is the element, which is the

1066
02:23:47,540 --> 02:23:54,060
one, and replace them with these elements instead. So, that's the way you can splice

1067
02:23:54,140 --> 02:24:01,140
a list. Okay. That's quite handy. This here, you can explore later. It's just, there's

1068
02:24:01,900 --> 02:24:06,900
things you can do with the range. Range is a built-in function that returns an iterable,

1069
02:24:06,900 --> 02:24:13,900
and you can use it to iterate, well, an iterable over numbers. Start at 10, stop before you

1070
02:24:13,980 --> 02:24:20,020
get to 20. Same thing, but count by threes. Count by tens from zero. Stop before you get

1071
02:24:20,020 --> 02:24:25,020
to 100. Alright. You can step backwards instead. This is the stop, the start, and the step.

1072
02:24:25,020 --> 02:24:32,020
Notice that with, oh, I didn't actually show that. I should show you. If you only give

1073
02:24:35,260 --> 02:24:41,460
it one argument, it assumes you mean the stop, and start is, zero is the default for the

1074
02:24:41,460 --> 02:24:45,260
start. If you give it two, then it says, oh, you mean start at 10 and stop at 20. That's

1075
02:24:45,260 --> 02:24:52,260
kind of unusual, but intuitive. Here, well, what's going on here? Here, I'm saying, give

1076
02:24:52,540 --> 02:24:59,220
me a list from zero to 99, and then do a slice, which is starting at offset 100, counting

1077
02:24:59,220 --> 02:25:06,220
by stop before you get to as far as you can go, and instead of, and here we're doing a

1078
02:25:08,900 --> 02:25:13,900
step as part of the slice instead. So, this is going to give us, this one's hard to predict

1079
02:25:13,900 --> 02:25:20,900
if we get it right. I don't think I will get it right. I'm going to start at 99 and

1080
02:25:21,620 --> 02:25:28,620
give us 89 all the way down to 9, maybe? Yes. And this one's similar, right? Start at minus

1081
02:25:30,660 --> 02:25:37,660
one, which means start at the end. Stop before you get to the element at offset one, which

1082
02:25:38,460 --> 02:25:45,460
is the number one. Zero is going to be zero, and count by minus one, and count by tens.

1083
02:25:52,060 --> 02:25:56,820
So slicing and indexing work on strings and tuples, too. So all this stuff, all this fancy

1084
02:25:56,820 --> 02:26:03,820
stuff in here, you can use on strings and tuples, but you can't change them, of course.

1085
02:26:07,660 --> 02:26:14,660
So, range eight gives me this range object. I can create a list by doing a for loop. You

1086
02:26:20,060 --> 02:26:23,140
haven't seen a for loop before, of course. Most of you have seen a for loop, but this

1087
02:26:23,140 --> 02:26:27,940
is the way you do a for loop in Python. You do for, name a variable that's going to get

1088
02:26:27,940 --> 02:26:33,940
bound to each of the elements in range eight as the for loop iterates over that object,

1089
02:26:33,940 --> 02:26:38,460
right? Think of range eight as a list, and that's the easy way to think of it. It's

1090
02:26:38,460 --> 02:26:41,380
actually a little bit more complicated. It's an object that every time for loop asks for

1091
02:26:41,380 --> 02:26:46,980
the next one, it gives it the next one, but it only computes it on as requested. And then

1092
02:26:46,980 --> 02:26:53,980
for each one, append i to the list m, and maybe I shouldn't show what m is here. And

1093
02:26:54,420 --> 02:27:01,420
we get that list. This syntax is called a list comprehension, and the nice thing about

1094
02:27:04,220 --> 02:27:08,300
it is, well, one, it's a little bit shorter code, but much more important, and this is

1095
02:27:08,300 --> 02:27:13,020
the way I suggest you think about it, it's a declaration of what you want, not how to

1096
02:27:13,020 --> 02:27:20,020
get it. And that's part of why it was adopted as a feature in Python. So it's similar, though.

1097
02:27:21,020 --> 02:27:28,020
We define, sorry, in a sense, we're saying for i in range eight, for e in range eight,

1098
02:27:30,420 --> 02:27:37,420
let's change that to i. And then what it does is it evaluates the first expression before

1099
02:27:40,340 --> 02:27:46,500
the word for, and whatever that evaluates to becomes the element that gets added to

1100
02:27:46,500 --> 02:27:50,860
the list as it builds the list. So it does that several times. And so this is just going

1101
02:27:50,860 --> 02:27:55,300
to give us the same thing we saw above. But I can have other expressions, right? I can

1102
02:27:55,300 --> 02:28:01,300
have two times e. So now I'm going to get two times zero, two times one, two times two,

1103
02:28:01,300 --> 02:28:06,380
all the way up to two times seven, right? Or I can do two plus, which would give me

1104
02:28:06,380 --> 02:28:12,020
two to nine instead of zero to seven. You can also have an if statement in there that

1105
02:28:12,020 --> 02:28:19,020
says, but only put this expression in the list if this value here has, if that evaluates

1106
02:28:23,220 --> 02:28:29,860
to true, right? And then it's just going to skip the odd ones. It's going to only include

1107
02:28:29,860 --> 02:28:35,460
the even ones, right? Put that in the list if it evenly divides by two. And you can have

1108
02:28:35,460 --> 02:28:40,100
other stuff here, right? Here's an f string, a big, long, complicated f string, relatively

1109
02:28:40,100 --> 02:28:43,540
speaking. It's bigger than the rest of the list comprehension. So it's going to put a

1110
02:28:43,540 --> 02:28:50,540
string in and evaluate that each time for all of those eight. And I get that. And I

1111
02:28:50,660 --> 02:28:57,660
can combine the, you know, complicated string and an if statement. Right. So I think this

1112
02:29:01,960 --> 02:29:08,960
is easier to read than that and cleaner and nicer. I think this is easier to read than

1113
02:29:10,100 --> 02:29:17,100
this is maybe not as clear as a for loop. So use list comprehension sparingly. Right?

1114
02:29:19,020 --> 02:29:26,020
It makes sense in some cases, but not all cases. So you notice here I didn't use the

1115
02:29:28,260 --> 02:29:34,820
E in the expression that gets evaluated to put stuff into the list. So it's just going

1116
02:29:34,820 --> 02:29:40,820
to give me eight spams. Right? So again, unusual use case. I think this is weird. I

1117
02:29:40,820 --> 02:29:45,260
would look at this code and say, is that what you meant? Yeah. Do it some way that's clear

1118
02:29:45,260 --> 02:29:51,380
that that's what you meant. Anyway. Okay. Oh, and you can do these nested, by the way.

1119
02:29:51,380 --> 02:29:58,380
You can have spam for E in range eight or you can have spam, E2 for E in range eight

1120
02:29:58,380 --> 02:30:05,380
or E2 in, I have, I've never seen a nested list comprehension that made sense to me easily.

1121
02:30:05,700 --> 02:30:10,540
So I would usually avoid that too. Anyway. All right. Let's, let's create months. Give

1122
02:30:10,540 --> 02:30:16,140
a name months, bind it to a list of three tuples, which are in alphabetical order, April,

1123
02:30:16,140 --> 02:30:19,220
February, March. They're not in month order and they're not in order based on the number

1124
02:30:19,220 --> 02:30:26,220
of days. There we go. So if I sort these things, as in create a new list which is sorted from

1125
02:30:27,100 --> 02:30:33,620
the old list, I get the same thing. If I reverse it, yeah, that's fine. It all works. And you

1126
02:30:33,620 --> 02:30:38,340
notice the way it's doing that sorting is it's comparing the tuples. Right? And you

1127
02:30:38,340 --> 02:30:43,340
know how it compares tuples. It compares the first element, then the set, then the third.

1128
02:30:43,340 --> 02:30:50,340
Right? All right. Let me show you some cool stuff in Python. Months sub two gives me,

1129
02:30:50,340 --> 02:30:57,340
oh, zero, one, two. It gives me March three thirty-one, which is why it's right there.

1130
02:30:59,780 --> 02:31:06,380
All right. So let me define a function called get index one, which instead of, which accesses

1131
02:31:06,380 --> 02:31:13,380
the element at, whatever you pass it, it accesses element at index one. So if I call get index

1132
02:31:13,380 --> 02:31:18,380
one of months, well, here's zero and here's one. So it should give me back that tuple,

1133
02:31:18,380 --> 02:31:23,380
right? So I've defined the function. Here's how you define a function in Python, by the

1134
02:31:23,380 --> 02:31:28,540
way, in case you've never seen it. Right? You choose the name of the function. You choose

1135
02:31:28,540 --> 02:31:32,540
to name the arguments, whatever you want. You use those names in here. You return something

1136
02:31:32,540 --> 02:31:37,740
when you're done. Okay. So let's do a get index one of months and hope we get the February

1137
02:31:37,740 --> 02:31:44,180
tuple back out. And if I do get index one of months sub two, this is just to make you

1138
02:31:44,180 --> 02:31:50,340
think. Right? So if I take months sub two, which would be March three thirty-one, and

1139
02:31:50,340 --> 02:31:57,340
call get index one on it, I should get back the three. Right? Okay. So Python, it's very

1140
02:32:00,420 --> 02:32:07,420
common in Python to have functions that return functions. So at the top of your screen, you

1141
02:32:07,740 --> 02:32:13,820
see my screen is the straightforward way to define the function get index one. At the

1142
02:32:13,820 --> 02:32:20,100
bottom here is I import the operator module. I call its item getter callable, which is

1143
02:32:20,100 --> 02:32:24,300
a function, and I pass it the number one. It returns me a function that does the same

1144
02:32:24,300 --> 02:32:30,420
thing. Okay? And for some of you, if you're like me, having worked in other languages,

1145
02:32:30,420 --> 02:32:34,380
this is a function that returns a function. That's really weird. But once you get used

1146
02:32:34,380 --> 02:32:38,700
to it, it's really, really powerful. And so if your brain hurts a little bit for some

1147
02:32:38,700 --> 02:32:43,220
of this stuff, that's normal. Keep trying and pretty soon you'll become fluent in it.

1148
02:32:43,220 --> 02:32:47,380
And you're like, oh yeah, this is way easier. It really makes sense. So I've just created

1149
02:32:47,380 --> 02:32:53,540
a function, and I bound that function in the namespace to this. Right? So it's kind of

1150
02:32:53,540 --> 02:32:58,780
funny because I take a function object and do an assignment of the name. I bind the name

1151
02:32:58,780 --> 02:33:02,540
get index one in the current namespace to that new function object. Well, that's exactly

1152
02:33:02,620 --> 02:33:08,820
how the DEF works. DEF basically evaluates some code, creates a function object, and

1153
02:33:08,820 --> 02:33:14,300
then adds the name to the namespace. Anyway, a little digression there. So now if I call

1154
02:33:14,300 --> 02:33:18,300
get index one, month two, I'm going to get the same thing, of course, as I did earlier.

1155
02:33:18,300 --> 02:33:25,300
Three, and there's the two. And what is index one of these tuples? It's the number of the

1156
02:33:25,300 --> 02:33:32,300
month. Now here's the trick. Is I can, oh no, wait, wait. Yeah, so that's just the third

1157
02:33:34,580 --> 02:33:41,580
one. So all I've done here is instead of having get index one, I just substitute the item

1158
02:33:41,660 --> 02:33:48,660
operator, item getter one. So here's this call. This is a hard one to read, eh? Let

1159
02:33:48,820 --> 02:33:55,820
me walk it through you slowly. Look at operator. It's a module. Access the object, which is

1160
02:33:56,420 --> 02:34:02,020
item getter. Look at the one. Create an integer object. Pass it off to this function. Whatever

1161
02:34:02,020 --> 02:34:09,020
it returns, call it because it's a function object. I can call it. Passing it, well, that

1162
02:34:09,100 --> 02:34:13,020
thing. All right? So that's what's going on there. And again, hard to read if you haven't

1163
02:34:13,020 --> 02:34:20,020
seen it before, but easy once you get used to it. So it works. It returns two, meaning

1164
02:34:21,140 --> 02:34:28,140
months sub one, which is February, is month number two. Okay. So here's the way you might

1165
02:34:28,500 --> 02:34:33,180
see it is, again, these are the same, but this is a common idiom. You'll often see,

1166
02:34:33,180 --> 02:34:39,660
I want to sort this based on a certain key. Right? And so what this does, this is called

1167
02:34:39,660 --> 02:34:45,300
a callback. So I pass sorted. You saw the sorted months reverse equals true. Well, here

1168
02:34:45,300 --> 02:34:52,300
I'm saying don't sort month in reverse order. I'm saying pass it by using as the key. When

1169
02:34:52,660 --> 02:34:58,660
you want a key, sort method, sorry, sort function, when you want a key to figure out how to compare

1170
02:34:58,660 --> 02:35:05,660
two things, to figure out the key for the sort, what order they should go in, call this

1171
02:35:05,860 --> 02:35:12,860
function. So every time that sorted, so sorted gets a list, it might be huge, and it goes,

1172
02:35:13,020 --> 02:35:15,820
which one goes first? We'll have to compare all these. It's doing all these comparisons.

1173
02:35:15,820 --> 02:35:18,380
Which one's less than, which one's greater than, which one's less than, these two are

1174
02:35:18,380 --> 02:35:22,320
equal, et cetera. Every time it does that, it looks at the objects. If key was passed

1175
02:35:22,320 --> 02:35:28,420
in, it calls that, it takes the object, passes it off to whatever operator, item getter,

1176
02:35:28,420 --> 02:35:35,060
one return, which is a function, and that pulls out of the object the piece that I should

1177
02:35:35,060 --> 02:35:41,020
actually, the sort function should be comparing. Okay? So that's how you can sort on something

1178
02:35:41,020 --> 02:35:48,020
other than just the straightforward order of a tuple. So if you're brave, don't snicker

1179
02:35:50,220 --> 02:35:55,220
at your neighbor. How many of you found that confusing? Oh, come on. I don't believe

1180
02:35:55,220 --> 02:36:01,060
you. I would have. Yeah, no, it's hard to get used to, but this is functions as first

1181
02:36:01,060 --> 02:36:08,060
class objects in Python were the most, very powerful thing. Okay. I'll give you one minute

1182
02:36:17,140 --> 02:36:24,140
for this one. For the exercises, go ahead.

1183
02:36:31,060 --> 02:36:38,060
Okay.

1184
02:37:01,060 --> 02:37:08,060
Okay.

1185
02:37:31,060 --> 02:37:38,060
Okay.

1186
02:38:01,060 --> 02:38:08,060
Okay. I'm going to keep us moving along. We're in the home stretch, less than an hour. I think

1187
02:38:13,660 --> 02:38:20,660
we've only got 40 minutes. Is that right? Thanks. Thanks for checking my math. Okay.

1188
02:38:20,660 --> 02:38:27,660
So this was straightforward. Straightforward, I think. Oh, yeah, nested. Yuck. It's getting

1189
02:38:28,660 --> 02:38:35,660
hard to read. Don't do it. Enumerate is something that, so in Python, in many languages, you

1190
02:38:38,260 --> 02:38:42,900
need to create an index value and enumerate and count starting at zero in order to do

1191
02:38:42,900 --> 02:38:46,340
things to a list. Python, you don't need to do that. So enumerate, you'll often will find

1192
02:38:46,340 --> 02:38:51,900
being used when you actually care as you walk through a list what element am I at. But you

1193
02:38:51,900 --> 02:38:56,860
can see what enumerate does is it takes an interval and it returns for each of the elements

1194
02:38:56,860 --> 02:39:02,140
of that interval, it returns a pair, which is the offset into the interval and the element,

1195
02:39:02,140 --> 02:39:09,140
the offset and the element. So here we get zero A one B two C. So basically, instead

1196
02:39:10,340 --> 02:39:15,100
of returning A, which it would have without the enumerate, it now returns the tuple zero

1197
02:39:15,100 --> 02:39:22,100
comma A. You can do various things with that. Zip is sort of like a zipper, but instead

1198
02:39:23,100 --> 02:39:28,740
of like this, it's, instead of like this, it pairs things together. Whatever you pass

1199
02:39:28,740 --> 02:39:35,740
it, two or more elements, it takes them all and puts them into tuples. So what this is

1200
02:39:35,740 --> 02:39:42,740
going to do is create a list of Jan one, Feb two, Mar three. All right. I threw in the

1201
02:39:42,740 --> 02:39:49,740
split just to, you know, keep things interesting. What's this going to do? I've got three months

1202
02:39:50,620 --> 02:39:55,980
and four months numbers. I know you can do it. Who thinks it's going to work? Raise

1203
02:39:55,980 --> 02:40:02,980
your hand. Who thinks it's going to give an error? It works. Weird, eh? But again, there

1204
02:40:04,580 --> 02:40:09,780
are, once you get used to this style of zip's going to stop when it gets to the end of one

1205
02:40:09,780 --> 02:40:14,100
of them, it's really handy. There are lots of places where you don't need to, lots of

1206
02:40:14,100 --> 02:40:17,060
places where what would have been two lines of code or an if statement is just, well,

1207
02:40:17,060 --> 02:40:21,740
just do this thing and for the default empty thing, it'll do the right whatever. That

1208
02:40:21,740 --> 02:40:26,700
wasn't very articulate. Sometimes you actually do care and you want something else, so you

1209
02:40:26,700 --> 02:40:32,700
can call ittertools.izip longest, I think, in supply default. Well, that's to do the

1210
02:40:32,700 --> 02:40:39,700
opposite. Anyway, so that's a little surprising, but that's the way it works. All right. And

1211
02:40:40,500 --> 02:40:44,700
these are just different ways to do fancy. All right. And then I told you to do that

1212
02:40:44,700 --> 02:40:50,460
and I'm not going to show you how you know how to do that. So, on to the next section.

1213
02:40:50,460 --> 02:40:56,900
Dictionaries are amazing. What I mean by that is they're really fast in Python and they

1214
02:40:56,900 --> 02:41:03,580
have order and lookup time and over the years, if you program in Python that long, you will

1215
02:41:03,580 --> 02:41:09,380
find yourself using dictionaries for more and more solutions to problems. And you'll,

1216
02:41:09,380 --> 02:41:13,100
and at first you're like, oh yeah, does that work? You'll see solutions to problems where

1217
02:41:13,100 --> 02:41:20,100
dictionaries, they're really powerful. Anyway, to explain dictionaries, we sort of hinted

1218
02:41:22,580 --> 02:41:26,560
at them over here. It's key value pairs. So let me start by explaining dictionaries by

1219
02:41:26,560 --> 02:41:31,840
reminding you at a higher level of abstraction, sort of mathematical. A list is a mapping,

1220
02:41:31,840 --> 02:41:36,980
a one-to-one mapping from a domain to a range. Anyone remember this from high school math?

1221
02:41:37,980 --> 02:41:44,980
And the domain is zero, one, two, three, et cetera. It starts at zero, counts up. So it's

1222
02:41:44,980 --> 02:41:49,540
ints to something. So that's what I mean by here, from ints to anything. You can have

1223
02:41:49,540 --> 02:41:55,340
anything in a list. Right? So here's an example. And I'm going to take January Firmware. I'm

1224
02:41:55,340 --> 02:42:00,340
going to add none to the front of it. Or if you have a newer version of Python, you can

1225
02:42:00,340 --> 02:42:06,340
just do that, which is kind of cool. Another example of this unpacking. And now, conveniently,

1226
02:42:07,140 --> 02:42:12,140
index zero is none. Index one is January, which we call the first month of the year.

1227
02:42:12,140 --> 02:42:15,540
February is the second month, and March is the third month. So that's why I did that.

1228
02:42:15,540 --> 02:42:19,940
Right? So now I can say, what's the first month? January. Second month. Third month.

1229
02:42:19,940 --> 02:42:24,980
A dictionary, you don't need to go to that hassle. You can just put in one maps to January,

1230
02:42:24,980 --> 02:42:28,660
two maps to February, three maps to March. I didn't have to put in some weird none. So

1231
02:42:28,660 --> 02:42:33,660
now I have something like that. Right? Now I can just say, tell me what month number

1232
02:42:33,660 --> 02:42:40,660
it is. Right? Or I can do that and get the reverse. Right? So what I'm doing here is

1233
02:42:43,780 --> 02:42:50,780
N, N, M. You notice I have for N, M, and then I have for M, colon, N. So this is a list

1234
02:42:51,700 --> 02:42:56,760
this is a dictionary comprehension where similar to a list comprehension uses a curly brace

1235
02:42:56,760 --> 02:43:01,260
instead of a square bracket. And instead of a single expression, it has two expressions

1236
02:43:01,260 --> 02:43:04,380
with a colon between them because that's the syntax of dictionaries as you see down

1237
02:43:04,380 --> 02:43:08,580
here. The key value pairs are separated by a colon. So same idea, slightly different

1238
02:43:08,580 --> 02:43:13,420
syntax. Play with it later and you'll get used to it. So here what I have is I've turned

1239
02:43:13,420 --> 02:43:20,420
that list into, well sorry, that list of, the list way up there in cell one into mapping

1240
02:43:23,380 --> 02:43:30,380
from month to month number. Okay? So now I can say, well what month number is January?

1241
02:43:31,260 --> 02:43:38,260
February? March? And it just works. Right? April, key error. That one's new, right?

1242
02:43:38,860 --> 02:43:43,800
Key errors when you try to access a key in a dictionary that isn't there. So I can add

1243
02:43:43,800 --> 02:43:50,420
it similar to the same syntax as list except instead of giving it an int, I'm giving it

1244
02:43:50,420 --> 02:43:55,560
almost whatever I want. I'm giving it a key and it puts the key value pair in. So it inserts

1245
02:43:55,560 --> 02:44:01,120
April four as a key value pair and then the lookup on April, that's the part that's just

1246
02:44:01,120 --> 02:44:06,200
really fast. No matter, a list of a million and it would look it up super fast because

1247
02:44:06,200 --> 02:44:13,200
it uses hashes. Go read about it. And then once I've done that, I can look at it. So

1248
02:44:14,200 --> 02:44:19,480
in Python three, if you're using an older version of Python, like three, I can't remember,

1249
02:44:19,480 --> 02:44:25,280
I think it's three, six is when sort, is when dictionary order of insertion was preserved.

1250
02:44:25,280 --> 02:44:28,200
So in this case, you notice when it prints out, it prints it in the order that they were

1251
02:44:28,200 --> 02:44:34,900
put in. I added month, April last and it shows up last. Before three, six, you, no guarantee

1252
02:44:34,900 --> 02:44:39,240
what the order was because that wasn't the purpose of dictionaries, was not primarily

1253
02:44:39,240 --> 02:44:45,680
about ordering. Anyway, so you can use in and it looks for the key. If you want to look

1254
02:44:45,680 --> 02:44:52,680
for the value, it's a lot slower. Month to int, if I do a del, it's going to delete

1255
02:44:53,480 --> 02:44:58,280
the one at that offset is what is the, is the terminology I use for a list. In this

1256
02:44:58,280 --> 02:45:04,280
case, delete the one at that key or that key and its value. The key value pair gets deleted.

1257
02:45:04,280 --> 02:45:10,720
It's gone. It's not in there anymore. Okay. Let's do a few things fun with dictionaries.

1258
02:45:10,720 --> 02:45:17,720
Here's an empty dictionary. For C in Mississippi, letters sub C equals one. So it's going to

1259
02:45:18,400 --> 02:45:25,400
add keys M, I, S and P to the dictionary multiple times except the M, it'll only add it once.

1260
02:45:28,200 --> 02:45:35,200
It'll keep overwriting some of them and each one will have the value one, right? So there's

1261
02:45:36,640 --> 02:45:43,640
the dictionary and those are the letters in Mississippi. So there's an example, trivial

1262
02:45:43,920 --> 02:45:48,040
of okay, I need, I've got this huge list. What are the unique keys of it or something?

1263
02:45:48,040 --> 02:45:55,040
What are the unique values in this list? Dictionary is a quick way to do it. You can also do this.

1264
02:46:02,240 --> 02:46:09,240
Dict dot, so dict dot, what I'm doing here is I'm, dict is the type from keys is a function

1265
02:46:09,320 --> 02:46:13,760
that's in that. So I'm not calling a method on a dictionary. I'm calling the function

1266
02:46:13,760 --> 02:46:17,480
that's in the dict that's sort of hanging off the dict type. And I'm saying create

1267
02:46:17,480 --> 02:46:24,480
me a new dictionary from the following keys. It's just going to create a dictionary with

1268
02:46:27,040 --> 02:46:32,280
those keys M, I, S and P and they all have the value none by default. You can add a different

1269
02:46:32,280 --> 02:46:37,280
default in here if you want as a second argument. Okay.

1270
02:46:37,280 --> 02:46:44,280
And here's another way to do the same thing where I'm using a dict comprehension. All

1271
02:46:45,280 --> 02:46:52,280
right. Okay, let's import collections. Remember that int returns zero if you call it with

1272
02:46:52,320 --> 02:46:56,240
nothing. So now I'm going to call, I'm going to create a default dict. Default dict is

1273
02:46:56,240 --> 02:47:03,240
a type that lets, that basically it's a dictionary that to start with is empty. But if I access

1274
02:47:04,240 --> 02:47:08,240
an element that's not in there, it doesn't fail. Instead it goes off and calls whatever

1275
02:47:08,240 --> 02:47:15,240
function I pass to it, puts in whatever that function returns and gives it back to me remembering.

1276
02:47:16,120 --> 02:47:23,120
Oh, all right. And now it knows that M is zero. Right? So now I can do this. I can actually

1277
02:47:24,960 --> 02:47:29,840
pull the value out, add one to it, put it back in. Even for letters like S that aren't

1278
02:47:29,840 --> 02:47:36,120
in there yet, it'll assume that there was a zero in there. Oh, so now I actually have

1279
02:47:36,120 --> 02:47:43,120
a count of the letters. Right? How many S's are in Mississippi? There are four. And I

1280
02:47:43,520 --> 02:47:49,960
can look at the, there's a, dictionaries have dot keys, dot items, dot keys, dot values

1281
02:47:49,960 --> 02:47:55,560
and dot items. The keys give just the keys, the items, values just give the values and

1282
02:47:55,560 --> 02:48:02,560
the items give the pairs. Okay. There's also collections, a counter thing that's a lot

1283
02:48:03,680 --> 02:48:08,680
easier, so you can just do that. Interestingly, dictionary views are these things that keys,

1284
02:48:08,680 --> 02:48:14,640
values and items return. You can iterate over them and do membership tests on them. So I

1285
02:48:14,640 --> 02:48:21,640
can iterate over them. What's the most, how many, find the highest number of, it's hard

1286
02:48:22,480 --> 02:48:29,480
to describe, Mississippi has letters. What's the most common letter? This doesn't answer

1287
02:48:29,480 --> 02:48:32,120
that. It's how many of them are there? The answer is there's four. There's more than

1288
02:48:32,120 --> 02:48:37,800
one letter that have four. Okay. And is Z in counts keys? No. Okay. There's also a set

1289
02:48:37,800 --> 02:48:44,800
type in Python, which is basically implemented and think about it a lot. Like it's the keys,

1290
02:48:46,480 --> 02:48:51,480
a set is like a dictionary with only the keys where the values are ignored. They're not

1291
02:48:51,480 --> 02:48:55,680
even stored in the dictionary. Right? So the set of Mississippi gives me that. You notice

1292
02:48:55,680 --> 02:48:59,280
there's no ordering on that, by the way. It doesn't order at M and then M. Like the set

1293
02:48:59,280 --> 02:49:05,280
order doesn't matter. Assiniboine is the river that I live close to and it also has lots

1294
02:49:05,280 --> 02:49:10,520
of I's and S's and N's, which is nice. So I can do things like what are the letters in

1295
02:49:10,520 --> 02:49:17,520
Assiniboine? I can do subtraction. I can do intersection. I can do or. Right? I can do

1296
02:49:18,520 --> 02:49:23,720
equality, of course. So lots of stuff you can do with sets, which are nice. And you

1297
02:49:23,720 --> 02:49:29,040
can do those straight on the views that dictionary gives you back. You can actually do set operations

1298
02:49:29,040 --> 02:49:36,040
on those directly, which is very nice. That doesn't do what I expected it to because

1299
02:49:37,480 --> 02:49:44,480
I didn't give it what I thought. Sorry. Because what I wanted here is probably the set of

1300
02:49:47,520 --> 02:49:53,680
sets. Doesn't matter. Trust me, it works. We'll keep going. No. Trust me, this doesn't

1301
02:49:53,680 --> 02:49:56,800
work because I did the wrong thing. But what I'm pointing out is you can do set operations

1302
02:49:56,800 --> 02:50:03,800
on the keys. The problem is the count keys. Oh, because count is, I don't know why it

1303
02:50:04,840 --> 02:50:08,080
didn't work. I'll figure it out later. Okay. So I said at the top here, you can put almost

1304
02:50:08,080 --> 02:50:12,480
anything in the dictionary as the key. You can't put everything. Hash is the way they

1305
02:50:12,480 --> 02:50:19,480
work. Hash basically returns a unique value for a string. Well, very unlikely. So it's

1306
02:50:20,280 --> 02:50:25,280
the way that dictionaries are fast. Try not to get distracted into those digressions.

1307
02:50:25,280 --> 02:50:32,280
And you can take a tuple and hash it. You can take a list and it says you can't, you

1308
02:50:33,000 --> 02:50:39,520
can take a list and hash it. And it will tell you it's unhashable. And the reason it's

1309
02:50:39,520 --> 02:50:43,120
unhashable is because you can change it and that would mess up the dictionary lookup if

1310
02:50:43,120 --> 02:50:47,680
you changed it after you put it in the dictionary. So that's why this is a valid dictionary and

1311
02:50:47,680 --> 02:50:54,680
this is a valid dictionary and this one doesn't work. Right? So if you really need to create

1312
02:50:54,680 --> 02:50:58,000
a dictionary with lists you know you're not going to change, you can create a subtype

1313
02:50:58,000 --> 02:51:03,240
of list and do stuff. But basically, the things you put into a dictionary, their hash can't

1314
02:51:03,240 --> 02:51:10,000
change once it's in the dictionary or it will mess up the way dictionaries work. Okay.

1315
02:51:10,000 --> 02:51:17,000
This one I'm going to just do a couple of these. I'm going to do, and I'll let you do

1316
02:51:26,040 --> 02:51:33,040
the rest later. Right? So pop and pop item. So pop item is the way that dictionaries work.

1317
02:51:33,320 --> 02:51:37,800
So a dictionary, once you put stuff in there you can access keys and values and items.

1318
02:51:37,800 --> 02:51:43,360
Pop says go get this one, take it out of the dictionary and return its key, sorry its value.

1319
02:51:43,360 --> 02:51:47,440
Take this key out and return its value. Pop item just says well go get me one and return.

1320
02:51:47,440 --> 02:51:54,440
Pop it out and give me some. Similar to list pop. Okay? And this one I'm going to skip

1321
02:51:55,240 --> 02:52:00,240
and the set stuff I'll let you play with. And I will just move on to this dictionary

1322
02:52:00,240 --> 02:52:07,240
example. I like this example. I hope it's helpful because the fact that functions are

1323
02:52:10,800 --> 02:52:17,800
first order objects, they're first class objects in Python, that and some other things

1324
02:52:17,800 --> 02:52:24,320
about Python blur the line more than usual between code and data. When you write Python

1325
02:52:24,720 --> 02:52:29,640
programs often you'll have stuff in code that looks in data, in a data structure that

1326
02:52:29,640 --> 02:52:34,040
looks like, that is code. And this shows you an example. And when you first see it it kind

1327
02:52:34,040 --> 02:52:38,480
of looks odd but you'll quickly, over time you'll learn, you'll say oh that thing I

1328
02:52:38,480 --> 02:52:43,320
wrote in that other language three years ago that was like 500 lines of if else statements.

1329
02:52:43,320 --> 02:52:48,200
I could have done it in a dictionary. And here's an example. So I'm just going to,

1330
02:52:48,200 --> 02:52:54,960
there's a little digression here to, let's create a calculator. Seven plus three. It's

1331
02:52:54,960 --> 02:52:59,080
a calculator that handles three characters. You can only give it three characters, a string

1332
02:52:59,080 --> 02:53:05,360
of three characters. So I'm going to start by reminding you that, oh, operator that had

1333
02:53:05,360 --> 02:53:10,720
item getter has a bunch of other things. It also has all the operators like the plus but

1334
02:53:10,720 --> 02:53:17,720
as names to objects that you can use as a function. So I can call operators add function

1335
02:53:18,640 --> 02:53:24,040
pass it two arguments and it's exactly the same as if I said seven plus three. Why don't

1336
02:53:24,040 --> 02:53:26,760
I just say seven plus three? Because I don't have to write an if statement. That's why.

1337
02:53:26,760 --> 02:53:33,760
You'll see why. Right? So that works. I'm looking for puzzled looks. I don't see too

1338
02:53:34,400 --> 02:53:41,400
many. So here I'm going to do the unpacking of my strictly three character calculator

1339
02:53:41,400 --> 02:53:48,400
input and get seven and a plus and a three. I'm going to turn the left hand side and

1340
02:53:48,400 --> 02:53:55,400
the right hand side of the plus operation into ints. So I get seven plus three with

1341
02:53:55,640 --> 02:54:02,640
the seven and the three as ints now instead of strings. Because then, oh, and now I'm

1342
02:54:02,640 --> 02:54:08,040
going to turn them around. Let's put the operator first so it looks like the order that operator

1343
02:54:08,720 --> 02:54:13,240
add needs. Now I've got the plus corresponds to the operator add and it passes the two

1344
02:54:13,240 --> 02:54:20,240
arguments in. Right? So that works. So now I do this. Right? So this is a dictionary

1345
02:54:25,640 --> 02:54:30,560
where the keys are a single character string, a string of length one and they happen to

1346
02:54:30,560 --> 02:54:36,600
be the operators plus and minus and the value is a function. So now, and again some of you

1347
02:54:36,600 --> 02:54:41,280
will go, this is obvious, others will go, this is really hard to think about. Ops sub

1348
02:54:41,280 --> 02:54:47,720
op is look in the dictionary for the key plus, for example, and whatever you get out, call

1349
02:54:47,720 --> 02:54:52,720
it, see the parentheses come right after this. Actually I put a space in there. But the point

1350
02:54:52,720 --> 02:54:58,040
is this is if you have an object and you put parentheses and some things and close parentheses,

1351
02:54:58,040 --> 02:55:01,720
that calls the object. So it's going to call the function. So when I call the function

1352
02:55:01,760 --> 02:55:08,760
add, I'm going to get ten. So here's my calculator. I define it taking an expression of three

1353
02:55:10,360 --> 02:55:17,360
characters. I do the same lines of code I just showed you and it returns the call of

1354
02:55:17,440 --> 02:55:24,440
the function it got out of the dictionary based on the single character string. Calls

1355
02:55:25,200 --> 02:55:28,880
it with the arguments it got out of that single string. I'm going to have to define it first.

1356
02:55:28,880 --> 02:55:35,880
So now I can do calc seven plus three, calc minus five, right? So it does math plus and

1357
02:55:36,360 --> 02:55:43,360
minus but it doesn't do slash. So the way you may have implemented something like this

1358
02:55:43,560 --> 02:55:49,680
in a class long ago or on your own long ago would have been an if statement. If it's a

1359
02:55:49,680 --> 02:55:56,680
slash do divide and all this stuff. Here if I want to change that I just add something

1360
02:55:57,320 --> 02:56:03,440
and it works. Again it's hard to imagine here but when you're doing something where you've

1361
02:56:03,440 --> 02:56:10,440
got lots of options often the data structure of code that holds code in the form of functions

1362
02:56:10,880 --> 02:56:17,880
is a lot easier to work with and all easier to maintain and reason about etc. Okay. Okay.

1363
02:56:18,880 --> 02:56:25,880
Anybody know what this is going to do? What? Syntax error. Yes. Indent error. I'm wrong.

1364
02:56:32,440 --> 02:56:37,200
It's an indentation error similar to a syntax error. So Python indentation matters. You

1365
02:56:37,200 --> 02:56:44,200
probably know that already but there's proof. Here's an example of a for loop. So you have

1366
02:56:45,200 --> 02:56:51,520
while and then an expression that evaluates to true or false or is evaluated as true or

1367
02:56:51,520 --> 02:56:55,600
false and we'll see later that some things that you might not think you could put there

1368
02:56:55,600 --> 02:56:59,480
you can like an empty list is false and a non-empty list is true. Anyway we'll see that

1369
02:56:59,480 --> 02:57:04,720
in a moment. So basically the colon starts a block. You put four spaces. You can do other

1370
02:57:04,720 --> 02:57:11,240
numbers and you can use tabs. Don't always use four spaces. It's what everyone does almost.

1371
02:57:11,240 --> 02:57:17,040
And then it executes these two lines of code and then it goes back up and says well is

1372
02:57:17,040 --> 02:57:20,480
i still less than five? If true it will keep going around the loop and as soon as it's

1373
02:57:20,480 --> 02:57:27,480
false it skips it to the end. Okay. So let's see if this works. Yes. The genie is out of

1374
02:57:29,080 --> 02:57:33,240
the bottle. Python is doing what we want. Here's an example of an if statement. If,

1375
02:57:33,240 --> 02:57:40,240
elif, elif, else. Just does some printing. Here's a for loop iterating over a string

1376
02:57:40,240 --> 02:57:47,000
which you've seen pieces of before but here's typically how it would look. Here's a nested

1377
02:57:47,000 --> 02:57:53,040
for loop. Right? And again it knows when does it, you can't see here but it ends the block

1378
02:57:53,040 --> 02:57:56,880
when it gets to the end of the file like in this case or when it gets to an unindented

1379
02:57:56,880 --> 02:58:01,000
line. So that's how it tells. So it's very clear. But unusual if you're used to curly

1380
02:58:01,000 --> 02:58:08,000
braces. Let's create a little dictionary. So you can see what it looks like. So it's

1381
02:58:10,240 --> 02:58:14,800
going to see what it looks like. Here's a simple for loop over a dictionary. So here

1382
02:58:14,800 --> 02:58:20,760
key and value for D in the items. So this is how you would iterate over. So you notice

1383
02:58:20,760 --> 02:58:27,760
here K comma V. This is a tuple. This is doing name tuple assignment. So items is going to

1384
02:58:27,760 --> 02:58:33,360
return pairs. Half the pair gets into K and the other in V. So K is bound to one. V is

1385
02:58:33,360 --> 02:58:40,360
bound to the other. Right? And I should do a nest string for that. Right? Here's a, loops

1386
02:58:47,960 --> 02:58:52,960
can have a break which says if you get to this, so here it's going to count, this for

1387
02:58:52,960 --> 02:58:56,240
loop is going to keep going, keep going, going until a thousand unless it hits a break which

1388
02:58:56,240 --> 02:59:01,280
it's going to because we have a nest statement in there. So a break is the way you stop early,

1389
02:59:01,280 --> 02:59:07,880
stop a for loop early. A continue is how you stop part way through the block of a for loop

1390
02:59:07,880 --> 02:59:14,880
and go to the next iteration around the loop. Okay? I can't remember why I have that one

1391
02:59:18,080 --> 02:59:23,880
in there. Well, you can have a pass. It just passes the empty. It does nothing. So apologize

1392
02:59:23,880 --> 02:59:30,880
for not remembering why. And these, 20 minutes left. So I'm going to stop here. So I'm going

1393
02:59:32,280 --> 02:59:39,280
to keep going. So is this going to print true or false? I told you two minutes ago. Well,

1394
02:59:45,040 --> 02:59:49,320
it's never going to print false because I didn't say to print false. Sorry. Is this

1395
02:59:49,320 --> 02:59:52,640
going to print true or not is what I should have said. All right? And the answer is it's

1396
02:59:52,640 --> 02:59:58,520
not going to print true because in Python, an empty list, an empty dict, an empty set,

1397
02:59:58,520 --> 03:00:05,520
the number 0, the number 0.0 in floats. Anything, I can't remember what else. Anything that

1398
03:00:06,120 --> 03:00:13,120
defines a dunder bool method and there's something else with non-zero. That might have been a

1399
03:00:15,600 --> 03:00:21,280
name change. Anyway, the point is there are things that are kind of falsy it's called.

1400
03:00:21,280 --> 03:00:26,160
And so, and that's confusing if you're not used to it. So this one especially, right?

1401
03:00:26,160 --> 03:00:30,120
Here I've got a list that only has something that is falsy because none is falsy. If you

1402
03:00:30,120 --> 03:00:34,000
say if none, it won't do it. Although as I mentioned earlier in a function, you would

1403
03:00:34,000 --> 03:00:41,000
often say if none, if argument is none because you care what they passed. You don't, I'll

1404
03:00:41,000 --> 03:00:45,440
explain that later. So this really looks like it ought to print true. But does it? Only.

1405
03:00:45,440 --> 03:00:49,080
Oh, it does because list is not empty. Non-empty. So it doesn't matter what's in the list.

1406
03:00:49,080 --> 03:00:53,000
As long as it's not empty, it's going to say, yeah, that's true and then therefore

1407
03:00:53,000 --> 03:00:59,360
I will execute that. So you can see that bool of that and that is why it did that.

1408
03:00:59,360 --> 03:01:03,160
And here are some other examples, right? Bool of an empty string is false. So an empty string

1409
03:01:03,160 --> 03:01:09,720
is falsy, truthy and falsy. I've only ever heard those talking about Python. How about

1410
03:01:09,720 --> 03:01:15,680
bool of false? It's true because it's a non-empty string and we don't need to convert. Like

1411
03:01:15,680 --> 03:01:19,080
int, it did a conversion. It's not going to convert the string false to false because

1412
03:01:19,080 --> 03:01:26,080
there's no point. So dictionaries, here's a, if you iterate over a dictionary without

1413
03:01:26,840 --> 03:01:33,840
the items, it actually just iterates over the keys. Okay? And you can do that. And I'll

1414
03:01:33,840 --> 03:01:40,840
skip those. I will skip all of those and let you do those. Okay. So let's talk a little

1415
03:01:40,920 --> 03:01:45,040
bit more formally about iterables and then just explore them a little bit. So what happens

1416
03:01:45,040 --> 03:01:52,040
in a for loop is whatever the expression is, is evaluated, right? So I might have some

1417
03:01:52,320 --> 03:01:56,360
complicated expression as opposed to just a single name that refers to a single object.

1418
03:01:56,360 --> 03:02:00,280
It gets evaluated and that's an iterable. We call that an iterable because it is able

1419
03:02:00,280 --> 03:02:06,120
to be iterated over. It then calls the iter built-in function on that object and that

1420
03:02:06,120 --> 03:02:12,800
produces an iterator and the next function is called repeatedly on it through the dunder

1421
03:02:12,800 --> 03:02:17,880
next method. And then eventually it raises a stop iteration which is an exception but

1422
03:02:17,880 --> 03:02:22,240
it's a special one that's actually not an error. It's just something convenient as a,

1423
03:02:22,240 --> 03:02:28,440
like when you're, like think of a function, a function that calls a function that calls

1424
03:02:28,440 --> 03:02:33,520
a function. In this function I might have a return and a return and a return but somewhere

1425
03:02:33,520 --> 03:02:37,620
in there if I have an exception, it might not be caught in that function, might not

1426
03:02:37,620 --> 03:02:41,920
be caught in that function, might go all the way back to the third one that called, right?

1427
03:02:41,920 --> 03:02:47,480
So exceptions are another way of returning a value but they go through a different route.

1428
03:02:47,480 --> 03:02:51,160
They don't just return to the caller as a function does. They return to whoever catches

1429
03:02:51,160 --> 03:02:57,800
the exception further up. And stop iteration is used internally by Python to implement

1430
03:02:57,800 --> 03:03:04,800
for loops because it's convenient. Okay. What does iter do? Well, it looks for a dunder

1431
03:03:06,400 --> 03:03:10,660
iter and calls it if it exists. If it doesn't then it calls dunder get item. So lists are

1432
03:03:10,660 --> 03:03:16,220
iterable because they have get item which is what the square brackets do. Anyway, that's

1433
03:03:16,220 --> 03:03:21,220
a high and dry, high level and kind of dry presentation but let's just play with it.

1434
03:03:21,220 --> 03:03:27,220
Remember this? I said you have to pass to a list. Well, we don't have to. We can remember,

1435
03:03:27,220 --> 03:03:31,220
like I saw what the object is. Let's just grab the object here. Actually maybe it would

1436
03:03:31,220 --> 03:03:38,220
be easier if I here did. Let's just look at it there, right? And its type is, doesn't

1437
03:03:40,660 --> 03:03:47,660
tell me much more. It has some arguments including a dunder next. So I can call it.

1438
03:03:53,620 --> 03:04:00,540
And what do I get? Well, it's a list 1, 2, 3, 4, 5 reversed. Well, no. It's something

1439
03:04:00,540 --> 03:04:06,180
that can iterate over a list in reverse order. So behind the scenes it's actually storing

1440
03:04:06,180 --> 03:04:12,540
the list and then marching through it backwards because it's better to do it lazy. Do the

1441
03:04:12,540 --> 03:04:18,220
evaluation later and there are times when that saves memory or CPU. Okay, so I can call

1442
03:04:18,220 --> 03:04:21,780
it again. So again this is the built in that you can call without the dunder iter. So the

1443
03:04:21,780 --> 03:04:25,780
first is a method on IT. That's what next calls. So I can call it again, call it again,

1444
03:04:25,780 --> 03:04:32,420
call it again. This is how the for loop works. It kind of knows to know that. And by the

1445
03:04:32,420 --> 03:04:39,420
way if an iterator is exhausted is the term, then when you call next on it again it should

1446
03:04:39,740 --> 03:04:43,860
still raise the stop iteration. So if you ever write your own iterators from scratch

1447
03:04:43,860 --> 03:04:48,860
it's easy to do. Make sure you handle that edge case correctly. Of course here's the

1448
03:04:48,860 --> 03:04:53,500
normal way we would write it. Right, we just do a for loop. We don't need to use the next.

1449
03:04:53,500 --> 03:04:57,140
It's the for loop that did the next for us. And when it got the stop iteration we never

1450
03:04:57,140 --> 03:05:04,140
saw the stop iteration. It just exit the loop. Okay. A list object doesn't have an iterator.

1451
03:05:09,260 --> 03:05:15,300
But if I pass it to the iter function and get back an iterable, sorry an iterator, take

1452
03:05:15,300 --> 03:05:22,300
the iterable, pass it to the iter function to get an iterator, it's got one. Right, and

1453
03:05:22,300 --> 03:05:29,300
it does similar kinds of things. And this is the way it works. So get item zero, remember

1454
03:05:30,940 --> 03:05:37,100
list here is one zero through five. Get item zero is what actually gets called when Python

1455
03:05:37,100 --> 03:05:43,420
or equivalent to when Python sees the square bracket. Right, so get item zero is the same

1456
03:05:43,420 --> 03:05:47,620
as M square bracket zero. Think of it that way. I can get the next one, I can get the

1457
03:05:48,340 --> 03:05:55,340
next one, I can get the next one. Sorry. Just a note to myself to remember I might change

1458
03:06:03,500 --> 03:06:10,500
that slightly. Okay. So here's a list comprehension. So here's a list comprehension. So here's

1459
03:06:18,140 --> 03:06:25,140
it is of type list as you can see. This looks almost the same except it uses round brackets

1460
03:06:25,540 --> 03:06:32,540
instead of square brackets, also known as parentheses. All right. Generator object,

1461
03:06:37,260 --> 03:06:41,660
gen expression. This is called a generator expression, similar to a list comprehension,

1462
03:06:41,660 --> 03:06:46,540
similar to a function which is a generator which we probably won't have time to see.

1463
03:06:46,540 --> 03:06:53,540
And its type is generator. Does it have one of these? Yes, it does. It has a bunch of

1464
03:06:54,060 --> 03:06:58,620
other stuff too but it's got in there, it's got GI code, frame, running yield from close,

1465
03:06:58,620 --> 03:07:02,540
send and throw, those are interesting things you might find out about if you go read about

1466
03:07:02,540 --> 03:07:09,540
generators. So I can call next on it and it raises a stop. Right, so this is an iterable.

1467
03:07:10,540 --> 03:07:17,540
So this thing is iterable and here we're just exploring how the iterator protocol uses

1468
03:07:19,580 --> 03:07:26,580
it by calling next and then it raises a stop duration. Okay. And I'll let you play with

1469
03:07:26,860 --> 03:07:33,860
this on your own. How much time we got? Twelve minutes, right? Anybody tired? Oh, I'm getting

1470
03:07:34,860 --> 03:07:41,860
tired a little bit. Well, if you're not, let's just keep going for three hours. Okay. So

1471
03:07:43,580 --> 03:07:50,580
I'm going to show you one more section probably which is this one. I don't think I'll get

1472
03:07:53,060 --> 03:07:56,140
to the next one which talks about classes a little bit and then there's another one after

1473
03:07:56,140 --> 03:08:01,780
that which has some exercises you can do on your own. So this is all great to have, you

1474
03:08:01,780 --> 03:08:05,260
know, one liners but this is not the way we actually code. So I thought, let me tell

1475
03:08:05,260 --> 03:08:09,380
you a little bit. So if you're going to write a script or module in Python, if it's a script

1476
03:08:09,380 --> 03:08:13,380
you're going to run, put that as the very first line. Even on Windows it works if you're

1477
03:08:13,380 --> 03:08:20,380
using the Pi tool. If not, on Windows you can use suffix.py. There's also a pyw that

1478
03:08:21,700 --> 03:08:26,980
works for reasons of whether or not it shows the console. When it evaluates the script,

1479
03:08:26,980 --> 03:08:32,620
when you import a module or run a Python script, it compiles it into bytecode on the

1480
03:08:32,620 --> 03:08:36,180
fly and stores it in a folder that looks like that. So if you see those line around, that's

1481
03:08:36,180 --> 03:08:40,920
what's going on. Only compiles it the first time it's used until you modify the py again.

1482
03:08:40,920 --> 03:08:44,540
Always name your scripts with lowercase and valid Python identifiers because then you

1483
03:08:44,540 --> 03:08:48,740
can use imports on them later as they change and grow over time. So what I'm going to do

1484
03:08:48,740 --> 03:08:53,780
here that you can do too is I'm going to write that file which happened to already be there

1485
03:08:53,780 --> 03:08:58,260
which is why it warned me using this special syntax. If you unpack the zip you should have

1486
03:08:58,260 --> 03:09:02,860
this file in there anyway so if you're not running Jupyter Notebook you'll be fine.

1487
03:09:02,860 --> 03:09:09,860
Import play zero, what's that going to do? Which one? Which error? No module close. Oh,

1488
03:09:18,100 --> 03:09:23,700
yes, totally right. Module not found error. So that's what import. When you try to import

1489
03:09:23,780 --> 03:09:30,300
so what it did is import took this not string but identifier. So it's not a string literal,

1490
03:09:30,300 --> 03:09:35,220
it's an identifier which is a valid identifier but it turns into a file name and it goes

1491
03:09:35,220 --> 03:09:39,020
looking for a file called play zero dot py and there isn't one here so it failed to get

1492
03:09:39,020 --> 03:09:45,220
it. It actually can look in dot py file dot pyc dot pyd and zip files that have things

1493
03:09:45,220 --> 03:09:49,740
in it. All sorts of things is where it can actually look but typically it's looking in

1494
03:09:49,740 --> 03:09:56,740
play zero dot py. Can't find it. So this one play so here this is interesting. When

1495
03:09:57,420 --> 03:10:00,900
it loads this code it runs it so x equals three y equals two and then it should do a

1496
03:10:00,900 --> 03:10:07,460
print. I only noticed last night that this is not going to print. It doesn't work with

1497
03:10:07,460 --> 03:10:10,700
Jupyter Lab which I was using last night. Jupyter does this correctly. Jupyter Lab

1498
03:10:10,700 --> 03:10:14,700
I think is either a bug or they just didn't do it. I don't know. So you notice that it

1499
03:10:15,020 --> 03:10:20,660
printed module loading when we imported play one. All right. That's why I have these comments

1500
03:10:20,660 --> 03:10:26,380
here is because it was doing different in Jupyter Lab which is the newer version. So

1501
03:10:26,380 --> 03:10:32,140
if I import it again it didn't print that. Right? So the first time it loaded it it loaded

1502
03:10:32,140 --> 03:10:39,140
the module. This print statement was executed as was the assignment the y equal and the

1503
03:10:39,140 --> 03:10:43,700
x equal. But when I load it when I do an import and it's already been loaded it just says

1504
03:10:43,700 --> 03:10:48,140
oh I've got that already and it doesn't reevaluate the code. It doesn't recompile all that and

1505
03:10:48,140 --> 03:10:52,100
get the function definitions or whatever else in that module. It just uses the one it already

1506
03:10:52,100 --> 03:10:59,100
has. If we look at what's in that module what attributes that module has. Well it has the

1507
03:10:59,340 --> 03:11:06,340
x and has the y. Right? Which are at the global module level up here. It has some other stuff

1508
03:11:06,340 --> 03:11:11,100
like the file which is where it came from, package, spec, etc. So we can access those

1509
03:11:11,100 --> 03:11:18,100
attributes and if they don't exist it will say not a name error but an attribute error.

1510
03:11:19,620 --> 03:11:26,620
Module play has no attribute. I can add them. Anybody get nervous seeing that? I can just

1511
03:11:26,780 --> 03:11:30,820
take someone else's module and put stuff in it. That's kind of weird but you can do that

1512
03:11:30,820 --> 03:11:37,820
in Python. You probably don't want to. So we trust you to do good things with Python.

1513
03:11:38,700 --> 03:11:45,700
Not write crazy code. Then I can access it. Now if I look at play one there's the z.

1514
03:11:46,740 --> 03:11:52,700
I can change the name and just give it a... So all this does is it does the import which

1515
03:11:52,700 --> 03:11:56,700
means it goes and finds that it's already imported it and just inserts a new name. So

1516
03:11:56,700 --> 03:12:00,500
what this does is it says when you go find where that module is called use this as the

1517
03:12:00,500 --> 03:12:06,560
name in the current module that is added in the namespace as opposed to using the name

1518
03:12:06,600 --> 03:12:13,040
I gave you which lets you go find the file. I can look at that object and see that it's

1519
03:12:13,040 --> 03:12:19,120
got the same attributes. I can delete that. Of course these are just two different names

1520
03:12:19,120 --> 03:12:24,760
and so neither of them have the z attribute now. If you really need to reload which occasionally

1521
03:12:24,760 --> 03:12:29,680
is handy when you're doing development for example you can import import lib and it tells

1522
03:12:29,680 --> 03:12:34,480
you what you can do. So you can do a reload of it and you notice it says module loading.

1523
03:12:34,840 --> 03:12:38,320
If you want to force a reload that's the way to do it. It won't automatically go look.

1524
03:12:38,320 --> 03:12:41,400
Every time you do an import it's not going to go look to see if it changed on the disk

1525
03:12:41,400 --> 03:12:45,520
because that would just slow Python down with not much value. It's pretty rare that you

1526
03:12:45,520 --> 03:12:49,600
need to do a reload. It's almost never would you do this in production code or regular

1527
03:12:49,600 --> 03:12:56,600
code you're running. It's almost always you would only use this when you're doing some

1528
03:12:57,120 --> 03:12:59,040
work.

1529
03:12:59,040 --> 03:13:06,040
So let's do this and import snt. So here you can just import some of the names from a module.

1530
03:13:09,880 --> 03:13:16,880
So I did from play to import snt, do your play to. Remember what this is going to do?

1531
03:13:17,560 --> 03:13:24,560
I only imported snt. I didn't import play to. It's a name error. It looks for play to.

1532
03:13:28,920 --> 03:13:35,920
Couldn't find it. But it does find snt. So I'm just helping you think here about what

1533
03:13:36,480 --> 03:13:41,640
the again focusing on namespaces. If you understand how names work everything is easier in Python.

1534
03:13:42,320 --> 03:13:49,080
Alright let's look at a bigger one. So this is a bad idea to actually have a module. When

1535
03:13:49,080 --> 03:13:56,080
you write a module it should never do anything other than define functions, define classes,

1536
03:13:56,720 --> 03:14:03,400
define constants and maybe import other modules. So putting a play right in here is a bad idea.

1537
03:14:03,400 --> 03:14:09,920
This on the other hand is allowed. So what this does and this is the right way to do

1538
03:14:09,920 --> 03:14:15,280
it and it looks weird I know but it's using that dunder name attribute of modules. Basically

1539
03:14:15,280 --> 03:14:21,520
what this does is if we are running the play module, python play3.py it will do all these

1540
03:14:21,520 --> 03:14:27,560
definitions and then this is the only code that gets executed. And if we're calling

1541
03:14:27,560 --> 03:14:34,560
it by typing python play3.py then the name will be made and it will execute test play

1542
03:14:35,480 --> 03:14:38,560
or whatever we want it to execute. That's the way you write a script or program that

1543
03:14:38,560 --> 03:14:45,560
top level runs. If we import this module and if we import this module it won't execute

1544
03:14:46,040 --> 03:14:51,360
test play it will only define functions and the global player. Okay so let's see if that's

1545
03:14:51,360 --> 03:14:57,360
right. Oh I've used the import star I told you not to use. Alright but you notice it

1546
03:14:57,360 --> 03:15:04,360
didn't, oh sorry this really needs to have a, I really want to prove it. I should have

1547
03:15:05,200 --> 03:15:10,920
a print in there but trust me it didn't actually run test play. It defined it but it didn't

1548
03:15:10,920 --> 03:15:16,560
run it and you can see that those are there. Player is one and there are the two functions

1549
03:15:16,560 --> 03:15:23,560
and their function names they've got these longer names to tell you where they came from.

1550
03:15:25,120 --> 03:15:32,120
Three minutes. Function, there's a longer exercise in section 11 that I'm not going

1551
03:15:33,120 --> 03:15:40,120
to do that does, talks about functions and lets you explore them more. Just some nomenclature,

1552
03:15:43,600 --> 03:15:50,020
the signature is even and if you want to use the precise terminology n is the parameter

1553
03:15:50,020 --> 03:15:54,920
and two is the argument. Not a big deal but when you're reading stuff that might make

1554
03:15:54,920 --> 03:16:01,920
things clear. Here's an example, an example, example, I'm going to skip this. Okay so

1555
03:16:02,120 --> 03:16:07,200
I'm going to skip this and talk about generators, last thing. So generators I mentioned them

1556
03:16:07,200 --> 03:16:12,440
in passing, we saw a generator expressions, here's how you write a generator function.

1557
03:16:12,440 --> 03:16:19,440
So this is a function but instead of having a return in it, it has yield and what that

1558
03:16:20,960 --> 03:16:27,960
does is, here's the function, it's a function right. So if I call it will I get one, two,

1559
03:16:28,280 --> 03:16:35,280
three? No, I get a generator object. If I pass that iterable off to list it will get

1560
03:16:36,840 --> 03:16:41,760
the one, two and three and stick them in a list for me. Okay let's do it the way we

1561
03:16:41,760 --> 03:16:48,760
saw a few minutes ago, there's the iterator, it's type is a generator and we can call

1562
03:16:49,060 --> 03:16:56,060
next on it right. So this function is something that a for loop can iterate over. So this

1563
03:16:58,160 --> 03:17:04,200
is a function, okay so here's how you would typically call it. Right so whether you call

1564
03:17:04,200 --> 03:17:08,480
list one, two, three and it returns a list or whether you call it and it only returns

1565
03:17:08,480 --> 03:17:15,480
an item every time as it goes around the loop, that's fine. So if you put a print statement

1566
03:17:17,360 --> 03:17:22,720
right in here in between these things you would actually see the prints interleaved

1567
03:17:22,720 --> 03:17:26,200
in here because it actually puts the function on hold and then it starts it again to get

1568
03:17:26,200 --> 03:17:28,880
the next one. It starts it again until it hits a yield, starts again until it hits a

1569
03:17:28,880 --> 03:17:35,880
yield. So the for loop and the iterator are working interleaved. Okay so here's a faster

1570
03:17:36,880 --> 03:17:40,080
way to do, a simpler way to do the same thing right. I could just instead of yield one,

1571
03:17:40,080 --> 03:17:46,400
yield two, yield three I could just do that and same kind of stuff. Alright let's try

1572
03:17:46,400 --> 03:17:53,400
factorials. Here's a way to do a factorial function. So let me call that, call that,

1573
03:17:56,200 --> 03:18:03,200
call that, call that. So what if I pass this factorial generator, which I should have named

1574
03:18:14,320 --> 03:18:21,320
that in there. What if I pass the factorial generator off to list? What's that? I will

1575
03:18:21,320 --> 03:18:28,320
run out of memory. I won't get a recursion error because I'm not doing a recursion solution.

1576
03:18:28,320 --> 03:18:32,320
I'll run out of memory because it will just never quit. Right? So I'm not going to run

1577
03:18:32,320 --> 03:18:36,920
that actually. But I, so what I will do is I'm going to, I'm going to create another

1578
03:18:36,920 --> 03:18:43,920
function which just stops when the length of what it returns is passed a certain length.

1579
03:18:43,920 --> 03:18:50,920
There we go, oh nice. Okay last thing. Here's a function that returns a list of even numbers

1580
03:18:56,840 --> 03:19:03,840
less than ten. Here is a generator that on demand returns a list of, not a list, a sequence

1581
03:19:04,880 --> 03:19:11,440
an iterable of even numbers less than ten. Which one's easier to read? Which one's simpler?

1582
03:19:11,440 --> 03:19:16,000
The first one I would say no. At least once you get used to it. You don't have to do

1583
03:19:16,000 --> 03:19:19,520
this thing. You don't have to do this thing. You replace, or you don't have to do this

1584
03:19:19,520 --> 03:19:26,520
thing. You just yield and it's simpler. Right? So generators are nice because they're lazy.

1585
03:19:26,660 --> 03:19:30,640
Some things you don't know when you don't want to compute all the factorials. But you

1586
03:19:30,640 --> 03:19:34,120
might want to compute some. You don't know how many. So you just only compute on demand.

1587
03:19:34,120 --> 03:19:37,120
Reading a file, you might be trying to read a file that's bigger than the amount of memory

1588
03:19:37,120 --> 03:19:40,860
you have. Well don't read it all at once. Read it line by line. There's lots of places

1589
03:19:40,860 --> 03:19:45,220
where that's true. Network traffic, same thing. And generators are important for async

1590
03:19:45,220 --> 03:19:50,660
stuff. But they're also just easier to think about and read and write. Well once you get

1591
03:19:50,660 --> 03:19:53,140
used to them they're easier to write. And you notice that the use of these two things

1592
03:19:53,140 --> 03:20:00,140
is the same, right? For renom and even ones, renom and evens two. Sorry. They do the same

1593
03:20:00,620 --> 03:20:07,460
thing. And there's an exercise and some stuff with calls and I'm out of time. And thank

1594
03:20:07,460 --> 03:20:07,940
you for coming.

