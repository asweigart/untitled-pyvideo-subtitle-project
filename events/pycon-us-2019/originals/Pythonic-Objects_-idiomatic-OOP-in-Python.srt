1
00:00:00,000 --> 00:00:12,560
But, so meanwhile, I'm going to do some extra credit conversation here, okay?

2
00:00:12,560 --> 00:00:27,520
So how many of you have significant experience in another language that is object-oriented?

3
00:00:27,520 --> 00:00:40,280
Okay, so I'm going to tell you a little story. This is, so I don't know how many of you know,

4
00:00:40,280 --> 00:00:48,120
but I wrote a book called Fluent Python, and the book has been a success. People love it.

5
00:00:48,120 --> 00:00:54,960
It's been selling well. It has been translated to eight languages. But Fluent Python is not a book

6
00:00:54,960 --> 00:01:01,680
for people that are learning Python. It's actually, Fluent Python grew out of a course

7
00:01:01,680 --> 00:01:07,800
that I used to teach in Brazil where I live that was called Python for people who know Python.

8
00:01:07,800 --> 00:01:15,520
So the idea is you are already using Python. Python is very easy to get started, and so that

9
00:01:15,520 --> 00:01:27,400
course was about making the most of Python and trying to code an idiomatic Python, because as

10
00:01:27,400 --> 00:01:33,440
somebody said, I forgot, somebody famous in the history of computer science once said that it's

11
00:01:33,440 --> 00:01:43,000
possible to write for trend in any programming language, right? And I have seen, because Java is

12
00:01:43,000 --> 00:01:52,080
one of the most popular languages. In the domain that Python is used, Java is also very popular.

13
00:01:52,080 --> 00:02:03,920
So I've seen a lot of Python code that had a very strong Java accent, just like my English with a

14
00:02:03,920 --> 00:02:17,560
very strong Portuguese accent. So I've seen that in Python code. And anyway, because I started

15
00:02:17,560 --> 00:02:26,720
writing the book in 2013 and finished in 2015, and then I went to work for ThoughtWorks where I'm

16
00:02:26,720 --> 00:02:32,920
doing other stuff besides coding in Python. I'm also coding in other languages and doing non-coding

17
00:02:32,920 --> 00:02:39,560
tasks. This all means that it's been about eight or nine years since I've taught an introductory

18
00:02:39,560 --> 00:02:45,720
class about object-oriented programming in Python. When Python has chapters about object-oriented

19
00:02:45,720 --> 00:02:50,360
programming, but they assume that you already know the basics of object-oriented programming in

20
00:02:50,360 --> 00:02:59,480
Python. And this was really interesting for me to, you know, after all these years, start thinking

21
00:02:59,480 --> 00:03:06,000
about what should I teach, what should I show to people that are getting started with Python in

22
00:03:06,000 --> 00:03:14,120
terms of object-oriented programming. And I went through old slides and exercises from courses that

23
00:03:14,120 --> 00:03:25,080
I used to give like ten years ago or something. And a lot of this stuff was wrong, you know,

24
00:03:25,080 --> 00:03:32,400
because over these years I've learned more about object-oriented programming, for example. And

25
00:03:32,400 --> 00:03:44,760
there's been trends also. I'm going to talk about that more, but there's a huge trend away from

26
00:03:44,760 --> 00:03:51,920
inheritance. You know, object-oriented programming was always, you know, when you took an introductory

27
00:03:52,200 --> 00:03:58,560
course about object-oriented programming, a lot of time was always spent with inheritance, right?

28
00:03:58,560 --> 00:04:04,600
And you had all those crazy examples of, you know, animals, you know, so you have the animal class

29
00:04:04,600 --> 00:04:11,040
and then the mammal class, the mammal subclass, and then the dog subclass of mammal and the cat

30
00:04:11,040 --> 00:04:25,240
and the bat, whatever, right? This is just wrong, people. This is not the way to program classes

31
00:04:25,240 --> 00:04:35,520
anymore. So for one thing, in reality, we don't use the inheritance hierarchy to do classification

32
00:04:35,600 --> 00:04:51,520
like an animal taxonomy. We don't use it for that. And so I'm going to talk about that. And another

33
00:04:51,520 --> 00:05:01,520
thing that, and also for instance, there's the famous Design Patterns book, the one that's

34
00:05:01,520 --> 00:05:07,600
nicknamed the book of the Gang of Four because it has four authors, right? So in that book,

35
00:05:07,600 --> 00:05:13,400
the introduction of that book is excellent. I think it's actually worth the price of the book,

36
00:05:13,400 --> 00:05:20,200
and the rest is not so important in my opinion. But the introduction is awesome. And in the

37
00:05:20,200 --> 00:05:26,160
introduction, the authors say that you should favor composition over inheritance. I'm going to

38
00:05:26,160 --> 00:05:34,080
talk about that and show examples. But this is a famous like proverb that has been written in,

39
00:05:34,080 --> 00:05:43,800
I don't know, it was written in 93 or 94, that book, and it's gaining more and more traction.

40
00:05:43,800 --> 00:05:52,120
And now we see programming languages emerging, for instance, in the data science space, there

41
00:05:52,120 --> 00:05:58,960
is a language called Julia, which is actually why Jupiter starts with G-U, because the Jupiter

42
00:05:58,960 --> 00:06:07,880
project supports Julia, Python, and R natively. So Julia is a programming language that has

43
00:06:07,880 --> 00:06:16,800
inheritance, but only of abstract classes. I'm going to talk about that too. Concrete classes,

44
00:06:16,800 --> 00:06:24,600
you cannot inherit. Go is another language that is growing very fast. It has a concept of types,

45
00:06:24,600 --> 00:06:30,320
they don't call it classes, but they have types with methods, which is very similar to a class,

46
00:06:30,320 --> 00:06:38,720
and they have the concept of interfaces, but there is no inheritance at all in Go. So these

47
00:06:38,720 --> 00:06:45,280
are some of the things that I had to, basically I had to rethink a lot of it. I created lots of

48
00:06:45,280 --> 00:06:52,720
examples just for this tutorial, and this is unlike any other course that I've given about

49
00:06:52,720 --> 00:07:01,800
this subject, because of the things that happened during this past few years in that area.

50
00:07:01,800 --> 00:07:09,520
What else can I say?

51
00:07:31,800 --> 00:07:51,400
Also, before this talk, or before this tutorial, whenever I talked about bitonic objects, I gave a

52
00:07:51,400 --> 00:07:58,600
lot of emphasis in the special methods. I'm going to talk a little bit about them here, but not as

53
00:07:58,600 --> 00:08:05,400
much as I talk. My whole book is about 700 pages of special methods. That's the core of the book,

54
00:08:05,400 --> 00:08:17,920
because the special methods are the way Python presents itself to the programmer as a toolkit

55
00:08:17,920 --> 00:08:23,520
for building frameworks, which is really interesting, but it's not something that you should be

56
00:08:23,520 --> 00:08:27,960
concerned when you're just getting started with object-oriented programming in Python.

57
00:08:27,960 --> 00:08:37,800
I am going to show one example at the very end that has lots of special methods, but most of them

58
00:08:37,800 --> 00:08:51,160
are going to use only a few of the most essential special methods. So just one more minute, and then

59
00:08:51,560 --> 00:09:09,040
it's 9.10, and we're going to get started. So for those who arrived after I showed this, that URL is the URL of the

60
00:09:09,040 --> 00:09:17,000
repo where the content of the talk is, and I decided not to do slides this time. There's only this opening,

61
00:09:17,960 --> 00:09:26,600
sort of like a title card, and everything else is Jupyter notebooks and also examples in code as

62
00:09:26,600 --> 00:09:47,960
Python modules. Everything is in this repo. All right. So you can clone the repo or you can just browse it

63
00:09:47,960 --> 00:10:12,760
through the GitHub UI. All right. Let's get started. So from now on, it's going to be recording. So good

64
00:10:12,760 --> 00:10:17,840
morning, people. Thank you very much for choosing this tutorial. I'm super happy to be here presenting

65
00:10:18,520 --> 00:10:27,800
a tutorial at PyCon. This is a conference that I love. I would like for you to not be shy and ask

66
00:10:27,800 --> 00:10:34,360
questions whenever you want. Just raise your hand. If I don't notice you, then you can start yelling.

67
00:10:35,320 --> 00:10:42,200
And there's a mic that we need to use when people ask questions so that the question is recorded as

68
00:10:42,280 --> 00:10:54,120
well. Okay? But please don't be shy. All right? So my name is Luciano Ramario, and I work for Thoughtworks,

69
00:10:55,080 --> 00:11:01,000
and we are going to talk about Pythonic objects, which is the essentials of object-oriented

70
00:11:01,000 --> 00:11:07,400
programming in Python. We're going to talk a lot about idioms and specifics of Python. Okay?

71
00:11:08,360 --> 00:11:14,840
So here's the thing. One thing that always bothered me when teaching object-oriented programming with

72
00:11:14,840 --> 00:11:21,480
Python, by the way, I love Python, okay? And I think it's a very deeply object-oriented language.

73
00:11:22,280 --> 00:11:29,240
In some respects, it's more object-oriented than Java, for example. Because, for instance, in Python,

74
00:11:29,240 --> 00:11:35,400
we don't have primitive objects. We don't have primitive values like the numbers in Java.

75
00:11:36,280 --> 00:11:42,360
Everything is an object in Python in the sense that everything was an object in small talk. Okay?

76
00:11:43,560 --> 00:11:49,640
But there is one particular topic, which is kind of an essential topic of object-oriented programming,

77
00:11:50,360 --> 00:11:56,600
that has always been a problem for me to talk about when I talk about Python. And that's because

78
00:11:56,920 --> 00:12:07,160
of this. I'm going to show you this screen here. It's from the book, Small Talk 80, the language.

79
00:12:08,600 --> 00:12:20,600
And that book has... So the language, small talk, grew together with an entire system,

80
00:12:20,600 --> 00:12:27,400
which was an operating system and a graphical user interface and what we call today an IDE.

81
00:12:28,040 --> 00:12:31,960
So this is one of the windows where you programmed it. So you see here are the

82
00:12:35,320 --> 00:12:43,320
class categories. And then the selected category is New Project. And then you see

83
00:12:43,320 --> 00:12:47,720
Financial History, which is the name of the class that's just been created here,

84
00:12:47,720 --> 00:12:56,280
that was just created. Actually, the previous screenshot in the book showed the person clicking

85
00:12:56,280 --> 00:13:04,520
accept to this definition. So the person typed, the user typed this definition. And then when

86
00:13:04,520 --> 00:13:13,080
she chose accept, it appeared here as one of the classes. And then it says here, no messages,

87
00:13:13,080 --> 00:13:18,360
which means that no methods have been defined for it. But if you look at the class definition,

88
00:13:19,080 --> 00:13:27,800
it says Object Subclass Financial History. So Object Subclass means this is a subclass of object.

89
00:13:29,480 --> 00:13:35,560
In Python 3, we don't need to say that anymore. If you declare a class, it's already a subclass

90
00:13:35,560 --> 00:13:43,960
of objects. If you don't specify a specific superclass, it's going to be a subclass of object.

91
00:13:45,240 --> 00:13:50,920
So this is what this definition says, the name of the new class and where it belongs in the hierarchy.

92
00:13:52,360 --> 00:13:58,920
And then you see here instance variable names. And then there is a string

93
00:13:59,320 --> 00:14:08,280
of names separated by spaces, which are, so Financial History. I'm actually going to show

94
00:14:10,440 --> 00:14:19,160
a Python version of this class later on. But here we have cash on hand, incomes, and expenditures

95
00:14:19,320 --> 00:14:29,000
are the instance variable names. So right at the start in Smalltalk,

96
00:14:30,600 --> 00:14:34,360
you tell the system the names of the attributes of the class.

97
00:14:39,720 --> 00:14:48,520
Let's take a look at another important reference, the official Java tutorial. The Java tutorial has

98
00:14:48,520 --> 00:14:57,640
these pictures. They talk about what is an object, and they say an object is fields in here,

99
00:14:58,280 --> 00:15:07,960
and it's surrounded by methods. The idea being that other objects can only communicate with

100
00:15:07,960 --> 00:15:14,440
this object through the methods and not have access to the fields directly. In Smalltalk,

101
00:15:14,440 --> 00:15:20,120
it was like that too. In fact, in Smalltalk, all the instance variables were private. There was no

102
00:15:20,120 --> 00:15:28,760
way to do a public instance variable in Smalltalk. So it was very much like this. And this is an

103
00:15:28,760 --> 00:15:36,200
example of what they call encapsulation. So the object encapsulates some values here, which are

104
00:15:36,200 --> 00:15:47,880
the fields. Okay. And here's a definition that talks about that. Hiding internal state and

105
00:15:47,880 --> 00:15:52,520
requiring all interaction to be performed through an object's methods is known as data encapsulation,

106
00:15:52,520 --> 00:15:58,040
a fundamental principle of object-oriented programming. Right? So here's an example.

107
00:15:59,000 --> 00:16:04,760
I like the example in the picture, although the code is not so good, but the picture, the idea is,

108
00:16:05,560 --> 00:16:12,520
this represents a bicycle. So you have methods that are like verbs of actions that you can

109
00:16:14,520 --> 00:16:21,320
do with the bike. So like change gears, break, change cadence. And then you have the values

110
00:16:21,320 --> 00:16:27,320
inside the fields. So this would be the speed because it says 18 miles per hour. This would

111
00:16:27,320 --> 00:16:35,400
be the cadence because it says 90 rotations per 90 RPM. And this is the gear, the currently engaged

112
00:16:35,400 --> 00:16:47,080
gear, fifth gear. Okay. Now, a crucial idea here is that there is no way to change the speed

113
00:16:47,080 --> 00:16:55,800
directly. There is no method called change speed, because the speed of the bicycle

114
00:16:56,760 --> 00:17:04,200
is one of the fields in there. It depends on other things. Right? So for instance, if you apply the

115
00:17:04,200 --> 00:17:15,160
brake, this will decrease the speed. Right? How much? Well, it depends on how much you press the

116
00:17:15,160 --> 00:17:20,760
brake and also whether it's going uphill or downhill or whether somebody is pedaling still or not.

117
00:17:21,240 --> 00:17:28,360
Right? So that's the idea. The idea is that this internal state of the object is changed

118
00:17:28,920 --> 00:17:37,320
through method calls that are not necessarily just straight setters and getters like we often see

119
00:17:37,880 --> 00:17:45,480
in introductory tutorials. Like I said, it doesn't make sense in a realistic simulation

120
00:17:45,480 --> 00:17:51,240
to be able to change the speed directly. Right? This would be like you're in a car and you pull

121
00:17:51,240 --> 00:18:02,120
the, how do you call the... The speedometer. Yeah. The little thing, how do you call the

122
00:18:02,120 --> 00:18:06,840
pointer in the speedometer, and that would make your car go faster. Doesn't make any sense. Right?

123
00:18:07,480 --> 00:18:14,680
So no. The speed is a consequence of other things that are happening. All right? And if you look at

124
00:18:14,680 --> 00:18:24,680
the Java code, it's very clear here that the class bicycle has three fields, cadence, speed,

125
00:18:24,680 --> 00:18:30,760
and gear. And then there is other methods. There are methods. Right? So what I'm talking about here

126
00:18:30,760 --> 00:18:38,440
is that both Java and small talk, which are very important object-oriented languages, have specific

127
00:18:38,440 --> 00:18:49,560
and explicit ways of defining what are the fields of a class. Right? And so I think the way in which

128
00:18:50,200 --> 00:18:56,200
Python is less like all the other object-oriented programming languages that I know is the fact that

129
00:18:56,200 --> 00:19:03,240
Python historically did not have a way of doing that. And now it's growing a way of doing that.

130
00:19:03,240 --> 00:19:11,720
I'm going to talk about that through the typing module and the data classes. But historically,

131
00:19:11,720 --> 00:19:22,600
there was no way of telling Python, okay, this class has these fields. Right? Also, Python has,

132
00:19:22,600 --> 00:19:31,240
well, all object-oriented languages have slightly varying terminologies. Right? But if you know about

133
00:19:31,240 --> 00:19:38,440
Java, it's useful to know that the Python term, what we call attributes in Python, is a generic

134
00:19:38,440 --> 00:19:45,880
term that encompasses the concepts of fields and methods in Java. Okay? All of that we consider

135
00:19:45,880 --> 00:19:54,120
in Python methods, attributes of the object as well. Right? And then when we talk, when you want

136
00:19:54,120 --> 00:20:00,680
to talk about what Java people call a field, we need to use this qualifier and call it a data

137
00:20:00,680 --> 00:20:09,160
attribute. Okay? And then method is a method. All right? So it's important to understand these

138
00:20:11,640 --> 00:20:20,120
different terms that I use. So like I was saying, Python prior to Python 3.6 had no way to declare

139
00:20:20,120 --> 00:20:27,080
instance variables without assigning. Actually, the assignment is what creates, the initial

140
00:20:27,080 --> 00:20:37,000
assignment is what creates a variable. Okay? But it's more than that because Python historically

141
00:20:37,000 --> 00:20:43,320
had no way to declare variables at all. No kinds of variables. You had any way of declaring.

142
00:20:43,320 --> 00:20:52,680
The only kinds of variables that you declare in Python are function arguments. Right? Okay.

143
00:20:53,240 --> 00:20:58,120
So the first assignment is a declaration and the attributes defined in a class body are class

144
00:20:58,120 --> 00:21:06,200
attributes. I'm going to talk about that. But then I don't know how many of you have studied

145
00:21:06,200 --> 00:21:17,720
or used Django? All right. Lots of people. So I was using Python, I started using Python in 1998

146
00:21:17,720 --> 00:21:28,840
and about, I don't know, 2005, 2006, around that time, I started studying Django and I looked at

147
00:21:28,840 --> 00:21:41,320
this and I said, what's going on here? You know? Because what you see here, I just said that

148
00:21:41,320 --> 00:21:50,040
attributes defined in a class body are class attributes. So these attributes here, which are

149
00:21:50,040 --> 00:21:56,840
in the body of the class and not inside the function or method, they are class attributes.

150
00:21:57,880 --> 00:22:05,160
But clearly, they are defining something that has to do with the instances. Right? So a musician

151
00:22:05,160 --> 00:22:12,360
has a first name, a last name and an instrument. Each musician would have a different name.

152
00:22:12,920 --> 00:22:20,680
Right? So this is an instance attribute. However, it's defined in the class. How does that work?

153
00:22:21,240 --> 00:22:28,280
Well, this is a very advanced topic called descriptors. Right? So these objects that

154
00:22:28,280 --> 00:22:36,600
are instantiated here are descriptors. And I want to say, I want to talk about that just because

155
00:22:36,600 --> 00:22:42,840
I don't want to go deeper into this subject, but I want to make sure that you believe and

156
00:22:43,640 --> 00:22:47,720
understand that everything that is defined in a class body are class attributes.

157
00:22:49,880 --> 00:22:57,640
However, a descriptor is a class attribute that is designed to manage attributes in the instances.

158
00:22:58,680 --> 00:23:08,680
Does that make sense? You know, think about a getter or a setter. So a getter or a setter

159
00:23:08,680 --> 00:23:15,560
is just a method that just retrieves the value of a data attribute. Right? That's all it does.

160
00:23:16,840 --> 00:23:24,520
So a getter is a method. And methods, because they are defined in the class, they are basically

161
00:23:24,600 --> 00:23:32,120
class attributes. But methods usually handle attributes of the instances. Does that make sense?

162
00:23:33,960 --> 00:23:40,360
The descriptor is another category of things that are not methods that have the same characteristic

163
00:23:40,360 --> 00:23:47,240
of something that is attached to the class, but that is designed to handle the instances.

164
00:23:47,960 --> 00:23:59,800
Okay. But I was surprised when I saw this in Python or in Django, because I was already

165
00:23:59,800 --> 00:24:05,080
using the language for several years, like seven years when I saw this, and I had never seen the

166
00:24:05,080 --> 00:24:14,360
descriptor before. And because the fact is, in the Python standard library, there are no

167
00:24:15,320 --> 00:24:23,000
data-oriented descriptors like this. All the ones that exist out there are provided by

168
00:24:23,880 --> 00:24:28,760
frameworks like Django, SQL alchemy, and things like that.

169
00:24:33,080 --> 00:24:37,560
So it's kind of a foreign idea. Of course, the infrastructure is there in the language

170
00:24:37,640 --> 00:24:45,000
for people to use it, and the framework authors have used it, but it's an advanced concept,

171
00:24:45,000 --> 00:24:50,600
this idea of the descriptor. So let's get back to basics, really basics. And now I'm going to start

172
00:24:50,600 --> 00:25:01,080
running code here. So the first thing I always do when I teach with a Jupyter notebook,

173
00:25:07,800 --> 00:25:14,120
so I don't know if everybody knows about Jupyter notebooks, the idea here is I am actually running

174
00:25:14,120 --> 00:25:23,160
this from the terminal here. This is the log of the server. Right? I run it by typing Jupyter

175
00:25:23,160 --> 00:25:28,440
space notebook, but I didn't, I don't think it's important for you to be running this right now.

176
00:25:30,280 --> 00:25:36,440
And the thing is, each of these cells, when it doesn't have a number, like this one and this one,

177
00:25:36,920 --> 00:25:42,440
it means that they were not executed yet. And this one was just executed. To execute it,

178
00:25:42,440 --> 00:25:53,160
I hit shift, shift, shift return. Okay? So I'm going to execute this cell, and now I just defined

179
00:25:53,880 --> 00:26:00,680
the class coordinate. Okay? What I had done before was just printing the Python version

180
00:26:01,400 --> 00:26:07,880
to make sure everybody understand that we are using Python 3.7 because some of the features

181
00:26:07,880 --> 00:26:14,920
I'm going to show depend on 3.7. All right. So I've defined the class. What does this class have?

182
00:26:14,920 --> 00:26:21,160
It just has a doc string. In the second line of a class, if you want to declare an empty class,

183
00:26:21,160 --> 00:26:27,880
you have to put something in there because of the syntax of Python requires. So you can put the

184
00:26:27,880 --> 00:26:36,040
pass keyword or I prefer to put a doc string. It serves the purpose of filling that space,

185
00:26:36,760 --> 00:26:43,320
and it's better than the password keyword because it says something. Okay? So I can create

186
00:26:44,600 --> 00:26:52,440
a coordinate, and I can assign a latitude and a longitude to it, and then this last line

187
00:26:53,400 --> 00:27:02,520
will make Jupiter show the value. Okay? So this is what we saw. So we have an object.

188
00:27:03,720 --> 00:27:15,720
Okay. And this is how it's displayed. I'm going to add another line here or another cell just to

189
00:27:15,720 --> 00:27:25,960
show you that I can actually look at the latitude of Cleveland. See? So I'm accessing

190
00:27:26,840 --> 00:27:30,760
the attributes. So this is the first thing that is very surprising.

191
00:27:34,200 --> 00:27:42,120
Not only there is no way to declare, there's no way to declare class or instance attributes

192
00:27:42,840 --> 00:27:48,760
or data attributes, but you don't need to because you can create a class and just assign

193
00:27:49,480 --> 00:27:58,280
merrily attributes to the instances. Okay? By default, this is how Python classes behave.

194
00:28:02,200 --> 00:28:09,000
It's not a good idea to be, you know, hanging new attributes while the class is being passed

195
00:28:09,000 --> 00:28:17,960
around the system. I also saw a very ugly bug that was because of that, but you can do it.

196
00:28:19,240 --> 00:28:27,400
All right. So in order to teach and also to test and document, I like to implement

197
00:28:29,720 --> 00:28:36,600
a method called Dunderwrapper. All right? So this is one thing that I consider an essential

198
00:28:36,600 --> 00:28:45,480
characteristic of a Python class. So what's the idea? Since the times of small talk,

199
00:28:45,480 --> 00:28:51,400
the people who have created object-oriented programming languages have realised that it's

200
00:28:51,400 --> 00:28:57,400
important for objects to have a way to present themselves as a string. Right? So if I have a,

201
00:28:58,120 --> 00:29:07,240
if I say print this object, the object, the print function will call something on the object

202
00:29:08,120 --> 00:29:16,840
so that the object is responsible for displaying itself. Okay? This is a very object-oriented way

203
00:29:16,840 --> 00:29:24,760
of thinking. Objects should be responsible for actions that have to do with their internal state.

204
00:29:25,400 --> 00:29:30,760
Right? So for instance, if I have to display myself, I have to show some attributes, my name

205
00:29:30,760 --> 00:29:39,560
or whatever, this should be my task as an object. But also, so in other languages like Java, you

206
00:29:39,560 --> 00:29:45,720
have a two-string method. Pretty much every object-oriented language has some method that

207
00:29:45,720 --> 00:29:51,880
is designed that you should implement so that your objects can represent themselves as strings.

208
00:29:51,880 --> 00:29:56,760
But Python has two methods. And we pronounce this

209
00:29:59,000 --> 00:30:06,120
dunder wrapper. So dunder is the double underscore on both sides. Dunder wrapper

210
00:30:08,120 --> 00:30:18,360
is one of the methods that you use. And the idea is that dunder wrapper is to

211
00:30:18,360 --> 00:30:27,480
show a technical representation of the object. Let's call it that. Okay? So a way of showing

212
00:30:27,480 --> 00:30:36,920
the object that is useful for debugging or for logging or for teaching. And that's in contracts

213
00:30:36,920 --> 00:30:43,800
with a way of displaying a string, a user-friendly string of the object. Okay? Which we are going to

214
00:30:44,760 --> 00:30:55,400
do soon. But anyway, I don't need this import hash right now here. This is leftover from another

215
00:30:55,400 --> 00:31:06,920
iteration. And now see the difference? So because now I have a dunder wrapper, my object doesn't

216
00:31:06,920 --> 00:31:15,160
display like that anymore. This is the dunder wrapper that my class inherited from objects.

217
00:31:15,160 --> 00:31:20,440
The object class shows objects like this. The name of the class and the position in memory.

218
00:31:21,480 --> 00:31:27,560
Just to, as a way of uniquely identifying that instance so that you know whether two instances

219
00:31:27,560 --> 00:31:32,920
are the same or different. Okay? Now, if you implement dunder wrapper, then you can

220
00:31:33,640 --> 00:31:40,200
make your objects appear some other way. And this is actually a good way of doing that, which is

221
00:31:44,360 --> 00:31:50,120
to display the object as the source code that you would use to reconstruct

222
00:31:50,760 --> 00:31:57,320
a copy of the object. Does that make sense? See? This is like calling the class and passing

223
00:31:57,320 --> 00:32:09,000
two arguments to build the object. Right? So some good best practices about the dunder wrapper.

224
00:32:09,000 --> 00:32:14,040
So dunder wrapper is good for exploratory programming, documentation, docs tests and debugging.

225
00:32:14,840 --> 00:32:21,080
The best practice, if viable, it's not always viable, but you should implement dunder wrapper

226
00:32:21,080 --> 00:32:25,320
returning a string with syntax required to create a new instance like the one inspected.

227
00:32:25,960 --> 00:32:32,840
Like I just said, right? This string here, if I copy and paste it in a terminal, in a Python shell,

228
00:32:32,840 --> 00:32:40,600
it's going to create another coordinate like that one. A more technical way of saying is that

229
00:32:42,680 --> 00:32:47,880
the wrapper function, which is a built-in function of Python, calls the dunder wrapper of objects.

230
00:32:48,520 --> 00:32:56,440
Right? So when you call wrapper of X, you get a string. If you have all the string,

231
00:32:56,440 --> 00:33:03,080
you should get an object that will be equal to the original X. Does that make sense? Now,

232
00:33:03,080 --> 00:33:09,400
I want to explain something that is kind of weird. Why do we â€“ so we have a method called dunder

233
00:33:09,400 --> 00:33:23,320
wrapper, but then let me show you this thing here. So what happens if I do this?

234
00:33:23,800 --> 00:33:41,880
Sorry, I have to call it. I get that string, right? And what happens if I do this?

235
00:33:45,880 --> 00:33:52,440
The same string. So which is better?

236
00:33:53,880 --> 00:34:01,880
Of course, this is more readable, although it does cause some concern to people coming from

237
00:34:01,880 --> 00:34:08,520
other languages because this doesn't look object-oriented. Most object-oriented languages

238
00:34:08,520 --> 00:34:15,880
these days have this kind of syntax where it's always object dot method to make the call, right?

239
00:34:16,600 --> 00:34:21,880
But in this case, it's like this. And you will see this over and over in Python. You have the

240
00:34:21,880 --> 00:34:28,600
len function. You have a bunch of built-in functions that are named like special methods

241
00:34:29,320 --> 00:34:35,160
and that you use like this. You should never do this, right? The special methods are not

242
00:34:35,160 --> 00:34:41,720
designed for you to be calling them. Python calls them for you when necessary. So what's the sense

243
00:34:41,720 --> 00:34:49,640
of that? Why is this like this? Because the thing is, for built-in objects which are part of the

244
00:34:49,640 --> 00:34:55,000
Python interpreter and that are implemented in C or for things that are not part of the

245
00:34:55,000 --> 00:35:02,680
interpreter but are also implemented in C, like for instance, the NumPy objects, the nd array,

246
00:35:03,240 --> 00:35:07,560
everything else in data science, most of those objects that you use when you're doing data

247
00:35:07,560 --> 00:35:13,400
science in Python, they are implemented in C. Some of them are implemented in other languages,

248
00:35:13,400 --> 00:35:21,000
but most of them are implemented in C. For an object implemented in C, Python has a shortcut.

249
00:35:22,440 --> 00:35:29,560
So when you call wrapper of an object, Python sees, okay, is this implemented in C? So there's a

250
00:35:29,560 --> 00:35:36,520
quicker way of making that happen that doesn't involve all the machinery of calling a method,

251
00:35:37,240 --> 00:35:41,240
you know, which has to do with expensive machinery because it has to do with

252
00:35:42,040 --> 00:35:49,480
all the dynamic way of looking up methods in the inheritance hierarchy and so on.

253
00:35:51,240 --> 00:36:00,440
And so the thing is, that's why you have this syntax, because this syntax is faster for built-in

254
00:36:00,440 --> 00:36:09,720
objects and objects implemented in C, but when it has a fallback, which is when you apply the

255
00:36:09,720 --> 00:36:16,120
wrapper function to an object that you created or somebody created in Python, then the system will

256
00:36:16,120 --> 00:36:22,760
fall back to call to do this, right? So does that make sense? I wanted to explain because sometimes

257
00:36:22,760 --> 00:36:32,520
people accuse Python of not being object oriented because of this syntax. But it's just like,

258
00:36:33,400 --> 00:36:39,240
it's a pragmatic solution to be able to be very fast with the built-ins. Okay?

259
00:36:39,720 --> 00:36:47,160
All right. I've already said that. So there's another, I said that there's another representation

260
00:36:47,160 --> 00:36:55,480
for end users and that's done with the Dunderster. And here is a nice Dunderster. I'm going to run it.

261
00:36:57,160 --> 00:37:03,240
So I just define the class again and then I'm going to explain the code soon. But

262
00:37:03,240 --> 00:37:12,920
see, isn't this nice? So now when I print a coordinate, it looks like the way users like to see coordinates.

263
00:37:15,240 --> 00:37:16,840
Right? So,

264
00:37:20,200 --> 00:37:23,800
all right. Oops.

265
00:37:23,960 --> 00:37:26,360
Okay.

266
00:37:32,280 --> 00:37:40,360
Something's not great here.

267
00:37:47,800 --> 00:37:48,840
All right. Thank you.

268
00:37:48,840 --> 00:37:59,240
Okay. So another thing that is a bit surprising when people get started with Python is that

269
00:38:01,560 --> 00:38:04,920
a method definition like this,

270
00:38:11,720 --> 00:38:15,640
when it's an instance method, the method that deals with the instance and most methods that

271
00:38:15,640 --> 00:38:22,360
you're going to create deal with the instance, they have to receive the self-arguments,

272
00:38:22,360 --> 00:38:27,240
which is not part of the call. Right? So,

273
00:38:33,000 --> 00:38:40,360
but the idea is that this actually has to do with the descriptor mechanism as well. But anyway,

274
00:38:40,920 --> 00:38:53,480
this makes, so when Python sees this, it passes this instance as the self-arguments.

275
00:38:55,560 --> 00:39:02,360
And so we have this other thing. Now I have a little shortcut here that I don't know if I am

276
00:39:03,880 --> 00:39:07,720
ashamed or proud of it, but I'm going to show you because it's kind of interesting.

277
00:39:08,600 --> 00:39:16,360
How does this work? So in order to select whether I'm going to write N or W or N or S

278
00:39:17,080 --> 00:39:22,680
or W or E and the coordinates, I use this crazy expression here.

279
00:39:24,280 --> 00:39:30,840
This actually doesn't look like Python, but it is Python. So let me tell you what's going on here.

280
00:39:31,480 --> 00:39:39,240
This expression here returns a Boolean. Right? All the comparison operators in Python return

281
00:39:39,240 --> 00:39:49,240
Booleans. And a Boolean in Python is actually a subclass of int. The true value is one and the

282
00:39:50,280 --> 00:39:58,920
zero value or the false value is zero. Okay? So because the Booleans are a type of int,

283
00:39:59,000 --> 00:40:06,120
a subtype of int, you can use them in arithmetic, which sometimes is interesting. You know,

284
00:40:06,120 --> 00:40:12,120
you can have an equation where there's a certain term that should be zero if a certain condition

285
00:40:12,120 --> 00:40:19,000
applies. So you can use it like that. And in this situation, I'm using it as an index to this string.

286
00:40:20,280 --> 00:40:27,960
So if this is false, then I'm going to display, so the result of this is going to be zero.

287
00:40:29,720 --> 00:40:36,360
So then I'm reading the zero index of this string, which is the letter N. Right? Otherwise,

288
00:40:37,640 --> 00:40:41,240
if it's true, then it's going to select the S. Okay?

289
00:40:43,880 --> 00:40:50,920
And over here is the, all the cool kids are using F strings. It's really cool.

290
00:40:52,520 --> 00:40:57,240
I'm not going to explain it a lot. I'm just going to say that it's pretty powerful because

291
00:40:57,240 --> 00:41:02,280
it allows you to put actually expressions. See, I have a method. I have a function call here.

292
00:41:03,320 --> 00:41:09,400
I'm calling the abs of the latitude. And then I have the, so this part here is an expression.

293
00:41:09,400 --> 00:41:15,560
And after the column is the formatting, all of this inside these braces here.

294
00:41:17,640 --> 00:41:24,680
Right? And this is just the variable, this variable here. Okay? Anyway, so,

295
00:41:25,320 --> 00:41:32,360
so it seems to be working this class of ours, except that we kind of punted on the whole topic

296
00:41:32,360 --> 00:41:37,400
of attributes, which is what I was talking about. Right? Because when I created the class to

297
00:41:37,400 --> 00:41:43,320
demonstrate every time I did like this, I created an instance and then I assigned the attributes.

298
00:41:43,880 --> 00:41:54,200
If I don't do that, I get an exception that says object has no attribute lot. Okay? The reason why

299
00:41:54,200 --> 00:42:04,360
I wrote all of this exception handling here is because otherwise we would see this here.

300
00:42:09,480 --> 00:42:15,400
And also, if I tell Jupyter Notebook to run everything to see if everything is okay,

301
00:42:15,400 --> 00:42:23,720
it stops here and it doesn't run the remaining cells. So that's why I do this.

302
00:42:25,000 --> 00:42:32,760
This way here, where I catch the exception and I print the message. Okay? Anyway, so what can I do

303
00:42:32,760 --> 00:42:46,040
to fix this? So the quick and dirty fix for this is to create two attributes here.

304
00:42:54,440 --> 00:43:00,680
So if I run this again, so I just added the attributes there in the body of the class.

305
00:43:01,880 --> 00:43:08,920
Right? So they are class attributes. But now when I run this, it works.

306
00:43:11,080 --> 00:43:14,600
And this is a peculiar thing about Python. The fact that

307
00:43:15,480 --> 00:43:24,360
what is happening implicitly here for this print to execute, this Dunderster is being called.

308
00:43:25,080 --> 00:43:40,440
And the Dunderster accesses self.lat and self.long. Right? So it's looking at attributes in the

309
00:43:41,400 --> 00:43:46,360
instance. However, the instance doesn't have the attributes. So then Python looks at the class

310
00:43:46,360 --> 00:43:59,480
and gets those values. So this way here is a way of having sort of default values for

311
00:44:02,040 --> 00:44:07,800
attributes. But I don't think this is very clean and I actually don't recommend it anymore.

312
00:44:08,120 --> 00:44:10,520
I'm going to be talking a lot more about that. Okay?

313
00:44:14,200 --> 00:44:19,960
Here's another example of using class attributes as default. So for instance, I have a class called

314
00:44:19,960 --> 00:44:28,280
pizza. It doesn't have any methods. Just class attributes. Class data attributes to be more

315
00:44:28,280 --> 00:44:36,680
precise. So I can create a pizza instance and I can ask for the slices and I get that. And I can

316
00:44:36,760 --> 00:44:47,960
ask for the flavor. And it's cheese. And here's the thing. The Dunderdict is a special attribute

317
00:44:48,520 --> 00:44:58,600
that most Python objects have. Some don't have it. But most Python objects have the Dunderdict.

318
00:44:58,600 --> 00:45:05,880
And the Dunderdict is basically a dictionary that tells you what are the attributes of that

319
00:45:05,880 --> 00:45:12,200
particular instance. Okay? And as you can see, even though I was asking about the slices and

320
00:45:12,200 --> 00:45:17,800
the flavor of the P instance, it doesn't have any attributes because it's getting everything from the

321
00:45:17,800 --> 00:45:35,320
class. Now, if I assign and look at the Dict, then I see the value appear as an instance attribute.

322
00:45:35,320 --> 00:45:43,720
So there's an asymmetry here. Which is when you read an attribute that doesn't exist in the

323
00:45:43,720 --> 00:45:51,480
instance, it goes looking at the class. But if you assign, it doesn't look at the class. It just

324
00:45:51,560 --> 00:46:08,360
assigns to the instance. Which means that the, you know, if I create another pizza here

325
00:46:13,880 --> 00:46:15,160
and ask for the flavor,

326
00:46:15,240 --> 00:46:21,240
it's going to be cheese. Because that's the default that's in the class. Right? The fact that I

327
00:46:21,240 --> 00:46:31,160
assigned to the instance didn't change the class at all. So I can check and see the Dict of the

328
00:46:31,160 --> 00:46:38,280
pizza of the class. The Dict of the class, the Dunderdict of the class is wrapped into this thing

329
00:46:38,280 --> 00:46:44,520
called the mapping proxy. It's just sort of like a read-along. It's just a little bit of a

330
00:46:44,760 --> 00:46:52,920
read-only dictionary. But as you can see, it has the attributes that are declared explicitly in

331
00:46:52,920 --> 00:46:57,960
the class, like diameters, lices, flavor, flavor two. And then it has other things,

332
00:46:59,320 --> 00:47:04,760
including this is where the doc string would be, if there was doc string. But I didn't create doc

333
00:47:04,840 --> 00:47:17,640
string in this case. All right? So now to wrap up this session here, I'm going to show a better

334
00:47:17,640 --> 00:47:28,360
pizza. So this is what I consider gourmet professional pizza. Okay? And what I did here is

335
00:47:28,440 --> 00:47:40,920
I separated, I created those two attributes. I considered them class attributes. Okay? Because

336
00:47:41,480 --> 00:47:46,920
every pizza that I make are going to be 40 centimeters in diameter and eight slices.

337
00:47:50,120 --> 00:47:56,680
Okay? They are sort of like a configuration option of the class. And the class is a factory

338
00:47:57,560 --> 00:48:03,720
of objects, right? So I can configure the class so that it starts making instances with those

339
00:48:03,720 --> 00:48:13,080
characteristics. So these are class attributes. And the instance attributes, the proper way of

340
00:48:13,080 --> 00:48:23,480
doing them today is to assign them all inside the Dunderdict. Some people call it the constructor

341
00:48:24,440 --> 00:48:30,840
because it does what the constructor does in Java. But it's actually not a constructor

342
00:48:32,040 --> 00:48:37,880
because it gets the object as the first argument. So the object has already been constructed.

343
00:48:38,600 --> 00:48:45,560
What the Dunderdict does is it initializes. That's why it's called Dunderdict. Right? So it gets the

344
00:48:45,560 --> 00:48:53,880
instance and then you initialize whatever you need to initialize here. And this is the most

345
00:48:53,880 --> 00:49:02,520
official way traditionally of declaring instance attributes in Python. It's assigning them in the

346
00:49:02,520 --> 00:49:09,160
Dunderdict. And it's a best practice. You should always assign everything that is going to be in

347
00:49:09,160 --> 00:49:15,320
all instances in the Dunderdict. And not do it piecemeal in different methods and so on

348
00:49:15,320 --> 00:49:22,040
or later. No. If you want to create an attribute later, the best practice is to create it in the

349
00:49:22,040 --> 00:49:28,520
Dunderdict and assign none to it. Okay? Or some empty value. Like an empty list or whatever.

350
00:49:29,080 --> 00:49:34,280
And then later when you have data to put in, the important thing is that the attribute is already

351
00:49:34,280 --> 00:49:39,160
declared so that people reading your class will know what to expect. So this class,

352
00:49:39,720 --> 00:49:46,120
so here we're dealing with the deficiency in Python. Get it? The deficiency is there is no

353
00:49:46,120 --> 00:49:56,440
explicit way of telling Python what are the instance attributes. So the best we can do is

354
00:49:56,440 --> 00:50:02,200
adopt conventions. And this is the best convention we have. Assign them all and then they're in it.

355
00:50:03,000 --> 00:50:13,880
All right? So the good practices shown here are that I use class attributes for attributes that

356
00:50:13,880 --> 00:50:21,240
are shared among all instances. And the attributes that are expected to vary among instances are

357
00:50:21,240 --> 00:50:27,160
instance attributes. And the instance attributes were all assigned in the Dunderdict. And the

358
00:50:27,160 --> 00:50:33,000
default value for instance attributes are argument defaults in the Dunderdict. So I can

359
00:50:33,000 --> 00:50:39,480
create a pizza without specifying the flavors because it has the Dunderdict has default arguments.

360
00:50:40,920 --> 00:50:48,120
So this is the best practice. And actually besides readability, which is a very important thing to

361
00:50:48,120 --> 00:50:55,320
have in a system, because systems, source code is read much more often than it is written.

362
00:50:56,040 --> 00:51:03,160
So it's important for source code to be readable. But there is now for people who are more motivated

363
00:51:03,160 --> 00:51:10,120
by performance, performance, performance, there is a technical reason to do that.

364
00:51:10,840 --> 00:51:18,280
There was a PEP and it's kind of it's not so new, actually. It came out around Python 3.4.

365
00:51:18,920 --> 00:51:28,760
So PEP 4.1.12, document and optimization, which is designed for this situation here.

366
00:51:29,560 --> 00:51:37,880
Let's suppose I have an Amazon pizza. So I have a million pizzas in the queue.

367
00:51:39,640 --> 00:51:47,880
And that means that I will have a million dictionaries with the attributes of each pizza

368
00:51:48,280 --> 00:51:55,320
has its own dictionary with the attributes, right? The Dunderdict. What this PEP does is

369
00:51:56,920 --> 00:52:05,720
they created this optimization where Python notices when you

370
00:52:08,280 --> 00:52:15,640
create an instance that the keys of this instance dicts are the same keys of another instance's

371
00:52:15,640 --> 00:52:25,240
dict and they share and Python shares the keys, which is basically a hash, the name and the

372
00:52:25,240 --> 00:52:34,120
hash and the value of the key, which may be a long string or an arbitrary object. So

373
00:52:35,960 --> 00:52:43,320
this key sharing can lead to significant economy of memory. But it only happens if you follow

374
00:52:43,320 --> 00:52:51,160
strictly this practice of initializing all your instances with all the instances attributes at

375
00:52:51,160 --> 00:53:02,440
once. Any time you, after the fact, decide to add another attribute, then this forces Python to

376
00:53:03,960 --> 00:53:09,320
remove that dictionary and copy it to another place where it's going to be a singleton and not

377
00:53:09,320 --> 00:53:20,120
be sharing keys with others. So I would like to propose that you do a little bit of coding

378
00:53:21,080 --> 00:53:30,200
and the idea is there is actually in the Google, oh sorry, I forgot something. I need to hand out

379
00:53:30,200 --> 00:53:41,800
something. Let me get it here. Yeah, okay. So oops, wrong, okay, wrong link. There's no,

380
00:53:42,840 --> 00:53:46,280
yeah, I simplified the link but I forgot to edit there. I'm gonna edit there.

381
00:53:46,920 --> 00:53:57,160
So this is the link and I'm gonna fix the notebook, sorry. Later I decided to simplify,

382
00:53:57,800 --> 00:54:07,240
or actually what did I do here? Wait, I think it's, I know what I did. I changed the label but I didn't

383
00:54:07,240 --> 00:54:20,520
change the actual link. All right, so now it works and I'm gonna commit and push so that you have this

384
00:54:20,520 --> 00:54:23,880
fixed version.

385
00:54:51,480 --> 00:54:58,840
All right, so I suggest that you do it in pairs and what I want to propose, so the exercise is

386
00:54:58,840 --> 00:55:09,640
described in this document here. All right, so there's three steps but let's call it the

387
00:55:10,760 --> 00:55:19,000
third step a bonus, okay. Do it only if you have time and what I'm gonna do is I'm gonna hand out

388
00:55:19,000 --> 00:55:25,880
post-its and if you want to do the exercise I'm gonna ask you to do this.

389
00:55:27,880 --> 00:55:36,520
If you have an issue, if you need help, you're gonna stick a red post-it to your screen here

390
00:55:37,560 --> 00:55:43,000
and when you're done with the step two, okay, because three is a bonus. If you're done with

391
00:55:43,000 --> 00:55:48,840
step two, you stick the green one. So when there's a bunch of people with the green one,

392
00:55:48,840 --> 00:55:54,280
we need to move on, all right. That's the idea. So please pass them around.

393
00:55:59,480 --> 00:56:02,120
So take one of each color

394
00:56:05,960 --> 00:56:09,640
and what I'm gonna

395
00:56:09,640 --> 00:56:19,240
do is I'm gonna, so the basic instructions I'm gonna show what's happening here is that we have

396
00:56:25,240 --> 00:56:27,240
sorry, oh yeah.

397
00:56:27,240 --> 00:56:29,240
Yeah.

398
00:56:32,520 --> 00:56:39,960
Oh okay, the fix is, the fix needs a fix. Okay, sorry.

399
00:56:43,000 --> 00:56:45,240
Oh it says one here.

400
00:56:45,400 --> 00:56:47,400
Yeah, but what you.

401
00:56:53,720 --> 00:57:00,520
Yeah, I'm gonna show you how to get there. So if you go to the repo,

402
00:57:02,200 --> 00:57:08,600
it's so PIOB, the link and then

403
00:57:08,760 --> 00:57:20,600
then lamps and then one and then this is it, right.

404
00:57:26,840 --> 00:57:30,520
So for instance, if I use this command here,

405
00:57:30,520 --> 00:57:39,480
here. So this is another feature of Python that is not very well known,

406
00:57:40,680 --> 00:57:48,520
which is the dock test. I'm gonna show you how it works. So if I go there to the labs, one, okay,

407
00:57:50,360 --> 00:57:57,720
this is what I have and I type this command and what happened is this,

408
00:57:57,720 --> 00:58:02,760
this. Okay, so what is going on here?

409
00:58:05,160 --> 00:58:09,560
I'm running the dock test module which comes with Python.

410
00:58:11,800 --> 00:58:21,480
So this is what the dash M dock test does on the readme.rst file, which is a text file.

411
00:58:21,800 --> 00:58:29,080
And the dash F at the end is just so that it stops at the first failure, because otherwise it's gonna

412
00:58:29,080 --> 00:58:36,200
show a lot of other things that are wrong, that are what the exercise is about. The exercise is

413
00:58:36,200 --> 00:58:44,200
about fixing those things. But anyway, if you do dash F, you're gonna do step by step, okay.

414
00:58:45,320 --> 00:58:50,120
So it stops at the first. And what does it say? Failed example, goof of guinea,

415
00:58:50,120 --> 00:59:01,560
goof of guinea, coordinate object has no attribute lot. Okay. So the problem is that

416
00:59:02,840 --> 00:59:09,240
it's asking you to create an image accepting a latitude and a longitude, right?

417
00:59:14,520 --> 00:59:16,600
The class that you have there doesn't have that.

418
00:59:20,120 --> 00:59:33,160
Okay. So I'm gonna cheat and just say, and this is not what the exercise is intended to do,

419
00:59:33,160 --> 00:59:42,040
but just to show you the dock test running. If I create the let attribute like I had done over there

420
00:59:42,040 --> 00:59:54,920
here, and I run it again, oops. Now it's gonna complain about the lack of the long and so on,

421
00:59:54,920 --> 01:00:01,400
right? So actually the dock tests, if you run it like this with dash F, they're gonna guide you

422
01:00:01,400 --> 01:00:10,200
through what you need to do. But if you start by doing the first step, which is to create the

423
01:00:10,520 --> 01:00:25,000
image like I had shown before, you can pass. So this is the example that is actually running.

424
01:00:25,560 --> 01:00:31,720
So what dock test does is it looks at text that has prompts that look like the Python prompt,

425
01:00:32,280 --> 01:00:40,040
executes the code and checks whether the output is the same as appears here. This is what dock

426
01:00:40,040 --> 01:00:45,640
test does. The idea of dock test is to make sure that the examples in documentation are accurate.

427
01:00:47,880 --> 01:01:05,560
But I also like to use them as a scaffolding for exercises like we're using now.

428
01:01:10,520 --> 01:01:20,200
So the first step is actually like the code that I just showed you with the image. The second step

429
01:01:20,200 --> 01:01:33,160
is new. The idea is that you're gonna create a class attribute. The example shows that you can

430
01:01:33,240 --> 01:01:37,880
access the class attribute through the class coordinate or through an instance.

431
01:01:40,600 --> 01:01:44,680
And step three is where you implement and encode

432
01:01:48,840 --> 01:01:52,680
the geohash method here.

433
01:02:03,160 --> 01:02:10,840
And here's what's gonna happen. I was supposed to read these announcements to you.

434
01:02:12,200 --> 01:02:23,720
Because we have a break. So we're gonna have a break at 10.15, okay? And it says snacks go quickly,

435
01:02:23,720 --> 01:02:30,840
so please let your group out at the right time. Right? So actually, if you wanna

436
01:02:31,800 --> 01:02:39,800
step outside soon, you know, go ahead and then we can come back. I don't know what's the length of

437
01:02:39,800 --> 01:02:53,800
the break, the duration of the break. Let me try and find out.

438
01:03:00,840 --> 01:03:08,680
Well, let's do a 15-minute break, okay? So the idea is we'll come back. You can step outside

439
01:03:08,680 --> 01:03:15,480
whenever you like and we'll come back at 10.30, okay? Or you can come back earlier and finish

440
01:03:15,480 --> 01:03:25,000
the exercise or whatever. Lunch will be at 12.20. And then it says here, we have placed as much power

441
01:03:25,000 --> 01:03:31,800
as we could afford. Please share the outlets. And there's a survey link to the tutorial. I don't

442
01:03:31,800 --> 01:03:39,160
know if you have that. Have you gotten a piece of paper that has this link? Otherwise, I'm gonna

443
01:03:39,160 --> 01:03:47,320
put it in the presentation here. It's a Survey Monkey link with a bunch of letters.

444
01:03:47,320 --> 01:03:55,640
I'm going to put it in the last presentation, the last.

445
01:05:17,320 --> 01:05:41,640
Yes, all right. So I put the link in the last page that we're gonna see.

446
01:14:11,640 --> 01:14:40,520
So I'm gonna step outside and come back in 15 minutes, okay? And then we resume. Let's go eat

447
01:14:40,520 --> 01:14:51,400
before it's all over.

448
01:29:40,520 --> 01:30:00,600
Let's get going. So maybe you noticed that there was a spoiler because the solution was right at

449
01:30:00,680 --> 01:30:09,880
the page that we were looking at, right? So and the GeoHash is a very interesting thing

450
01:30:11,080 --> 01:30:24,440
because it computes an alphabetical, an alphanumerical hash that has some very interesting properties.

451
01:30:31,320 --> 01:30:34,520
Oh, that's in the readme, actually. The property is that,

452
01:30:38,120 --> 01:30:46,280
you see, I have here the coordinates of the airport of Cleveland, the one in the west,

453
01:30:46,280 --> 01:30:53,240
and this is the coordinate of the city as it appears, I think, on Wikipedia. And you see

454
01:30:53,240 --> 01:31:00,360
that the first three letters are the same. So this is what is cool about GeoHashes, is that

455
01:31:00,360 --> 01:31:05,800
it's super fast to compare. It's very easy to determine whether two things are close,

456
01:31:06,440 --> 01:31:13,320
depending on the number of letters that match. And if you have more letters matching, that means

457
01:31:13,320 --> 01:31:19,880
it's really close. If you have like 10 letters matching, that's probably in the next room,

458
01:31:21,480 --> 01:31:28,840
right? Of course, there are exceptions because it involves cutting the world in squares,

459
01:31:28,840 --> 01:31:33,880
and if you are on a boundary, then you have to check other things. But at most, you do

460
01:31:33,880 --> 01:31:37,960
eight different checks and you can determine whether something is very close or not.

461
01:31:38,680 --> 01:31:48,280
Anyway, GeoHash is cool. All right, so what I'm going to do is, so the next topic is actually

462
01:31:49,000 --> 01:31:55,000
something that is, these are the first examples that we just saw are new for this tutorial.

463
01:31:55,720 --> 01:32:00,840
The examples here are from my book, and I'm kind of,

464
01:32:04,280 --> 01:32:10,920
I want to, there's more interesting stuff to see rather than these examples. What I'm going to

465
01:32:10,920 --> 01:32:15,640
talk about, so I'm going to just speed through this page and then we're going to go to the next one.

466
01:32:15,640 --> 01:32:22,120
But this page is something that you can study later if my super quick explanation here

467
01:32:22,600 --> 01:32:29,480
leaves you with questions or you can ask me later too. But these are all, you know, the haunted bus

468
01:32:30,200 --> 01:32:36,520
and the haunted bus version two and the Twilight bus, they are bad for you, okay?

469
01:32:38,840 --> 01:32:45,960
The good bus is the bus, all right? So this is basically three counter examples that talk about

470
01:32:46,920 --> 01:32:54,840
problems that can happen when you have like a default argument, a default class attribute

471
01:32:55,800 --> 01:33:02,760
that is mutable and you're using it as the default for the instances. So what happens with the

472
01:33:02,760 --> 01:33:09,320
haunted bus is basically you created this bus one instance and you put two people in it and then

473
01:33:09,320 --> 01:33:16,680
when you create the two, when you create the bus two version, the bus two instance,

474
01:33:17,560 --> 01:33:24,520
you have the ghost of the same people. So they are in both buses. This is really scary.

475
01:33:25,240 --> 01:33:32,520
And the other example is you don't have a class attribute anymore but you have a mutable default

476
01:33:32,520 --> 01:33:39,880
in the constructor and that basically has the same issue because think about it.

477
01:33:40,680 --> 01:33:50,680
Like I said before, methods are class attributes, right? And the full values in method declarations

478
01:33:51,640 --> 01:34:00,040
are attributes of the methods. So this empty list is an attribute of Dunderinit

479
01:34:00,680 --> 01:34:05,320
and Dunderinit is a method of the class. So indirectly this is an attribute of the class

480
01:34:05,320 --> 01:34:13,960
as well. So you have the exact same issue. This last example is more subtle. Oh, sorry.

481
01:34:17,640 --> 01:34:22,920
Actually this is fixed. This is not what I wanted it to be.

482
01:34:22,920 --> 01:34:37,480
Sorry. I was trying it out later, sooner and it's wrong. So this is correct and we're going to

483
01:34:38,200 --> 01:34:45,320
save it soon. This is what it was intended to be. The idea is for this example, this looks pretty

484
01:34:45,320 --> 01:34:54,440
good, okay? Because you don't have a default in the class and you follow this idiom of

485
01:34:54,440 --> 01:35:00,120
for any mutable arguments you put none as the default and then you check and you explicitly create

486
01:35:01,080 --> 01:35:08,920
an empty list in this case, okay? So this looks okay. But there is a subtle problem with it.

487
01:35:08,920 --> 01:35:19,160
So we have a hockey team here with six women, all right? And then I am loading the bus,

488
01:35:19,160 --> 01:35:28,280
the Twilight bus with the six players, passengers. So what happened is passengers, not none in this

489
01:35:28,280 --> 01:35:35,720
case, it's the hockey team. So I have this assignment here. And now the bus, which is bus 5,

490
01:35:35,720 --> 01:35:44,200
is going to drop Sue and Pat. And you can see that they are no longer in the bus. Yes, but they are

491
01:35:44,200 --> 01:35:57,160
no longer in the hockey team either. So they fell into a void, right? And, you know, a lot of Python

492
01:35:57,160 --> 01:36:02,440
programmers will look at this code and say that it's okay, but there is this subtle problem. And

493
01:36:02,440 --> 01:36:10,040
the solution to the problem is this assignment here is dangerous because you're using this as a

494
01:36:10,040 --> 01:36:15,480
list. You can see that it's a list because I'm calling append and remove methods. And also in

495
01:36:15,480 --> 01:36:24,360
the default case I'm creating an empty list. But if I just assign the arguments, my instance is

496
01:36:24,360 --> 01:36:31,000
actually sharing the list that was passed. And as I drop people along the way, I'm actually removing

497
01:36:31,000 --> 01:36:38,520
them from the list that I got. And this is probably not what the end user wants. So there's two ways

498
01:36:38,520 --> 01:36:49,800
to fix this. One way is using this notation, which creates a copy of the list. But if you get a

499
01:36:49,800 --> 01:36:57,640
tuple argument, the addender in it will work, but will create a copy of the tuple. But then the class

500
01:36:57,640 --> 01:37:01,720
will break later because you're going to try and do append and remove in the tuple and it doesn't

501
01:37:01,720 --> 01:37:12,760
work. So the best way is to do this. So what I'm doing here is actually I'm using the passengers

502
01:37:12,760 --> 01:37:19,080
list as the argument to the constructor of a new list. So this does create a copy. But it's more

503
01:37:19,080 --> 01:37:27,320
flexible than the other notation because if I get a tuple as an argument, I'm building a list from it.

504
01:37:27,320 --> 01:37:34,120
If I get any iterable as argument, I'm building a list of it. So it's flexible and safe at the same

505
01:37:34,120 --> 01:37:41,240
time. And this is the best solution. So now if we run the test, you see that the hockey team is

506
01:37:41,240 --> 01:37:48,920
still complete. So this is the best practice to take whatever arguments that you get that are

507
01:37:49,560 --> 01:37:55,720
mutable and make a copy. Of course, there are exceptions, right? Maybe it's 10 million

508
01:37:57,560 --> 01:38:03,160
items in this list and you don't want to copy 10 million items, but then you have to document,

509
01:38:03,960 --> 01:38:09,560
pay attention, I'm going to change whatever you pass me. But by default, I think this is a very

510
01:38:09,560 --> 01:38:20,760
good practice. And it's also, yeah, so this is the solution of the bus. Yeah, all right.

511
01:38:23,160 --> 01:38:31,160
Okay. And it's also an example. If I do, like I said, as I convert the argument to a list,

512
01:38:32,680 --> 01:38:39,480
I'm offering flexibility to the user. They can pass any iterable object and I will build a list

513
01:38:39,480 --> 01:38:46,920
from it. And this is an example of Postel's law, which is one of the

514
01:38:49,880 --> 01:38:54,040
best practices in the internet, right? Be conservative in what you send and be liberal

515
01:38:54,040 --> 01:39:00,200
in what you accept. In fact, if people did that on Facebook and on Twitter, that would be awesome

516
01:39:00,200 --> 01:39:13,560
too, right? Anyway, so let's now, so I started talking about how

517
01:39:17,800 --> 01:39:20,680
Python doesn't have an easy way of declaring

518
01:39:21,640 --> 01:39:29,640
class attributes. And this is particularly painful with classes like this one that I,

519
01:39:29,640 --> 01:39:38,360
I'm back to the page one here. So this class is basically, you know, a pair of coordinates,

520
01:39:40,840 --> 01:39:45,480
right? There's not a whole lot of functionality. The most interesting functionality here is the

521
01:39:45,480 --> 01:39:53,400
geohash method that we added later. But it's basically just like a struct or a record in a

522
01:39:53,400 --> 01:40:00,840
database. It has two numbers and that's it, right? So the fact that Python didn't have an easy way

523
01:40:00,840 --> 01:40:06,440
to declare the instance attributes made it difficult to avoid this kind of boilerplate

524
01:40:06,440 --> 01:40:12,040
of having to write this in it with a lot of repetition of the names of the arguments

525
01:40:12,040 --> 01:40:17,640
assigned to the, and then the wrapper, which is like a standard thing that looks like this.

526
01:40:17,640 --> 01:40:23,640
And so there's a lot of boilerplates involved here. So over the years, and this is our next subject,

527
01:40:25,160 --> 01:40:29,320
the Python community has evolved ways of dealing with these kinds of classes,

528
01:40:29,320 --> 01:40:36,040
which are called data classes. And here I'm using a space, okay? Because I'm using the term in,

529
01:40:36,120 --> 01:40:42,520
like a general term. What is a data class? A data class is mostly just like a struct. It's a class

530
01:40:42,520 --> 01:40:47,160
that looks like a database record. It doesn't have a lot of algorithms. It doesn't have a lot of

531
01:40:47,720 --> 01:40:53,640
weird methods. It just stores fields and displays fields and lets you access the fields, okay?

532
01:40:54,360 --> 01:41:00,360
So other languages have grown this kind of features too. Ruby has always had a very simple

533
01:41:00,360 --> 01:41:08,840
way of doing this. And the first solution to this problem that appeared was NameItTouple. NameItTouple

534
01:41:08,840 --> 01:41:13,160
is pretty old. I don't know when it started, but probably more than 10 years old. But anyway,

535
01:41:13,160 --> 01:41:17,560
so NameItTouple is actually a function that you call

536
01:41:20,680 --> 01:41:27,400
passing two arguments. The first is the name of a class that, so NameItTouple is a factory of classes,

537
01:41:28,360 --> 01:41:34,280
okay? And by the way, this is one way in which Python is more object oriented than Java.

538
01:41:35,080 --> 01:41:37,080
Because in Java, the classes are not

539
01:41:40,120 --> 01:41:48,920
full first class classes or objects. What I mean is, in Java, you cannot write Java code,

540
01:41:48,920 --> 01:41:55,000
just pure Java code to create a class at runtime. If you need to create a class at runtime, you need

541
01:41:55,080 --> 01:42:03,240
to write byte codes. You need to generate byte codes at runtime. But in Python, these

542
01:42:04,360 --> 01:42:10,760
classes are objects. And as such, they can be created at runtime. And this is a function that

543
01:42:10,760 --> 01:42:18,680
creates, when I invoke this, it creates a class with this name and with these attributes, okay?

544
01:42:18,680 --> 01:42:28,440
Okay. And now I use it like this. And you see it has a very nice wrapper by default

545
01:42:29,320 --> 01:42:42,280
that spells out the name of the argument. And it's any class created by NameItTouple

546
01:42:42,920 --> 01:42:51,960
is actually a subtype of tuple. So that means I can use this notation here to unpack the values.

547
01:42:55,720 --> 01:43:03,160
See? This object is an instance of my class. And it also behaves like a tuple. I can do

548
01:43:03,160 --> 01:43:09,240
this multiple assignments. And I can read the different parts. All right? And it includes

549
01:43:09,400 --> 01:43:15,160
a Dundee queue method. The Dundee queue method is the one that implements the equality operator.

550
01:43:15,160 --> 01:43:22,520
Right? And the Dundee queue that is generated by the NameItTouple factory actually knows how

551
01:43:22,520 --> 01:43:35,480
to compare my instances with any tuple. See? So NameItTouple is pretty cool. I use it a lot.

552
01:43:35,480 --> 01:43:39,960
But there are some limitations. Limitations are not always bad, right? Sometimes it's good to have

553
01:43:39,960 --> 01:43:45,240
limitations because you're being explicit. I don't need anything fancier than a NameItTouple here.

554
01:43:45,240 --> 01:43:54,120
I'm going to use a NameItTouple. NameItTouples are also, they use less memory than classes.

555
01:43:54,600 --> 01:43:59,880
Because they don't have a Dundee dict. They have another mechanism called Dundee slots,

556
01:44:00,360 --> 01:44:07,400
which is less flexible but saves memory. The problem is the instances are immutable. This may

557
01:44:07,400 --> 01:44:12,440
be a problem or not. It's a limitation. Maybe it's a feature, depending on your situation.

558
01:44:12,440 --> 01:44:17,640
And there's no simple way to implement custom methods. So, for instance, if I wanted to put

559
01:44:17,640 --> 01:44:27,800
our custom Dundee stir or the Geo hash method that we created before, there's no simple way to implement

560
01:44:27,800 --> 01:44:33,480
it before. There's no simple way to do that because I just can't edit. I don't see the body

561
01:44:33,480 --> 01:44:40,920
of the class anywhere in my source code. Right? So you could do it through monkey patching, but that's

562
01:44:42,200 --> 01:44:51,320
not the case. Anyway, so then something interesting happened. So Python is now doing this whole

563
01:44:51,320 --> 01:44:59,960
movement towards a system of typing that allows you to declare the types of variables

564
01:45:00,760 --> 01:45:08,760
and function arguments and function return types and so on. And in Python 3.5,

565
01:45:09,560 --> 01:45:16,120
they invented this thing called NameItTouple, typing NameItTouple, which is very similar to

566
01:45:16,200 --> 01:45:21,560
the NameItTouple, the traditional NameItTouple, except that when you specify the NameItTouple

567
01:45:22,360 --> 01:45:32,840
with the typing NameItTouple class, in that case it's a class, you can specify the types.

568
01:45:32,840 --> 01:45:38,600
And there's actually two syntaxes, but this is the more interesting syntax that appeared

569
01:45:39,560 --> 01:45:47,240
in Python 3.6. So in Python 3.5, the typing NameItTouple had a syntax that is similar to the

570
01:45:47,240 --> 01:45:54,440
old NameItTouple, and in Python 3.6, they added syntax for variable declarations,

571
01:45:55,000 --> 01:46:07,640
and that allowed this kind of notation. Okay? So basically this does everything that our, well,

572
01:46:07,640 --> 01:46:14,680
except it doesn't have the, this has a nice wrapper, it has equality, it has a lot of features,

573
01:46:17,080 --> 01:46:25,960
and I can also add methods. But there is a trick, because remember when I said that for

574
01:46:28,280 --> 01:46:35,080
all of the history of Python until Python 3.6, anything that was declared at the class level

575
01:46:35,880 --> 01:46:48,600
was a class attribute, but not anymore. Whenever you have a type annotation near a variable name

576
01:46:49,160 --> 01:46:55,880
at the class level, this is interpreted by Python as an instance attribute.

577
01:46:59,000 --> 01:47:03,320
So now that thing that was missing for many years in Python, we have it.

578
01:47:05,080 --> 01:47:11,720
But unfortunately, my opinion as a teacher is a bit confusing, this scenario, because some things

579
01:47:11,720 --> 01:47:19,800
that you always thought was true, like anything declared at the class body is a class attribute,

580
01:47:19,800 --> 01:47:26,760
is no longer true. In fact, notice the situation here. This is a class attribute. You know why?

581
01:47:29,160 --> 01:47:33,880
Because there is no type declaration. So that's really subtle, right?

582
01:47:35,560 --> 01:47:43,880
I don't like that too much. I like the features, but I don't like to explain it,

583
01:47:44,600 --> 01:47:47,640
which probably means there's something wrong with it. Right?

584
01:47:51,880 --> 01:48:03,160
Yeah. Okay. So the other day, so I'm starting to dive deeply into the typing, the whole typing

585
01:48:03,160 --> 01:48:08,280
infrastructure, because that was something that appeared after I wrote my book, and I'm working

586
01:48:08,280 --> 01:48:14,760
on the second edition. And this whole subject is very complicated, and it's probably going to

587
01:48:15,560 --> 01:48:22,600
take three chapters in the new edition to explain, and that's not going to be super detailed, just

588
01:48:22,600 --> 01:48:29,480
give an overview. But one thing that is true about it, that I tweeted the other day is,

589
01:48:29,480 --> 01:48:34,840
the good thing about typing in Python is that it's optional. Actually, the best thing about

590
01:48:34,840 --> 01:48:40,920
typing in Python is that it's optional. And this is not just a joke. It means that you can add it

591
01:48:40,920 --> 01:48:47,080
when you feel like it, but when you don't feel like it, just use a node, name it up, or don't declare

592
01:48:47,080 --> 01:48:56,360
the types anywhere. You know? This is so you can ease into it by using it step by step. It's sort

593
01:48:56,360 --> 01:49:01,800
of like TypeScript, and also the Dart language from Google. Those are examples of languages that

594
01:49:01,800 --> 01:49:13,960
have this characteristic of optional typing. Okay? Anyway. Oops. What is happening here? Oh,

595
01:49:13,960 --> 01:49:21,880
okay. I need to run this because I need to... I ran this, and now I'm going to run this, and it works.

596
01:49:22,840 --> 01:49:29,240
And then the nice... Oh, here's an interesting thing. Now I'm going to try and do an assignment.

597
01:49:30,840 --> 01:49:38,280
And look at what happens. I got an error because it's a tuple, remember? And tuples are immutable.

598
01:49:40,120 --> 01:49:49,160
So once I created this coordinate, I can't assign to its attributes anymore.

599
01:49:49,480 --> 01:49:59,560
And I cannot assign, interestingly enough, to... I can read the reference system, which is the

600
01:50:02,280 --> 01:50:10,600
class variable there, the class attribute, but I cannot assign to it either. See?

601
01:50:11,160 --> 01:50:11,640
See?

602
01:50:17,480 --> 01:50:23,160
All right. So this is another option that we have now to create these kinds of data classes.

603
01:50:23,800 --> 01:50:31,480
And now let's talk about the properly named data class. So data class is a brand new thing,

604
01:50:32,280 --> 01:50:44,440
and it comes as a decorator, right? Yet another example of how inheritance is going out of fashion.

605
01:50:46,840 --> 01:50:52,840
Because they chose to implement this as a decorator and not, like in this case here,

606
01:50:53,960 --> 01:50:55,400
through inheritance. See?

607
01:50:55,400 --> 01:51:01,080
And...

608
01:51:03,880 --> 01:51:10,680
Anyway, so what is a class decorator? A class decorator is actually a function

609
01:51:11,560 --> 01:51:18,840
that when the Python interpreter reads this class the first time, when it defines this class,

610
01:51:19,800 --> 01:51:28,280
it's the... What happens when you execute a class statement? Everything in the body of the

611
01:51:29,560 --> 01:51:35,480
class is defined, and this whole bundle of things becomes a class object, right?

612
01:51:36,840 --> 01:51:44,920
This object which is a class. And this whole object is passed to the data class

613
01:51:45,560 --> 01:51:53,160
decorator, which can then do stuff with it. And what the data class decorator mostly does is

614
01:51:53,160 --> 01:52:02,200
it creates methods for you. So that the boilerplate is gone, right? Like the Dunder wrapper and others.

615
01:52:02,200 --> 01:52:06,680
Now there's a different kind of syntax here. I could have

616
01:52:09,800 --> 01:52:15,800
written this like this, like in the example of the name of the name of tuple. So this is a class

617
01:52:15,800 --> 01:52:23,480
attribute. But if you want to specify the type of a class attribute, and in this case,

618
01:52:23,480 --> 01:52:30,760
the class attribute is a class attribute, then you can specify the type of a class attribute.

619
01:52:32,200 --> 01:52:38,440
It's more important because it's mutable. It can be updated, right? So in the other case,

620
01:52:39,800 --> 01:52:44,920
it's not supported. I don't know why, but it's not super important because in a name of tuple,

621
01:52:44,920 --> 01:52:51,160
this cannot be changed. So by reading the source code, you know what the type of this is, right?

622
01:52:51,160 --> 01:53:00,440
Because it's a string here, and it will never change. But in this case, because by default,

623
01:53:00,440 --> 01:53:07,800
data classes are mutable, what if I want to specify the type?

624
01:53:10,040 --> 01:53:17,640
Then you have to use this notation here. And so you need to import from class var,

625
01:53:18,360 --> 01:53:24,360
and then you see class var, and then within the square brackets, you see what the type is.

626
01:53:25,000 --> 01:53:32,360
So this is the way of... So again, it becomes tricky to write the syntax because

627
01:53:32,360 --> 01:53:39,320
this is a class attribute. This is an instance attribute.

628
01:53:44,760 --> 01:53:46,600
But this is a class attribute.

629
01:53:46,600 --> 01:53:56,440
Right? It's becoming a bit complicated.

630
01:54:05,480 --> 01:54:10,440
Now, does this mean that with those type declarations, even in the case of the

631
01:54:10,440 --> 01:54:16,040
name of tuple as well, does this mean that Python will do type checking for you?

632
01:54:17,000 --> 01:54:27,560
It does not. And this is kind of weird. But the whole point of these annotations is to support

633
01:54:27,560 --> 01:54:37,480
IDEs like PyCharm and others, and to support tools that you can use in the command line like MyPy.

634
01:54:37,480 --> 01:54:46,840
Okay? So I can actually show an example here that I have, which is...

635
01:54:50,200 --> 01:54:56,520
In order to show this example, I cannot use the Jupyter Notebook because I want to use MyPy to

636
01:54:56,520 --> 01:55:11,320
show you. So in examples here, I have coordinates. See, I'm going to do...

637
01:55:21,800 --> 01:55:25,480
So these are the coordinates of Sao Paulo, the city where I live, more or less.

638
01:55:26,760 --> 01:55:34,280
Okay? And I'm going to run this.

639
01:55:39,000 --> 01:55:46,520
See? And it shows the coordinates. Now, what if I write here...

640
01:55:46,520 --> 01:56:01,080
Blah. Well, what happened was a type error because of some operation that I did. Right?

641
01:56:02,120 --> 01:56:07,480
So there was no type check. You had a runtime check. But if I run MyPy...

642
01:56:07,480 --> 01:56:25,560
So MyPy knows to read that. So in addition to the kinds of tools that we use to check the correctness

643
01:56:25,800 --> 01:56:38,200
of the code and other linters, if you use MyPy in your toolchain, it will catch these errors

644
01:56:38,200 --> 01:56:52,840
without running your program. That's the idea of the annotations. Okay. So the data class decorator,

645
01:56:52,840 --> 01:57:00,520
I used it in the simplest way, but it's actually a function that you can pass a lot of arguments to

646
01:57:00,520 --> 01:57:08,360
it. And I have this little table here that summarizes what the arguments are. So the first...

647
01:57:08,360 --> 01:57:17,080
Most of them have to do with whether or not the decorator will generate methods for your class.

648
01:57:17,720 --> 01:57:23,880
Okay? So by default, it generates a Dunder init, a Dunder wrapper, and a Dunder EQ.

649
01:57:26,520 --> 01:57:32,280
If you want to be able to sort, for instance, collections of this type that you're creating,

650
01:57:32,920 --> 01:57:39,080
you need to also pass this order, which by default is false. But if you set it to true,

651
01:57:39,640 --> 01:57:45,880
then it will generate other methods that allow you to compare whether a certain thing is greater

652
01:57:45,880 --> 01:57:52,120
than another or smaller or equal than another, things like that. The hash I won't be able to

653
01:57:52,680 --> 01:57:59,560
comment. It's complicated, and I put it here. It has complex semantics and several caveats.

654
01:57:59,560 --> 01:58:11,320
But the idea is that it has to do with implementing Dunder hash is one of the things

655
01:58:11,320 --> 01:58:19,560
that you need to do to enable... To allow your objects to be hashable. And when they are hashable,

656
01:58:19,560 --> 01:58:26,280
they can be put in sets and they can be used as keys in dictionaries. But this is a complicated

657
01:58:26,280 --> 01:58:33,000
topic that we don't have time to cover here. And you can also say that it's frozen. By default,

658
01:58:33,000 --> 01:58:39,400
it says false, but you can say frozen equals true, right? The asterisk in the beginning of the

659
01:58:39,400 --> 01:58:46,680
declaration here means that if you're going to use any of these arguments, you need to prefix it

660
01:58:46,680 --> 01:58:51,960
with the name of the keyword. Okay? So it doesn't matter the order. You have to spell out all the

661
01:58:51,960 --> 01:58:57,800
names of the options. So if you want something that behaves like a tuple in the sense that it's

662
01:58:57,880 --> 01:59:10,840
not mutable, you say frozen equals true. All right? Okay. Just to show another example of

663
01:59:10,840 --> 01:59:19,480
a data class that's more complicated, this is a data class that represents a dublin core resource.

664
01:59:19,640 --> 01:59:29,720
Dublin core is a standard in information sciences for describing media in general. Books, films,

665
01:59:29,720 --> 01:59:45,080
recordings, pictures, whatever, paintings. And this here, I just created, I just instantiated the

666
01:59:45,080 --> 01:59:55,960
card, the class, and I'm going to put the data about my book. So I'm creating a resource with all of these

667
02:00:00,360 --> 02:00:10,520
values. All right? And then I'm going to, and if I ask to show it, it shows a nice wrapper that

668
02:00:10,520 --> 02:00:15,960
is broken into several lines, but this would work as source code, right? Because when Python

669
02:00:16,760 --> 02:00:22,760
sees an opening parenthesis, until that parenthesis closes, all the line breaks are ignored. They become

670
02:00:22,760 --> 02:00:31,400
like spaces. The same thing happens with braces and square brackets. Right? So this actually is

671
02:00:31,400 --> 02:00:45,560
valid syntax. But I'm going to show you, because this has two fields that are lists. The creator

672
02:00:45,560 --> 02:00:55,560
field is called creators, is a list of strings. See? But I want to have a default value because I

673
02:00:55,560 --> 02:01:03,080
want to be able to create a resource like this and then later fill it up. So I have the default list,

674
02:01:03,960 --> 02:01:11,240
but I don't want to have a haunted resource that has ghost values floating around.

675
02:01:11,880 --> 02:01:19,000
So how do you do that? Is by using this field function that comes from the data classes

676
02:01:19,960 --> 02:01:30,440
module. So the field function, the most common use of it is this one, which is to

677
02:01:33,000 --> 02:01:42,360
give a function that's going to be called by the data class to create the default value of every

678
02:01:42,360 --> 02:01:49,080
new instance that's created when the default value is required. Right? So that the list is not shared

679
02:01:49,080 --> 02:02:03,160
among the instances. Okay? And in the wrapper here, which I created because I wanted to be able to

680
02:02:03,160 --> 02:02:13,880
display a nice, you know, wrapper with one argument per line here. So I hand rolled

681
02:02:14,520 --> 02:02:22,200
this wrapper and you can see that I'm using the fields function, which is also from the data classes

682
02:02:22,760 --> 02:02:35,880
module. And what that does is it lists the fields of the class for you. Right? So here I iterate over

683
02:02:35,880 --> 02:02:44,600
the fields. So in the end, remember when I said at first that in Python terms, we call what the

684
02:02:44,680 --> 02:02:53,720
Java people call fields, we call data attributes. Okay. That's true. But in the specific domain of

685
02:02:53,720 --> 02:03:04,520
data classes, the things that are named with types are fields. So a field is a specific type

686
02:03:05,640 --> 02:03:13,000
or a specific kind of data attribute, which has a type annotation. Okay.

687
02:03:15,400 --> 02:03:23,800
Um, and the field function also takes a lot of arguments. If you look at the, so

688
02:03:24,920 --> 02:03:32,360
Jupyter notebook has this shortcut like IPython does. You put a question mark and it shows the

689
02:03:32,360 --> 02:03:39,880
help of the thing. So see it has a bunch of attributes or arguments that I don't have time to

690
02:03:40,840 --> 02:03:48,840
explain, but, um, the main part, the most important one by far is the default factor.

691
02:03:48,840 --> 02:03:54,280
The in it, which by default is true means that it's going, this, this field will be

692
02:03:56,200 --> 02:04:02,200
an argument for the cost for the initializer for the other in it. And it's going to be assigned in

693
02:04:02,200 --> 02:04:08,520
the dunder unit. Maybe you have a few that you don't want to be an argument for the

694
02:04:09,960 --> 02:04:17,880
dunder unit. Then you set this in it to false and so on. Uh, the compare for instance,

695
02:04:17,880 --> 02:04:22,520
by default is true, but if it's false means that that specific field will not be used

696
02:04:22,520 --> 02:04:31,160
as a criteria for comparison of two instances. So this is a super quick overview of different

697
02:04:31,160 --> 02:04:36,200
ways of doing data classes in Python. So we have the traditional name and tuple, and now we have the

698
02:04:36,200 --> 02:04:43,320
more modern typing name and tuple, which allows you to create methods and, uh,

699
02:04:44,760 --> 02:04:52,120
what requires you to do type annotations and data classes, which are, uh,

700
02:04:54,120 --> 02:05:03,320
more flexible. Okay. So, all right. Now let's talk about classes.

701
02:05:06,200 --> 02:05:14,040
Um, so one of the issues with the examples that we've seen so far is that

702
02:05:15,080 --> 02:05:21,000
they're very data driven and also they're like standalone classes. And I wanted to show examples

703
02:05:21,800 --> 02:05:31,640
of, of classes interacting. In this example here, I'm using, uh, UML to describe what we're going to

704
02:05:31,640 --> 02:05:39,720
have. Uh, let me show what it does first. So actually I'm going to skip a little bit and then

705
02:05:39,720 --> 02:05:45,960
we're going to come back. So the idea of this example is I have this budget, budget class.

706
02:05:48,280 --> 02:05:58,600
Okay. Uh, whoops. I have this budget class, which I, it's for people, you know, you know, when you,

707
02:05:59,240 --> 02:06:06,440
I used to go out camping a lot. Uh, and when we went, went camping, a bunch of people,

708
02:06:07,320 --> 02:06:13,560
some people had to buy stuff before we went on the trip and people bought stuff with different, uh,

709
02:06:13,560 --> 02:06:19,880
spent different amounts of money. So the idea of this is you stop, you start a budget by giving

710
02:06:19,880 --> 02:06:26,920
the names of the people that are going to be on the trip. And then, uh, initially the total is zero.

711
02:06:27,880 --> 02:06:31,800
There's a method called people that list the people that are on the trip. And then there's

712
02:06:31,800 --> 02:06:38,120
a method called contributes that you call with the name of somebody that is on the trip and, and the

713
02:06:38,120 --> 02:06:45,400
amount that they've spent. And then when you ask for the total, it gives you the total amount that

714
02:06:45,400 --> 02:06:51,000
everybody has spent is a hundred here. And the most interesting part is the reports,

715
02:06:51,800 --> 02:06:58,440
because the reports, if you run the reports method, it's going to tell you what was the

716
02:06:58,440 --> 02:07:06,280
total, what is the individual share. And then it says, Charlie paid zero. His balance is

717
02:07:06,280 --> 02:07:16,760
25 minus 25 and paid 10. Her balance is minus 15. Debbie paid 40. Her balance is 15. So she needs

718
02:07:16,760 --> 02:07:28,680
to get 15 and Bob paid 50. He needs to get 25. Okay. So that's, that settles all the, uh, expenses.

719
02:07:30,520 --> 02:07:36,760
All right. So this is what this class does, but it has to, the solution that I created has two

720
02:07:36,760 --> 02:07:46,920
classes. A budget has several campers, right? And in UML, you have, uh,

721
02:07:48,840 --> 02:07:51,960
these boxes here that represent a class, the name of the class.

722
02:07:53,640 --> 02:07:59,080
These are attributes. The underlying ones are class attributes and the, without an airline,

723
02:07:59,480 --> 02:08:06,920
instance attributes. And this bill and the box below is the methods. Again, there are methods

724
02:08:06,920 --> 02:08:14,120
here. Budget apparently does not have instance attribute, but it actually has because this

725
02:08:14,120 --> 02:08:21,240
notation here means that budget has an attribute called underscore campus, which has a bunch of

726
02:08:21,240 --> 02:08:29,720
these instances. Okay. So we don't duplicate this name in there. Anyway, so this is the description

727
02:08:29,720 --> 02:08:36,120
and now we are going to take a look at the, so, and what, what is, what does a camper do? So a camper,

728
02:08:38,440 --> 02:08:45,720
you create a camper with a name and then you all, you, you invoke the pay method. So that adds to

729
02:08:45,720 --> 02:08:50,760
the amount that that person has paid. And then there's a function called display,

730
02:08:52,520 --> 02:08:58,280
which is a little bit complicated because I want to be able to create this tabulation at the end,

731
02:08:58,920 --> 02:09:06,600
see where the columns are aligned here. So the, this, the, the logic to do the columns alignment

732
02:09:06,600 --> 02:09:14,920
is in the display method here. So if I just display one person, it's like that. But if I use

733
02:09:14,920 --> 02:09:20,680
display in the, in a, in a loop like this, I have the columns aligned and I'm going to show you how

734
02:09:20,680 --> 02:09:36,840
that's done. Okay. So this example is in the repository right here. Camping. So it's pile B

735
02:09:37,000 --> 02:09:45,800
examples, camping, and I have, I created three solutions, but I won't have time to show the one

736
02:09:45,800 --> 02:09:50,520
class solution. The one class solution is just what it says. It has just one class budget.

737
02:09:50,520 --> 02:09:55,480
The two class solution is the one that I'm talking about. It has the, the,

738
02:09:57,640 --> 02:10:02,280
the camp, camper and the, and the budget classes.

739
02:10:02,280 --> 02:10:14,600
Okay. So the camper has two class attributes. One is just a template that shows, that is used by the

740
02:10:16,200 --> 02:10:25,240
display methods. Okay. So this template has a trick, which is this. You see that here

741
02:10:25,400 --> 02:10:31,000
within these calibrations is the name of a, okay, here. Calibrations, name of a field,

742
02:10:32,200 --> 02:10:38,680
colon, formatting. Okay. In this case, we have name of a field, colon, formatting,

743
02:10:38,680 --> 02:10:46,520
but the formatting has another field inside. This allows me to parameterize the

744
02:10:46,920 --> 02:10:49,560
this allows me to parameterize the

745
02:10:53,560 --> 02:11:04,040
right justification. See this greater than sign here will do right alignment of the names.

746
02:11:05,080 --> 02:11:11,560
And this is going to give the, this could be a constant number, but since it's a variable,

747
02:11:11,560 --> 02:11:22,280
it's going to give me a variable with of the column. Okay. And the way I do this is I pass

748
02:11:22,280 --> 02:11:29,880
as the name, then the self dot max name, then which although I am reading from the instance here

749
02:11:29,880 --> 02:11:36,120
is actually a class attribute. So that's not a very good example of course. Sorry about that.

750
02:11:36,840 --> 02:11:40,920
I should have written camper here, but it does work. You know, it's just not clear.

751
02:11:41,720 --> 02:11:46,920
Okay. Here, this is better. Camper dot template. If you're going to talk, if you're going to

752
02:11:46,920 --> 02:11:53,480
refer to a class attribute, use the class name. Makes it more readable. This also should say,

753
02:11:53,480 --> 02:12:01,720
should say camper dot max name. So what happens here is every time that I create a new camper,

754
02:12:01,720 --> 02:12:08,360
I update the max name, max name land when I see a name that is bigger than the, the

755
02:12:08,360 --> 02:12:13,160
all the others that I've seen so far. So this class has a memory of the width of the

756
02:12:14,120 --> 02:12:20,440
longest name. Okay. It's not a super smart solution. If I had a bunch of these, I would

757
02:12:20,440 --> 02:12:26,120
have this thing growing forever. So it works for a command line script that wakes up and dies,

758
02:12:26,120 --> 02:12:33,960
but for a, a system on the web or a server side long running process, this would not be a good

759
02:12:34,040 --> 02:12:38,920
solution. It's just an example that I wanted to use to talk about because most of the

760
02:12:40,120 --> 02:12:46,600
class attributes that we've seen so far were static and this one is updated. I wanted to show that.

761
02:12:46,600 --> 02:12:53,000
And like I said before, if you need to update a class attribute, you need to put the name of

762
02:12:53,000 --> 02:12:58,200
the class. That's for sure. Because if you don't, if you put self here, then this would be a bug,

763
02:12:58,200 --> 02:13:04,280
right? Because it would create the attribute in the instance. So there's this asymmetry again.

764
02:13:04,280 --> 02:13:11,400
I can be, I, I, this can work by reading from self max max name land, but if I was writing

765
02:13:11,400 --> 02:13:18,760
to self max name land, then it wouldn't work. It would be a bug. All right. Well, so anyway,

766
02:13:18,760 --> 02:13:26,760
and the budget class has a bunch of, of matters. But what I want to, I want to talk about some

767
02:13:26,760 --> 02:13:32,040
details. I don't want to describe the whole text of the class, but what I want to talk about is

768
02:13:33,000 --> 02:13:38,680
the fact that this class here has an attribute that I called underscore campers. All right.

769
02:13:39,640 --> 02:13:50,360
And so this is a convention. Python doesn't have a way of declaring something private explicitly,

770
02:13:50,360 --> 02:13:58,040
but many Python programmers, this is a situation, this is something where if you ask around at PyCon,

771
02:13:58,040 --> 02:14:06,280
you're going to hear people with one, a lot of people would have one opinion.

772
02:14:06,280 --> 02:14:12,040
There are a lot of people who have another opinion. The two opinions are, oh, private method,

773
02:14:12,040 --> 02:14:17,320
private, private fields. I just use this one underscore, which is a convention. It's just a

774
02:14:17,320 --> 02:14:26,600
convention. Anybody can write to this easily. Okay. The other alternative would be to write

775
02:14:26,600 --> 02:14:35,640
two underscores. And I have an example here in the, in the number four classes

776
02:14:35,640 --> 02:14:47,480
of this notebook that talks about that. So, so I have a class here called black box.

777
02:14:48,680 --> 02:14:53,720
Let's say that the black box is something that I used to, it's a physical black box that I have that

778
02:14:54,840 --> 02:15:03,080
I store things in it. And anyway, so it has a top and a bottom, but notice that the top is with,

779
02:15:03,560 --> 02:15:08,600
the top attribute is written with one underscore and the bottom is written with two underscores.

780
02:15:09,480 --> 02:15:17,720
Right. And I put, so when I create this black box, I put gold in the top and diamonds in the bottom.

781
02:15:18,600 --> 02:15:30,520
Okay. So if I do that, I can read the top easily. Right. But if I ask whether there is a bottom

782
02:15:30,520 --> 02:15:39,000
attribute, it says false. If I, if I ask about the top, it says true. Actually.

783
02:15:45,400 --> 02:15:53,160
So this function asks, does this object have that attribute? And it says true, but it says

784
02:15:53,160 --> 02:15:58,440
that it doesn't have a bottom, even though it's written right here. But the thing is with two

785
02:15:58,440 --> 02:16:08,040
underscores, you're telling Python, please hide this a little bit. And the way Python hides it is

786
02:16:09,400 --> 02:16:17,240
by prepending the name of the class with one underscore in front of the name of the

787
02:16:17,240 --> 02:16:23,720
attribute that is preceded by two underscores. So this is what, this is the best we can do in

788
02:16:23,720 --> 02:16:31,160
terms of private attributes, okay, in Python. However, a lot of people that are super smart

789
02:16:31,160 --> 02:16:35,480
and that I respect a lot hate this. They think this is just too private.

790
02:16:44,760 --> 02:16:48,760
My main reason for not using this on a daily basis

791
02:16:48,760 --> 02:17:04,760
is that I think it's ugly. And I think it's, this one is good enough. You know. But anyway,

792
02:17:04,760 --> 02:17:14,680
this is, so it's easy to bypass, right? So if I write this code here, I am reading the diamonds

793
02:17:14,680 --> 02:17:21,640
from the bottom, but I'm doing it on purpose, right? It's not an accident. I am going a little

794
02:17:21,640 --> 02:17:30,520
bit out of my way to read that, right? So the main idea of that is like a safety switch like this,

795
02:17:30,520 --> 02:17:38,920
or a safety cover in a switch, you know? This won't prevent a terrorist from

796
02:17:39,560 --> 02:17:47,800
hitting the switch, right? But it does prevent somebody from doing it by accident. That's the

797
02:17:47,800 --> 02:17:53,800
idea of the private. And by the way, it's the same thing in Java, you know? Because through

798
02:17:53,800 --> 02:18:01,160
reflection, the reflection API in Java also lets you go and access the private fields,

799
02:18:01,160 --> 02:18:06,920
except it's more code. But it's the same situation in Java in terms of, it's not really

800
02:18:07,320 --> 02:18:14,360
a security feature, it's a safety feature, okay? So like I said, Pythonists are divided about that.

801
02:18:18,680 --> 02:18:25,720
And another thing that is related is some people advocate that you just use public attributes

802
02:18:25,720 --> 02:18:31,240
everywhere, no underscores at all. And if one day you need to protect it, then you turn it into a

803
02:18:31,240 --> 02:18:39,320
property. It's another option. And another thing that is, I think, a good point is that

804
02:18:40,520 --> 02:18:47,000
excessive use of getters and statuses is actually weak encapsulation, right? Because if you have a

805
02:18:47,000 --> 02:18:55,160
lot of getters and statuses, that means you're exposing the state without any controls, right?

806
02:18:55,160 --> 02:19:05,960
So that's about, so the camping budget allowed us to see some techniques about using a

807
02:19:09,480 --> 02:19:16,600
class attribute that we updated. We also saw the interaction between two classes

808
02:19:16,600 --> 02:19:30,520
where the API, the end user API of this, it only presents the budget because the camper is created.

809
02:19:31,800 --> 02:19:37,480
It's used internally here. So the end user doesn't need to know that there is a camper class,

810
02:19:38,760 --> 02:19:45,640
only the budget class. In fact, I could write this with an underscore in front.

811
02:19:47,480 --> 02:19:53,640
Just to tell people that the camper is part of my implementation, but it's just a convention.

812
02:19:53,640 --> 02:19:57,320
However, in this case, it's not just a convention because there's a difference,

813
02:19:57,960 --> 02:20:03,480
because this is an attribute of the module, right? The class is an attribute of the module, right?

814
02:20:04,040 --> 02:20:12,600
The top level. If I import star from a module, Python does not import things that start with

815
02:20:12,600 --> 02:20:18,360
one underscore by default. So it becomes a little bit more private, but not really.

816
02:20:19,480 --> 02:20:26,200
That's just the detail. Anyway, I don't do that often. Okay.

817
02:20:28,440 --> 02:20:37,320
Now let's go to the fifth thing. Okay. Now finally let's talk about inheritance.

818
02:20:38,280 --> 02:20:45,640
And because of all the discussions about inheritance, I decided to go

819
02:20:48,440 --> 02:20:55,480
pick an example from the book of the people who invented the name, the term object oriented,

820
02:20:56,120 --> 02:21:06,360
right? So this specification says financial history, class protocol,

821
02:21:06,360 --> 02:21:14,680
the word protocol is used in small talk, but also in Python and some other languages as a

822
02:21:14,680 --> 02:21:20,200
synonym of an interface. Okay. So this is the description of the interface of the class.

823
02:21:20,200 --> 02:21:26,040
It says the methods and it explains what each method does. This is from that book.

824
02:21:27,080 --> 02:21:31,400
This example is a running example in that book. So this text is actually in the, in the,

825
02:21:31,880 --> 02:21:34,440
the, like the first page of the book.

826
02:21:36,680 --> 02:21:42,840
And this is our UML diagram. And in this diagram, you see financial history is the one that is

827
02:21:42,840 --> 02:21:50,520
here, although here it's with Python syntax, not small talk syntax, the names. And this arrow here

828
02:21:51,160 --> 02:22:01,640
with the open triangle is inheritance, right? So contrast this with this.

829
02:22:03,000 --> 02:22:10,680
This is composition, right? So it says that a budget has one or more campers in it.

830
02:22:11,400 --> 02:22:19,240
And this is inheritance. This inherits from that. Okay. And

831
02:22:21,800 --> 02:22:28,600
so let's take a look at the, the example that is in the repository.

832
02:22:30,760 --> 02:22:36,840
So financial history is, oh, let's, let's take a look at the readme because the readme has some

833
02:22:37,240 --> 02:22:48,760
doc tests. So this is like a high level description of the API, but this is the

834
02:22:48,760 --> 02:22:57,480
demonstration is more interesting. So financial history is a class where you, it would like,

835
02:22:57,480 --> 02:23:05,640
would be like a super simple implementation of a bank account. So you start the financial history

836
02:23:05,640 --> 02:23:13,480
with a certain amount. And then when you display it, it shows the balance, the wrapper shows the

837
02:23:13,480 --> 02:23:27,960
balance. And I spend it and I see that it's the value is going from the balance. Oh, this is

838
02:23:27,960 --> 02:23:32,200
actually okay. We can't see that it's a decimal, but we're going to see soon.

839
02:23:32,200 --> 02:23:39,400
Anyway, I'm formatting the number, the balance.

840
02:23:44,520 --> 02:23:50,840
And now I can receive. So I say, receive the amount from that source.

841
02:23:52,840 --> 02:23:59,000
So I want, I want a thousand and one, a thousand dollars and one cents at Molly's game. And

842
02:23:59,640 --> 02:24:08,440
I found $10 on the street. So this is my balance and I spend the money. And now, and I, so I have

843
02:24:08,440 --> 02:24:14,680
methods that allow me to filter. So I can ask, what's the amount spent for a meal? And it says

844
02:24:14,680 --> 02:24:22,120
this. So this value is a decimal. See, this is what I was formatting over there when I did

845
02:24:22,120 --> 02:24:31,000
the balance. So this is a decimal and I'm going to talk about why it is a decimal.

846
02:24:33,240 --> 02:24:40,440
And I can check the amount spent for travel is zero. I didn't travel. All right.

847
02:24:41,400 --> 02:24:44,040
So let's take a look at the implementation.

848
02:24:44,040 --> 02:25:01,480
Okay. So the interesting thing about this class is besides being a classic example from the history

849
02:25:01,480 --> 02:25:09,240
of object oriented programming is that in Python, I decided to use decimals to deal with money,

850
02:25:09,880 --> 02:25:18,520
which is a best practice because I don't know if you've seen this, but I'm going to show

851
02:25:22,200 --> 02:25:23,480
one problem with.

852
02:25:27,880 --> 02:25:35,560
So I have X equals one, X equals 1.1. Okay.

853
02:25:35,560 --> 02:25:41,480
Okay. Good enough. Now let's print X.

854
02:25:45,960 --> 02:25:51,160
All right. Now let's print

855
02:25:51,640 --> 02:25:58,760
X with lots of decimal cases. Oops. Sorry.

856
02:25:59,400 --> 02:26:14,120
Oops. So even a simple number like 1.1 as a float has an infinite number of decimal cases.

857
02:26:14,120 --> 02:26:31,720
Oops. So even a simple number like 1.1 as a float has an imprecision. Right? So the problem is

858
02:26:32,280 --> 02:26:38,840
every machine, this is not a Python bug. If we call this a bug, it's a bug that exists in every

859
02:26:38,840 --> 02:26:49,080
machine that implements the IEEE 7.2 standard for floating point arithmetic. This standard

860
02:26:49,080 --> 02:27:00,520
converts decimal numbers into a binary representation where one tenth is a repeating

861
02:27:00,520 --> 02:27:09,800
bit, not a repeating decimal, but a repeating bit or a repeating bit pattern. And, you know,

862
02:27:09,800 --> 02:27:18,040
just like when you divide one by three, you get a repeating decimal. When you divide

863
02:27:20,200 --> 02:27:25,800
one by 10 and represent that as a floating point number, you get a repeating bit.

864
02:27:25,800 --> 02:27:31,960
So there is no way to show these things with precision or not to show, but to represent them

865
02:27:32,680 --> 02:27:39,880
in precision with the way the machine architectures are implemented today. So the solution is to use

866
02:27:39,880 --> 02:27:50,280
float, I mean decimal, the decimal class, which is what I used here. Okay. So that's why, for instance,

867
02:27:50,360 --> 02:27:57,560
where is the, so decimal is like this, for instance, if I do,

868
02:28:03,400 --> 02:28:06,440
it's kind of tricky, but let me show you. So

869
02:28:09,560 --> 02:28:10,600
if I do,

870
02:28:11,400 --> 02:28:19,320
so fraction is another Python class, so I can do

871
02:28:19,400 --> 02:28:25,480
tenth equal to such,

872
02:28:27,000 --> 02:28:35,560
infinite fractions

873
02:28:36,520 --> 02:28:39,080
Lind guides

874
02:28:40,600 --> 02:29:02,200
was fraction 110. So the issue here, let me show you, is if I try to build a decimal

875
02:29:02,200 --> 02:29:31,160
from this X, I will have the same problem. Take a look. See? Because X is a float, so

876
02:29:31,160 --> 02:29:49,560
it is hiding this error. But if I do like this, I create a fraction, for example, then

877
02:29:49,560 --> 02:30:14,520
I don't have the problem. Oops. I thought I could do that. That's weird. Well, okay.

878
02:30:14,520 --> 02:30:22,760
So here's the thing. I can do this. Sorry about the detour into the fraction. But if

879
02:30:22,760 --> 02:30:30,680
I convert the float into a string, then Python does a trick in order to not scare people

880
02:30:30,680 --> 02:30:42,820
when you do print, which is although internally 1.1 is really this weird number here, when

881
02:30:42,820 --> 02:30:54,660
you the the the the under stir of floats has an algorithm that goes like this. Okay, so

882
02:30:54,660 --> 02:31:00,620
this is the float that we have in the machine. This is its value. But are there other floats

883
02:31:00,620 --> 02:31:09,180
with less digits that result in the same periodic repetition? If yes, then it's going to pick

884
02:31:09,180 --> 02:31:14,620
the shortest string that does that. Does that make sense? So this is something that

885
02:31:14,620 --> 02:31:23,060
was introduced, I think, in Python 3.3. And now if you don't care about revealing this

886
02:31:23,060 --> 02:31:29,900
imprecision, you can always create decimals by converting the float into a string, and

887
02:31:29,900 --> 02:31:36,940
then you have a decimal that looks like what you wanted. Okay? So anyway, this is the trick

888
02:31:36,940 --> 02:31:44,940
that I'm using. Now, when I created this example, I want to tell you that my first idea was,

889
02:31:44,940 --> 02:31:50,700
okay, I wish the decimal class did that for me. When I passed a float that it converted

890
02:31:50,700 --> 02:31:58,100
to string and then did the decimal from the string to lose the error of the float. But

891
02:31:58,100 --> 02:32:02,780
then I actually talked about that on Twitter with some people even with who answered my

892
02:32:02,900 --> 02:32:09,020
questions about that, and they said, no, no, no, the decimal must be utterly precise. So

893
02:32:09,020 --> 02:32:14,860
if you're constructing a decimal from a float which is imprecise, the decimal will be as

894
02:32:14,860 --> 02:32:21,940
imprecise, will be precisely as imprecise as the float that you gave it. All right?

895
02:32:21,940 --> 02:32:27,820
This is how they want it. And I said, okay, I'm going to create a class called newDecimal

896
02:32:27,820 --> 02:32:34,500
that inherits from decimal and that looks at the argument to the constructor and converts

897
02:32:34,500 --> 02:32:41,500
it to a string before, okay? So that was my first idea. And this is another example of

898
02:32:41,500 --> 02:32:48,300
why often inheritance gives you more trouble than it's worth. My first idea was, okay,

899
02:32:48,300 --> 02:32:55,460
I'm going to create a more perfect decimal, the new decimal, okay, as a subclass. The

900
02:32:55,460 --> 02:33:02,100
problem is then I had an init that was like this function here, okay? The init would take

901
02:33:02,100 --> 02:33:07,580
the argument, the value, and see if it's a float, then it would use the wrapper to convert

902
02:33:07,580 --> 02:33:14,580
into a string and then would build, you know? So if I gave it an integer or a string, it

903
02:33:17,340 --> 02:33:21,140
wouldn't do anything with it, but if it was a float, it would convert with this. This

904
02:33:21,140 --> 02:33:28,140
was the logic that was inside my Dunder init. However, it didn't work. My subclass of decimal

905
02:33:28,900 --> 02:33:35,340
with a Dunder init with this logic didn't work. You know why? Because the decimal is

906
02:33:35,340 --> 02:33:42,340
immutable. So when I get the self that was constructed by the Python machinery, the value

907
02:33:42,340 --> 02:33:49,340
is already set. I cannot override that value. So that meant that I had to go under or deeper

908
02:33:55,500 --> 02:34:00,220
and implement another method that we seldom use on a daily basis, which is the Dunder

909
02:34:00,220 --> 02:34:06,700
new method. Dunder new in Python is the actual constructor, the method that builds an object

910
02:34:06,700 --> 02:34:11,420
and returns it. Dunder init doesn't return anything. It just initializes attributes,

911
02:34:11,420 --> 02:34:17,220
right? But then when I created Dunder new, it behaved in a weird way because I needed

912
02:34:17,220 --> 02:34:24,220
to use the decimal to construct the class, the instance. So I had my own class, but when

913
02:34:26,860 --> 02:34:33,860
I instantiated it, the instances were all decimals and not new decimals, which was kind

914
02:34:34,900 --> 02:34:40,660
of weird. So I said, you know what? I don't need inheritance. What I need is a function.

915
02:34:41,060 --> 02:34:48,060
This is an advice. Think hard if a function isn't better than the class that you're thinking

916
02:34:48,060 --> 02:34:55,060
about. Maybe it's all you need, a function. So this is what the new function, the new

917
02:34:57,420 --> 02:35:04,420
decimal function does. So everywhere in this code here, I'm using new decimal to start

918
02:35:04,540 --> 02:35:11,540
the balance. The incomes and expenses are default dicts. Default dicts is a special

919
02:35:12,300 --> 02:35:19,300
subclass of dicts in Python that you pass, when you build a default dict, you give it

920
02:35:19,820 --> 02:35:26,820
a function or a class that is going to be used to create instances when no such instance

921
02:35:27,060 --> 02:35:34,060
exists. What does that mean, for instance? The expenses is a dictionary. But if there

922
02:35:36,180 --> 02:35:43,180
is no travel expenses and I ask for travel expenses, this will immediately create a decimal

923
02:35:44,020 --> 02:35:49,620
and return that to me. This is what the default dict does. So it's a dict that when what you're

924
02:35:49,620 --> 02:35:56,620
looking for doesn't exist, it will create at once that thing and return it to you. So

925
02:35:56,820 --> 02:36:03,820
this is the default dict. This is a default dict that is going to be by default returning

926
02:36:11,300 --> 02:36:17,220
zero decimals. The initial balance is also a decimal because of my new decimal function.

927
02:36:17,220 --> 02:36:24,220
So everything here is in decimals. So this is just an example of doing proper Python

928
02:36:25,220 --> 02:36:32,220
coding using money, which is using decimal instead of floats to avoid those accumulation

929
02:36:32,220 --> 02:36:39,220
errors that happen when people insist on spending fractures of 10, like 0.1. Anyway, yeah, so

930
02:36:48,020 --> 02:36:52,100
the rest of the class is not very interesting. Another thing that I did here is I decided

931
02:36:52,100 --> 02:36:58,860
to have the balance as a property. So this decorator here means that I can read the balance

932
02:36:58,860 --> 02:37:05,860
as if it was a data attribute. And you can see that in the example. That's in the history.

933
02:37:14,260 --> 02:37:21,260
See here, I'm not invoking the balance as a method. There's no parenthesis here. I'm

934
02:37:22,100 --> 02:37:28,980
just reading it. And the way to do that is by declaring something a property. There's

935
02:37:28,980 --> 02:37:35,980
more to properties than this, but I am afraid I don't have time to talk about that. Oh,

936
02:37:38,940 --> 02:37:45,940
sorry, this is another example. So this becomes a read-only property. It's basically a method.

937
02:37:45,940 --> 02:37:52,940
It's a getter. But because it's decorated with a property, I invoke it. I access it

938
02:37:57,380 --> 02:38:04,380
as if it was a data attribute and not a method. I don't use the parenthesis. Okay? Another

939
02:38:05,300 --> 02:38:12,300
thing that is interesting to talk about is that although it is a little bit of work using

940
02:38:12,300 --> 02:38:19,300
decimal, it's less work than it would be in some other languages that don't have operator

941
02:38:22,740 --> 02:38:29,740
overloading. Python has operator overloading, so that means that this works. I don't have

942
02:38:29,900 --> 02:38:36,900
to call a method on the decimal. I just use an operator. In Go, for instance, there's

943
02:38:42,340 --> 02:38:46,340
no operator overloading. In Java, there's no operator overloading. So you wouldn't be

944
02:38:46,340 --> 02:38:53,340
able to use this short notation to add and subtract. You would have to have a method

945
02:38:53,380 --> 02:39:00,380
like dot subtract dot add and so on. Anyway, so I wanted to show an example that is a classic

946
02:39:02,620 --> 02:39:09,100
example, but I also implemented it using decimals, which makes it a little bit more interesting.

947
02:39:09,100 --> 02:39:14,500
And this is also an example of subclassing, because in the book they give an example which

948
02:39:14,500 --> 02:39:21,500
is the deductible history. So the idea is that the data is not a method, but a method

949
02:39:23,340 --> 02:39:30,340
that makes it possible to make a donation. So in this case, in this class, you can do

950
02:39:30,340 --> 02:39:37,340
expenses that are partially or totally deductible. So in this example here, I'm saying that I'm

951
02:39:38,380 --> 02:39:45,380
spending 600 for a course, but the course is I can deduct $150 of that course, of that

952
02:39:45,380 --> 02:39:51,140
course. I can also make a donation, and in this case there's another method called spend

953
02:39:51,140 --> 02:39:58,140
deductible that is to deduct the full amount. And then I can see what are the total deductions,

954
02:40:04,380 --> 02:40:11,380
400, because I spent this course cost 600, but I deducted 150, and this course cost $150,

955
02:40:15,940 --> 02:40:22,940
or this donation was 250, no, yeah, donation 250, so far my deductions are 400. So this

956
02:40:28,300 --> 02:40:35,060
is how it works. It has some different methods that allow you to expand with deductions,

957
02:40:35,060 --> 02:40:42,060
and this is the code. The code is interesting because it shows an example of inheritance,

958
02:40:46,300 --> 02:40:53,300
which requires the use of the super function. So the thing is, when you create a subclass,

959
02:40:59,620 --> 02:41:06,620
you need sometimes to invoke a method of the superclass to do stuff. For instance, my dunder

960
02:41:06,620 --> 02:41:13,620
in it. So a deductible history is basically a financial history with the deductions, and

961
02:41:15,380 --> 02:41:22,380
this extra attribute, it is the deductions, which is just a decimal number, and this spend

962
02:41:28,580 --> 02:41:35,580
method that now has an extra optional argument, and the spend deductible, which is a new method,

963
02:41:35,580 --> 02:41:42,580
and the deductions, which is a new property. So in order to leverage the machinery of

964
02:41:46,820 --> 02:41:53,820
financial history, I have to be explicit about this. For instance, in the initializer, I

965
02:41:53,900 --> 02:41:58,340
invoke the initializer of the superclass. And by the way, this is different from the

966
02:41:58,340 --> 02:42:04,140
way it works in Java. In Java, the constructor automatically invokes the constructor of

967
02:42:04,140 --> 02:42:09,900
the superclass. In Python, you have to be explicit about that. And there's two ways

968
02:42:09,900 --> 02:42:16,900
of being explicit about that. I could write here financial history dot in it, but then

969
02:42:18,380 --> 02:42:25,380
I'm calling the method on the class, and I would have to pass self as an explicit argument,

970
02:42:25,580 --> 02:42:32,580
which is ugly. And also, Python supports multi-point hash, which is a method that is used to pass

971
02:42:34,140 --> 02:42:39,380
inheritance. It doesn't mean it's a good idea, but it does support it. And it can be

972
02:42:39,380 --> 02:42:46,380
used, you know, it's used very judiciously, can be useful. It's not like the example that

973
02:42:47,220 --> 02:42:52,220
I used to have, for instance. I was so ashamed when I found that. So I had a, like remember,

974
02:42:52,220 --> 02:42:59,220
I said I had animals, and there was mammals and dogs, and there's several kinds of dogs,

975
02:42:59,220 --> 02:43:06,220
like Labrador. And then there was the San Bernard. You know the San Bernard? That legend

976
02:43:06,820 --> 02:43:13,820
says in Switzerland they use San Bernard dogs patrolling the roads, and they have like a

977
02:43:15,380 --> 02:43:22,380
little vat of cognac. So my San Bernard, I swear to God, inherited from dog and vat.

978
02:43:22,380 --> 02:43:29,380
That's just stupid, okay? What it should be is a subclass of dog, the San Bernard, that

979
02:43:38,140 --> 02:43:45,140
has a composition that includes this component, which is a vat. Okay? This is what it should

980
02:43:45,620 --> 02:43:51,420
be. Not an example of multiple inheritance. But anyway, I wanted to show it. I don't want

981
02:43:51,420 --> 02:43:58,420
to show it anymore. Multiple inheritance most of the time is bad. But anyway, you never

982
02:43:59,500 --> 02:44:03,620
know, right? Maybe you don't like multiple inheritance, somebody else in your team, somebody

983
02:44:03,620 --> 02:44:09,220
in the future, something happens in the hierarchy that you don't control. Maybe it's a third-party

984
02:44:09,220 --> 02:44:14,920
library that you're subclassing from, and you don't control that code. In order for

985
02:44:14,920 --> 02:44:21,920
your methods to cooperate correctly with a hierarchy that has multiple inheritance,

986
02:44:26,320 --> 02:44:32,360
you have to use super, okay? This is what super does. So the super function is a magical

987
02:44:32,360 --> 02:44:39,360
function that returns a proxy that by default does what it needs to do in order for your

988
02:44:40,360 --> 02:44:47,360
dunder init to resolve up in the hierarchy. So what I'm doing here is my initializer is

989
02:44:49,160 --> 02:44:56,160
delegating the initialization up the chain of inheritance. And by using super, this is

990
02:44:58,040 --> 02:45:05,040
going to work predictably, as predictably as possible, in a multiple inheritance situation,

991
02:45:06,040 --> 02:45:13,040
okay? On the other hand, if I hard-coded the name of the class here, then maybe I could

992
02:45:14,520 --> 02:45:21,520
have problems if it turned out that the hierarchy became a multiple inheritance hierarchy later.

993
02:45:23,720 --> 02:45:30,720
So the syntax improved in Python 3 is still ugly, in my opinion. Calling this function

994
02:45:30,720 --> 02:45:37,720
like this, it returns this proxy object that then you invoke methods on it. But in Python

995
02:45:37,720 --> 02:45:42,920
2, it was worse because you had to pass two parameters here. And now Python is smart enough

996
02:45:42,920 --> 02:45:48,840
to introspect the frame where this is happening in the code and getting that information that

997
02:45:48,840 --> 02:45:55,840
defaults for you, okay? So the dunder init delegates to the hierarchy and then initializes

998
02:45:56,720 --> 02:46:03,720
the deductions, which is this new class, this new instance attribute of my deductible history

999
02:46:04,360 --> 02:46:11,360
class. The spend also uses the same mechanism. The spend calls super spend, so it uses the

1000
02:46:13,920 --> 02:46:20,360
mechanics of the spend and the super class, and then if there was a value deducting, it

1001
02:46:20,360 --> 02:46:27,360
adds to the deductions, okay? So this is an example of a method that is not the initializer,

1002
02:46:29,680 --> 02:46:36,520
but just any other regular method, delegating some of its functionality to the super class.

1003
02:46:36,520 --> 02:46:43,520
And the last example here is an example of one method of the instance delegating to another

1004
02:46:44,520 --> 02:46:51,520
method of the same instance. See? The spend deductible is implemented by calling spend

1005
02:46:52,560 --> 02:46:59,560
repeating the amount here, right? Because the idea of the spend deductible is that it

1006
02:46:59,960 --> 02:47:06,960
records the expense with full deduction. So it just repeats the amount and uses that one.

1007
02:47:07,240 --> 02:47:13,760
So what I want you to notice here is the use of super and self in this delegation. Delegation

1008
02:47:13,760 --> 02:47:20,760
is a fancy word that object-oriented programmers use to say when one object tells the other

1009
02:47:25,960 --> 02:47:32,960
object to do something, right? And in this example here, this is called a self-delegation.

1010
02:47:33,960 --> 02:47:40,960
The object is telling itself to do something, right? And this is a super delegation. Anyway,

1011
02:47:49,000 --> 02:47:56,000
so it's an example of inheritance. However, although it's like I said, it's a classic

1012
02:47:56,000 --> 02:48:03,000
example from a very important book in the history of object-oriented programming, nowadays

1013
02:48:03,000 --> 02:48:10,000
it's not considered an excellent example. Many authors don't recommend anymore to do

1014
02:48:12,920 --> 02:48:18,800
inheritance of concrete classes. Okay? So what we have here is financial history is

1015
02:48:18,800 --> 02:48:24,660
a concrete class that can create instances of it, and the deductible history is another

1016
02:48:24,660 --> 02:48:31,660
concrete class. This creates complications that because both classes have inner states

1017
02:48:36,300 --> 02:48:43,300
so they can step on each other's toes. You may forget to invoke super. It's actually,

1018
02:48:43,780 --> 02:48:50,780
it would be a good exercise to rewrite this just to feel the difference using composition,

1019
02:48:50,780 --> 02:48:57,780
you know? So deductible history is a class that has a financial history inside it. And

1020
02:49:04,960 --> 02:49:11,420
then it wouldn't need to use super anywhere. It wouldn't need to do self-delegation. You

1021
02:49:11,420 --> 02:49:18,420
would write a little bit more code, but it would be clearer, and it would be more flexible.

1022
02:49:19,380 --> 02:49:25,180
The problem with, one of the problems with inheritance of concrete classes is that it's

1023
02:49:25,180 --> 02:49:30,420
a very tight coupling between the subclass and the superclass. And that's something that

1024
02:49:30,420 --> 02:49:37,420
you want to avoid to make systems easier to evolve, this kind of tight coupling. Okay?

1025
02:49:38,620 --> 02:49:44,520
But I needed to show you this because I needed to show examples of super. When you notice,

1026
02:49:44,520 --> 02:49:51,520
when you are inheriting from an abstract class, you don't have these problems because

1027
02:49:52,720 --> 02:49:59,720
there's no implementation for you to leverage. You need to implement everything mostly. This

1028
02:49:59,720 --> 02:50:05,720
happens really when you're, the need of super appears when you're doing inheritance from

1029
02:50:05,720 --> 02:50:12,720
concrete, from one concrete class to another. So, you know, super is a class that has a

1030
02:50:15,220 --> 02:50:22,220
super. Okay. So, this was, okay, this is the inheritance, the classic example. We've seen

1031
02:50:24,160 --> 02:50:31,160
that. Okay. Another, so this is a series of examples that talk about different ways of

1032
02:50:34,720 --> 02:50:41,720
doing inheritance. Right? So, each of them will lead you to a part in the examples over

1033
02:50:42,720 --> 02:50:49,720
there. So, the bingo, bingo is a very simple class that emulates a bingo cage. So, the

1034
02:50:52,760 --> 02:50:59,760
idea is you fill it with balls, this cage, and then you call pop and it gives out a random

1035
02:51:01,760 --> 02:51:08,760
ball. Right? So, that's the mechanics of the bingo cage. You put a sequence of balls,

1036
02:51:11,720 --> 02:51:18,720
or a collection of items in it, and it's, each time you call pop, it will give you one

1037
02:51:18,800 --> 02:51:25,640
of those items picked at random. There's also a dunderland so that you can ask how many

1038
02:51:25,640 --> 02:51:32,640
items are in the cage, which also allows you, because the bool, the bool built-in function

1039
02:51:32,640 --> 02:51:39,640
of Python uses as a fallback dunderland to determine whether something is true or false.

1040
02:51:44,120 --> 02:51:51,120
So you can do this code. While cage, print next item, else no more items available. So

1041
02:51:52,800 --> 02:51:59,800
this will be, this will be a loop that will repeat until the cage is exhausted. Okay?

1042
02:52:00,800 --> 02:52:07,800
Anyway, the implementation of this is super simple, but, where is it? Yeah, this is it.

1043
02:52:21,840 --> 02:52:28,840
I use that trick that I told you about before, which is making a list, because I'm going

1044
02:52:29,800 --> 02:52:35,640
to, otherwise, every time I do pop, I'm going to be throwing away something that belongs

1045
02:52:35,640 --> 02:52:42,640
to my user. So this is a very simple implementation. Now the fun part of this is with the other

1046
02:52:45,160 --> 02:52:52,160
examples here. The other examples here, which are in the tombola directory. So tombola is

1047
02:52:52,960 --> 02:52:59,960
an Italian or Portuguese word, which is a synonym of bingo. And this directory here,

1048
02:53:02,760 --> 02:53:09,760
tombola, has several implementations of different bingo machines, and it has a single test suite

1049
02:53:14,680 --> 02:53:20,360
that works for all of them to prove that they're all, that they all behave the same, even though

1050
02:53:20,360 --> 02:53:27,360
the implementations are very different. And this tombola.py is the ABC. So this is how

1051
02:53:27,400 --> 02:53:33,840
you declare an interface in Python. If you want to formalize an interface in Python,

1052
02:53:33,840 --> 02:53:40,840
what you do is you, you import ABC and the ABC package, there is an ABC, uppercase ABC

1053
02:53:40,840 --> 02:53:47,840
class, which when you inherit from it, it means that your class is an abstract class.

1054
02:53:49,600 --> 02:53:56,600
And in an abstract class, you can use these decorators, ABC abstract method, to say that

1055
02:53:58,240 --> 02:54:05,240
you expect the subclasses to implement that. Okay? So this is the, this is the, this is

1056
02:54:05,240 --> 02:54:12,240
the, that you expect the subclasses to implement that. Okay? So I'm saying here that a tombola

1057
02:54:14,480 --> 02:54:21,480
machine has to have a load, a pick, and a loaded, and an inspect module, methods. The

1058
02:54:22,960 --> 02:54:29,960
interesting thing here is that load and pick are abstract methods, so they only have a

1059
02:54:30,520 --> 02:54:37,520
doc string, there's no body, but the loaded and the inspect are concrete methods. So this

1060
02:54:42,280 --> 02:54:49,280
is something that Python allows you to do. An abstract class can have concrete methods

1061
02:54:50,200 --> 02:54:57,200
as long as they depend only on the abstract methods, because then the subclasses will

1062
02:54:57,200 --> 02:55:02,200
complement the abstract methods and the concrete methods from the abstract class will be able

1063
02:55:02,200 --> 02:55:09,200
to leverage them. So, for instance, the loaded, which should tell you whether there is at

1064
02:55:11,840 --> 02:55:18,840
least one item or not, will call inspect and convert the result into a Boolean. The inspect,

1065
02:55:19,840 --> 02:55:26,840
this is very strange, okay, but I was just, my idea was to illustrate a concrete method

1066
02:55:30,560 --> 02:55:37,560
in an abstract class. So the inspect returns a sorted tuple with the items currently inside,

1067
02:55:39,080 --> 02:55:43,440
but I can only, I cannot look at the implementation, right? I don't know what the implementation

1068
02:55:43,440 --> 02:55:49,040
is. This is an abstract class. What I know for sure is that the implementation will have

1069
02:55:49,040 --> 02:55:56,040
a pick method, right? And the pick method will raise lookup error when the instance

1070
02:56:04,680 --> 02:56:10,440
is empty. This is written in the documentation. It's the contract. It's in English, not in

1071
02:56:10,640 --> 02:56:17,640
Python, okay? Anyway, so my inspect relies on that. So what it does is it creates a list

1072
02:56:18,880 --> 02:56:24,680
called items and then goes into this loop where it's calling pick and append into the

1073
02:56:24,680 --> 02:56:31,680
list until it gets a lookup error, then it breaks, and now it has emptied the machine.

1074
02:56:32,480 --> 02:56:39,480
And now it loads it again with the items and returns the tuple of the items, okay? So the

1075
02:56:43,160 --> 02:56:50,160
way that inspect works, since it's limited to rely on the abstract method, is by invoking

1076
02:56:53,000 --> 02:56:59,080
pick until it exhausts everything and then puts it in, it loads back the things in the

1077
02:56:59,080 --> 02:57:06,080
machine, right? So that's how it works. So this is an abstract class. And here there

1078
02:57:08,160 --> 02:57:15,160
are other examples that I use it, where I use it, okay? So the lotto, for instance,

1079
02:57:18,600 --> 02:57:25,600
is a lottery blower inherits from Tombola, I initialize load and pick, and I have a better

1080
02:57:26,600 --> 02:57:31,760
implementation of load and inspect, okay? Because I know the implementation, so I can

1081
02:57:31,760 --> 02:57:38,760
override these methods with a better implementation. But you can also have something like the drum

1082
02:57:40,440 --> 02:57:45,080
implementation which just implements load and pick, and it doesn't have the inspect

1083
02:57:45,080 --> 02:57:52,080
and so on, but it will inherit from the Tombola. Anyway, all of these examples, if you look

1084
02:57:52,600 --> 02:57:59,360
at them later, you will see that they have very different implementations, but they work

1085
02:57:59,360 --> 02:58:06,120
the same. But one interesting example, I think the most interesting example is this one here,

1086
02:58:06,120 --> 02:58:13,120
TomboList. So TomboList is interesting because it, let me hide that line for a moment, it

1087
02:58:14,000 --> 02:58:21,000
inherits from list, okay? Not a very good idea. All the others use lists inside with

1088
02:58:21,000 --> 02:58:27,760
composition, okay? But I wanted to show that it's also possible to create a device like

1089
02:58:27,760 --> 02:58:34,760
that that inherits from lists, so it uses self-pop because it inherits the pop method

1090
02:58:35,120 --> 02:58:42,120
from lists and so on. But the interesting thing is, okay, so if I inherit it from lists,

1091
02:58:43,520 --> 02:58:49,320
how do I tell people that this is actually a TomboList? And the way to do it is because

1092
02:58:49,320 --> 02:58:56,320
TomboList is an abstract class, I can call, I can use it, abstract classes in Python have

1093
02:58:59,280 --> 02:59:06,280
a function called .register, which when you use as a decorator, it registers this list

1094
02:59:10,560 --> 02:59:17,560
as a subclass of that class even though it doesn't inherit from it. This is what is called

1095
02:59:18,200 --> 02:59:24,960
a virtual subclass, okay? So a virtual subclass is a class that doesn't really inherit from

1096
02:59:24,960 --> 02:59:31,960
the other one, but you declare that it works like that one, that it fulfills that interface,

1097
02:59:36,320 --> 02:59:43,320
okay? Does that make sense, people? Yeah? So this is an option that you have, and you

1098
02:59:43,880 --> 02:59:50,880
can even do that with third-party codes because there's this other syntax here. You know,

1099
02:59:51,160 --> 02:59:56,600
if I imported something from somebody else's module and I want to say, okay, this thing

1100
02:59:56,600 --> 03:00:02,040
that somebody else implemented actually implemented this interface that I need to make, and I

1101
03:00:02,040 --> 03:00:09,040
need to make this fact explicit so I can call my abc.register, the other person's class,

1102
03:00:10,040 --> 03:00:17,040
and it's, what I'm doing here is I'm telling Python, trust me, this thing works like that

1103
03:00:18,160 --> 03:00:25,160
thing. It works as if it was a subclass of that thing, okay? But now when I do that,

1104
03:00:27,600 --> 03:00:34,600
there's no inheritance involved, so I really need to implement everything, even the concrete

1105
03:00:35,360 --> 03:00:42,360
methods that the other classes are inheriting. Okay, so this set of examples have to do with

1106
03:00:43,920 --> 03:00:50,920
inheriting from an abc. So this is what I was showing, variations on a bingo machine,

1107
03:00:50,920 --> 03:00:57,920
different examples that implement the same interface via different means, okay?

1108
03:01:04,920 --> 03:01:11,920
All right, so what are the takeaways of this section? The takeaways are, you know, you

1109
03:01:11,920 --> 03:01:18,920
know, I was kind of saying that inheritance has a bad reputation, but in fact, one of

1110
03:01:18,920 --> 03:01:25,920
the things, I found a quote by Alan Kay when I was writing my book, but I forgot to put

1111
03:01:25,920 --> 03:01:32,920
it here, but one of the things that Alan Kay says is that they think, that he thinks

1112
03:01:33,280 --> 03:01:40,280
inheritance was a mistake because it does too many things at once, right? So I'm saying

1113
03:01:40,280 --> 03:01:47,280
that inheritance has a bad reputation, but in fact, one of the things, I found a quote

1114
03:01:47,280 --> 03:01:53,600
by Alan Kay says is that he thinks inheritance was a mistake because it does too many things

1115
03:01:53,600 --> 03:02:00,600
at once, right? And there's a book that I'm going to show you in the next section called

1116
03:02:04,480 --> 03:02:09,200
Introduction to Object-Oriented Programming by Tim Budd. I have a picture of it in the

1117
03:02:09,200 --> 03:02:16,200
next section. So in that book, the author actually lists ten reasons why you would inherit,

1118
03:02:17,200 --> 03:02:24,200
or why people inherit stuff. One of the reasons is classification, you know, like I was saying

1119
03:02:26,200 --> 03:02:33,080
before, like hierarchies that look like taxonomies. This is considered wrong in most situations

1120
03:02:33,080 --> 03:02:40,080
these days. So the author lists ten reasons for why people inherit stuff, or why people

1121
03:02:41,080 --> 03:02:48,080
subclass. But the two main reasons that many authors talk about are interface inheritance

1122
03:02:50,600 --> 03:02:57,600
and implementation inheritance. So the idea is, are you inheriting because you want to

1123
03:03:00,080 --> 03:03:07,080
say that this fulfills that interface, or are you inheriting because you want to leverage

1124
03:03:08,080 --> 03:03:14,160
the implementation of the other thing and do your own stuff. Java has this very clear,

1125
03:03:14,160 --> 03:03:21,160
this distinction very clear, right? When you say extends or implements, right? So extends

1126
03:03:21,480 --> 03:03:28,480
means implementation inheritance, and implements means interface inheritance, right? However,

1127
03:03:29,480 --> 03:03:36,480
C++ and Python don't have this distinction very clear, and a lot of times when you inherit,

1128
03:03:37,520 --> 03:03:44,040
you're inheriting. And here's the thing, when you're doing implementation inheritance,

1129
03:03:44,040 --> 03:03:49,040
even though you're maybe just interested in the implementation, you're also inheriting

1130
03:03:49,040 --> 03:03:56,040
the interface, right? And maybe that's not what you want, but that's what you want. So

1131
03:03:59,440 --> 03:04:05,640
that is what you're going to get. So a classic example that people talk about is where squares,

1132
03:04:05,640 --> 03:04:12,640
a square class should inherit from rectangle or vice versa. And if I, one way to think

1133
03:04:18,800 --> 03:04:24,120
about it is that the square is simpler than the rectangle. So if I'm thinking about implementation,

1134
03:04:24,120 --> 03:04:31,120
I don't want my millions of squares to have the overhead of rectangles when they are simpler.

1135
03:04:33,840 --> 03:04:40,840
They have only ones with its attributes, right? But on the other hand, you can say that okay,

1136
03:04:46,680 --> 03:04:53,680
but all squares are rectangles. But if I do that, that also means that maybe there are

1137
03:04:53,680 --> 03:04:58,440
methods in rectangle that I'm inheriting and that I shouldn't. For instance, maybe

1138
03:04:58,440 --> 03:05:05,200
I have a stretch method that doubles the width without increasing the height of the rectangle,

1139
03:05:05,200 --> 03:05:11,760
and that would not make sense in the square. But if I inherit, I will inherit that too.

1140
03:05:11,760 --> 03:05:17,640
So what do I do with it? Oh, okay, so you can implement it and raise an exception. You

1141
03:05:17,640 --> 03:05:23,640
cannot stretch it, right? So it's a complicated situation, but you have to be, it's a very

1142
03:05:24,000 --> 03:05:29,360
simple problem. This is an important thing. This is a hint. I don't, if this is new to

1143
03:05:29,360 --> 03:05:35,400
you guys or to some of you, I put it here because I think it's something that you need

1144
03:05:35,400 --> 03:05:41,280
to pay attention and go after and understand. But it's important to understand the difference

1145
03:05:41,280 --> 03:05:46,920
between interface inheritance and implementation inheritance because the bad things that I

1146
03:05:46,920 --> 03:05:52,640
said about inheritance are mostly about implementation inheritance. Interface inheritance is not

1147
03:05:52,680 --> 03:05:59,680
a big problem. So Python actually has, for instance, a huge... So this here doesn't look

1148
03:06:13,680 --> 03:06:18,000
like a hierarchy, but it is because you can see that it says here, this inherits from

1149
03:06:18,000 --> 03:06:25,000
that and so on. So this is a diagram of abstract classes that the Python library brings. So

1150
03:06:28,000 --> 03:06:35,000
for instance, you can see that a sequence inherits from revertible and collection,

1151
03:06:38,600 --> 03:06:44,640
collection inherits from size and container. This is actually examples also of multiple

1152
03:06:44,640 --> 03:06:51,360
inheritance. But multiple inheritance is usually not a problem when you're doing interface

1153
03:06:51,360 --> 03:06:57,320
inheritance. And in fact, Java allows it, right? You can implement lots of interfaces,

1154
03:06:57,320 --> 03:07:04,320
but you can only extend one implementation. And then you have a mutable sequence which

1155
03:07:04,320 --> 03:07:11,320
inherits from sequence, sequence C. So this is a tree of collections in Python that is

1156
03:07:22,760 --> 03:07:29,760
useful to study to understand what is available and how the collections in Python are organized.

1157
03:07:30,480 --> 03:07:37,480
So the point is that... And like I said, for instance, when I mentioned Julia before, the

1158
03:07:39,280 --> 03:07:46,280
Julia language allows interface inheritance arbitrarily deep, but it doesn't allow implementation

1159
03:07:49,200 --> 03:07:56,200
inheritance. You cannot subclass concrete classes in Julia. Yeah, I already said that. I've

1160
03:07:56,200 --> 03:08:03,200
already inherited from concrete classes. Oh, here's the thing. Butynes, I put one example

1161
03:08:08,960 --> 03:08:15,960
here where I implemented TomboList as a subclass of list. Okay? This example works because

1162
03:08:16,960 --> 03:08:23,960
the things that I do with the list are not complicated. But there is a problem that the

1163
03:08:34,880 --> 03:08:41,280
built-in objects in Python which are written in C, they don't always call... When you subclass

1164
03:08:41,480 --> 03:08:48,480
one of those, they don't always call your methods as they should. In terms of the C++

1165
03:08:48,480 --> 03:08:55,480
world is what they call their... The implementations in C of these objects have non-virtual methods

1166
03:08:57,440 --> 03:09:02,680
which are hard-coded to do something. So one example of this is, for instance, let's say

1167
03:09:02,680 --> 03:09:09,680
I have... I want to create a list that only allows numbers in the list. Okay? So what

1168
03:09:11,280 --> 03:09:18,280
I'm going to do is I'm going to override the method append to make sure that whatever

1169
03:09:20,440 --> 03:09:27,440
is being appended is a number. And I also want to override the dunder set item which

1170
03:09:28,640 --> 03:09:33,840
is the one that when I assign to a position using square brackets, it's also going to

1171
03:09:33,840 --> 03:09:40,840
do that. But then there's a method called extend, right? Which you call to... You can

1172
03:09:41,880 --> 03:09:48,880
append a bunch of items at once. And if you think you can rely on the C implementation

1173
03:09:52,440 --> 03:09:58,560
to call your own append repeatedly in the extend implementation, it's not going to do

1174
03:09:58,560 --> 03:10:05,560
that. Right? So this is a tricky thing. And that's why in the collections page that I

1175
03:10:06,240 --> 03:10:13,240
just was showing to you, there is a user list, a user string, and a user dict class. These

1176
03:10:17,160 --> 03:10:23,080
are the ones that you should subclass if you want to have your own custom list, your own

1177
03:10:23,080 --> 03:10:30,080
custom dict or your own custom string. Okay? And it's interesting if you take a look at

1178
03:10:30,080 --> 03:10:37,080
the code of these classes, they are done with composition. So the user dict actually

1179
03:10:37,080 --> 03:10:43,480
has a real dict inside of it. But it implements all the methods to do delegation and so it

1180
03:10:43,480 --> 03:10:50,480
makes sure that everything goes through those methods that are written in Python. And that

1181
03:10:54,040 --> 03:10:58,280
advice from the Gang of Four that I already mentioned, favor object composition over class

1182
03:10:58,760 --> 03:11:05,760
inheritance. And we got a sign that we have five minutes and that's good because now we

1183
03:11:06,160 --> 03:11:13,160
can go to the big ideas. All right. So big ideas. So I had a lot of fun going back to

1184
03:11:17,840 --> 03:11:24,840
the origins of these ideas to give... To think about an introduction to this subject and

1185
03:11:28,280 --> 03:11:35,280
so one of the things that I found was an email from Alan Kay who was the leader of

1186
03:11:39,360 --> 03:11:46,360
the project that created Smalltalk. This guy, Stefan Ram, asked him, what does object-oriented

1187
03:11:49,560 --> 03:11:56,560
programming mean to you? And he says, OOP to me means only messaging, local retention,

1188
03:11:56,960 --> 03:12:03,960
and protection, and hiding of state process, and extreme late binding of all things. It

1189
03:12:04,360 --> 03:12:09,360
can be done in Smalltalk and Lisp. There are possibly other systems in which this is possible,

1190
03:12:09,360 --> 03:12:16,360
but I'm not aware of them. So it's interesting because inheritance is not here. Messaging

1191
03:12:17,360 --> 03:12:24,360
is basically method calls. And there's another... Local retention and protection of health and

1192
03:12:25,360 --> 03:12:32,360
hiding of state processes, encapsulation. Right? Extreme late binding is doing that

1193
03:12:34,160 --> 03:12:41,160
thing that I just told you that the Python built-ins don't do correctly, which is to

1194
03:12:41,160 --> 03:12:48,160
respect the inheritance hierarchy when method delegates to the other and go to the proper

1195
03:12:58,160 --> 03:13:03,920
level in the inheritance hierarchy to resolve that. This is what is called late binding.

1196
03:13:03,920 --> 03:13:10,920
The problem with the implementation of Lists and Gicton string in Python is that it's

1197
03:13:12,160 --> 03:13:19,160
early binding, so some of the methods in there are hard-coded to delegate to others in C.

1198
03:13:23,840 --> 03:13:30,840
Another thing that I found is a message by... Oh, recently there was an interview, very

1199
03:13:33,480 --> 03:13:40,480
interesting interview with... I don't know if you remember, but I was in a meeting with

1200
03:13:41,720 --> 03:13:48,720
Joe Armstrong, the inventor of Erlang, died last week. And Erlang is a language that is

1201
03:13:49,520 --> 03:13:54,400
totally based... It's not an object-oriented language, but it's totally based on the idea

1202
03:13:54,400 --> 03:14:01,400
of multiple processes talking and exchanging messages. So although it's a functional programming

1203
03:14:01,560 --> 03:14:08,560
language, it goes closer to the core idea of what Alan Kay now defines as object-oriented

1204
03:14:09,560 --> 03:14:16,560
than Python and Java and so on. There was an interview that was great. Joe Armstrong

1205
03:14:18,040 --> 03:14:25,040
interviewed Alan Kay. I really recommend that you look it up on YouTube. And the last thing

1206
03:14:28,320 --> 03:14:33,000
that I wanted to share with you that was a result of this research that I was doing,

1207
03:14:33,000 --> 03:14:40,000
I already have a bunch, I have like, I don't know, two yards of object-oriented programming

1208
03:14:40,800 --> 03:14:47,800
books in my office that I bought over the last 30 years. But this one is a new one for

1209
03:14:49,040 --> 03:14:55,000
me. It's not new, it's from 2003, but it's super interesting. I don't know why I never

1210
03:14:55,000 --> 03:15:02,000
stumbled on it. So it's called An Introduction to Object-Oriented Programming by this professor

1211
03:15:02,600 --> 03:15:09,600
Timothy Budd, who teaches at, I think, Oregon State. And what is great about this book is

1212
03:15:16,800 --> 03:15:22,600
it's the only book that covers general topics in object-oriented programming with a very

1213
03:15:22,600 --> 03:15:29,600
good depth and that does it with several languages. It's not focused on a single language. The

1214
03:15:30,600 --> 03:15:37,600
book actually has examples in all of these languages. So it's really interesting to really

1215
03:15:40,800 --> 03:15:47,240
understand object-oriented programming, the paradigm in general, as opposed to particulars

1216
03:15:47,240 --> 03:15:53,160
of this or that implementation. And one of the great things, I want to finish with this,

1217
03:15:53,160 --> 03:15:58,720
one of the great things about this book is that I found a super elegant solution to the

1218
03:15:58,720 --> 03:16:05,720
eight queens problem, which is a classic problem that Dykstra created to demonstrate

1219
03:16:06,360 --> 03:16:13,200
backtracking. He didn't create it. The problem existed since the 19th century. The idea of

1220
03:16:13,200 --> 03:16:18,280
how do you place eight queens on a chessboard so that none of them attacks each other. And

1221
03:16:18,280 --> 03:16:22,080
that's super hard to do, actually. If you want to try it, I recommend starting with

1222
03:16:22,080 --> 03:16:27,920
four. There's no solution for two or three. With four, there's basically one solution.

1223
03:16:27,920 --> 03:16:34,920
And you can find it in a few minutes. With eight, I don't know. If you're serving time,

1224
03:16:37,760 --> 03:16:44,760
that may be a good pastime because it's... Anyway, but what is beautiful about this solution

1225
03:16:47,080 --> 03:16:51,960
is because when I thought about it, okay, so object-oriented eight queens, how would

1226
03:16:51,960 --> 03:16:58,960
I think about that? And the way I would do is, okay, so I'm going to have objects that

1227
03:17:00,160 --> 03:17:05,200
represent the queens, and then there's an object called the player that is going to

1228
03:17:05,200 --> 03:17:12,200
move the queens. And then I implement Dykstra's algorithm in the head, so to speak, of this

1229
03:17:12,200 --> 03:17:18,000
player, right? Well, this is an anti-pattern of object-oriented programming called, you

1230
03:17:18,240 --> 03:17:24,840
know what it's called? The God class. It's when all the logic of a system resides in

1231
03:17:24,840 --> 03:17:31,840
a class that just moves the others as pawns. So the nice solution of this, the nice idea

1232
03:17:38,640 --> 03:17:44,660
of this example, and I wanted to show you this because this is an example that for me

1233
03:17:44,660 --> 03:17:51,660
really summarizes what object-oriented is all about, is that you have this queen class,

1234
03:17:52,020 --> 03:17:59,020
okay? There's a problem with the... So the queens, the idea is that the queens communicate,

1235
03:18:01,020 --> 03:18:08,020
so each queen will collaborate with a neighbor, and this will work recursively. So this is

1236
03:18:14,660 --> 03:18:20,200
a solution. So when the last queen found a solution, that means that everybody else

1237
03:18:20,200 --> 03:18:27,200
found solutions as well. The first piece of the solution, the first queen in one of the

1238
03:18:29,060 --> 03:18:34,420
implementations here has a lot of ifs, because, oh no, if I am on the edge of the... I don't

1239
03:18:34,420 --> 03:18:40,220
have, you know, if my neighbor is none or whatever, this kind of thing. But this solution

1240
03:18:40,220 --> 03:18:47,220
here has a special piece called the guard, and if you look at the API of the queen, it

1241
03:18:47,660 --> 03:18:54,660
has can attack, advance, find solution, locate. The guard has three of those methods implemented,

1242
03:18:57,780 --> 03:19:04,780
and for advance it always returns false, meaning I can't advance. Can attack false, meaning

1243
03:19:04,940 --> 03:19:11,940
I can't attack, and locate, meaning this would be to return a list of the positions of everybody

1244
03:19:13,420 --> 03:19:20,420
else, but I'm the... like the sentinel, so they start with an empty list. And the queens,

1245
03:19:25,360 --> 03:19:32,360
so for instance, when a queen... the queens are in a position, each in a row, and they

1246
03:19:32,360 --> 03:19:37,520
move until they find a place where they cannot be attacked. If they can't find a place where

1247
03:19:37,520 --> 03:19:43,600
they cannot be attacked, then they will ask the neighbor to move again. So this is basically

1248
03:19:43,600 --> 03:19:50,600
how it works. And the main program is this. So it creates a guard, this is the figure,

1249
03:19:50,940 --> 03:19:57,940
and then for each row of the board it creates a queen passing the number of columns so it

1250
03:19:58,940 --> 03:20:05,940
knows how to move, the number of the queen, and the figure, which initially is the guard,

1251
03:20:07,180 --> 03:20:12,780
but in the next iteration is going to be another queen. And then so it creates a queen and

1252
03:20:12,780 --> 03:20:18,580
asks the queen to find a solution. If any of them at this stage say not found, that

1253
03:20:18,580 --> 03:20:23,140
means there's no solution. The first one is easy, right? The first one anywhere that it

1254
03:20:23,140 --> 03:20:29,820
rests, it's okay. The second one, the first position will be attacked by the first one,

1255
03:20:29,820 --> 03:20:34,460
second position also, third position, no, it's fine, okay. So it rests there. And the

1256
03:20:34,460 --> 03:20:39,860
third one and so on. So the great thing about this is an example is that it goes back to

1257
03:20:39,860 --> 03:20:46,860
the idea of another of the visions of Alan Kay was that an object-oriented system is

1258
03:20:46,860 --> 03:20:53,860
an autonomous system, is a system of autonomous objects, sort of like cells in the body. Each

1259
03:20:55,420 --> 03:21:02,420
one, each cell goes about doing its own thing, but they also collaborate. And the solution

1260
03:21:02,620 --> 03:21:09,180
of the problem is, it's difficult to understand the algorithm, but it's elegant because it's

1261
03:21:09,180 --> 03:21:14,700
very object-oriented in this sense that the queens collaborate to find the solution and

1262
03:21:14,780 --> 03:21:21,780
there's no god class. Anyway, so this was a great finding when I was doing research

1263
03:21:22,980 --> 03:21:29,980
for this workshop to discover this book. I learned a lot reading it. And this is basically

1264
03:21:32,140 --> 03:21:39,140
it. And if you can please fill the survey, we will be very happy. And I'll be around

1265
03:21:39,140 --> 03:21:46,140
the next days. I also have cards here if you want to contact me. I do have, there was

1266
03:21:52,500 --> 03:21:57,500
another lab that we didn't have time to do. If you want to do the lab as homework, you

1267
03:21:57,500 --> 03:22:04,500
can write to me. There's my email here. And I will help you do your homework if you want.

1268
03:22:04,500 --> 03:22:06,380
And that's it. Thank you very much, folks.

