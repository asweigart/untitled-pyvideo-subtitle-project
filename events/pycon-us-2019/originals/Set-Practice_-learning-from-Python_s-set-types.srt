1
00:00:00,000 --> 00:00:01,800
Good morning, everyone.

2
00:00:01,800 --> 00:00:02,960
Please be seated.

3
00:00:02,960 --> 00:00:05,640
Our first talk is just about to start.

4
00:00:05,640 --> 00:00:09,760
So our first speaker today is Luciano Hamaleo,

5
00:00:09,760 --> 00:00:12,800
and he is going to be talking about sets.

6
00:00:12,800 --> 00:00:16,800
The talk is titled Set Practice, Learning from Python Set Types.

7
00:00:16,800 --> 00:00:21,240
So please give a warm PyCon welcome to Luciano.

8
00:00:21,440 --> 00:00:23,880
So thank you very much, everyone.

9
00:00:23,880 --> 00:00:26,840
Thank you very much, Maras and the PyCon organizers.

10
00:00:26,840 --> 00:00:27,920
I love this conference.

11
00:00:27,920 --> 00:00:31,720
I've made many friends over the years here.

12
00:00:31,720 --> 00:00:34,240
So I am Luciano Hamaleo.

13
00:00:34,240 --> 00:00:36,360
I am a principal consultant at Thoughtworks,

14
00:00:36,360 --> 00:00:38,480
a company that has offices around the world.

15
00:00:38,480 --> 00:00:41,040
It's an American company that has offices in many countries.

16
00:00:41,040 --> 00:00:43,480
And I'm a co-founder of the PyCon.

17
00:00:43,480 --> 00:00:44,880
I'm a co-founder of the PyCon.

18
00:00:44,880 --> 00:00:46,320
I'm a co-founder of the PyCon.

19
00:00:46,320 --> 00:00:47,680
I'm a co-founder of the PyCon.

20
00:00:47,680 --> 00:00:49,040
I'm a co-founder of the PyCon.

21
00:00:49,120 --> 00:00:51,560
I'm a co-founder of the PyCon, a company that has offices

22
00:00:51,560 --> 00:00:52,480
in many countries.

23
00:00:52,480 --> 00:00:54,040
And I live in Brazil.

24
00:00:54,040 --> 00:00:56,120
And I work in their Sao Paulo office.

25
00:00:56,120 --> 00:01:04,200
So I am better known in the Python community these days

26
00:01:04,200 --> 00:01:06,800
because I wrote fluent Python.

27
00:01:06,800 --> 00:01:09,200
And that's the Chinese edition that I learned

28
00:01:09,200 --> 00:01:10,800
only a couple months ago.

29
00:01:10,800 --> 00:01:14,520
Has already sold 30,000 copies in mainland China.

30
00:01:14,520 --> 00:01:18,000
And there's another Chinese edition in Taiwan

31
00:01:18,000 --> 00:01:19,000
where it's available.

32
00:01:19,000 --> 00:01:21,960
So I'm really happy that the book is a success

33
00:01:21,960 --> 00:01:23,480
and people like it.

34
00:01:23,480 --> 00:01:28,080
And I want to tell you that I'm working on the second edition.

35
00:01:28,080 --> 00:01:30,720
I signed the contract with O'Reilly to do that.

36
00:01:30,720 --> 00:01:36,040
And my goal is to get it finished as soon as possible

37
00:01:36,040 --> 00:01:38,560
after Python 3.8 is released.

38
00:01:38,560 --> 00:01:42,480
The Python 3.8 release is scheduled for October.

39
00:01:42,480 --> 00:01:45,600
And so my idea is to get done by October, November,

40
00:01:45,600 --> 00:01:46,400
something like that.

41
00:01:46,400 --> 00:01:49,560
And then O'Reilly needs probably three months

42
00:01:49,560 --> 00:01:51,680
to finish the post-production.

43
00:01:51,680 --> 00:01:54,000
So the book will be available early next year

44
00:01:54,000 --> 00:01:55,560
in the first quarter.

45
00:01:55,560 --> 00:01:57,400
OK?

46
00:01:57,400 --> 00:02:00,040
So let's get started.

47
00:02:00,040 --> 00:02:05,120
So this talk is broadly divided in four parts.

48
00:02:05,120 --> 00:02:08,080
The first part is motivation.

49
00:02:08,080 --> 00:02:12,000
That is, why should you care about sets at all?

50
00:02:12,000 --> 00:02:18,320
I'm going to talk about how sets work in Python,

51
00:02:18,320 --> 00:02:22,360
meaning how you use them from a user perspective.

52
00:02:22,360 --> 00:02:24,520
Then we're going to discuss a little bit of some

53
00:02:24,520 --> 00:02:28,320
of the ideas of the set API, which can inspire you

54
00:02:28,320 --> 00:02:31,120
when you do your own APIs.

55
00:02:31,120 --> 00:02:37,160
And I'm going to talk a little bit about the Dunder methods,

56
00:02:37,160 --> 00:02:41,040
the magic methods that make the sets work.

57
00:02:41,040 --> 00:02:43,520
And I'm going to do that by showing the source code

58
00:02:43,520 --> 00:02:49,760
for a completely different implementation of sets

59
00:02:49,760 --> 00:02:53,520
that I've developed, that although the implementation is

60
00:02:53,520 --> 00:02:57,280
radically different from the one that Python has,

61
00:02:57,280 --> 00:02:59,560
it fulfills the same contract.

62
00:02:59,560 --> 00:03:01,440
So it fulfills the same API and can

63
00:03:01,440 --> 00:03:05,320
be used in place of other sets.

64
00:03:05,320 --> 00:03:08,480
All right, so about motivation.

65
00:03:08,480 --> 00:03:15,360
We often need to work on stories that are like this,

66
00:03:15,360 --> 00:03:15,880
for instance.

67
00:03:15,880 --> 00:03:18,800
Display product if all words in the query

68
00:03:18,800 --> 00:03:21,000
appear in the product description.

69
00:03:21,000 --> 00:03:22,000
OK?

70
00:03:22,000 --> 00:03:26,200
So another language that I've been studying and using

71
00:03:26,200 --> 00:03:28,440
recently has been Go.

72
00:03:28,440 --> 00:03:31,120
And Go doesn't have sets as built-ins.

73
00:03:31,120 --> 00:03:35,000
So I had to write code like this.

74
00:03:35,000 --> 00:03:39,200
You know, if you look at the, it's not a lot of lines,

75
00:03:39,200 --> 00:03:41,960
but the cyclomatic complexity of this code

76
00:03:41,960 --> 00:03:44,160
is pretty high because there's two nested loops,

77
00:03:44,160 --> 00:03:45,440
and then there's an if in there.

78
00:03:45,440 --> 00:03:47,080
There's two ifs.

79
00:03:47,080 --> 00:03:57,920
And notice that, so there is a found flag that

80
00:03:57,920 --> 00:04:00,000
breaks from the inner loop.

81
00:04:00,000 --> 00:04:01,960
And then there's the not found flag

82
00:04:01,960 --> 00:04:04,160
that breaks from the outer loop.

83
00:04:04,200 --> 00:04:08,240
So it's kind of tricky to write this.

84
00:04:08,240 --> 00:04:11,800
It can be better if you split it into different functions.

85
00:04:14,520 --> 00:04:19,880
But the thing is, step back and look at that.

86
00:04:19,880 --> 00:04:20,680
You know?

87
00:04:20,680 --> 00:04:23,120
What if, and then the guy says, later I'm

88
00:04:23,120 --> 00:04:25,800
too busy coding nested loops.

89
00:04:25,800 --> 00:04:29,560
The thing is, you can look at this as a set operation.

90
00:04:29,560 --> 00:04:32,920
So you have a set of words that describe the product

91
00:04:32,960 --> 00:04:35,560
and a set of query of words that are in the query.

92
00:04:35,560 --> 00:04:38,840
So in this case, the query is coffee grinder,

93
00:04:38,840 --> 00:04:43,160
and the description says manual stainless steel coffee grinder.

94
00:04:43,160 --> 00:04:46,960
And so this is basically asking whether the query is

95
00:04:46,960 --> 00:04:49,480
a subset of the description.

96
00:04:49,480 --> 00:04:50,400
Right?

97
00:04:50,400 --> 00:04:53,200
And if you think about that in a more declarative way,

98
00:04:53,200 --> 00:04:54,400
that's better.

99
00:04:54,400 --> 00:04:57,280
And sets allow you to do that.

100
00:04:57,280 --> 00:04:58,560
Another example.

101
00:04:58,560 --> 00:05:00,720
Mark all products previously favorited

102
00:05:00,720 --> 00:05:04,080
except those already in the shopping cart.

103
00:05:04,080 --> 00:05:08,720
So now we have the F set, which is the favorite favorite

104
00:05:08,720 --> 00:05:12,640
products, and the C is the cart.

105
00:05:12,640 --> 00:05:17,480
And what you have here is a difference, right?

106
00:05:17,480 --> 00:05:22,160
Which we would write in Python as F minus C. OK.

107
00:05:22,160 --> 00:05:27,960
So the thing is, sets are really powerful.

108
00:05:27,960 --> 00:05:29,120
In fact, I found this quote.

109
00:05:29,120 --> 00:05:31,520
Nobody has yet discovered the branch of mathematics

110
00:05:31,520 --> 00:05:36,840
that has successfully resisted formalization into set theory.

111
00:05:36,840 --> 00:05:37,320
Right?

112
00:05:40,160 --> 00:05:43,840
And so logic conjunction is intersection.

113
00:05:43,840 --> 00:05:45,880
So the end operator is intersection.

114
00:05:45,880 --> 00:05:47,960
Right?

115
00:05:47,960 --> 00:05:51,040
The or operator is union.

116
00:05:51,040 --> 00:05:53,040
Right?

117
00:05:53,040 --> 00:05:58,280
Symmetric difference is what we call an exclusive or.

118
00:05:58,360 --> 00:06:02,320
In computer science.

119
00:06:02,320 --> 00:06:09,160
The difference is basically the elements of one set

120
00:06:09,160 --> 00:06:11,160
minus the elements of the other.

121
00:06:11,160 --> 00:06:12,760
Right?

122
00:06:12,760 --> 00:06:18,760
So in my opinion, people in the Python community

123
00:06:18,760 --> 00:06:22,840
don't use sets as much as they should.

124
00:06:22,840 --> 00:06:24,880
Put it another way.

125
00:06:24,880 --> 00:06:28,440
I've done code reviews where I saw code that

126
00:06:28,440 --> 00:06:32,200
could be drastically simplified and also made faster, which

127
00:06:32,200 --> 00:06:33,680
is a big win.

128
00:06:33,680 --> 00:06:34,200
Right?

129
00:06:34,200 --> 00:06:36,720
When you get to have something that becomes more readable

130
00:06:36,720 --> 00:06:38,160
and faster at the same time.

131
00:06:38,160 --> 00:06:39,480
That's excellent.

132
00:06:39,480 --> 00:06:41,960
And sets often give you this kind of opportunity.

133
00:06:41,960 --> 00:06:44,280
But people missed this opportunity,

134
00:06:44,280 --> 00:06:47,280
perhaps because of experience in other languages.

135
00:06:47,280 --> 00:06:49,080
I did a little research.

136
00:06:49,080 --> 00:06:53,240
And I found out that in some other major standard libraries,

137
00:06:53,240 --> 00:06:54,280
there are sets.

138
00:06:54,280 --> 00:06:57,800
When there are sets, like I said, in the Go language,

139
00:06:57,800 --> 00:07:00,240
there are no sets in the standard library.

140
00:07:00,240 --> 00:07:02,880
But when there are sets, most of the set implementations

141
00:07:02,880 --> 00:07:05,560
available in other languages are very poor.

142
00:07:05,560 --> 00:07:12,160
Meaning they don't implement a rich API with all the common set

143
00:07:12,160 --> 00:07:14,400
operations.

144
00:07:14,400 --> 00:07:19,320
So people coming from JavaScript may think of sets.

145
00:07:19,320 --> 00:07:23,520
OK, a set is a way of having unique elements.

146
00:07:23,520 --> 00:07:24,560
That's one part of it.

147
00:07:24,560 --> 00:07:27,240
But the other part is having those operations,

148
00:07:27,240 --> 00:07:31,160
intersection, union, symmetric difference, and so on.

149
00:07:31,160 --> 00:07:33,480
So among those languages, only Python and Ruby

150
00:07:33,480 --> 00:07:37,920
have what I consider a rich set API.

151
00:07:37,920 --> 00:07:41,000
So let's talk a little bit about sets in Python.

152
00:07:41,000 --> 00:07:42,480
Ignore the code above.

153
00:07:42,480 --> 00:07:44,960
It's just a generator to generate Fibonacci numbers.

154
00:07:44,960 --> 00:07:48,520
But the important thing is I have this F set below

155
00:07:48,520 --> 00:07:50,880
that I built with a set comprehension.

156
00:07:50,880 --> 00:07:55,320
So it's the set of the Fibonacci numbers up to 10

157
00:07:55,320 --> 00:07:58,440
and excluding 10.

158
00:07:58,440 --> 00:08:01,120
Another example, the primes.

159
00:08:01,120 --> 00:08:03,120
So I have this function that generates primes.

160
00:08:03,120 --> 00:08:06,120
And I have the primes up to 10.

161
00:08:06,120 --> 00:08:10,880
So we have the F and the P set here, right?

162
00:08:10,880 --> 00:08:12,760
So some operations.

163
00:08:12,760 --> 00:08:15,600
A basic operation is to determine whether an element is

164
00:08:15,600 --> 00:08:16,200
in the set.

165
00:08:16,200 --> 00:08:18,360
And we do that with the in operator in Python,

166
00:08:18,400 --> 00:08:23,560
which is implemented underneath using the DunderContains

167
00:08:23,560 --> 00:08:24,800
method.

168
00:08:24,800 --> 00:08:28,120
And this is super fast in the Python standard library

169
00:08:28,120 --> 00:08:33,640
because it's implemented using a hash table underneath.

170
00:08:33,640 --> 00:08:36,000
I'm so old that actually when I started with Python,

171
00:08:36,000 --> 00:08:37,600
there was no set in Python.

172
00:08:37,600 --> 00:08:42,280
But we used dicts because of the hash table

173
00:08:42,320 --> 00:08:48,560
to emulate sets or to build on dicts to do sets.

174
00:08:48,560 --> 00:08:52,040
And then you have all of the fundamental set operations

175
00:08:52,040 --> 00:08:55,640
also implemented as operators, as infix operators in Python.

176
00:08:55,640 --> 00:08:58,800
So the ampersand is intersection,

177
00:08:58,800 --> 00:09:05,520
which makes sense if you think about the default meaning

178
00:09:05,520 --> 00:09:09,760
of that operator in Python is the bitwise end.

179
00:09:09,760 --> 00:09:11,560
And the pipe is the bitwise or.

180
00:09:11,560 --> 00:09:13,440
So naturally is the union.

181
00:09:13,440 --> 00:09:17,680
And the carrot is the symmetric difference

182
00:09:17,680 --> 00:09:20,240
because it's the bitwise shore.

183
00:09:20,240 --> 00:09:22,800
And then the minus is the difference.

184
00:09:22,800 --> 00:09:25,720
So we have these operators as infix operators.

185
00:09:25,720 --> 00:09:32,320
And we also have the subset and superset comparisons

186
00:09:32,320 --> 00:09:34,640
that are implemented that are coded

187
00:09:34,640 --> 00:09:36,120
in math with those symbols.

188
00:09:36,120 --> 00:09:40,480
In Python, we use the less than, greater than, less than,

189
00:09:40,480 --> 00:09:43,600
equal those comparison operators.

190
00:09:43,600 --> 00:09:48,360
They are overridden in sets to do

191
00:09:48,360 --> 00:09:52,400
that kind of supersetting subset testing.

192
00:09:52,400 --> 00:09:57,240
And you can have complex expressions.

193
00:09:57,240 --> 00:09:59,120
I'm not going to go into detail here.

194
00:09:59,120 --> 00:10:03,760
But it's like, so this is a demonstration of De Morgan's law.

195
00:10:03,760 --> 00:10:12,800
In line 20 there, it says that the difference between a set

196
00:10:12,800 --> 00:10:16,840
and the intersection of the second and a third set

197
00:10:16,840 --> 00:10:20,920
is like the difference between the first set,

198
00:10:20,920 --> 00:10:23,920
the original set, and the second, and the original,

199
00:10:23,920 --> 00:10:30,320
and the third with or operator inside.

200
00:10:30,320 --> 00:10:31,880
Anyway, so this is De Morgan's law,

201
00:10:31,880 --> 00:10:33,440
another example of De Morgan's law.

202
00:10:33,480 --> 00:10:35,600
Just think about these expressions written

203
00:10:35,600 --> 00:10:38,480
without the infix operators, calling methods.

204
00:10:38,480 --> 00:10:40,960
That would be really sad, right?

205
00:10:40,960 --> 00:10:42,320
Difficult to read.

206
00:10:42,320 --> 00:10:44,280
And that's what you have in some other languages

207
00:10:44,280 --> 00:10:45,760
that will not be named, that don't

208
00:10:45,760 --> 00:10:49,000
have operator overloading.

209
00:10:49,000 --> 00:10:51,280
Anyway, but Python, and this is where

210
00:10:51,280 --> 00:10:55,440
we learn some good ideas about the API of sets

211
00:10:55,440 --> 00:10:57,400
that we can leverage in our own APIs.

212
00:10:58,280 --> 00:11:03,440
Because the Python standard library also

213
00:11:03,440 --> 00:11:06,840
offers lots of methods for sets.

214
00:11:06,840 --> 00:11:09,880
And this is a table from my book.

215
00:11:09,880 --> 00:11:14,040
But as you can see, for instance, in the first,

216
00:11:14,040 --> 00:11:16,440
so this table is basically split in two parts.

217
00:11:16,440 --> 00:11:18,400
The top part is about intersection,

218
00:11:18,400 --> 00:11:20,920
and the bottom part is about union.

219
00:11:20,920 --> 00:11:23,360
So you have these three different,

220
00:11:23,400 --> 00:11:27,000
you have these operators, infix operators,

221
00:11:27,000 --> 00:11:29,320
to do intersection at the top.

222
00:11:29,320 --> 00:11:34,040
But also you have the methods that

223
00:11:34,040 --> 00:11:36,880
implement those operations underneath,

224
00:11:36,880 --> 00:11:39,400
and that you should never call your own code.

225
00:11:39,400 --> 00:11:41,560
You should not call those methods usually.

226
00:11:41,560 --> 00:11:45,240
But what you would call if you wanted to use the method form

227
00:11:45,240 --> 00:11:48,240
would be s.intersection.

228
00:11:48,240 --> 00:11:53,320
But a good idea here, an example of good design in this API,

229
00:11:53,360 --> 00:11:57,480
is that this is not just redundant, another way of calling.

230
00:11:57,480 --> 00:12:03,840
But they leverage the fact that the function call notation

231
00:12:03,840 --> 00:12:07,120
allows you to have more than two operands.

232
00:12:07,120 --> 00:12:10,600
So infix notation is just for two operands.

233
00:12:10,600 --> 00:12:13,240
But here you can have as many operands as you like.

234
00:12:13,240 --> 00:12:16,560
You have the receiver, which is s.

235
00:12:16,560 --> 00:12:18,880
And then within the parentheses, you

236
00:12:18,880 --> 00:12:22,040
can put as many other things as you want.

237
00:12:22,040 --> 00:12:24,520
And then you have the intersection of all of those things.

238
00:12:24,520 --> 00:12:26,440
And I'm saying things here because they

239
00:12:26,440 --> 00:12:27,400
don't need to be set.

240
00:12:27,400 --> 00:12:29,400
They can be any iterables.

241
00:12:29,400 --> 00:12:31,240
And that, again, is another thing

242
00:12:31,240 --> 00:12:34,920
that they did in the method that is

243
00:12:34,920 --> 00:12:36,200
different from the operators.

244
00:12:36,200 --> 00:12:40,480
The operators strictly operate with sets.

245
00:12:40,480 --> 00:12:44,880
If you use the n% form, for instance,

246
00:12:44,880 --> 00:12:51,160
you need to do one set, n% another set.

247
00:12:51,200 --> 00:12:53,840
But if you want more flexibility,

248
00:12:53,840 --> 00:12:55,440
then you can use the method.

249
00:12:55,440 --> 00:12:59,800
And it allows you to use any iterable.

250
00:12:59,800 --> 00:13:02,840
And it also allows you to use multiple iterables.

251
00:13:02,840 --> 00:13:08,160
So this is a great idea of how this API is implemented.

252
00:13:08,160 --> 00:13:10,960
Think about that.

253
00:13:10,960 --> 00:13:19,880
Often, if you code your API so that you get iterables,

254
00:13:20,040 --> 00:13:22,960
you make it more flexible for the users

255
00:13:22,960 --> 00:13:25,240
to pass whatever is convenient for them

256
00:13:25,240 --> 00:13:29,880
to pass into your API instead of assuming that you're

257
00:13:29,880 --> 00:13:33,000
getting a list, for example.

258
00:13:33,000 --> 00:13:35,720
But an interesting thing that I talked about in my tutorial

259
00:13:35,720 --> 00:13:39,320
the day before yesterday is that maybe you do need a list

260
00:13:39,320 --> 00:13:41,840
inside your operations.

261
00:13:41,840 --> 00:13:43,640
Or in this case, maybe they do need

262
00:13:43,640 --> 00:13:47,960
the set the way that this method is implemented inside.

263
00:13:47,960 --> 00:13:51,440
It's OK, because the set constructor and the list

264
00:13:51,440 --> 00:13:55,080
constructor both know how to handle

265
00:13:55,080 --> 00:13:56,880
iterables, generic iterables.

266
00:13:56,880 --> 00:13:59,120
So one thing that you can do, which is very easy,

267
00:13:59,120 --> 00:14:02,600
is you accept an argument of any iterable type.

268
00:14:02,600 --> 00:14:04,880
And then immediately, you convert it

269
00:14:04,880 --> 00:14:07,080
to whatever you need inside your method.

270
00:14:07,080 --> 00:14:11,480
In this case, a set, or in some other case, a list.

271
00:14:11,480 --> 00:14:15,000
So that gives you flexibility and also gives you safety.

272
00:14:15,000 --> 00:14:19,040
Because at the point that if somebody passes you something

273
00:14:19,040 --> 00:14:22,440
that is not iterable, it will be easy to debug,

274
00:14:22,440 --> 00:14:26,280
because the program will break right there

275
00:14:26,280 --> 00:14:28,720
at the start of the method.

276
00:14:28,720 --> 00:14:30,600
Does that make sense?

277
00:14:30,600 --> 00:14:33,000
So I think this is a good practice.

278
00:14:33,000 --> 00:14:35,440
Of course, it has a cost attached to it,

279
00:14:35,440 --> 00:14:38,360
because when you're using an operation like that,

280
00:14:38,360 --> 00:14:41,120
you're doing a copy most of the time.

281
00:14:41,120 --> 00:14:43,520
Python is smart enough that it doesn't copy, for instance,

282
00:14:43,520 --> 00:14:47,320
frozen sets or tuples, because they are immutable.

283
00:14:47,320 --> 00:14:51,560
So when you use notation in Python to copy those things,

284
00:14:51,560 --> 00:14:53,520
Python cheats underneath and passes you

285
00:14:53,520 --> 00:14:56,240
a reference to the same thing, because it's immutable.

286
00:14:56,240 --> 00:15:00,480
So it doesn't matter whether it's a copy or the same.

287
00:15:00,480 --> 00:15:03,960
Anyway, and so it's like this.

288
00:15:03,960 --> 00:15:06,640
The other operations, the difference

289
00:15:06,640 --> 00:15:08,080
and symmetric difference are also

290
00:15:08,080 --> 00:15:10,080
implemented within fixed operators

291
00:15:10,080 --> 00:15:16,520
and also with methods.

292
00:15:16,520 --> 00:15:18,640
Oh, one thing that I wanted to comment here

293
00:15:18,640 --> 00:15:26,640
is also that there are, here I am describing the full set API,

294
00:15:26,640 --> 00:15:30,440
but there is the frozen set, which is a smaller API,

295
00:15:30,440 --> 00:15:32,680
because it's immutable.

296
00:15:32,680 --> 00:15:35,000
So for instance, both kinds of sets

297
00:15:35,040 --> 00:15:41,480
have the intersection methods and the infix, sorry,

298
00:15:41,480 --> 00:15:45,400
the inplace end, which is written like ampersand equals

299
00:15:45,400 --> 00:15:49,360
to change in place the receiver.

300
00:15:49,360 --> 00:15:57,440
But the set, which is mutable, also has an update version.

301
00:15:57,440 --> 00:16:00,000
So that's one difference.

302
00:16:00,000 --> 00:16:05,640
And I like the naming that is very explicit in this case.

303
00:16:05,640 --> 00:16:08,320
In the case of the union, it's just

304
00:16:08,320 --> 00:16:11,640
called update, the version that changes,

305
00:16:11,640 --> 00:16:16,040
because that goes with the update method in dicts as well.

306
00:16:16,040 --> 00:16:17,400
So it makes sense.

307
00:16:17,400 --> 00:16:21,520
But the other operators are insertion update, difference

308
00:16:21,520 --> 00:16:23,880
update, and symmetric difference update.

309
00:16:24,880 --> 00:16:27,040
OK.

310
00:16:27,040 --> 00:16:30,360
And then you also have the different sets

311
00:16:30,360 --> 00:16:34,080
or the different tests that return billions.

312
00:16:34,080 --> 00:16:36,040
And you have a bunch of other methods

313
00:16:36,040 --> 00:16:41,000
that are mostly about, that don't have anything

314
00:16:41,000 --> 00:16:43,520
to do with set theory in math, but have

315
00:16:43,520 --> 00:16:47,120
to do with practical computing, like adding elements,

316
00:16:47,120 --> 00:16:51,080
removing all elements of a set, making a couple of it,

317
00:16:51,080 --> 00:16:56,840
removing an element, a specific element, iterate over,

318
00:16:56,840 --> 00:17:05,560
get the len pop, which removes some elements

319
00:17:05,560 --> 00:17:10,560
and then raises an exception if the set is empty, and so on.

320
00:17:13,720 --> 00:17:17,360
Now, there is ABCs in Python that define

321
00:17:17,360 --> 00:17:19,160
what a set should look like.

322
00:17:19,160 --> 00:17:20,800
And those ABCs are like that.

323
00:17:20,800 --> 00:17:24,640
So you have the set ABC, the set abstract base class,

324
00:17:24,640 --> 00:17:30,000
that has many other methods that are basically the most of them

325
00:17:30,000 --> 00:17:32,800
have to do with the infix operators.

326
00:17:32,800 --> 00:17:36,320
And set inherits from container, iterable, and sized.

327
00:17:40,680 --> 00:17:46,600
And it's interesting that the set type there,

328
00:17:46,600 --> 00:17:51,720
although it's abstract, all of those methods are concrete.

329
00:17:51,720 --> 00:17:52,440
OK?

330
00:17:52,440 --> 00:17:56,080
It assumes, they assume that you have implemented

331
00:17:56,080 --> 00:17:58,520
the abstract methods that are inherited from container,

332
00:17:58,520 --> 00:18:00,480
iterable, and sized.

333
00:18:00,480 --> 00:18:02,720
And if you have implemented those,

334
00:18:02,720 --> 00:18:06,240
then you get everything else for free.

335
00:18:06,240 --> 00:18:08,560
And in the case of mutable sets, you

336
00:18:08,560 --> 00:18:11,760
need to implement add and discard, which are abstract.

337
00:18:11,760 --> 00:18:15,160
You see the italics there mean that it's abstract.

338
00:18:15,160 --> 00:18:16,880
And then if you implement that, you

339
00:18:16,880 --> 00:18:20,720
get the other methods for free.

340
00:18:20,720 --> 00:18:23,720
Those concrete methods in the abstract classes

341
00:18:23,720 --> 00:18:29,000
is what the Python documentation called mixing methods.

342
00:18:29,000 --> 00:18:31,600
All right, so now let's talk a little bit

343
00:18:31,600 --> 00:18:32,920
about operator overloading.

344
00:18:32,920 --> 00:18:36,000
So the idea of operator overloading

345
00:18:36,000 --> 00:18:39,120
is that you have those other methods that

346
00:18:39,120 --> 00:18:44,560
are called when the Python interpreter sees

347
00:18:44,560 --> 00:18:46,560
one of those infix operators.

348
00:18:50,040 --> 00:18:52,760
Pretty much all of the standard operators in Python

349
00:18:52,760 --> 00:18:59,120
are you can override with this notation,

350
00:18:59,120 --> 00:19:05,240
with the Dunder methods, except for, I think, four of them.

351
00:19:05,240 --> 00:19:07,800
The is cannot be overridden.

352
00:19:07,800 --> 00:19:13,400
The and, or, and not.

353
00:19:13,400 --> 00:19:16,440
The and, or, and not that are written as words cannot be

354
00:19:16,440 --> 00:19:18,320
overridden.

355
00:19:18,320 --> 00:19:21,480
Because of the way the short-circuit evaluation works

356
00:19:21,480 --> 00:19:23,560
with and, and, or, it would not be

357
00:19:23,560 --> 00:19:29,320
possible to implement them as methods.

358
00:19:29,320 --> 00:19:32,600
And the is is not overridden, because what it does

359
00:19:32,600 --> 00:19:33,760
is just compare references.

360
00:19:33,760 --> 00:19:37,160
So there's nothing to change there.

361
00:19:37,160 --> 00:19:44,000
Anyway, but the implementation of the comparison operator

362
00:19:44,000 --> 00:19:45,480
is the simplest part.

363
00:19:45,480 --> 00:19:47,560
That's why in my book I cover that first.

364
00:19:55,880 --> 00:19:59,600
Because there is a symmetry in all of these operators, right?

365
00:19:59,600 --> 00:20:03,400
If you ask whether a equals b or b equals a,

366
00:20:03,400 --> 00:20:04,840
it's the same thing.

367
00:20:04,880 --> 00:20:08,120
And if you ask whether a is greater than b,

368
00:20:08,120 --> 00:20:11,920
it's the same thing as asking whether b is smaller than a.

369
00:20:11,920 --> 00:20:15,000
So you have the forward method and the reverse methods.

370
00:20:15,000 --> 00:20:18,800
There's a symmetry that comes by the definition

371
00:20:18,800 --> 00:20:20,800
of these operators.

372
00:20:20,800 --> 00:20:23,760
But with the other operators, the situation

373
00:20:23,760 --> 00:20:29,320
is more complicated, because maybe you have just

374
00:20:29,320 --> 00:20:32,400
invented some new type, and you wanted

375
00:20:32,400 --> 00:20:35,280
to interoperate with the built-in type.

376
00:20:35,280 --> 00:20:38,520
So let's say I just invented a new set type,

377
00:20:38,520 --> 00:20:41,760
and I want my set type to interoperate with the built-in

378
00:20:41,760 --> 00:20:43,080
set types.

379
00:20:43,080 --> 00:20:45,800
Now, the built-in set types don't know about my set type.

380
00:20:45,800 --> 00:20:50,240
So they wouldn't be able to do, for instance,

381
00:20:50,240 --> 00:20:57,080
the ampersand operation, like built-in set ampersand my set.

382
00:20:57,080 --> 00:21:00,360
This would be a method call on the built-in set,

383
00:21:00,360 --> 00:21:02,280
and it would look at the type of my set

384
00:21:02,320 --> 00:21:05,320
and say, I don't know how to handle that.

385
00:21:05,320 --> 00:21:08,280
You know, the built-in source code of Python

386
00:21:08,280 --> 00:21:09,600
doesn't know about that.

387
00:21:09,600 --> 00:21:13,360
So the way this is solved is the method that

388
00:21:13,360 --> 00:21:18,160
doesn't know how to deal with the other operands

389
00:21:18,160 --> 00:21:22,080
returns a special value called not implemented.

390
00:21:22,080 --> 00:21:23,360
This is not an exception.

391
00:21:23,360 --> 00:21:25,000
It's a special value.

392
00:21:25,000 --> 00:21:26,960
And when you return that special value,

393
00:21:26,960 --> 00:21:31,000
you're signaling to the interpreter,

394
00:21:31,000 --> 00:21:33,080
you need to try something else.

395
00:21:33,080 --> 00:21:36,720
And what the interpreter tries is to reverse the operands

396
00:21:36,720 --> 00:21:40,880
and call the method with the R prefix.

397
00:21:40,880 --> 00:21:44,800
So the end, if the other end doesn't

398
00:21:44,800 --> 00:21:47,200
know how to do with the argument,

399
00:21:47,200 --> 00:21:48,880
then the Python interpreter, then it

400
00:21:48,880 --> 00:21:51,120
will return not implemented, and the Python interpreter

401
00:21:51,120 --> 00:21:58,440
will call the R end method on the other operand,

402
00:21:58,440 --> 00:22:01,920
passing the initial, the first argument as argument.

403
00:22:01,920 --> 00:22:05,360
So with this reversal, the interpreter

404
00:22:05,360 --> 00:22:07,960
is now giving an opportunity for my set class

405
00:22:07,960 --> 00:22:11,880
to handle the built-in set class.

406
00:22:11,880 --> 00:22:19,520
And there's a whole, I drew this flow chart

407
00:22:19,520 --> 00:22:23,520
that talks about how this mechanism works.

408
00:22:23,520 --> 00:22:25,040
And I think it's really elegant.

409
00:22:25,040 --> 00:22:27,280
I think it's really beautiful the way this works.

410
00:22:30,120 --> 00:22:35,120
So one thing that I did was to create an example

411
00:22:35,120 --> 00:22:38,440
implementation of a different sort of sets.

412
00:22:38,440 --> 00:22:43,400
And my set that I created is actually

413
00:22:43,400 --> 00:22:46,440
inspired by a great example in the Go programming language

414
00:22:46,440 --> 00:22:50,120
book by Donovan and Carnegie.

415
00:22:50,120 --> 00:22:52,240
That's one of the best programming language books

416
00:22:52,240 --> 00:22:53,360
that I ever read.

417
00:22:54,320 --> 00:22:58,240
Carnegie is the K in the KNR, classic C book.

418
00:22:58,240 --> 00:22:59,760
And that's also awesome.

419
00:22:59,760 --> 00:23:01,960
And this book is really great.

420
00:23:01,960 --> 00:23:03,800
And in one of the examples there,

421
00:23:03,800 --> 00:23:09,840
they actually implement a set type for unsigned integers

422
00:23:09,840 --> 00:23:16,120
where the values are stored in an array of bits.

423
00:23:16,120 --> 00:23:19,080
So they have an array of uints.

424
00:23:19,080 --> 00:23:22,680
And each bit there tells you whether there is or not

425
00:23:23,480 --> 00:23:24,600
an element there.

426
00:23:24,600 --> 00:23:30,840
So the idea is, for instance, in my implementation,

427
00:23:30,840 --> 00:23:34,920
this constructor here, I'm constructing an uint

428
00:23:34,920 --> 00:23:38,560
set with those numbers.

429
00:23:38,560 --> 00:23:41,680
This is represented by these long ints in Python.

430
00:23:41,680 --> 00:23:42,800
Go doesn't have long ints.

431
00:23:42,800 --> 00:23:45,120
So when they did that in Go, they

432
00:23:45,120 --> 00:23:49,880
needed to use an array of uints.

433
00:23:49,880 --> 00:23:52,360
And that's actually what I did when I first ported this code

434
00:23:52,360 --> 00:23:53,400
to Python.

435
00:23:53,400 --> 00:23:57,520
But then I realized I was suffering

436
00:23:57,520 --> 00:24:03,400
a case of the von Neumann bottleneck syndrome, which

437
00:24:03,400 --> 00:24:07,160
is when you think like a stupid CPU that only reads

438
00:24:07,160 --> 00:24:08,640
one word at a time.

439
00:24:08,640 --> 00:24:11,280
And we are using a high level language, very powerful

440
00:24:11,280 --> 00:24:12,400
high level language.

441
00:24:12,400 --> 00:24:15,600
And we have ints that are arbitrary precision.

442
00:24:15,600 --> 00:24:18,120
So those are implemented underneath the covers

443
00:24:18,160 --> 00:24:23,520
in C, which is a von Neumann limited bottleneck language,

444
00:24:23,520 --> 00:24:27,120
as an array of uints or something like that.

445
00:24:27,120 --> 00:24:28,880
But I don't need to care about that.

446
00:24:28,880 --> 00:24:34,440
So I can represent that set by this number.

447
00:24:34,440 --> 00:24:36,840
This is a long in Python.

448
00:24:36,840 --> 00:24:39,480
We used to call them longs in Python 2.7.

449
00:24:39,480 --> 00:24:40,920
Now we just call them ints.

450
00:24:40,920 --> 00:24:42,520
This is so elegant.

451
00:24:42,520 --> 00:24:46,360
And that's actually represent that.

452
00:24:46,360 --> 00:24:47,440
How does that make sense?

453
00:24:47,440 --> 00:24:48,920
Because it's this bit pattern.

454
00:24:51,640 --> 00:24:54,760
Now I'm going to switch to another slide here

455
00:24:54,760 --> 00:24:57,840
that has only one element, which is the last element.

456
00:24:57,840 --> 00:25:04,400
So this other set, which has only the element 290,

457
00:25:04,400 --> 00:25:07,240
is represented by that huge hint integer, which

458
00:25:07,240 --> 00:25:09,200
has the same number of bits.

459
00:25:09,200 --> 00:25:11,160
But all of them are 0.

460
00:25:11,160 --> 00:25:12,720
And just one of them is 1.

461
00:25:12,720 --> 00:25:15,840
That represents the value 290, because it's

462
00:25:15,840 --> 00:25:18,880
in the position 290.

463
00:25:18,880 --> 00:25:20,280
Does that make sense?

464
00:25:20,280 --> 00:25:24,040
So that's how the implementation that I did works.

465
00:25:24,040 --> 00:25:26,600
And so, for instance, a tricky thing

466
00:25:26,600 --> 00:25:30,960
is how do you represent an empty set?

467
00:25:30,960 --> 00:25:33,000
You represent it by 0.

468
00:25:33,000 --> 00:25:35,080
0 is the empty set.

469
00:25:35,080 --> 00:25:37,080
The number 0 is the empty set.

470
00:25:37,080 --> 00:25:40,000
How do you represent a set with 0?

471
00:25:40,000 --> 00:25:45,760
It's 1, because you need to have one set

472
00:25:45,760 --> 00:25:48,560
bit to describe a number that's there.

473
00:25:48,560 --> 00:25:51,840
And this one set bit is in position 0,

474
00:25:51,840 --> 00:25:55,040
meaning 0 is in the set.

475
00:25:55,040 --> 00:26:04,480
And a set with one number 1 is represented by the number 2,

476
00:26:04,480 --> 00:26:09,300
which is like that bit pattern.

477
00:26:09,300 --> 00:26:12,320
And that's how this thing works.

478
00:26:12,360 --> 00:26:16,240
Now, the source code for this is on github.com

479
00:26:16,240 --> 00:26:20,160
slash stand-updev slash uintset.

480
00:26:20,160 --> 00:26:23,320
And I don't have time to show that now.

481
00:26:23,320 --> 00:26:28,520
But what I've agreed with my friends that work for JetBrains

482
00:26:28,520 --> 00:26:31,520
is 15 minutes after this is over,

483
00:26:31,520 --> 00:26:33,160
I'm going to be at their booth.

484
00:26:33,160 --> 00:26:37,240
And I'm going to be going over the code

485
00:26:37,240 --> 00:26:38,680
for this implementation.

486
00:26:38,680 --> 00:26:40,080
But you can look at it here.

487
00:26:40,480 --> 00:26:41,880
It has tests.

488
00:26:41,880 --> 00:26:43,400
And it's a complete implementation

489
00:26:43,400 --> 00:26:48,920
of the set interface using these crazy mechanics of having

490
00:26:48,920 --> 00:26:52,800
bits representing integers.

491
00:26:52,800 --> 00:26:57,640
And so that was what I wanted to tell you about.

492
00:26:57,640 --> 00:27:02,080
The key takeaways here are that set operations

493
00:27:02,080 --> 00:27:05,200
allow simpler and faster solutions for many tasks.

494
00:27:06,160 --> 00:27:08,240
The Python set classes are good lessons

495
00:27:08,240 --> 00:27:11,840
in idiomatic API design for two reasons.

496
00:27:11,840 --> 00:27:16,240
I think it's not easy to always justify operator overloading.

497
00:27:16,240 --> 00:27:18,320
Sometimes it's overused.

498
00:27:18,320 --> 00:27:19,840
And in fact, there's a key reason

499
00:27:19,840 --> 00:27:22,920
why James Gosling didn't put it in Java.

500
00:27:22,920 --> 00:27:28,680
I read a quotation of him saying that they didn't put it in Java

501
00:27:28,680 --> 00:27:33,960
because operator overloading was way overused in C++.

502
00:27:33,960 --> 00:27:35,880
And they didn't want to have this problem.

503
00:27:35,880 --> 00:27:43,160
But I think everybody has learned not to overuse operator

504
00:27:43,160 --> 00:27:44,080
overloading.

505
00:27:44,080 --> 00:27:45,720
But it's a feature that we have in Python.

506
00:27:45,720 --> 00:27:47,880
And it can be used judiciously.

507
00:27:47,880 --> 00:27:50,520
And I think sets is a great example of using that

508
00:27:50,520 --> 00:27:52,480
in a way that makes sense.

509
00:27:52,480 --> 00:27:56,120
Also, I like the fact that they have the other methods that

510
00:27:56,120 --> 00:27:57,440
take intervals.

511
00:27:57,520 --> 00:28:00,880
So those are the key takeaways.

512
00:28:00,880 --> 00:28:04,560
And like I said, at 11.45, I will

513
00:28:04,560 --> 00:28:08,840
be at the JetBrains booth giving an overview of the code.

514
00:28:08,840 --> 00:28:11,520
The code is on GitHub, like I said,

515
00:28:11,520 --> 00:28:14,760
in my account called stand-updev there.

516
00:28:14,760 --> 00:28:20,240
And also, at 4 PM in the O'Reilly booth,

517
00:28:20,240 --> 00:28:21,960
there's going to be a book signing.

518
00:28:21,960 --> 00:28:23,960
And that's going to be a book signing.

519
00:28:23,960 --> 00:28:27,400
In the O'Reilly booth, there's going to be a book signing.

520
00:28:27,400 --> 00:28:30,520
And the way O'Reilly does is they brought a bunch of copies

521
00:28:30,520 --> 00:28:34,080
of my book, I think about 40 copies or something like that.

522
00:28:34,080 --> 00:28:35,720
And they're going to hand them out.

523
00:28:35,720 --> 00:28:38,080
I don't know what's the procedure for that.

524
00:28:38,080 --> 00:28:41,680
But I think it involves handing out little tickets to people

525
00:28:41,680 --> 00:28:44,120
that are in a line.

526
00:28:44,120 --> 00:28:46,080
And then if you get one of the tickets,

527
00:28:46,080 --> 00:28:49,720
you can stand in a line.

528
00:28:49,720 --> 00:28:51,440
And you will get a copy.

529
00:28:51,440 --> 00:28:54,520
And I will sign it for you if you want.

530
00:28:54,520 --> 00:28:58,600
So those are the things that I'm also going to be doing today.

531
00:28:58,600 --> 00:29:02,120
And thank you very much.

532
00:29:02,120 --> 00:29:03,720
I'm honored to be talking to you.

533
00:29:03,720 --> 00:29:06,880
And I will be hanging around in the hallways as well.

534
00:29:06,880 --> 00:29:07,640
Thank you.

535
00:29:07,640 --> 00:29:09,900
Thank you.

