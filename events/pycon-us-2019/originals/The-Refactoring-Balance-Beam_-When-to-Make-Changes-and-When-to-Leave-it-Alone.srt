1
00:00:00,000 --> 00:00:03,040
Hello, everyone.

2
00:00:03,040 --> 00:00:07,640
Next up we have Amanda Sopkin presenting the Refactoring Balance Beam, When to Make Changes

3
00:00:07,640 --> 00:00:10,720
and When to Leave it Alone.

4
00:00:10,720 --> 00:00:14,400
All right.

5
00:00:14,400 --> 00:00:17,760
Thank you very much.

6
00:00:17,760 --> 00:00:20,600
Welcome to, as he said, the Refactoring Balance Beam.

7
00:00:20,600 --> 00:00:24,900
The inspiration for this title is that when you're refactoring, you're sort of striking

8
00:00:24,900 --> 00:00:29,500
a balance between what it's worth making changes to and what, you know, you should just kind

9
00:00:29,500 --> 00:00:32,140
of leave well enough alone.

10
00:00:32,140 --> 00:00:34,620
And I'm going to start out with a joke.

11
00:00:34,620 --> 00:00:39,340
So I'll kind of tell you what's going on in case it's hard to read the print.

12
00:00:39,340 --> 00:00:42,620
Basically this developer has just cloned his master branch.

13
00:00:42,620 --> 00:00:44,700
Both of the branches look like monsters.

14
00:00:44,700 --> 00:00:47,380
And the master branch is asking about the new branch.

15
00:00:47,380 --> 00:00:49,980
And the developer says that it's just a refactoring branch.

16
00:00:49,980 --> 00:00:52,140
I'm removing all the bad coding.

17
00:00:52,140 --> 00:00:56,700
And then shortly later on, the master branch is concerned because the refactoring branch

18
00:00:56,700 --> 00:01:00,620
has been reduced to a pile of bones and there's really not much left at all.

19
00:01:00,620 --> 00:01:04,180
And he's saying you'll never do that to the master branch, will you?

20
00:01:04,180 --> 00:01:08,460
And the developer is saying it seems not much is left after all.

21
00:01:08,460 --> 00:01:11,040
So maybe you've had this experience while you're refactoring.

22
00:01:11,040 --> 00:01:12,040
Maybe not.

23
00:01:12,040 --> 00:01:16,300
I found in my career that there are a lot of decisions that get made around refactoring

24
00:01:16,300 --> 00:01:21,860
that are kind of difficult to balance, like deciding when to do it, how to prevent affecting

25
00:01:22,340 --> 00:01:28,060
changes, how to prevent affecting feature code, and even just socially navigating, making

26
00:01:28,060 --> 00:01:32,860
substantial changes to something that someone else on your team potentially wrote.

27
00:01:32,860 --> 00:01:38,780
So I'm hopeful that this talk will give you some guidance on how to make those decisions.

28
00:01:38,780 --> 00:01:43,020
And if you're someone who likes to follow along with slides as the talk is going, I

29
00:01:43,020 --> 00:01:50,060
did tweet them out five minutes ago, or you can go to this short URL, bit.ly slash PyCon19.

30
00:01:50,060 --> 00:01:55,140
And they'll also put the slides up after all of this is said and done.

31
00:01:55,140 --> 00:01:59,340
So I'm going to start out by talking about some of the motivations for refactoring.

32
00:01:59,340 --> 00:02:02,800
We'll spend the meat of this talk kind of looking at different code smells and good

33
00:02:02,800 --> 00:02:04,500
ways to address them.

34
00:02:04,500 --> 00:02:09,460
And then we'll talk about different approaches to refactoring and ways to answer that question

35
00:02:09,460 --> 00:02:13,740
of whether or not you should be doing refactoring.

36
00:02:13,740 --> 00:02:17,080
So I want to start out by putting the Zen of Python up here.

37
00:02:17,080 --> 00:02:20,880
You've probably seen this several times this weekend alone, but I think there are a few

38
00:02:20,880 --> 00:02:25,880
pieces that are worth calling out to get us into the right head state for a refactoring

39
00:02:25,880 --> 00:02:26,880
talk.

40
00:02:26,880 --> 00:02:31,440
So in particular, beautiful is better than ugly, explicit is better than implicit, simple

41
00:02:31,440 --> 00:02:34,520
is better than complex, readability counts.

42
00:02:34,520 --> 00:02:38,140
There should be one and preferably only one obvious way to do it.

43
00:02:38,140 --> 00:02:41,840
And if the implementation is hard to explain, it's a bad idea.

44
00:02:41,840 --> 00:02:49,800
So I think these are good guiding philosophical ideas as we go through our refactoring journey.

45
00:02:49,800 --> 00:02:54,460
The definition of refactoring from Wikipedia is sufficient in my opinion.

46
00:02:54,460 --> 00:02:59,240
Code refactoring is the process of restructuring existing computer code without changing its

47
00:02:59,240 --> 00:03:00,960
external behavior.

48
00:03:00,960 --> 00:03:05,280
So I've highlighted without changing, if you're refactoring something, you're not adding or

49
00:03:05,280 --> 00:03:09,000
at least the point is not to add additional features.

50
00:03:09,000 --> 00:03:12,800
The point is to hopefully make it more understandable.

51
00:03:12,800 --> 00:03:14,160
So why do we refactor?

52
00:03:14,160 --> 00:03:18,840
The purpose is to increase understanding and hopefully reach a more enlightened state,

53
00:03:18,840 --> 00:03:22,480
both for you, the person writing it, and then also for future people who will look at this

54
00:03:22,480 --> 00:03:25,040
code and add to it.

55
00:03:25,040 --> 00:03:26,920
So keep that purpose in mind.

56
00:03:26,920 --> 00:03:31,120
If the refactoring is making it more complicated, then we've sort of failed somewhere along

57
00:03:31,120 --> 00:03:32,520
the way.

58
00:03:32,520 --> 00:03:36,160
A couple other terms that I'll be using that I want to define.

59
00:03:36,400 --> 00:03:41,440
A design pattern is just a repeatable solution to a software engineering problem.

60
00:03:41,440 --> 00:03:44,840
And early in my career, I used to think that design patterns were something like those

61
00:03:44,840 --> 00:03:49,240
sewing patterns that they sell at Walmart, where you've got these complicated diagrams

62
00:03:49,240 --> 00:03:52,560
and all these weird names and it's hard to keep track of them.

63
00:03:52,560 --> 00:03:56,640
But I think a better analogy is more like a box of tools.

64
00:03:56,640 --> 00:04:00,320
So it really doesn't matter if you know the names for design patterns.

65
00:04:00,320 --> 00:04:02,440
There's no final exam here.

66
00:04:02,440 --> 00:04:06,880
They're just a set of tools that you probably already use pretty frequently.

67
00:04:06,880 --> 00:04:13,800
And if you can get used to that, then it'll be helpful for you as a developer.

68
00:04:13,800 --> 00:04:18,040
Code smell is defined as a characteristic in the source code of a program that possibly

69
00:04:18,040 --> 00:04:20,200
indicates a deeper problem.

70
00:04:20,200 --> 00:04:24,440
So if it's something that if you see this happening, it's a good clue that maybe you

71
00:04:24,440 --> 00:04:30,160
should look a little bit closer and see if there's something that you should change.

72
00:04:30,160 --> 00:04:33,840
Before we get started refactoring, I want to issue a warning that you should have a

73
00:04:33,840 --> 00:04:38,680
rollback strategy, particularly if you're working with live code.

74
00:04:38,680 --> 00:04:42,240
It's very possible that you'll make changes, even if you're just renaming something that

75
00:04:42,240 --> 00:04:46,240
will have unforeseen consequences on your production code.

76
00:04:46,240 --> 00:04:50,560
So make sure you have some way to roll those changes back and preferably also like a test

77
00:04:50,560 --> 00:04:55,040
suite that you can use to make sure that you haven't broken anything.

78
00:04:55,040 --> 00:04:59,560
So some of the basic tools that we have at our disposal, renaming, that's a really good

79
00:04:59,600 --> 00:05:04,280
way to make things more readable, moving or splitting things in general, and redefining

80
00:05:04,280 --> 00:05:11,000
inheritance boundaries are some of the big tools that we'll be using to refactor.

81
00:05:11,000 --> 00:05:14,960
And I'm going to go over some code smells, and they basically fit into three different

82
00:05:14,960 --> 00:05:16,400
buckets.

83
00:05:16,400 --> 00:05:19,560
First of all, when something is too long or too complex.

84
00:05:19,560 --> 00:05:23,040
Second of all, if it's not useful enough, not really doing enough for us.

85
00:05:23,040 --> 00:05:26,920
And third of all, if you've got some bad object-oriented programming going on.

86
00:05:27,320 --> 00:05:29,960
None of this means that anyone really did anything wrong.

87
00:05:29,960 --> 00:05:34,480
It might just be that the decision made sense at the time, and now in retrospect, it doesn't

88
00:05:34,480 --> 00:05:37,880
really make sense anymore.

89
00:05:37,880 --> 00:05:41,840
So the basic ways that we'll address these problems, if it's too long, we'll split it

90
00:05:41,840 --> 00:05:42,840
out.

91
00:05:42,840 --> 00:05:46,320
If it's not useful enough, then we'll compress it or put it somewhere else.

92
00:05:46,320 --> 00:05:51,760
And if there's bad object-oriented programming going on, we'll restructure it somehow.

93
00:05:51,760 --> 00:05:53,760
So quick note on code smells.

94
00:05:53,760 --> 00:05:58,200
Just because there's a code smell does not mean that you need to change anything or even

95
00:05:58,200 --> 00:06:01,440
that anything is necessarily wrong.

96
00:06:01,440 --> 00:06:05,720
There are patterns that often indicate that something could have been done better.

97
00:06:05,720 --> 00:06:08,480
But there are times when it's totally okay to have a code smell.

98
00:06:08,480 --> 00:06:11,200
So I just want to point that out.

99
00:06:11,200 --> 00:06:15,040
So the first common bucket for code smells that we're going to look at is when something

100
00:06:15,040 --> 00:06:16,560
is a little too long.

101
00:06:16,560 --> 00:06:19,520
And I also want to say that these are going to start out kind of simple, but they'll build

102
00:06:19,520 --> 00:06:20,520
on each other.

103
00:06:20,600 --> 00:06:23,760
So don't worry, it'll get more interesting.

104
00:06:23,760 --> 00:06:27,640
So the first one that we see pretty frequently is when you have duplicated code.

105
00:06:27,640 --> 00:06:30,720
So you're doing the same thing in several different places.

106
00:06:30,720 --> 00:06:36,160
This is a good clue that you should pull that out into a method or potentially a class.

107
00:06:36,160 --> 00:06:39,640
And if you're pulling something into a class, at this point, I feel like I should ask you

108
00:06:39,640 --> 00:06:43,220
and you should ask yourself, do you really need another class?

109
00:06:43,220 --> 00:06:46,880
Because that's a frequent cause of other code smells.

110
00:06:46,880 --> 00:06:50,320
So when you're kind of deciding whether or not you need a new class for this or whether

111
00:06:50,320 --> 00:06:54,880
you can just use a method, there are a couple of things you can do to make that decision

112
00:06:54,880 --> 00:06:55,880
easier.

113
00:06:55,880 --> 00:07:00,480
So you should create a class if you have something that looks like this, where you have a similar

114
00:07:00,480 --> 00:07:04,640
â€“ you have some similar arguments that are being used in multiple functions and a mix

115
00:07:04,640 --> 00:07:06,920
of mutable and immutable.

116
00:07:06,920 --> 00:07:11,360
So in this example, I'm initializing a grid structure and then I'm passing that grid.

117
00:07:11,360 --> 00:07:13,240
Sometimes I'm making changes to it.

118
00:07:13,240 --> 00:07:15,560
For check for winner, I'm not making a change.

119
00:07:15,560 --> 00:07:21,960
So this is a pretty good indication that it would be useful for me to use a class.

120
00:07:21,960 --> 00:07:25,440
In this case, it's probably better to use a function.

121
00:07:25,440 --> 00:07:29,600
You've got only two methods here, one of which is doing initialization and then a second

122
00:07:29,600 --> 00:07:30,600
one.

123
00:07:30,600 --> 00:07:32,880
And you've only got static methods.

124
00:07:32,880 --> 00:07:35,280
So really, this will work just as well as a method.

125
00:07:35,280 --> 00:07:39,920
We've got a calculator class where we're initializing two operands and one operator.

126
00:07:39,920 --> 00:07:44,000
And really, we can just do this as a function where we pass those in directly, perform the

127
00:07:44,040 --> 00:07:48,360
operation and then return it.

128
00:07:48,360 --> 00:07:51,280
Next code smell I want to talk about is long methods.

129
00:07:51,280 --> 00:07:55,400
And in this case, when I say the word long, there's no perfect cutoff point when you

130
00:07:55,400 --> 00:07:58,440
know that whatever you've written has too many lines.

131
00:07:58,440 --> 00:08:01,400
It's really more about the complexity of whatever it is.

132
00:08:01,400 --> 00:08:05,760
So I think a good guiding principle is that if you can't come up with a single cohesive

133
00:08:05,760 --> 00:08:10,640
purpose for your method or even a good name that really encompasses what it's doing,

134
00:08:10,640 --> 00:08:13,260
you might need to split out some functionality.

135
00:08:13,260 --> 00:08:17,040
But in general, you shouldn't just copy and paste pieces just because it looks a little

136
00:08:17,040 --> 00:08:18,340
too long to you.

137
00:08:18,340 --> 00:08:21,580
So we've talked about extract class and extract method.

138
00:08:21,580 --> 00:08:25,820
A couple other things you can do to doctor your code, you can replace method with method

139
00:08:25,820 --> 00:08:27,100
object.

140
00:08:27,100 --> 00:08:30,540
So here I've got a procedure where I'm passing in a bunch of different variables and doing

141
00:08:30,540 --> 00:08:32,300
a lot of computations.

142
00:08:32,300 --> 00:08:36,340
It's several lines long, so maybe I want to pull aspects of that out.

143
00:08:36,340 --> 00:08:42,300
In this case, it might be a good idea to introduce a method or a class where I can store that

144
00:08:42,340 --> 00:08:48,540
data and then pretty easily break it up into smaller pieces.

145
00:08:48,540 --> 00:08:51,340
Another thing we can do is introduce a parameter object.

146
00:08:51,340 --> 00:08:55,820
So if you have frequent groups of parameters that you're using together, like in this example,

147
00:08:55,820 --> 00:09:01,460
we've got start time and end time, then it might be a good idea to create an object,

148
00:09:01,460 --> 00:09:06,820
in this case it's called time range, to encompass those parameters.

149
00:09:06,820 --> 00:09:09,820
The next code I want to talk about is called data clumps.

150
00:09:09,820 --> 00:09:13,940
This happens if you've got frequent clumps of data appearing throughout your code.

151
00:09:13,940 --> 00:09:18,100
In this case, it might make it better to pull that clump into an object.

152
00:09:18,100 --> 00:09:21,740
And I want to point out that there's a reciprocal code smell for this one that we'll talk about

153
00:09:21,740 --> 00:09:22,740
later.

154
00:09:22,740 --> 00:09:26,900
So for a lot of these, you can take an action and if you take it too far, then you might

155
00:09:26,900 --> 00:09:29,060
end up introducing a new code smell.

156
00:09:29,060 --> 00:09:32,260
So keep in mind that it's a balance.

157
00:09:32,260 --> 00:09:36,780
The next big bucket of code smells we'll talk about is when something is not quite useful

158
00:09:36,780 --> 00:09:37,780
enough.

159
00:09:37,780 --> 00:09:41,980
So the most common one is a lazy class or a speculative generality.

160
00:09:41,980 --> 00:09:45,740
This usually happens if when I set out to create my project, I thought I was going to

161
00:09:45,740 --> 00:09:50,660
have a bunch of parent classes and subclasses and maybe I went a little overboard in creating

162
00:09:50,660 --> 00:09:51,660
those.

163
00:09:51,660 --> 00:09:55,340
And then later on when I look at it, I see that a lot of those classes aren't doing anything

164
00:09:55,340 --> 00:09:56,340
for me.

165
00:09:56,340 --> 00:10:02,500
So as an example, let's say I have an employee parent class that has a name and a salary

166
00:10:02,500 --> 00:10:04,000
associated with it.

167
00:10:04,000 --> 00:10:08,940
And then I've got an engineer, which is a subclass of employee, and an engineer has

168
00:10:08,940 --> 00:10:10,240
a team.

169
00:10:10,240 --> 00:10:13,320
And maybe when I created these, I thought I was going to have lots of different kinds

170
00:10:13,320 --> 00:10:16,160
of employees that were going to need their own information.

171
00:10:16,160 --> 00:10:20,100
Maybe only engineers would have teams and executives wouldn't have teams or something

172
00:10:20,100 --> 00:10:21,260
like that.

173
00:10:21,260 --> 00:10:25,960
But now that I'm looking at it, it seems like employee isn't really doing anything for me.

174
00:10:25,960 --> 00:10:26,960
So there's no shame in that.

175
00:10:26,960 --> 00:10:30,500
I'll just lift that value into the employee class.

176
00:10:30,500 --> 00:10:35,000
And now employee can have a concept of a team.

177
00:10:35,000 --> 00:10:39,160
The next code smell is the reciprocal of the data clumps code smell that we talked about

178
00:10:39,160 --> 00:10:40,320
earlier.

179
00:10:40,320 --> 00:10:43,920
So this happens if you end up with a lot of classes that are doing nothing but storing

180
00:10:43,920 --> 00:10:44,980
data.

181
00:10:44,980 --> 00:10:49,160
So if this happens and it's happening in a lot of places, the best thing you can do is

182
00:10:49,160 --> 00:10:53,960
probably try and find methods that are often associated with those clumps of data so that

183
00:10:53,960 --> 00:10:57,080
your class can be a little bit more useful for you.

184
00:10:57,080 --> 00:11:00,200
And again, just because this is happening doesn't mean it's a bad thing.

185
00:11:00,220 --> 00:11:03,420
It might be appropriate to have at least a few data holders.

186
00:11:03,420 --> 00:11:07,420
But if it's happening pretty frequently, then you might want to look into it a little bit more.

187
00:11:09,420 --> 00:11:13,380
So now we're going to get to the third most complicated and most interesting bucket of

188
00:11:13,380 --> 00:11:19,460
code smells, which is related to issues with object-oriented programming.

189
00:11:19,460 --> 00:11:22,460
So the first one I'll talk about is divergent change.

190
00:11:22,460 --> 00:11:26,700
This happens if one class is being changed a lot for different reasons.

191
00:11:26,700 --> 00:11:30,880
And again, this is kind of unavoidable to some extent, but if possible, each object

192
00:11:30,880 --> 00:11:35,560
should only be changed as a result of one kind of changes.

193
00:11:35,560 --> 00:11:41,360
A kind of similar code smell, and my favorite name for a code smell is shotgun surgery.

194
00:11:41,360 --> 00:11:44,600
This happens when every time you make a change, you find that you have to make changes in

195
00:11:44,600 --> 00:11:49,760
a bunch of different places, and suddenly your code kind of looks like a trauma victim.

196
00:11:49,760 --> 00:11:55,720
So this can be made better by trying to encapsulate those changes in a particular place.

197
00:11:55,740 --> 00:12:00,720
So to go through an example, let's say that I've got a bank, and those banks have offices,

198
00:12:00,720 --> 00:12:04,420
and then I've also got some type of financial regulating authority.

199
00:12:04,420 --> 00:12:09,060
My bank is doing really well, so I'm having to introduce new kinds of currency when I

200
00:12:09,060 --> 00:12:11,020
go into a new area.

201
00:12:11,020 --> 00:12:16,220
And I find that every time I have to do that, I have to make changes in all three of these places.

202
00:12:16,220 --> 00:12:20,620
So this is a good clue that maybe I want to pull those into one currency handler so that

203
00:12:20,620 --> 00:12:25,180
every time I'm adding a new currency, which is potentially something I'm doing a lot,

204
00:12:25,200 --> 00:12:29,080
I only have to make that change in one place.

205
00:12:29,080 --> 00:12:33,560
A similar code smell is called parallel inheritance hierarchies.

206
00:12:33,560 --> 00:12:38,260
This happens when every single time you make a subclass of one hierarchy, you're finding

207
00:12:38,260 --> 00:12:41,400
that you have to make it in another place as well.

208
00:12:41,400 --> 00:12:45,800
So as an example, let's say that I manage small businesses, and I've got a dentist and

209
00:12:45,800 --> 00:12:50,920
a primary care office, and I have to create a payment manager class for both of those.

210
00:12:50,920 --> 00:12:54,560
And then I find that I have to split out insurance functionality, so I find myself having to

211
00:12:54,560 --> 00:12:58,540
create that subclass again in both of those places.

212
00:12:58,540 --> 00:13:02,700
If I'm having to do that a lot, it's a good clue that maybe I want to centralize those

213
00:13:02,700 --> 00:13:06,660
and maybe have one single finance handler that can handle both of those for each of

214
00:13:06,660 --> 00:13:10,420
these different subclasses.

215
00:13:10,420 --> 00:13:13,500
Next code smell I want to talk about is called feature envy.

216
00:13:13,500 --> 00:13:17,540
This happens if you've got an object that's kind of reaching in very frequently to another

217
00:13:17,540 --> 00:13:18,540
class.

218
00:13:18,540 --> 00:13:23,460
And it's very similar to inappropriate intimacy, which happens when classes know more about

219
00:13:23,480 --> 00:13:26,840
each other than they probably should.

220
00:13:26,840 --> 00:13:31,880
So as an example, let's say I've got an entree class, and I'm reaching into this junk food

221
00:13:31,880 --> 00:13:36,880
class pretty frequently to do things like get the calorie content for my entree, find

222
00:13:36,880 --> 00:13:38,600
out how much sugar is in it.

223
00:13:38,600 --> 00:13:43,680
And a good clue here that something is messed up is the names, because an entree isn't necessarily

224
00:13:43,680 --> 00:13:45,260
junk food.

225
00:13:45,260 --> 00:13:50,840
So it probably makes more sense to pull those functions out into a nutrition info provider

226
00:13:50,940 --> 00:13:55,620
so that both my entree and my junk food can access it.

227
00:13:55,620 --> 00:13:57,780
The next code smell is somewhat visual.

228
00:13:57,780 --> 00:14:01,620
This happens when you've got a lot of different switch statements.

229
00:14:01,620 --> 00:14:05,740
And generally the way that we address this is by taking those switch statements out into

230
00:14:05,740 --> 00:14:10,820
a method, finding a class where we can store that method, and then attempting to extract

231
00:14:10,820 --> 00:14:13,660
what we're switching upon into state.

232
00:14:13,660 --> 00:14:18,260
So for example, if you're switching on employee type, you could create employee type as a

233
00:14:18,320 --> 00:14:23,680
class and then use that to figure out which employee you're looking at.

234
00:14:23,680 --> 00:14:25,980
Next code smell is called message chains.

235
00:14:25,980 --> 00:14:30,200
This happens if you have one client that has to keep asking an object about another object

236
00:14:30,200 --> 00:14:34,400
and then maybe this object about another object and so on and so forth.

237
00:14:34,400 --> 00:14:37,520
So there are a couple ways to address that, but the one I want to talk about is called

238
00:14:37,520 --> 00:14:39,600
hide delegate.

239
00:14:39,600 --> 00:14:43,840
So let's imagine that I have a client, and it needs to figure out it's reaching into

240
00:14:43,840 --> 00:14:47,720
an object to figure out a person, and then to figure out the department that that person

241
00:14:47,740 --> 00:14:48,740
belongs to.

242
00:14:48,740 --> 00:14:53,020
It has to go to the department, and maybe it's looking at both person and department.

243
00:14:53,020 --> 00:14:57,900
Sometimes it looks at department to get the manager, and that can be kind of confusing.

244
00:14:57,900 --> 00:15:01,540
So ideally the client should only have to have knowledge of one of those, so we can

245
00:15:01,540 --> 00:15:07,060
hide this delegate by having the client interact only with person, which will interact on its

246
00:15:07,060 --> 00:15:09,500
own with department.

247
00:15:09,500 --> 00:15:13,180
And the reciprocal code smell here is called middleman, which happens when you've got a

248
00:15:13,180 --> 00:15:16,260
bunch of classes that are only acting as delegates.

249
00:15:16,280 --> 00:15:22,080
So if that happens, you probably need to go through and delete some along the way.

250
00:15:22,080 --> 00:15:25,840
This code smell has probably the most complicated name.

251
00:15:25,840 --> 00:15:30,200
This happens, it's called refused bequest, and basically it just means that a child class

252
00:15:30,200 --> 00:15:32,960
doesn't need everything that it's inheriting.

253
00:15:32,960 --> 00:15:37,640
So as a general guideline, if a child should need everything that its parent is giving

254
00:15:37,640 --> 00:15:41,640
it, and if it does not, the best thing you can probably do is push down some of that

255
00:15:41,640 --> 00:15:44,640
functionality into a sibling class.

256
00:15:46,360 --> 00:15:50,840
And this is getting into an important concept here, which is the difference in the trade-offs

257
00:15:50,840 --> 00:15:53,720
between inheritance and composition.

258
00:15:53,720 --> 00:15:56,880
And there's enough material here to go into another talk.

259
00:15:56,880 --> 00:16:00,520
In fact, there was a talk about this same subject yesterday, so I'm not going to go

260
00:16:00,520 --> 00:16:05,160
into it too much, but basically you want to ask yourself, do I need to inherit all of

261
00:16:05,160 --> 00:16:09,520
the things this parent can do, and if not, is it better to just contain the specific

262
00:16:09,520 --> 00:16:11,320
functionality I need?

263
00:16:12,320 --> 00:16:17,060
So the basic smells, or the basic categories of smells that we've looked at, are when something

264
00:16:17,060 --> 00:16:18,580
is too long, we split it out.

265
00:16:18,580 --> 00:16:23,180
If it's not useful enough, we need to compress it or move the functionality, and if we've

266
00:16:23,180 --> 00:16:27,260
got bad object-oriented programming, we're restructuring.

267
00:16:27,260 --> 00:16:31,980
So now I want to talk about specific code smells for Python.

268
00:16:31,980 --> 00:16:37,300
So the first one, and I guess this isn't necessarily specific to Python, is extremely nested code

269
00:16:37,300 --> 00:16:39,740
where you've got a lot of if statements.

270
00:16:39,740 --> 00:16:43,480
In Python, often there are things you can do to rip that out entirely.

271
00:16:43,480 --> 00:16:47,520
So like, for example, if you're looking at a list and doing a lot of boundary checking,

272
00:16:47,520 --> 00:16:51,080
often you can just use an iterator and avoid doing all of that.

273
00:16:51,080 --> 00:16:55,400
But I am going to go through a longer demo for one of these in a couple of minutes, so

274
00:16:55,400 --> 00:16:57,200
we'll come back to this.

275
00:16:58,200 --> 00:17:00,520
Unnecessary boilerplate code.

276
00:17:00,520 --> 00:17:04,600
This happens if you've got a class that's basically just storing a bunch of data and

277
00:17:04,600 --> 00:17:07,400
maybe overriding a couple of things.

278
00:17:07,400 --> 00:17:11,200
So if this happens, you're probably reinventing the wheel a little bit.

279
00:17:11,200 --> 00:17:16,720
So as an example, let's say that I've got this math object, and I'm storing a bunch

280
00:17:16,720 --> 00:17:21,140
of variables, and then I'm redefining the repr method and the string method.

281
00:17:21,140 --> 00:17:24,820
So if I'm doing this, the odds are that I could use something else.

282
00:17:24,820 --> 00:17:28,780
In particular, I could do this with a data class where I pass in all the variables I

283
00:17:28,780 --> 00:17:32,820
need and their types, and then it will redefine repr and string for me.

284
00:17:32,820 --> 00:17:38,120
Or I could use an adder, kind of a similar concept here.

285
00:17:38,120 --> 00:17:42,340
The next Python code smell I want to talk about is when your exception handling is too

286
00:17:42,340 --> 00:17:45,260
tightly coupled to your business logic.

287
00:17:45,260 --> 00:17:48,180
So in general, we like those to be kind of separate because it's just easier to read

288
00:17:48,180 --> 00:17:49,860
and nicer to deal with.

289
00:17:49,860 --> 00:17:54,540
So if this happens, then hopefully you can push down your exception handling maybe like

290
00:17:54,540 --> 00:17:58,360
in a try and accept block.

291
00:17:58,360 --> 00:18:03,200
And the last Python specific code smell I'll talk about is if you're repeating set up and

292
00:18:03,200 --> 00:18:05,640
tear down actions frequently.

293
00:18:05,640 --> 00:18:08,880
So if this is happening, you might want to introduce a context manager, which you would

294
00:18:08,880 --> 00:18:11,760
usually call using the with method.

295
00:18:11,760 --> 00:18:13,320
Great.

296
00:18:13,320 --> 00:18:18,040
So now I said I would do a demo of a longer example with nested if statements.

297
00:18:18,040 --> 00:18:19,160
So that's what I'm going to do.

298
00:18:19,160 --> 00:18:22,080
And I will point out what's important, so if you can't read this or see it, hopefully

299
00:18:22,080 --> 00:18:24,720
that will be okay.

300
00:18:24,720 --> 00:18:28,600
So let's say that I'm building a restaurant menu and I want to be able to decide what

301
00:18:28,600 --> 00:18:30,920
the menu looks like at a given night.

302
00:18:30,920 --> 00:18:34,760
And I'm going to base that off of what ingredients were freshly available at the market in a

303
00:18:34,760 --> 00:18:35,760
given day.

304
00:18:35,760 --> 00:18:40,240
And let's also say, so these are the basic things I can make at my restaurant.

305
00:18:40,240 --> 00:18:42,320
It's very basic.

306
00:18:42,320 --> 00:18:44,320
I can make pizza with bread and sauce.

307
00:18:44,320 --> 00:18:49,440
I can make grilled cheese with cheese and bread, fish, cheese and fish, and then steak.

308
00:18:49,440 --> 00:18:51,740
So very simple options here.

309
00:18:51,740 --> 00:18:55,380
And let's say I want to vary my menu based on season.

310
00:18:55,380 --> 00:18:58,680
So now I have to look at the ingredients I have available and the season that I'm in

311
00:18:58,680 --> 00:19:00,900
to decide a menu.

312
00:19:00,900 --> 00:19:03,500
And let's also say that I'm very frugal.

313
00:19:03,500 --> 00:19:05,540
I want to increase my profit margin.

314
00:19:05,540 --> 00:19:11,880
So I only want to offer the customer the cheapest thing that I'm capable of making.

315
00:19:11,880 --> 00:19:15,180
So let's say I just kind of like puke this logic into code.

316
00:19:15,180 --> 00:19:17,500
I might end up with something that looks like this.

317
00:19:17,500 --> 00:19:18,500
You don't have to read it.

318
00:19:18,500 --> 00:19:22,420
Basically, I'm just going through and looking at the season and then figuring out if I can

319
00:19:22,420 --> 00:19:25,100
make the first cheapest option for that season.

320
00:19:25,100 --> 00:19:26,380
And if I can, I return that.

321
00:19:26,380 --> 00:19:29,540
Then I go to the next option and so on and so forth.

322
00:19:29,540 --> 00:19:33,580
And you have to read it a couple of times to really parse what's going on.

323
00:19:33,580 --> 00:19:36,500
So obviously, this is a good candidate for refactoring.

324
00:19:36,500 --> 00:19:41,340
But before we do that, I want to show what will happen if we have to add functionality.

325
00:19:41,340 --> 00:19:45,580
So let's say that now I need to track whether or not my customer ordered an alcoholic drink

326
00:19:45,580 --> 00:19:46,580
with their order.

327
00:19:46,740 --> 00:19:51,260
And let's say there's a law that mandates that if I'm ordering an alcoholic drink, I

328
00:19:51,260 --> 00:19:54,940
have to eat an entree that has protein in it.

329
00:19:54,940 --> 00:19:58,300
So now I need to keep track of whether or not they ordered a drink, the season I'm in,

330
00:19:58,300 --> 00:20:01,580
and the ingredients that I have available.

331
00:20:01,580 --> 00:20:06,580
So if I just add this parameter to all of the statements where I need it, that's how

332
00:20:06,580 --> 00:20:07,580
that looks.

333
00:20:07,580 --> 00:20:09,860
I have to make that change in a lot of different places.

334
00:20:09,860 --> 00:20:14,300
And now my logic is getting even worse and harder to look at, which is bound to happen

335
00:20:14,380 --> 00:20:18,140
when you have code that needs to be refactored.

336
00:20:18,140 --> 00:20:22,060
So first thing I'm going to do here is switch to using a list of menu items.

337
00:20:22,060 --> 00:20:26,820
So rather than returning the first available cheapest option, we will put the cheapest

338
00:20:26,820 --> 00:20:31,380
option in first and then return a list that's sorted by the cheapest available entree to

339
00:20:31,380 --> 00:20:33,620
the most expensive.

340
00:20:33,620 --> 00:20:38,620
So here I'm just adding a list and then appending to it before I return.

341
00:20:38,620 --> 00:20:45,260
The next thing I'm going to do is pull out this kind of icky logic into methods for two

342
00:20:45,260 --> 00:20:46,260
reasons.

343
00:20:46,260 --> 00:20:49,300
First of all, because it will make the if statements more descriptive.

344
00:20:49,300 --> 00:20:53,140
And second of all, because as a rule, these statements are going to get more complicated,

345
00:20:53,140 --> 00:20:55,140
not less.

346
00:20:55,140 --> 00:20:57,220
So just a couple of things to point out here.

347
00:20:57,220 --> 00:21:02,420
I have a menu class where I am mapping each entree to the ingredients that compose it.

348
00:21:02,420 --> 00:21:06,500
And then I'm going through and I'm just figuring out if I can make each one of those entrees.

349
00:21:06,500 --> 00:21:10,140
And if I can, then that's a possible dish for that night.

350
00:21:10,140 --> 00:21:13,700
And if my person has ordered a drink, then I know that I can only use entrees from the

351
00:21:13,700 --> 00:21:16,900
proteins list.

352
00:21:16,900 --> 00:21:21,140
So now I have a series of methods where I can get the menu according to a season based

353
00:21:21,140 --> 00:21:25,820
on what entrees are available in that season.

354
00:21:25,820 --> 00:21:28,840
And now my logic is a lot cleaner to look at.

355
00:21:28,840 --> 00:21:34,540
I just check what season I'm looking at and then get the menu for that particular season.

356
00:21:34,540 --> 00:21:38,740
The next thing I'm going to do is pull these functions into methods for a few different

357
00:21:38,740 --> 00:21:39,740
reasons.

358
00:21:39,740 --> 00:21:43,020
First of all, so I can kind of precompute the menu for that night rather than doing

359
00:21:43,020 --> 00:21:44,700
it in each if statement.

360
00:21:44,700 --> 00:21:49,180
I'm going to override the bool method so that I can easily check which menu to use.

361
00:21:49,180 --> 00:21:53,300
And then mainly really the third reason is it will make my unit test easy because now

362
00:21:53,300 --> 00:21:56,880
I can just create this object and kind of spot check a couple of things rather than

363
00:21:56,880 --> 00:22:02,340
having to look at the menu and check that certain things were called internally.

364
00:22:02,340 --> 00:22:08,500
So now I'm adding a concept of season to my menu and I have subclasses that store the

365
00:22:08,500 --> 00:22:12,540
options for that particular night and a bool method which will tell me if I'm looking at

366
00:22:12,540 --> 00:22:13,540
the right season.

367
00:22:13,540 --> 00:22:15,900
So now my code looks like this.

368
00:22:15,900 --> 00:22:19,580
I check to see if it's appropriate to use the summer menu and if it is, I grab that

369
00:22:19,580 --> 00:22:20,820
menu.

370
00:22:20,820 --> 00:22:21,940
This code is still not perfect.

371
00:22:21,940 --> 00:22:26,100
I could be returning directly for starters rather than grabbing the menu since I will

372
00:22:26,100 --> 00:22:28,380
only be in one season at a time.

373
00:22:28,380 --> 00:22:30,560
But this is where we're going to leave it for now.

374
00:22:30,560 --> 00:22:33,680
So I want to point out a few things.

375
00:22:33,680 --> 00:22:36,660
First of all, don't add your functionality while you're refactoring.

376
00:22:36,660 --> 00:22:40,480
You want to do that before you refactor or after you've refactored everything.

377
00:22:40,480 --> 00:22:45,360
If you try to do them both simultaneously, it will probably be a bad time.

378
00:22:45,360 --> 00:22:49,200
You want to make changes incrementally and then if you can, hopefully verify that your

379
00:22:49,200 --> 00:22:52,000
tests continue to pass as you're going.

380
00:22:52,000 --> 00:22:55,960
And remember that making progress is better than ending up with perfect code.

381
00:22:55,960 --> 00:22:59,760
So when you're refactoring, it's pretty easy to go down this rabbit hole where you're like,

382
00:22:59,760 --> 00:23:02,720
OK, I need to change this, so this class should really be like this, and now I need a new

383
00:23:02,720 --> 00:23:06,280
class here, and kind of end up changing everything.

384
00:23:06,280 --> 00:23:10,980
And it's better to just make progress incrementally rather than getting yourself into a mess or

385
00:23:10,980 --> 00:23:14,460
rewriting all of the code.

386
00:23:14,460 --> 00:23:17,000
So how are we going to do the refactoring?

387
00:23:17,000 --> 00:23:19,280
Few different strategies.

388
00:23:19,280 --> 00:23:22,740
Test-driven development, if you have good tests, then run them repeatedly to make sure

389
00:23:22,740 --> 00:23:25,020
things still pass between changes.

390
00:23:25,020 --> 00:23:29,980
And if not, create the tests that you wanted and then refactor until they pass.

391
00:23:29,980 --> 00:23:33,460
Litter pickup, if you want to do it incrementally along the way.

392
00:23:33,460 --> 00:23:39,340
So small things that you can do, add a repr for debugging, delete or migrate unused functionality.

393
00:23:39,340 --> 00:23:43,420
And then one that we do on my team, if you have a comment that indicates that something

394
00:23:43,420 --> 00:23:48,220
was not clear enough to stand by itself, so if you can refactor to make it stand alone

395
00:23:48,220 --> 00:23:52,780
and then remove the comment, that's an easy thing to do.

396
00:23:52,780 --> 00:23:56,220
Preparation if you want to start by understanding the code and then take that understanding

397
00:23:56,220 --> 00:24:01,380
and put it into the codes, the next person has an easier time.

398
00:24:01,380 --> 00:24:05,820
Preparatory if you want to refactor so that you can do something else later.

399
00:24:05,820 --> 00:24:09,940
Planned which happens if you have to actually schedule out the refactoring, which probably

400
00:24:09,940 --> 00:24:12,860
means that you waited a little too long.

401
00:24:12,860 --> 00:24:16,700
And red-green refactoring which is very similar to test-driven development where you create

402
00:24:16,700 --> 00:24:20,120
the tests that you want and then they will fail and then you kind of refactor until they

403
00:24:20,120 --> 00:24:22,360
pass.

404
00:24:22,360 --> 00:24:24,220
So now I want to throw a wrench in this.

405
00:24:24,220 --> 00:24:25,920
What if we need to maintain backwards compatibility?

406
00:24:25,920 --> 00:24:28,120
I will do this quickly.

407
00:24:28,120 --> 00:24:30,520
Let's say we're going to use an expand contract pattern.

408
00:24:30,520 --> 00:24:34,240
So we have the old code, we'll add the new code alongside it and then we'll contract

409
00:24:34,240 --> 00:24:35,980
to just the new code.

410
00:24:35,980 --> 00:24:40,560
So in Python, we can split classes by passing in optional parameters and then issue warnings

411
00:24:40,560 --> 00:24:42,160
in the old code path.

412
00:24:42,160 --> 00:24:46,280
So as an example, if I have a Cheeto class with a name and amount and a cost and then

413
00:24:46,280 --> 00:24:50,840
I start to add parameters to it like spiciness and kind of cheese, then I decide to lift

414
00:24:51,000 --> 00:24:54,320
some of that into a parent class called snack.

415
00:24:54,320 --> 00:24:56,280
So now I have two different code paths.

416
00:24:56,280 --> 00:25:01,040
If I'm passing in my snack parent class, then I'll use that and if not, I'll accept parameters

417
00:25:01,040 --> 00:25:02,640
to build it myself.

418
00:25:02,640 --> 00:25:06,200
And then I also want to issue a warning in the second case to tell the person that they

419
00:25:06,200 --> 00:25:08,640
should be using the refactored version.

420
00:25:08,640 --> 00:25:09,840
Great.

421
00:25:09,840 --> 00:25:13,760
So now back to that same question to refactor or not.

422
00:25:13,760 --> 00:25:15,160
When to not refactor?

423
00:25:15,160 --> 00:25:18,080
If you can add better documentation instead.

424
00:25:18,080 --> 00:25:22,080
So if that's possible to just document an endpoint, you might want to do that.

425
00:25:22,080 --> 00:25:27,680
If you're just showing off by showing that you can do like a 360 deluxe prototype refactor,

426
00:25:27,680 --> 00:25:32,420
then that's probably not a great idea and it won't make your coworkers like you more.

427
00:25:32,420 --> 00:25:37,440
And if you need to rewrite it from scratch, then you might not even bother refactoring.

428
00:25:37,440 --> 00:25:42,240
So in general, good reasons to refactor if you've regretted not doing this before.

429
00:25:42,240 --> 00:25:47,160
If no one on the team has any idea what this does anymore, then it's a good idea, then

430
00:25:47,160 --> 00:25:51,160
you can be that person who kind of works in understanding and then puts that into the

431
00:25:51,160 --> 00:25:52,440
code.

432
00:25:52,440 --> 00:25:56,840
And then if refactoring this code now will definitely make it easier to change later

433
00:25:56,840 --> 00:26:01,480
on, those are all good reasons to refactor.

434
00:26:01,480 --> 00:26:07,320
And remember that our mantra here when it comes to refactoring is progress, not perfection.

435
00:26:07,320 --> 00:26:10,120
So we're trying to make progress with the code that we're writing and in fact, it's

436
00:26:10,120 --> 00:26:14,680
better to start with a smaller change so that everyone can kind of get used to how this

437
00:26:14,680 --> 00:26:19,000
works rather than rewriting everything altogether and now you might end up with the same issue

438
00:26:19,000 --> 00:26:24,280
where there's only one person who understands how all of this works.

439
00:26:24,280 --> 00:26:29,080
So I want to say that a lot of the code smells, most of the code smells in this talk are from

440
00:26:29,080 --> 00:26:32,360
the book Refactoring, which is written by Martin Fowler.

441
00:26:32,360 --> 00:26:37,000
So if you're interested in learning more about code smells or design patterns, then that's

442
00:26:37,000 --> 00:26:41,040
an excellent place to start.

443
00:26:41,440 --> 00:26:46,000
If you take anything away from this talk, first of all, if you get the sense that there's

444
00:26:46,000 --> 00:26:50,840
a code smell here, so if your spidey senses are sort of starting to tingle and you feel

445
00:26:50,840 --> 00:26:54,640
like there's something wrong, then pay attention to that feeling or that instinct and it will

446
00:26:54,640 --> 00:26:58,140
probably get sharper as you go on in your career.

447
00:26:58,140 --> 00:27:02,480
That means that there's something that's worth looking into and it's not a hard and fast

448
00:27:02,480 --> 00:27:06,960
rule if there's a code smell that doesn't mean that something necessarily has to change,

449
00:27:06,960 --> 00:27:10,000
but it is worth paying attention to.

450
00:27:10,000 --> 00:27:14,880
Remember that the true meaning of refactoring is to arrive at a better understanding ultimately

451
00:27:14,880 --> 00:27:17,560
and something that is easier to maintain.

452
00:27:17,560 --> 00:27:22,080
So if you've done a lot of refactoring and it ends up more complicated, that means that

453
00:27:22,080 --> 00:27:24,760
something went amiss along the way.

454
00:27:24,760 --> 00:27:28,520
And try and think about your strategy for refactoring before jumping in.

455
00:27:28,520 --> 00:27:33,040
So at a minimum, this means having a rollback strategy and hopefully some kind of test suite

456
00:27:33,040 --> 00:27:37,400
that you can use to make sure you didn't break anything, but it also means being deliberate

457
00:27:37,400 --> 00:27:39,720
about how you do the refactoring.

458
00:27:39,720 --> 00:27:43,580
So taking the time to say, okay, if I refactor this piece, then I need to have backwards

459
00:27:43,580 --> 00:27:47,880
compatibility here, so I'm going to do that and then I'll work on this piece and kind

460
00:27:47,880 --> 00:27:52,880
of break it up in a thoughtful way so that you don't just dive in and kind of get yourself

461
00:27:52,880 --> 00:27:56,880
into a quandary where you're not able to change anything anymore.

462
00:27:56,880 --> 00:27:58,800
Great.

463
00:27:58,800 --> 00:28:00,440
So thank you for coming.

464
00:28:00,440 --> 00:28:05,080
I tweeted out these slides and I'm not going to be doing open Q&A, so if you do want to

465
00:28:05,080 --> 00:28:09,680
talk, happy to discuss this or more code smells, feel free to tweet at me or come talk to me

466
00:28:09,720 --> 00:28:11,560
in person.

467
00:28:11,560 --> 00:28:12,560
And thank you.

468
00:28:12,560 --> 00:28:13,560
Have a good rest of your PyCon.

469
00:28:13,560 --> 00:28:14,060
Applause.

