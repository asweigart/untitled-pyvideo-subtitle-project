1
00:00:30,000 --> 00:00:37,120
Welcome to this afternoon's session of PyCon 2019.

2
00:00:37,120 --> 00:00:38,800
Our next presenter is Bernard Gabour.

3
00:00:38,800 --> 00:00:40,600
He will be speaking to us about type inting.

4
00:00:40,600 --> 00:00:48,200
Please make him feel welcome.

5
00:00:48,200 --> 00:00:51,360
Thank you and thank you everyone for joining for this session.

6
00:00:51,360 --> 00:00:56,480
I'm Bernard Gabour and I will try to convince you in the next half hour that type inting

7
00:00:56,480 --> 00:00:59,760
in Python is a good thing and hopefully you should use it.

8
00:00:59,760 --> 00:01:00,760
Okay.

9
00:01:00,760 --> 00:01:02,240
So first, who am I?

10
00:01:02,240 --> 00:01:06,680
I'm quite a wide participant of the open source ecosystem.

11
00:01:06,680 --> 00:01:09,200
I maintain both the virtual and the talks tool.

12
00:01:09,200 --> 00:01:13,720
Plus, I work at the Bloomberg as a software engineer, mostly on data ingestion and quality

13
00:01:13,720 --> 00:01:14,720
control.

14
00:01:14,720 --> 00:01:19,320
But most importantly for this talk, I did attend the typing summit which happened just

15
00:01:19,320 --> 00:01:23,080
a few days ago, which means that hopefully I should be perfectly positioned to actually

16
00:01:24,080 --> 00:01:27,680
not just what is in typing, what is next for typing.

17
00:01:27,680 --> 00:01:28,680
Okay.

18
00:01:28,680 --> 00:01:30,240
So I hear you all.

19
00:01:30,240 --> 00:01:31,240
Yeah.

20
00:01:31,240 --> 00:01:33,920
Typing in Python, I get this question, yeah, really?

21
00:01:33,920 --> 00:01:37,920
And I'm like, okay, why should I add typing to the Python?

22
00:01:37,920 --> 00:01:41,120
Shouldn't I just write Java in that case?

23
00:01:41,120 --> 00:01:42,680
And my answer is that no.

24
00:01:42,680 --> 00:01:44,960
Actually adding typing in Python is good.

25
00:01:44,960 --> 00:01:50,600
And just a disclaimer, I do like very much seers and penguins and because this is quite

26
00:01:50,600 --> 00:01:55,600
a dense subject, I added a few of them into the slides so it gets a bit more congestible.

27
00:01:55,600 --> 00:01:56,600
Okay.

28
00:01:56,600 --> 00:02:05,120
So typing was added in Python back in 2017, I think, with Python 3.5.

29
00:02:05,120 --> 00:02:08,120
The foundation lay down in the PATH 4.8.

30
00:02:08,120 --> 00:02:13,880
It was actually initially designed, the accepted solution was initially designed by Juca in

31
00:02:13,880 --> 00:02:19,240
MyPy and then Guido inspected that and liked what he saw and basically together with Ivan

32
00:02:19,400 --> 00:02:24,800
and Lucas kind of adopted improved on the MyPy and that's what we have now in the language.

33
00:02:24,800 --> 00:02:30,000
With Python 3.5, you can actually just do from typing import any and that typing module

34
00:02:30,000 --> 00:02:35,000
actually contains a lot of type definitions what you can use to type into your code.

35
00:02:35,000 --> 00:02:36,160
Okay.

36
00:02:36,160 --> 00:02:40,600
So the obvious disclaimer, if you're still on Python, we have bad news for you.

37
00:02:40,600 --> 00:02:43,000
You don't have much left, meaning like seven months.

38
00:02:43,000 --> 00:02:44,960
This era has come to an end.

39
00:02:44,960 --> 00:02:46,580
But you don't have to disappear.

40
00:02:46,580 --> 00:02:51,820
You can actually still use typing even on Python 2.7 and Dropbox, for example, uses

41
00:02:51,820 --> 00:02:57,140
heavily like this, the type information, and it has been backported via PyPI package so

42
00:02:57,140 --> 00:03:00,180
you can just import it and happily use it.

43
00:03:00,180 --> 00:03:01,260
Okay.

44
00:03:01,260 --> 00:03:03,980
So the first question is, like always, why do it?

45
00:03:03,980 --> 00:03:07,140
This is the part where I try to sell you this.

46
00:03:07,140 --> 00:03:12,060
Why do you think, why do I think that adding type information is going to improve your

47
00:03:12,060 --> 00:03:15,140
code base even if it might hurt a bit?

48
00:03:15,140 --> 00:03:19,860
So the first and the biggest argument, I think, is that once you add type information, the

49
00:03:19,860 --> 00:03:24,320
code base becomes a lot easier to understand and reason about it, meaning that it's going

50
00:03:24,320 --> 00:03:28,300
to also become a lot easier to maintain and it's also going to become a lot easier to

51
00:03:28,300 --> 00:03:31,740
actually debug your code base because you're always going to be in control.

52
00:03:31,740 --> 00:03:39,360
You're always going to know what function, what type of input types it actually accepts.

53
00:03:39,360 --> 00:03:43,660
So for example, if I have this random function called send request, without type information,

54
00:03:43,660 --> 00:03:47,860
it would be quite hard for me to tell what each of these accepted arguments are.

55
00:03:47,860 --> 00:03:51,740
For example, I know that in this case that the request can really be anything, but for

56
00:03:51,740 --> 00:03:55,900
example, the headers always must be a dictionary of string to string.

57
00:03:55,900 --> 00:03:58,980
For example, I cannot have numbers inside the values there.

58
00:03:58,980 --> 00:03:59,980
Okay?

59
00:03:59,980 --> 00:04:03,660
And this makes it just much more declarative, much clearer if you like even want to debug

60
00:04:03,660 --> 00:04:07,540
or just read the code, what kind of cases you need to care, what kind of options you

61
00:04:07,540 --> 00:04:11,060
actually have to treat within your code.

62
00:04:11,060 --> 00:04:15,220
So it makes also refactoring easier.

63
00:04:15,220 --> 00:04:19,740
If you can actually, if you have type information, you can easily find out what are the usages

64
00:04:19,740 --> 00:04:20,740
of your type.

65
00:04:20,740 --> 00:04:23,740
You can easily find out call here for your code.

66
00:04:23,740 --> 00:04:28,420
You can actually make the life of your idea a lot better.

67
00:04:28,420 --> 00:04:32,300
You're going to actually know where and how your objects are used, even without actually

68
00:04:32,300 --> 00:04:34,700
running and inspecting the code.

69
00:04:34,700 --> 00:04:35,700
Okay?

70
00:04:35,700 --> 00:04:40,700
One of the biggest benefits, at least, I find is that my editor suddenly becomes not the

71
00:04:40,740 --> 00:04:46,380
best effort code suggestion, but instead becomes a very accurate code suggestion.

72
00:04:46,380 --> 00:04:50,580
Whenever something is there, so what kind of functions can I call on this function?

73
00:04:50,580 --> 00:04:55,180
It's going to exactly tell me with the exact argument types what are the right and what

74
00:04:55,180 --> 00:04:58,300
are the bad way of evoking it.

75
00:04:58,300 --> 00:05:03,580
And one of the big benefits is that now you can actually run rain checkers on your code.

76
00:05:03,580 --> 00:05:07,740
Your ID, both Python and Visual Studio code, actually does this lovely.

77
00:05:07,980 --> 00:05:11,580
It's going to display your suggestion that, hey, whatever you have here are really bad.

78
00:05:11,580 --> 00:05:13,300
Maybe you should not do it.

79
00:05:13,300 --> 00:05:17,660
But more importantly, you have multiple type checkers available.

80
00:05:17,660 --> 00:05:20,380
For example, MyPy is one of these type checkers.

81
00:05:20,380 --> 00:05:24,700
It is kind of like the reference implementation of the type checkers.

82
00:05:24,700 --> 00:05:25,700
But you have other tools.

83
00:05:25,700 --> 00:05:31,980
For example, Pyre is developed by Facebook or PyType developed by Google or PyRyc developed

84
00:05:31,980 --> 00:05:36,620
by Microsoft are all valid type checkers that you can use to actually improve it or check

85
00:05:36,620 --> 00:05:42,060
that type annotation while your code is correct.

86
00:05:42,060 --> 00:05:46,460
The interesting thing about this, one is that the PyWrite, for example, is actually written

87
00:05:46,460 --> 00:05:47,620
in TypeScript.

88
00:05:47,620 --> 00:05:54,620
So actually there is now JavaScript code that helps Python, which is kind of odd.

89
00:05:54,620 --> 00:05:58,820
So another thing is that your documentation will be much improved.

90
00:05:58,820 --> 00:06:04,140
You no longer will have to specify in your documentation with a long list of human readable

91
00:06:04,140 --> 00:06:05,780
way of what are the correct types.

92
00:06:05,780 --> 00:06:09,900
You can actually now take the type annotations and put it directly in your documentation.

93
00:06:09,900 --> 00:06:15,860
And the user will have a well-defined way of reading exactly what are the correct type

94
00:06:15,860 --> 00:06:17,900
information.

95
00:06:17,900 --> 00:06:19,500
But this is OK.

96
00:06:19,500 --> 00:06:22,300
Another use case which you can have is basically data validations.

97
00:06:22,300 --> 00:06:27,060
For example, you can use the PyDentic library, which is going to take all this type information

98
00:06:27,060 --> 00:06:30,600
and can actually enforce at runtime the values.

99
00:06:30,600 --> 00:06:35,740
So it means that you no longer have to have at the start of your function like five lines

100
00:06:35,740 --> 00:06:37,580
where you just validated the arguments.

101
00:06:37,580 --> 00:06:41,780
You can basically just ask, in this case, PyDentic, hey, use the type information and

102
00:06:41,780 --> 00:06:47,420
make sure everything I pass there is also accurate at runtime, not just at the static

103
00:06:47,420 --> 00:06:50,460
analyzer at the analyzing time.

104
00:06:50,460 --> 00:06:51,620
OK.

105
00:06:51,620 --> 00:06:56,580
Another interesting use case, for example, Facebook users, this is to actually detect

106
00:06:56,580 --> 00:06:58,620
security vulnerabilities.

107
00:06:58,620 --> 00:07:05,260
Because for example, if you manage to type in all your user inputs as unsafe strings,

108
00:07:05,260 --> 00:07:10,780
you can actually use the static checker to validate that unsafe strings never get passed

109
00:07:10,780 --> 00:07:13,900
into the unsafe functions.

110
00:07:13,900 --> 00:07:18,820
For example, calling out the subprocess or generally just like maybe database injection,

111
00:07:18,820 --> 00:07:20,380
that kind of thing.

112
00:07:20,380 --> 00:07:26,100
You can then check with the type enter that everything that is in your code base is first

113
00:07:26,100 --> 00:07:34,020
validated and escaped before actually passing on to any security flaws into the downstream.

114
00:07:34,540 --> 00:07:35,540
OK.

115
00:07:35,540 --> 00:07:39,220
So for example, in this case, we can know that this first one is an error.

116
00:07:39,220 --> 00:07:43,420
You should never pass into a subprocess check called an unsafe string.

117
00:07:43,420 --> 00:07:46,140
But if you pass the second one, that's perfectly fine.

118
00:07:46,140 --> 00:07:53,180
That's probably something that the actual programmer wrote in and it's like an approved

119
00:07:53,180 --> 00:07:54,780
type of invocation.

120
00:07:54,780 --> 00:07:56,060
OK.

121
00:07:56,060 --> 00:07:57,420
So yeah.

122
00:07:57,420 --> 00:07:58,420
So what it is not.

123
00:07:58,460 --> 00:08:05,300
So I tell you what everything that was the dream was for typing thing to be.

124
00:08:05,300 --> 00:08:09,220
I'm going to also tell you what it wasn't designed to be, just to give you like a hint

125
00:08:09,220 --> 00:08:12,900
of if you want to use it for this, you might find rough edges around it.

126
00:08:12,900 --> 00:08:15,660
So it wasn't used to actually do runtime type inferences.

127
00:08:15,660 --> 00:08:19,380
Like the Python interpreter will never actually try to at runtime check that whatever your

128
00:08:19,380 --> 00:08:20,780
type is there.

129
00:08:20,780 --> 00:08:27,900
Essentially, any type information you had, the interpreter basically treats it as comment.

130
00:08:27,900 --> 00:08:29,380
So it's ignored.

131
00:08:29,380 --> 00:08:33,460
It also wasn't added to improve performance of the actual framework.

132
00:08:33,460 --> 00:08:37,180
But wait, this was actually two days ago, but apparently no longer.

133
00:08:37,180 --> 00:08:41,900
Because there's these people at the MyPy who found that the MyPy itself is kind of slow.

134
00:08:41,900 --> 00:08:43,900
And they were like, how can we improve it?

135
00:08:43,900 --> 00:08:48,860
And because MyPy itself is written in Python, they had this great idea that what if we can

136
00:08:48,860 --> 00:08:53,780
actually somehow remove all the unneeded checks?

137
00:08:53,780 --> 00:08:58,260
So they created a MyPy which actually compiles your Python code into C code.

138
00:08:58,260 --> 00:09:02,340
And this way you can get performance benefit out of that.

139
00:09:02,340 --> 00:09:08,180
For example, MyPy itself managed to get a four-time speed improvement, mostly by avoiding

140
00:09:08,180 --> 00:09:10,100
hash table lookups.

141
00:09:10,100 --> 00:09:13,820
For example, whenever you do an even like a function call, or you just call a property

142
00:09:13,820 --> 00:09:18,900
invocation, during that, Python will always do hash table lookup because all those are

143
00:09:18,900 --> 00:09:22,940
stored in hash tables like what is the function I'm calling, what is the property I need to

144
00:09:23,100 --> 00:09:24,100
call.

145
00:09:24,100 --> 00:09:28,220
And if you compile it with MyPy, see all these kind of hash table lookups get eliminated.

146
00:09:28,220 --> 00:09:29,220
Okay?

147
00:09:29,220 --> 00:09:31,380
So, yeah, for now it's MyPy.

148
00:09:31,380 --> 00:09:35,100
Use it, but it is planned to even improve the performance on the black in the future

149
00:09:35,100 --> 00:09:38,220
so we can have our favorite format even faster.

150
00:09:38,220 --> 00:09:39,220
Okay.

151
00:09:39,220 --> 00:09:40,220
So, yeah.

152
00:09:40,220 --> 00:09:43,860
Bottom line, it was designed to improve the developer experience, not performance.

153
00:09:43,860 --> 00:09:44,860
Oh, wait.

154
00:09:44,860 --> 00:09:45,860
No, yeah.

155
00:09:45,860 --> 00:09:46,860
And performance nowadays.

156
00:09:46,860 --> 00:09:51,580
The performance part is definitely still kind of like a research project, work in progress.

157
00:09:51,580 --> 00:09:56,540
It works mostly and doesn't support the entire language, but definitely maybe a few years

158
00:09:56,540 --> 00:09:59,020
down the line it's going to be widely usable.

159
00:09:59,020 --> 00:10:00,020
Okay?

160
00:10:00,020 --> 00:10:05,300
If you want to try this out, definitely reach out to the MyPy team and they might help you

161
00:10:05,300 --> 00:10:08,620
get if you can see if at the moment it's good or not.

162
00:10:08,620 --> 00:10:09,620
Okay.

163
00:10:09,620 --> 00:10:13,220
So, hopefully I managed to convince you now that why you should use typing and why it's

164
00:10:13,220 --> 00:10:14,220
good.

165
00:10:14,220 --> 00:10:18,500
So, let's have a quick look what kind of typing hinting or type information is added to the

166
00:10:18,500 --> 00:10:19,940
Python language.

167
00:10:19,940 --> 00:10:26,620
So, MyPy treats it basically gradual typing, meaning that you don't have to type into your

168
00:10:26,620 --> 00:10:27,860
entire code base.

169
00:10:27,860 --> 00:10:31,540
If you type into only a section of your code base, it's only going to type check that section

170
00:10:31,540 --> 00:10:35,820
of your code base, meaning that you can actually gradually adopt type hinting.

171
00:10:35,820 --> 00:10:40,020
You don't have to do like a big boom for your entire project.

172
00:10:40,020 --> 00:10:44,660
You can type in function parameters, function return and variables, and yeah, only whatever

173
00:10:44,660 --> 00:10:45,660
you type into are checked.

174
00:10:45,660 --> 00:10:50,540
For example, in this case, the type hinter will be able to tell you that, hey, wait,

175
00:10:50,540 --> 00:10:54,940
this call if you invoke the MyPy, hey, this call is actually not correct because the first

176
00:10:54,940 --> 00:11:00,460
argument is a number but should be a string or hey, you call these names but these names

177
00:11:00,460 --> 00:11:05,100
doesn't actually exist on the type and it even can suggest to you that we have this

178
00:11:05,100 --> 00:11:06,460
name and underscore name.

179
00:11:06,460 --> 00:11:08,620
Maybe this is what you actually wanted to call it.

180
00:11:08,620 --> 00:11:10,900
This was just a typo.

181
00:11:10,900 --> 00:11:12,600
So how to edit?

182
00:11:12,600 --> 00:11:14,420
So once you decide, okay, I want this.

183
00:11:14,420 --> 00:11:15,420
I want speed.

184
00:11:15,420 --> 00:11:18,100
I want improved maintainability, improve everything.

185
00:11:18,100 --> 00:11:19,100
How do I edit?

186
00:11:19,100 --> 00:11:20,900
You have multiple options.

187
00:11:20,900 --> 00:11:24,820
And the most simplest and cleanest way is by using the type annotations.

188
00:11:24,820 --> 00:11:28,620
The type annotations for the interest in Python 3.0 at the function level.

189
00:11:28,620 --> 00:11:31,620
At the variable level, it will interest in Python 3.6.

190
00:11:31,620 --> 00:11:36,040
And it means basically that if you have a function like this, you can annotate the function

191
00:11:36,040 --> 00:11:42,020
or you can annotate the actual string or the actual variable as you see there, basically

192
00:11:43,020 --> 00:11:47,660
using this double code or double colon or the arrow annotation.

193
00:11:47,660 --> 00:11:48,660
Okay?

194
00:11:48,660 --> 00:11:49,660
So, yeah.

195
00:11:49,660 --> 00:11:52,660
So type annotations, quite clean.

196
00:11:52,660 --> 00:11:55,060
Meshes really looks really nicely in Python.

197
00:11:55,060 --> 00:11:59,140
The packaging is solved because all your type information is already there in the code.

198
00:11:59,140 --> 00:12:03,580
The bad side is that it does require Python 3.6 and granted this may become less or less

199
00:12:03,580 --> 00:12:08,860
of issue as we go ahead but for now, we still have a lot of Python 2.0 which we need to

200
00:12:08,860 --> 00:12:13,780
migrate or we have dependencies that are still not there for us to migrate right away.

201
00:12:13,780 --> 00:12:18,700
So the downside is that it does require importing all your type dependencies.

202
00:12:18,700 --> 00:12:20,540
This may be invoked type penalty.

203
00:12:20,540 --> 00:12:25,140
It also gives extra information that the interpreter needs to evaluate.

204
00:12:25,140 --> 00:12:30,340
But it's not all despair because with Python 3.7, you can actually add this magic from

205
00:12:30,340 --> 00:12:31,940
few import annotations.

206
00:12:31,940 --> 00:12:36,820
And once you do this, the interpreter actually treats all the type information as a comment

207
00:12:36,900 --> 00:12:38,700
and actually doesn't get evaluated.

208
00:12:38,700 --> 00:12:39,900
Nothing gets constructed.

209
00:12:39,900 --> 00:12:45,020
So this should alleviate some of the performance penalties that you might otherwise get.

210
00:12:45,020 --> 00:12:46,700
So yeah.

211
00:12:46,700 --> 00:12:50,340
Another way you can edit and this is how you can edit even in Python 2 and also support

212
00:12:50,340 --> 00:12:53,440
it for both Python 2 and 3 is by using type comments.

213
00:12:53,440 --> 00:12:58,860
This is what Dropbox uses for the entire code base and works under any Python version because

214
00:12:58,860 --> 00:13:04,500
his comments really was supported with the language 1.0 or 0.1 so it shouldn't be any

215
00:13:04,500 --> 00:13:05,500
that kind of issue.

216
00:13:05,620 --> 00:13:08,180
The type information is still kept locally.

217
00:13:08,180 --> 00:13:10,780
The packaging is solved because you're going to ship your comments hopefully.

218
00:13:10,780 --> 00:13:15,860
I'm not sure if anyone removed their comments after they shipped the code.

219
00:13:15,860 --> 00:13:20,700
The bad side is it's kind of like ugly because all the type information is right beside where

220
00:13:20,700 --> 00:13:24,180
it should be but not exactly where it should be.

221
00:13:24,180 --> 00:13:26,020
It has a lot of unused import.

222
00:13:26,020 --> 00:13:28,900
Especially your linter might start complaining that hey, you have this list.

223
00:13:28,900 --> 00:13:29,900
It only is in the comments.

224
00:13:29,900 --> 00:13:31,380
It's really not used.

225
00:13:31,380 --> 00:13:38,100
More importantly, it starts confusing linter and then you need to add further disables.

226
00:13:38,100 --> 00:13:44,140
So just to give you a better impression of this, imagine I have this simple swap function.

227
00:13:44,140 --> 00:13:48,180
It basically swaps two elements as a context manager.

228
00:13:48,180 --> 00:13:52,380
So if I want to actually type in this, I first need to add the actual type information for

229
00:13:52,380 --> 00:13:55,580
each and every variable and the return value.

230
00:13:55,580 --> 00:14:00,780
And you see this can get quite big, especially if your type information is more complex.

231
00:14:01,060 --> 00:14:06,340
Then you also need to add further imports to actually ensure that the type checker knows

232
00:14:06,340 --> 00:14:08,940
where to pull all this type information.

233
00:14:08,940 --> 00:14:12,820
And maybe you use a few aliases to actually fit into a line and be like more readable

234
00:14:12,820 --> 00:14:14,380
code base.

235
00:14:14,380 --> 00:14:19,620
And then you end up basically making the six lines into this lovely 14 lines, which is

236
00:14:19,620 --> 00:14:24,420
only good if you get paid by the number of lines you write because double your salary

237
00:14:24,420 --> 00:14:26,380
easily.

238
00:14:26,380 --> 00:14:31,180
So this is kind of like a downside of this, but there's no real workaround.

239
00:14:31,180 --> 00:14:34,140
It works mostly fine, though.

240
00:14:34,140 --> 00:14:38,380
Another option that you can go to is instead of writing comments, you can write stuff files.

241
00:14:38,380 --> 00:14:42,340
This stuff files is basically what you already know from C++, the headers.

242
00:14:42,340 --> 00:14:46,580
In this stuff files, the good thing is that you no longer have to even touch your current

243
00:14:46,580 --> 00:14:47,580
code base.

244
00:14:47,580 --> 00:14:51,100
You can basically just add further files to it and it's going to get all these wonderful

245
00:14:51,100 --> 00:14:53,940
benefits which I listed earlier.

246
00:14:53,940 --> 00:14:57,980
It works under any Python because here no interpreter actually looks at this stuff files.

247
00:14:57,980 --> 00:15:01,460
It also doesn't carry out the source content change.

248
00:15:01,460 --> 00:15:06,780
Can use any latest Python features because again no interpreter actually interprets these

249
00:15:06,780 --> 00:15:07,780
files, only the type checker.

250
00:15:07,780 --> 00:15:12,860
And the type checker is smart enough to understand the latest fancy syntax and doesn't conflict

251
00:15:12,860 --> 00:15:16,420
with linters because again the linters don't really check this.

252
00:15:17,420 --> 00:15:22,500
So and it is also very well tested because the entire standard library is actually type

253
00:15:22,500 --> 00:15:28,300
aware made by using this option.

254
00:15:28,300 --> 00:15:32,020
So the downside is that now you have a duplicate code.

255
00:15:32,020 --> 00:15:35,380
Basically instead of one file, now you have to maintain two files.

256
00:15:35,380 --> 00:15:39,900
So and it's kind of like you also have to package extra content for which there is a

257
00:15:39,900 --> 00:15:44,140
PEP you can do it and it's standard supported by the old type checkers.

258
00:15:44,140 --> 00:15:49,420
So you can actually use hint to the element that hey yeah you can add this information

259
00:15:49,420 --> 00:15:53,740
or like to pull information from alongside the stuff files.

260
00:15:53,740 --> 00:15:57,180
The biggest downside which I see is basically at the moment it is kind of troublesome to

261
00:15:57,180 --> 00:16:03,820
maintain because once you add it basically all type checkers or linters treat your stuff

262
00:16:03,820 --> 00:16:08,860
file as a single source of truth meaning that if you add something in your source file and

263
00:16:08,860 --> 00:16:14,300
you don't have type annotations for the linter those additional functions don't exist.

264
00:16:14,300 --> 00:16:18,140
So from this point on this is kind of like not gradual typing.

265
00:16:18,140 --> 00:16:21,980
It's like either everything or nothing or you're running into issues.

266
00:16:21,980 --> 00:16:28,380
So yeah we have an actual plan to address this but I'll talk about that a bit later.

267
00:16:28,380 --> 00:16:33,340
So yeah another bonus way where you could like historically if you read really old code

268
00:16:33,340 --> 00:16:38,620
you could also if the type information were added in the doc strings this is kind of documented

269
00:16:38,620 --> 00:16:43,180
but the it's not fully functional it doesn't allow you to actually type into all the complex

270
00:16:43,180 --> 00:16:49,020
code so I would really not recommend this kind of option going ahead.

271
00:16:49,020 --> 00:16:55,180
Okay so the other question is so what kind of types can you add.

272
00:16:55,180 --> 00:16:58,780
Basically at this point the type is kind of like have two options.

273
00:16:58,780 --> 00:17:01,100
One of the options are the nominal types.

274
00:17:01,100 --> 00:17:04,700
Nominal types are basically all the types which actually have a name you can actually

275
00:17:04,780 --> 00:17:07,420
name them like a classes the top of the dictionary.

276
00:17:07,420 --> 00:17:10,780
These actually have a proper type that you can kind of envision.

277
00:17:11,580 --> 00:17:17,660
Vector like even distinct types or you have also the composer operations like you can

278
00:17:17,660 --> 00:17:22,380
specify this or that or that this is optional that kind of arguments.

279
00:17:22,380 --> 00:17:26,300
You can even similarly have like callbacks which are basically this is the type information for a

280
00:17:26,300 --> 00:17:32,380
function or type variables which are more allow you to even define kind of like generic type

281
00:17:32,380 --> 00:17:36,700
information for your class when depending on the construction of the class you can have different

282
00:17:36,700 --> 00:17:38,620
types into your class.

283
00:17:38,620 --> 00:17:43,340
Okay and you have also the any then is the magic keyword because any basically means

284
00:17:44,540 --> 00:17:48,860
this is treated just as it was before type checking means disabled type checking more or less

285
00:17:49,500 --> 00:17:54,460
on the any and that means anything is allowed on whatever that type or on that object.

286
00:17:55,740 --> 00:18:00,300
The other options that you can have is basically the pythonic way of if it looks like a doc and

287
00:18:00,300 --> 00:18:05,260
it works like a doc it is a doc the protocols are kind of like this here instead of specifying an

288
00:18:05,260 --> 00:18:14,220
actual type I can say if whatever you pass in has that get item and that get item returns an int

289
00:18:14,220 --> 00:18:20,620
I'm happy and I'm good and that's what I want so this is a more generic way of defining the

290
00:18:20,620 --> 00:18:23,260
requirements for the arguments of your functions.

291
00:18:23,260 --> 00:18:28,140
Okay so I'm going to quickly go over a few gotchas these are the kind of gotchas that once you do

292
00:18:28,140 --> 00:18:31,740
start adding this type information you might run into these kind of problems.

293
00:18:31,740 --> 00:18:36,220
So if you have a code base that you need to maintain both on python 2 and 3 and this is what

294
00:18:36,220 --> 00:18:41,100
you had on python 2 once you move to python 3 and for example add the for future input

295
00:18:41,100 --> 00:18:45,500
unicode literals now your wrapper will look a lot more complicated because depending on the

296
00:18:46,860 --> 00:18:50,460
interpreter your type information needs to be different because it needs to be like

297
00:18:51,580 --> 00:18:56,300
unicode on python 3 and it needs to be like by stream on python 2 so it kind of like makes

298
00:18:56,300 --> 00:19:02,220
your wrapper a lot more complicated or the other option is that if you want to have like

299
00:19:02,220 --> 00:19:09,100
depending on the input type the output type can change the first impression of you do it is you

300
00:19:09,100 --> 00:19:13,580
can specify that yeah the input can be both this and the output can be both of these types

301
00:19:13,580 --> 00:19:19,180
and this kind of things but now the type checker going to think that that type might return also

302
00:19:19,180 --> 00:19:23,500
the additional type for example in this case even to the first function is called with an int

303
00:19:23,500 --> 00:19:28,700
it might think that the return value of that magic can also be string and there is a solution

304
00:19:28,700 --> 00:19:33,180
for this you basically can use multiple return times by using overloads the overloads are

305
00:19:33,180 --> 00:19:38,300
basically how you define that depending on this input what would be the output the only downside

306
00:19:38,300 --> 00:19:44,060
of this is that now you need to define this interface one per every file or one per every

307
00:19:45,820 --> 00:19:50,940
combination and it is kind of like now your type enter the kind of things that you're disabling

308
00:19:50,940 --> 00:19:56,860
the same or declaring the same function multiple time which is a bit not the best other option

309
00:19:56,860 --> 00:20:02,700
that you have you basically can have this issue of the how the type lookup happens for example if

310
00:20:02,700 --> 00:20:07,580
you define this class and the value of the class can interpret it in multiple functions it's just

311
00:20:07,580 --> 00:20:12,940
kind of natural that you're going to have multiple properties or functions which return the name of

312
00:20:12,940 --> 00:20:20,620
that element so if you run that code against mypy mypy going to complain that hey this is in the

313
00:20:20,620 --> 00:20:26,860
type and use like what test a dot float wait no i just say this float not that magical type

314
00:20:27,420 --> 00:20:31,100
and the reason why this is is that basically the way the type checker works whenever it discovers

315
00:20:31,100 --> 00:20:37,100
the type it tries to locate that value going out from that namespace so to say and in that

316
00:20:37,100 --> 00:20:42,380
namespace the closest float that it can find is actually the function itself so it kind of thinks

317
00:20:42,380 --> 00:20:48,060
the type of your return value of that function is the function type itself and you can work around

318
00:20:48,060 --> 00:20:53,420
this by making explicit here you explicitly declare that the built-ins that float is what

319
00:20:53,420 --> 00:20:58,780
you want and not any type of float and this will solve the problem and just now you need to import

320
00:20:58,780 --> 00:21:03,260
buildings to actually be able to refer to it both under python two and three and to do that you can

321
00:21:03,260 --> 00:21:11,740
use this guard this if typing dot type checking this this is guaranteed to be only be true under

322
00:21:11,740 --> 00:21:17,500
python under the static linter the interpreter will always set this to false so whatever you

323
00:21:17,500 --> 00:21:24,300
put behind this will never be executed another interesting example is that when you do start

324
00:21:24,300 --> 00:21:31,180
doing inter inheritance you run into this issue of contravariant arguments for example if you

325
00:21:31,180 --> 00:21:36,460
have this function and you inherit from it it might be easy for you to think that hey i have

326
00:21:36,460 --> 00:21:41,500
this base class the business can take both type but in the master class i basically gonna root

327
00:21:42,700 --> 00:21:47,180
an egg subtype to actually handle one of the use cases for example you say that be only

328
00:21:47,180 --> 00:21:53,020
going to have int and i want b to only get three that case once you're still running to that this

329
00:21:53,020 --> 00:22:00,860
cannot happen the argument types for inheritance or when you extend classes can only treat more

330
00:22:00,860 --> 00:22:06,060
you cannot like treat less than the parent actually defines it treats

331
00:22:09,820 --> 00:22:13,660
yeah and you basically like this would be a valid one you can say that the base class

332
00:22:13,660 --> 00:22:18,220
also handles bull but you cannot say that i'm gonna handle less than my parent cause

333
00:22:18,220 --> 00:22:23,420
and the reason for this is basically the parent anyone can take a look at your class as the parent

334
00:22:23,420 --> 00:22:29,660
and that's a valid thing and the parent whatever the parent defines must be always satisfied by

335
00:22:29,660 --> 00:22:36,860
the children of your inherit of your inheritance chain okay so this is another interesting problem

336
00:22:36,860 --> 00:22:43,500
so imagine you have this lovely class and you basically say yeah i want to define this class

337
00:22:43,500 --> 00:22:48,860
method this class method may basically instantiate the class and it's going to return the a and once

338
00:22:48,860 --> 00:22:53,340
you inherit the inheritance also takes an additional argument because i need to use it for something

339
00:22:54,620 --> 00:23:01,580
so once you're going to try to actually run this if anyone has like a few seconds just to think

340
00:23:01,580 --> 00:23:09,260
about it this will actually fail at runtime because actually it turns out that you never passed in the

341
00:23:09,260 --> 00:23:13,820
float value for the b so it's going to be like wait you did not pass the position or required

342
00:23:13,820 --> 00:23:21,420
argument and the type checker will also actually warn for this and i'm going to admit this wonderful

343
00:23:21,420 --> 00:23:27,020
error and you can fix it easily by basically just making that argument optional and now this actually

344
00:23:27,020 --> 00:23:31,660
will work and the type checker will also be happy but you're thinking okay so i have this for the

345
00:23:31,660 --> 00:23:36,380
class method what if i do the same for like constructors like the init method basically

346
00:23:36,940 --> 00:23:42,860
what's gonna happen if you run and one would you run the same code it's gonna feel just as the same

347
00:23:42,860 --> 00:23:47,980
but what happens if you like run it with the type checker oh yeah that's the last sign is actually

348
00:23:47,980 --> 00:23:52,860
what the type checker says meaning the type checker says yeah everything's good and even to this

349
00:23:52,860 --> 00:23:57,340
fails and the type checker doesn't complain the reason for it that is apparently it's too common

350
00:23:57,340 --> 00:24:02,860
to prohibit incompatible init and new and this is kind of like an edge kill which you might run to

351
00:24:02,860 --> 00:24:09,580
like why wasn't the type checker actually handles this but it seems in the real code basis by usage

352
00:24:09,580 --> 00:24:14,540
there were way too many false positive and this kind of disabled even it does work for class methods

353
00:24:14,540 --> 00:24:20,220
which are kind of like additional constructors okay so once you see all these sketches you might

354
00:24:20,220 --> 00:24:27,100
have kind of like this feeling and especially just seeing how much your code extends and i'm here to

355
00:24:27,100 --> 00:24:31,980
tell you that no you don't need that bridge yet because whenever you hit the wall and you feel

356
00:24:31,980 --> 00:24:36,780
like this is too much you always have a bit of help you can use the reveal type to actually

357
00:24:37,500 --> 00:24:44,540
print out what the type what the type checker actually thinks your type there is at the moment

358
00:24:44,540 --> 00:24:50,300
this is kind of like inspect whatever happens within the type enter or the type checker or

359
00:24:50,300 --> 00:24:55,820
you can use the cast when you can say basically say i know this is going to be this type just trust me

360
00:24:55,820 --> 00:25:00,780
it's basically an unsafe cast if there's something like it meaning that it's going to basically force

361
00:25:01,340 --> 00:25:06,700
the type checker to treat it as it is or if it's too complicated even with casting to solve you can

362
00:25:06,700 --> 00:25:11,260
always just ignore it i don't recommend this usually should put something at the end of it as

363
00:25:11,260 --> 00:25:16,060
a temporary workaround like maybe this is a bug in the framework or maybe this is actually

364
00:25:16,060 --> 00:25:20,620
something that is too complicated now for you to fix and you want to come back later on just

365
00:25:20,620 --> 00:25:27,820
ignore it for now and put the to do after it okay so one more thing which i kind of like get hinted

366
00:25:27,820 --> 00:25:32,220
earlier but i got back yes you can actually merge your doc string and the typing meaning that

367
00:25:33,340 --> 00:25:41,340
you can actually use the pep 257 defines how type information should be in the documentation string

368
00:25:41,340 --> 00:25:45,580
you basically just need to include this to information into your documentation string

369
00:25:45,580 --> 00:25:49,980
and if you have type hinting this is possible by using this things documentation and you

370
00:25:49,980 --> 00:25:55,660
are also using things as a documentation generator meaning that if you install this package and you

371
00:25:55,660 --> 00:26:00,380
configure it as an extension in the swings you can make code that looks like this notice that

372
00:26:00,380 --> 00:26:05,740
there's no type information in the doc string but once the generation runs it's actually going to

373
00:26:05,740 --> 00:26:11,180
inject all the type information for you into the actual doc strings now the only kind of downside

374
00:26:11,180 --> 00:26:16,300
of this at the moment is that it's actually going to unroll your type information so it might get

375
00:26:16,300 --> 00:26:23,100
very long and complicated we definitely should improve it to be able to like use the actual type

376
00:26:24,060 --> 00:26:29,660
or the type aliases for example in this case instead of the should use that reducer and module

377
00:26:29,660 --> 00:26:37,340
instead of actually injecting the full expanded value so yeah so this is kind of like where we

378
00:26:37,340 --> 00:26:41,180
stand at the moment in the final few minutes i would like to present you where we are heading

379
00:26:41,180 --> 00:26:47,340
next so what are the further improvements we're going to add to the typing and how we plan to

380
00:26:47,340 --> 00:26:52,060
actually make this experience even better for all of you so the first thing which is the accepted

381
00:26:52,060 --> 00:26:57,100
pep and it's also already implemented in my pi is the literal types this means that basically you

382
00:26:57,100 --> 00:27:03,100
can whenever based on the literal type of the argument such as the open function the return

383
00:27:03,100 --> 00:27:08,300
value of the functions change now you can actually do it for example in this case if you open a file

384
00:27:08,300 --> 00:27:13,260
by just using the read literal you can actually hint it that the return value going to be always

385
00:27:13,260 --> 00:27:20,140
a text like a unicode in python tree at least or if you open a file with the binary literal it's

386
00:27:20,140 --> 00:27:26,940
always going to return bytes this should make your code whenever based on like a you know more

387
00:27:26,940 --> 00:27:33,100
literal the type of the output change much more nicer to use another improvement that's coming up

388
00:27:33,100 --> 00:27:37,820
is the acceptance of the type dictionaries this is again an accepted pep and also is something that

389
00:27:38,380 --> 00:27:43,980
implemented in my pi this allows you to basically type in type your dictionaries too not just your

390
00:27:43,980 --> 00:27:50,860
list itself another thing that's happening is the final qualifier this is again accepted

391
00:27:50,860 --> 00:27:59,180
and implemented in my pi this is basically the type the python typings gray joy style but instead

392
00:27:59,180 --> 00:28:04,700
of what is that may never die now we're what is set may never ever be set again so once you set

393
00:28:04,700 --> 00:28:10,140
something you'll see that if you try to set it again the type checker will just complain that

394
00:28:10,140 --> 00:28:15,580
hey you already set this variable earlier maybe not try to override it because that's not going

395
00:28:15,580 --> 00:28:21,580
to be a good thing another thing that we plan to add is basically what i hinted earlier we plan to

396
00:28:21,580 --> 00:28:28,060
improve the maintenance of the stuff files by actually checking and omitting errors if your

397
00:28:28,060 --> 00:28:36,620
stuff files and your source file differ in any way and we also plan to like the way the current

398
00:28:37,180 --> 00:28:43,340
vision is the way we do it we merge the two files so you can use like local type annotations to

399
00:28:43,340 --> 00:28:48,300
actually annotate your local variables because those are actually not part of the interface

400
00:28:49,020 --> 00:28:55,420
okay another thing which is happening is numpy and panda support we have these three requirements

401
00:28:55,420 --> 00:29:02,060
to make that true and for each of this the typing team has a plan the exact type there is

402
00:29:02,220 --> 00:29:07,580
very type variables or the key types are going to be added into the typing and with this hopefully

403
00:29:07,580 --> 00:29:16,060
we can start annotating all the numpy and pandas code base too so another thing this all the

404
00:29:16,060 --> 00:29:20,780
everything else after does comes is more like we would like to and there is a plan for it but it

405
00:29:20,780 --> 00:29:27,180
might change so one thing is everyone kind of gets annoyed that why do i need this capitalist and why

406
00:29:27,180 --> 00:29:31,900
do i need capital dictionaries wouldn't be nice if i could basically just not have to import it

407
00:29:31,900 --> 00:29:38,780
and basically just do this it's a bit cleaner so there is definitely a tentative to make this a

408
00:29:38,780 --> 00:29:43,900
truth another thing is we can also maybe have the union and the option is probably the ones we're

409
00:29:43,900 --> 00:29:49,420
going to use the most of the time and you can make even this shorter by basically using this syntax

410
00:29:49,420 --> 00:29:56,140
for as proposed for example so the question mark is the optional and the or operator as a union of

411
00:29:56,140 --> 00:30:03,340
elements and we'll also now that we have four plus type checkers we want to make easier to run the

412
00:30:03,340 --> 00:30:08,140
multiple type checkers on the same code base and have like unified error code so there is a plan to

413
00:30:08,700 --> 00:30:15,580
actually define for each type of error what is the type code error code that should be raised

414
00:30:15,580 --> 00:30:19,180
this would mean that you could usually transition from one type checker the other type checker

415
00:30:19,180 --> 00:30:23,580
and would also have like a common database of all the possible errors and how we should fix them

416
00:30:23,580 --> 00:30:29,900
okay so basically just unifying the error codes between the various type checkers so yeah my

417
00:30:29,900 --> 00:30:34,220
conclusion is that basically you should always use types whenever you would write unit test

418
00:30:34,940 --> 00:30:41,980
the type is basically just like a type of unit test you and remember that you can achieve much

419
00:30:41,980 --> 00:30:46,380
more with this you can even improve the performance of your application if you really want to but do

420
00:30:46,380 --> 00:30:50,380
prepare for some discomforts and challenges on the road do allocate a bit of time to actually

421
00:30:50,380 --> 00:30:57,260
migrate your code base or just do it very gradually okay so thank you very much in case my talk was a

422
00:30:57,260 --> 00:31:03,100
bit too fast or did not catch everything on that link there down you actually have a more detailed

423
00:31:03,100 --> 00:31:12,780
description of all this thank you

