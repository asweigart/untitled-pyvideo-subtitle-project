1
00:00:00,000 --> 00:00:04,520
All right, everyone, if you could take your seats.

2
00:00:04,520 --> 00:00:06,120
I'm here to introduce Paul Gansel, who

3
00:00:06,120 --> 00:00:08,760
will be speaking with you today about working with time zones

4
00:00:08,760 --> 00:00:10,680
and everything you wish you didn't need to know.

5
00:00:10,680 --> 00:00:11,180
Woo!

6
00:00:11,180 --> 00:00:11,680
Woo!

7
00:00:11,680 --> 00:00:12,180
Woo!

8
00:00:12,180 --> 00:00:12,680
Woo!

9
00:00:12,680 --> 00:00:13,180
Woo!

10
00:00:13,180 --> 00:00:13,680
Woo!

11
00:00:13,680 --> 00:00:15,880
Woo!

12
00:00:15,880 --> 00:00:18,560
All right, they saved the best for last.

13
00:00:18,560 --> 00:00:20,840
But I think all those other sessions are closed,

14
00:00:20,840 --> 00:00:24,160
so you will have to stay in this one.

15
00:00:24,160 --> 00:00:26,880
OK, so as Chris said, I'm Paul Gansel.

16
00:00:26,880 --> 00:00:29,120
I maintain date util.

17
00:00:29,120 --> 00:00:31,720
And today I'm going to talk to you about working with time

18
00:00:31,720 --> 00:00:33,040
zones.

19
00:00:33,040 --> 00:00:35,720
So we'll start easy.

20
00:00:35,720 --> 00:00:37,680
We'll talk about UTC.

21
00:00:37,680 --> 00:00:40,080
UTC is the reference time zone.

22
00:00:40,080 --> 00:00:42,320
It is monotonic-ish.

23
00:00:42,320 --> 00:00:45,280
Why they decided to put leap seconds in the reference time

24
00:00:45,280 --> 00:00:51,560
zone and in civil time in general, I do not know.

25
00:00:51,560 --> 00:00:53,920
I sort of wish they had asked me.

26
00:00:53,920 --> 00:00:57,240
I would have said no.

27
00:00:57,240 --> 00:00:58,640
I think it's also important for you

28
00:00:58,640 --> 00:01:01,400
to understand the difference between time zones and offsets.

29
00:01:01,400 --> 00:01:04,120
So UTC plus 1 is an offset.

30
00:01:04,120 --> 00:01:07,120
That's the offset that applies now in London.

31
00:01:07,120 --> 00:01:09,680
Europe London is a time zone.

32
00:01:09,680 --> 00:01:12,600
Time zone is a set of rules for what

33
00:01:12,600 --> 00:01:15,080
time zone offset and other time zone information

34
00:01:15,080 --> 00:01:19,600
applies as a function of the time.

35
00:01:19,600 --> 00:01:23,040
BST, which is the abbreviation that applies right now

36
00:01:23,040 --> 00:01:28,480
in London, is a highly context-dependent abbreviation.

37
00:01:28,480 --> 00:01:32,800
So in the context of London, it means British summertime.

38
00:01:32,800 --> 00:01:34,200
And that's UTC plus 1.

39
00:01:34,200 --> 00:01:35,680
But if you're in Bangladesh, that

40
00:01:35,680 --> 00:01:38,760
means Bangladesh standard time, which is UTC plus 6.

41
00:01:38,760 --> 00:01:40,360
And if you're in Papua New Guinea,

42
00:01:40,360 --> 00:01:45,840
it's Bugainville standard time, which is UTC plus 11.

43
00:01:45,840 --> 00:01:47,800
Now this is the part of the talk that I'm sure

44
00:01:47,800 --> 00:01:49,440
is the main reason you came.

45
00:01:49,440 --> 00:01:51,280
I'm going to talk about all the weird stuff

46
00:01:51,280 --> 00:01:54,880
people get up to with their time zones.

47
00:01:54,880 --> 00:01:57,680
You may have a friend, it's OK.

48
00:01:57,680 --> 00:02:01,440
I know you're asking for a friend, who

49
00:02:01,440 --> 00:02:04,760
thinks that there's only like 24 time zone offsets,

50
00:02:04,760 --> 00:02:08,560
and they're all just exactly one hour increments away from UTC.

51
00:02:08,560 --> 00:02:10,760
But if you go to Australia, there

52
00:02:10,760 --> 00:02:12,400
are places that are half an hour away.

53
00:02:12,400 --> 00:02:14,120
Or in Southeast Asia, you'll see some places

54
00:02:14,120 --> 00:02:18,000
that are multiple of 15 minutes away.

55
00:02:18,000 --> 00:02:19,920
And historically, it wasn't even true

56
00:02:19,920 --> 00:02:24,480
that time zones had to be an integer number of minutes

57
00:02:24,480 --> 00:02:25,360
away.

58
00:02:25,360 --> 00:02:30,000
In Liberia, before 1979, they were 44 minutes and 30 seconds

59
00:02:30,000 --> 00:02:30,640
ahead of UTC.

60
00:02:33,600 --> 00:02:36,840
There's also the situation where you may think,

61
00:02:36,840 --> 00:02:42,720
well, the only time that offsets will change

62
00:02:42,720 --> 00:02:46,560
is if daylight saving time has changed, and vice versa.

63
00:02:46,560 --> 00:02:48,120
Daylight saving time will not change

64
00:02:48,120 --> 00:02:49,480
without the offset changing.

65
00:02:49,480 --> 00:02:52,360
But in 1992, Portugal decided that they

66
00:02:52,360 --> 00:02:54,600
didn't want to be on Western European time anymore.

67
00:02:54,600 --> 00:02:56,840
Instead, they wanted to be on Central European time.

68
00:02:56,840 --> 00:02:59,640
So they were going to shift their base offset by one hour.

69
00:02:59,640 --> 00:03:02,880
And they decided to do this at a time that

70
00:03:02,880 --> 00:03:05,040
would be convenient for humans, but it turns out

71
00:03:05,040 --> 00:03:08,720
to be kind of annoying for computers, which

72
00:03:08,720 --> 00:03:12,440
is when daylight saving time was going to end,

73
00:03:12,440 --> 00:03:15,920
instead of going from Western Standard Time to Western

74
00:03:15,920 --> 00:03:18,040
European summertime to Western European time,

75
00:03:18,040 --> 00:03:20,000
they just switched over to Central European time.

76
00:03:20,000 --> 00:03:22,040
So the only thing that changed about the offset

77
00:03:22,040 --> 00:03:25,320
is that they went from daylight saving time to Standard.

78
00:03:25,320 --> 00:03:28,600
So you can have a daylight saving time status

79
00:03:28,600 --> 00:03:32,400
change without any change in the total offset.

80
00:03:32,400 --> 00:03:35,320
As an aside, in 1996, they decided

81
00:03:35,320 --> 00:03:39,920
that having the sunset after midnight was not a good idea.

82
00:03:39,920 --> 00:03:42,040
And they did the reverse.

83
00:03:42,040 --> 00:03:45,960
So after going from Central European time,

84
00:03:45,960 --> 00:03:49,400
instead of going to, I guess, Central European summertime,

85
00:03:49,400 --> 00:03:51,800
they just went directly to Western European summertime

86
00:03:51,800 --> 00:03:54,120
with no change in the offset.

87
00:03:54,120 --> 00:03:58,120
So now we know that a couple of things that can happen.

88
00:03:58,120 --> 00:04:00,360
But you think, OK, well, the only times

89
00:04:00,360 --> 00:04:02,760
that things will change is if the base offset changes

90
00:04:02,760 --> 00:04:04,160
or daylight saving time.

91
00:04:04,160 --> 00:04:07,080
And daylight saving time is obviously only once a year,

92
00:04:07,080 --> 00:04:08,320
not the case in Morocco.

93
00:04:08,320 --> 00:04:12,080
So in Morocco since 2012, there have

94
00:04:12,080 --> 00:04:14,720
been two daylight saving time transitions every year.

95
00:04:14,720 --> 00:04:17,360
So what happens here is in the spring,

96
00:04:17,360 --> 00:04:18,840
they go on to daylight saving time.

97
00:04:18,840 --> 00:04:22,640
And then in this case, in 2012, they had, at the end of July,

98
00:04:22,640 --> 00:04:25,200
they decided to just turn off daylight saving time.

99
00:04:25,200 --> 00:04:27,840
And they'll just go back on to Standard Time.

100
00:04:27,840 --> 00:04:31,400
And then one month later, they turn it back on.

101
00:04:31,400 --> 00:04:34,560
And people who've seen me talk about this before

102
00:04:34,560 --> 00:04:36,920
may know the spoiler that Morocco

103
00:04:36,920 --> 00:04:39,880
is a majority Muslim country.

104
00:04:39,880 --> 00:04:42,280
And this month is the month of Ramadan.

105
00:04:42,280 --> 00:04:43,880
And during Ramadan, Muslims are not

106
00:04:43,880 --> 00:04:46,000
supposed to eat until the sun goes down.

107
00:04:46,000 --> 00:04:48,420
So they would much prefer to be on Standard Time

108
00:04:48,420 --> 00:04:49,680
during that time.

109
00:04:49,680 --> 00:04:53,240
So they just said, well, let's just go back to Standard Time

110
00:04:53,240 --> 00:04:54,760
just for that one month.

111
00:04:54,760 --> 00:04:58,400
And they've continued to do that with surprisingly little notice

112
00:04:58,400 --> 00:05:00,920
every year.

113
00:05:00,920 --> 00:05:02,480
All right, so you say, OK, well, I

114
00:05:02,480 --> 00:05:05,280
know that there can be more than one daylight saving time offset

115
00:05:05,280 --> 00:05:06,960
change per year.

116
00:05:06,960 --> 00:05:09,280
But these only happen at like 2 in the morning.

117
00:05:09,280 --> 00:05:12,240
So I'm never going to see an ambiguous time or something

118
00:05:12,240 --> 00:05:14,320
like that during the day.

119
00:05:14,320 --> 00:05:17,800
But in 1994, Christmas Island, which

120
00:05:17,800 --> 00:05:21,280
I guess is part of Kiribati, they

121
00:05:21,280 --> 00:05:23,360
decided that they wanted to be on the other side

122
00:05:23,360 --> 00:05:24,520
of the international dateline.

123
00:05:24,520 --> 00:05:26,280
This is some island in the South Pacific.

124
00:05:26,280 --> 00:05:30,560
And presumably, they decided that one trading partner was

125
00:05:30,560 --> 00:05:31,840
more important than another one.

126
00:05:31,840 --> 00:05:33,200
I don't really know the details.

127
00:05:33,200 --> 00:05:36,720
But the upshot of it was that they

128
00:05:36,720 --> 00:05:40,400
decided they're not going to have a December 31 in 1994.

129
00:05:40,400 --> 00:05:45,560
They'll just go December 30, 1159, and then one minute later,

130
00:05:45,560 --> 00:05:47,840
happy new year.

131
00:05:47,840 --> 00:05:49,640
And you say, oh, well, that's just something

132
00:05:49,640 --> 00:05:50,880
that happens in the far past.

133
00:05:50,880 --> 00:05:51,920
This was the 90s.

134
00:05:51,920 --> 00:05:54,680
We were inventing programming languages and watching Seinfeld.

135
00:05:58,320 --> 00:06:00,120
That's not going to happen today, right?

136
00:06:00,120 --> 00:06:02,960
But just eight years ago, the same thing happened in Samoa.

137
00:06:02,960 --> 00:06:06,040
And historically, you've also seen things

138
00:06:06,040 --> 00:06:07,680
happen going the other way.

139
00:06:07,680 --> 00:06:12,640
So Kwajalein Atoll switched from one side to the other.

140
00:06:12,640 --> 00:06:15,520
And there were just two September 30s in 1969

141
00:06:15,520 --> 00:06:17,600
in Kwajalein Atoll.

142
00:06:17,600 --> 00:06:20,800
So you say, OK, fine.

143
00:06:20,800 --> 00:06:23,160
Daily saving time changes can happen whenever.

144
00:06:23,160 --> 00:06:25,000
And there can be millions of them.

145
00:06:25,000 --> 00:06:25,960
And it's just chaos.

146
00:06:25,960 --> 00:06:28,800
But there's one thing that I can rely on.

147
00:06:28,800 --> 00:06:30,680
And that's if I know someone's location,

148
00:06:30,680 --> 00:06:33,880
I know what time zone they're in.

149
00:06:33,880 --> 00:06:37,160
But I think you know where this is going.

150
00:06:37,160 --> 00:06:40,000
In China, they decided that it would be a great idea

151
00:06:40,000 --> 00:06:42,360
to have one time zone for the entire country.

152
00:06:42,360 --> 00:06:44,320
And this is a country that normally would span

153
00:06:44,320 --> 00:06:46,440
three or four time zones.

154
00:06:46,440 --> 00:06:49,320
But I guess administratively, it's easier.

155
00:06:49,320 --> 00:06:51,680
So they went with UTC Plus 8, which

156
00:06:51,680 --> 00:06:55,960
I think is great in Beijing, somewhere over here.

157
00:06:55,960 --> 00:07:00,520
In Xinjiang, which is far to the east

158
00:07:00,520 --> 00:07:07,560
and west, the west of China, the sunrise

159
00:07:07,560 --> 00:07:09,320
is about 4.30 in the morning.

160
00:07:09,320 --> 00:07:10,760
So that's not great.

161
00:07:10,760 --> 00:07:13,120
So they decided we're going to be UTC Plus 6.

162
00:07:13,120 --> 00:07:17,400
But Beijing, the government, does not like this.

163
00:07:17,400 --> 00:07:20,280
So all the trains and the post offices and all those things,

164
00:07:20,280 --> 00:07:21,880
they still run on UTC Plus 8.

165
00:07:21,880 --> 00:07:25,480
And then the people just use UTC Plus 6.

166
00:07:25,480 --> 00:07:27,920
And according to Wikipedia, the main difference

167
00:07:27,920 --> 00:07:30,600
of when you would choose which time zone

168
00:07:30,600 --> 00:07:34,240
is actually whether you are part of the Han majority

169
00:07:34,240 --> 00:07:36,240
or the Uyghur minority.

170
00:07:36,240 --> 00:07:39,880
So what this means is that this is actually a racial time zone.

171
00:07:39,880 --> 00:07:41,680
So I guess it is true that if you

172
00:07:41,680 --> 00:07:46,320
know someone's location and their ethnicity, then I suppose

173
00:07:46,320 --> 00:07:49,200
you can know their time zone.

174
00:07:49,200 --> 00:07:51,040
OK, so I've scared you.

175
00:07:51,040 --> 00:07:53,880
I said time zones are crazy.

176
00:07:53,880 --> 00:07:55,640
There's no possible rules.

177
00:07:55,640 --> 00:07:57,480
Why would we want to work with these at all?

178
00:07:57,520 --> 00:08:00,000
Why not just convert everything to UTC right away

179
00:08:00,000 --> 00:08:02,680
and never work with time zones?

180
00:08:02,680 --> 00:08:04,880
But time zones are actually very convenient.

181
00:08:04,880 --> 00:08:07,920
So if you're working with something like business

182
00:08:07,920 --> 00:08:11,880
markets or something and they have a business closed

183
00:08:11,880 --> 00:08:14,080
time of 5 o'clock during the weekdays,

184
00:08:14,080 --> 00:08:16,520
it's very easy for me to express this in an R rule

185
00:08:16,520 --> 00:08:20,800
and say, every day at 5 o'clock, that's the market close.

186
00:08:20,800 --> 00:08:22,080
And it happens in New York.

187
00:08:22,080 --> 00:08:24,360
So I'm going to attach this New York City time zone.

188
00:08:24,360 --> 00:08:27,260
And if you look, if I print each of these,

189
00:08:27,340 --> 00:08:28,340
I always get 5 o'clock.

190
00:08:28,340 --> 00:08:32,620
And I have the right UTC offset applied for each one of these.

191
00:08:32,620 --> 00:08:34,580
And I can get UTC from this.

192
00:08:34,580 --> 00:08:36,420
So I can compare between time zones

193
00:08:36,420 --> 00:08:39,740
by just converting over to UTC.

194
00:08:39,740 --> 00:08:41,900
And if you look at it, it's not obvious

195
00:08:41,900 --> 00:08:44,420
how you would do this if you were just working in UTC.

196
00:08:44,420 --> 00:08:46,540
Because then I would have to know when this 10 o'clock

197
00:08:46,540 --> 00:08:48,780
to 11 o'clock transition happens.

198
00:08:48,780 --> 00:08:52,180
And in fact, knowing that when those transitions happen

199
00:08:52,180 --> 00:08:53,740
is basically a time zone.

200
00:08:53,740 --> 00:08:58,740
So now hopefully this is the most convincing argument

201
00:08:58,740 --> 00:09:02,140
that you've ever seen that time zones are worth using.

202
00:09:02,140 --> 00:09:04,700
And we can just jump right in to how

203
00:09:04,700 --> 00:09:07,260
Python represents time zones.

204
00:09:07,260 --> 00:09:10,460
Python uses TZ info, which is an abstract base class.

205
00:09:13,220 --> 00:09:16,660
A concrete implementation of a time zone

206
00:09:16,660 --> 00:09:18,360
would be a subclass of TZ info.

207
00:09:18,360 --> 00:09:21,700
And it's supposed to implement these three methods, TZ name,

208
00:09:21,740 --> 00:09:24,140
UTC offset, and DST.

209
00:09:24,140 --> 00:09:26,580
As an aside, I would not recommend using this DST

210
00:09:26,580 --> 00:09:27,620
function.

211
00:09:27,620 --> 00:09:30,020
Anytime I've ever seen someone try and use it,

212
00:09:30,020 --> 00:09:34,180
they were kind of making some assumptions

213
00:09:34,180 --> 00:09:37,380
about daily saving time that don't always apply.

214
00:09:37,380 --> 00:09:40,300
So I would just kind of stick to the TZ name and UTC offset.

215
00:09:43,300 --> 00:09:44,860
But one thing that you should note

216
00:09:44,860 --> 00:09:47,280
is that each of these is implemented

217
00:09:47,280 --> 00:09:48,740
as a function of the date time.

218
00:09:48,740 --> 00:09:52,620
So what these do is they get attached to a date time,

219
00:09:52,620 --> 00:09:55,060
and then you call corresponding methods on the date time.

220
00:09:55,060 --> 00:09:57,740
And it will give you this information

221
00:09:57,740 --> 00:09:59,660
as a function of the date time.

222
00:09:59,660 --> 00:10:01,100
And I'm going to make this concrete

223
00:10:01,100 --> 00:10:04,820
by showing you this example implementation of a time zone

224
00:10:04,820 --> 00:10:06,300
representing Eastern time.

225
00:10:06,300 --> 00:10:09,220
And I don't recommend that you implement this,

226
00:10:09,220 --> 00:10:10,980
and you'll see why in a second.

227
00:10:10,980 --> 00:10:14,420
But what I've done is I have this is daylight method,

228
00:10:14,420 --> 00:10:17,380
and I've implemented the other three as a function of that.

229
00:10:17,380 --> 00:10:22,620
It just says, if daily saving time applies at this time,

230
00:10:22,620 --> 00:10:28,100
return this, or if it doesn't, return this other thing.

231
00:10:28,100 --> 00:10:33,380
And so if I construct one of these Eastern time objects,

232
00:10:33,380 --> 00:10:35,980
and I attach it to something on the daily saving time side,

233
00:10:35,980 --> 00:10:37,580
I get UTC minus 4.

234
00:10:37,580 --> 00:10:40,020
And if I attach the same object to something

235
00:10:40,020 --> 00:10:45,260
on the standard time side, I get UTC minus 5.

236
00:10:45,260 --> 00:10:48,460
But what happens if I attach it to something

237
00:10:48,460 --> 00:10:49,940
that's in the middle?

238
00:10:54,060 --> 00:10:58,100
So if I go with the Eastern daylight time side first,

239
00:10:58,100 --> 00:11:03,620
I go to the last possible time before it switches,

240
00:11:03,620 --> 00:11:05,700
or close to the last possible time.

241
00:11:05,700 --> 00:11:08,780
If I say 1.30 Eastern daylight time,

242
00:11:08,780 --> 00:11:11,460
it looks like that works fine.

243
00:11:11,460 --> 00:11:13,020
One hour after that, because we're

244
00:11:13,020 --> 00:11:15,620
about to set the clocks back, should be 1.30 Eastern standard

245
00:11:15,620 --> 00:11:16,420
time.

246
00:11:16,420 --> 00:11:19,700
But in my implementation, if I do this,

247
00:11:19,700 --> 00:11:23,500
I get 2.30 Eastern standard time.

248
00:11:23,500 --> 00:11:24,460
Why is this happening?

249
00:11:24,460 --> 00:11:29,260
It's because I didn't properly handle ambiguous times.

250
00:11:29,260 --> 00:11:31,940
Ambiguous times are times like the one

251
00:11:31,940 --> 00:11:34,700
I just showed where when you set your clock back,

252
00:11:34,700 --> 00:11:37,980
you're going to see the same time appear more than once.

253
00:11:37,980 --> 00:11:42,460
But as I mentioned earlier, the offsets

254
00:11:42,460 --> 00:11:47,660
are a function of the naive portion of the daytime,

255
00:11:47,660 --> 00:11:51,900
whereas these daytimes, 1.30 Eastern daylight time

256
00:11:51,900 --> 00:11:53,820
and 1.30 Eastern standard time, they're

257
00:11:53,820 --> 00:11:57,820
differentiated only by the output of that function, which

258
00:11:57,820 --> 00:11:59,580
is the offset.

259
00:11:59,580 --> 00:12:00,980
So how do we handle this?

260
00:12:00,980 --> 00:12:04,460
Well, the answer prior to Python 3.6 is we don't.

261
00:12:04,460 --> 00:12:05,540
Throw your hands up.

262
00:12:05,540 --> 00:12:07,940
It's not possible.

263
00:12:07,940 --> 00:12:10,860
And you were just supposed to always return

264
00:12:10,860 --> 00:12:12,180
Eastern standard time.

265
00:12:12,220 --> 00:12:15,540
But in Python 3.6, pep495 fixed this

266
00:12:15,540 --> 00:12:20,620
by introducing the fold attribute of daytime.

267
00:12:20,620 --> 00:12:25,060
And what this does is it adds a fold attribute,

268
00:12:25,060 --> 00:12:27,420
and that makes which side of that transition

269
00:12:27,420 --> 00:12:29,300
you're on a property of the daytime.

270
00:12:29,300 --> 00:12:31,300
So now you can write functions that

271
00:12:31,300 --> 00:12:33,180
take the local portion of the daytime

272
00:12:33,180 --> 00:12:35,620
and whether or not it's on one side or the other,

273
00:12:35,620 --> 00:12:40,340
and you return different tz-info information based on that.

274
00:12:40,340 --> 00:12:43,340
And how it works is that fold defaults to 0,

275
00:12:43,340 --> 00:12:48,780
and if it's 0, it represents the first instance,

276
00:12:48,780 --> 00:12:51,380
and if it's 1, it represents the second instance.

277
00:12:51,380 --> 00:12:56,100
So now we can implement functions that handle the fold.

278
00:12:56,100 --> 00:12:59,900
There are other changes that went in along with this that

279
00:12:59,900 --> 00:13:04,060
have to do with comparisons of time zone-aware daytimes.

280
00:13:04,060 --> 00:13:07,460
And so I'm going to just go into how

281
00:13:07,460 --> 00:13:09,820
the semantics of comparison work in daytime,

282
00:13:09,820 --> 00:13:11,940
because it's actually a little bit complicated.

283
00:13:11,940 --> 00:13:15,900
So there's two different regimes that apply.

284
00:13:15,900 --> 00:13:19,180
One is when the two daytimes you're comparing

285
00:13:19,180 --> 00:13:21,740
are in the same time zone.

286
00:13:21,740 --> 00:13:23,180
If they're in the same time zone,

287
00:13:23,180 --> 00:13:26,180
then the assumption is you only care about the local time.

288
00:13:26,180 --> 00:13:28,340
So in an ambiguous daytime, you'll

289
00:13:28,340 --> 00:13:32,380
see in most cases this makes no difference

290
00:13:32,380 --> 00:13:34,880
whether you're comparing the absolute time or the local time.

291
00:13:34,880 --> 00:13:37,080
But in ambiguous times, the question

292
00:13:37,080 --> 00:13:39,360
is whether you care about the time that's

293
00:13:39,360 --> 00:13:41,000
whether the thing you want to be equal

294
00:13:41,000 --> 00:13:43,600
is the time that's shown on the wall,

295
00:13:43,600 --> 00:13:46,240
or whether it's like the time that it would

296
00:13:46,240 --> 00:13:48,320
be if you converted to UTC.

297
00:13:48,320 --> 00:13:49,960
And they chose the time on the wall.

298
00:13:49,960 --> 00:13:54,400
So here you can see that if something is different only

299
00:13:54,400 --> 00:13:57,980
because of its fold, then those two things

300
00:13:57,980 --> 00:14:00,400
will compare equal.

301
00:14:00,400 --> 00:14:09,480
In the case of different zones, then they

302
00:14:09,480 --> 00:14:12,440
will just be converted to UTC and compared.

303
00:14:12,440 --> 00:14:15,920
So that's maybe more what you would expect,

304
00:14:15,920 --> 00:14:19,940
except when either daytime is ambiguous, in which case

305
00:14:19,940 --> 00:14:21,920
it just is like, whatever, it's false.

306
00:14:21,920 --> 00:14:23,760
I don't know.

307
00:14:23,760 --> 00:14:25,440
And I don't actually know why this is.

308
00:14:25,440 --> 00:14:27,240
It has something to do with hash invariance.

309
00:14:27,240 --> 00:14:29,560
And I'm sure that it has a very good reason

310
00:14:29,560 --> 00:14:34,360
because the people involved thought about this a lot.

311
00:14:34,360 --> 00:14:36,600
So I'm going to show you an interesting case that

312
00:14:36,600 --> 00:14:39,600
came up on the DateUtil issue tracker for TZ.

313
00:14:39,600 --> 00:14:43,920
So here what I have is I've created a daytime that

314
00:14:43,920 --> 00:14:48,080
represents 1 AM on March 25, 2007 in London.

315
00:14:48,080 --> 00:14:49,380
I convert it to a timestamp.

316
00:14:49,380 --> 00:14:51,960
And then I convert it back and get

317
00:14:51,960 --> 00:14:57,040
an object that represents two of the timestamp and then back

318
00:14:57,040 --> 00:14:59,460
using the London time zone, the original object.

319
00:14:59,460 --> 00:15:02,220
And then I create a brand new object

320
00:15:02,220 --> 00:15:03,420
that also represents London.

321
00:15:03,420 --> 00:15:07,380
It's the exact same data as there.

322
00:15:07,380 --> 00:15:10,660
And if I check whether x and y are equal to each other,

323
00:15:10,660 --> 00:15:11,820
I get false.

324
00:15:11,820 --> 00:15:14,860
So that's not a great start.

325
00:15:14,860 --> 00:15:18,900
But now x and z, those do equal each other.

326
00:15:18,900 --> 00:15:22,020
So that's good, but surprising that it's different.

327
00:15:22,020 --> 00:15:24,780
But at least that just means, like, why is this weirdo?

328
00:15:24,780 --> 00:15:28,780
But oh, wait, y and z.

329
00:15:28,780 --> 00:15:32,620
So now we have this weird non-transitive relationship.

330
00:15:32,620 --> 00:15:34,100
And to explain why this is, I have

331
00:15:34,100 --> 00:15:35,740
to explain imaginary times.

332
00:15:39,740 --> 00:15:43,260
So an imaginary time is a wall time that

333
00:15:43,260 --> 00:15:44,940
doesn't exist in a given zone.

334
00:15:44,940 --> 00:15:48,140
So this happens when you push your clocks forward by one hour.

335
00:15:48,140 --> 00:15:50,540
So it'll be 1.30, and then one hour after that is actually

336
00:15:50,540 --> 00:15:51,060
3.30.

337
00:15:51,060 --> 00:15:54,620
So Python is fine with you constructing a daytime that

338
00:15:54,620 --> 00:16:02,180
is like 2.30 in New York, or apparently 1 AM on March 25,

339
00:16:02,180 --> 00:16:03,820
2007 in London.

340
00:16:03,820 --> 00:16:08,340
So this 1 AM date that someone passed actually doesn't exist.

341
00:16:08,340 --> 00:16:12,900
So if I represent the one hour before and after this in UTC,

342
00:16:12,900 --> 00:16:16,300
I get midnight and 2 AM in London.

343
00:16:16,300 --> 00:16:18,900
So this happened during a transition.

344
00:16:18,900 --> 00:16:21,900
But that still really doesn't explain why it's non-transitive.

345
00:16:21,900 --> 00:16:24,100
I guess you could be like undefined behavior or whatever.

346
00:16:24,100 --> 00:16:25,500
It's not where it wants.

347
00:16:25,500 --> 00:16:28,060
But there's actually a reason why it's non-transitive.

348
00:16:28,060 --> 00:16:33,100
And the reason is that imaginary datetimes can't make round

349
00:16:33,100 --> 00:16:37,060
trips because once you map to something that's in UTC,

350
00:16:37,060 --> 00:16:38,260
you have an absolute daytime.

351
00:16:38,260 --> 00:16:41,020
And that will always map to some time that existed.

352
00:16:41,020 --> 00:16:43,100
So we start with our imaginary daytime.

353
00:16:43,100 --> 00:16:45,700
We convert it to UTC.

354
00:16:45,700 --> 00:16:49,020
And then when we convert it back, we get a different daytime.

355
00:16:49,020 --> 00:16:53,460
And so if you look, y and z were both products of a round trip

356
00:16:53,460 --> 00:16:56,460
because they went to timestamp and back.

357
00:16:56,460 --> 00:17:00,340
But we attached actually different time zones to them.

358
00:17:00,340 --> 00:17:02,780
Even though they represent the exact same data,

359
00:17:02,780 --> 00:17:05,940
the way the same zone, different zone semantics get applied

360
00:17:05,940 --> 00:17:09,780
is whether the time zones are exactly the same object.

361
00:17:09,780 --> 00:17:13,340
So because we have different object equalities,

362
00:17:13,340 --> 00:17:18,660
the first one, x and y, are using same zone semantics.

363
00:17:18,660 --> 00:17:21,240
And x and z are using different zone semantics.

364
00:17:21,240 --> 00:17:25,440
So in x and y, they just check whether 1 AM,

365
00:17:25,440 --> 00:17:28,480
they just check whether this 1 AM and midnight are the same.

366
00:17:28,480 --> 00:17:29,800
And they say false.

367
00:17:29,800 --> 00:17:33,780
And with y and z or x and z, they

368
00:17:33,780 --> 00:17:35,000
convert them both to UTC.

369
00:17:35,000 --> 00:17:37,740
Both of them will get to midnight UTC.

370
00:17:37,740 --> 00:17:38,840
And those are the same.

371
00:17:38,840 --> 00:17:41,040
So you'll get true.

372
00:17:41,040 --> 00:17:41,760
All right.

373
00:17:41,760 --> 00:17:43,720
So now we know all the edge cases.

374
00:17:43,720 --> 00:17:45,960
There's no more left.

375
00:17:45,960 --> 00:17:49,160
And we'll go into the practical aspects

376
00:17:49,160 --> 00:17:50,840
of working with time zones.

377
00:17:50,920 --> 00:17:53,600
So if you're working with time zones with date util,

378
00:17:53,600 --> 00:17:56,000
and I know the maintainer is a great guy.

379
00:17:56,000 --> 00:18:01,040
I recommend using these time zones.

380
00:18:01,040 --> 00:18:03,360
You can just attach them regularly to the daytime.

381
00:18:03,360 --> 00:18:05,880
And it's a little surprising that I have to say that.

382
00:18:05,880 --> 00:18:08,000
But you just use the constructor.

383
00:18:08,000 --> 00:18:09,280
You pass it to tzinfo.

384
00:18:09,280 --> 00:18:11,520
And it will give you this.

385
00:18:11,520 --> 00:18:14,240
It'll have the correct time zone information.

386
00:18:14,240 --> 00:18:16,400
If you have a naive time or say we

387
00:18:16,400 --> 00:18:18,000
wanted to take that first daytime

388
00:18:18,000 --> 00:18:21,680
and then reinterpret it to be in a different zone.

389
00:18:21,680 --> 00:18:25,400
So it's at 2 o'clock in San Francisco.

390
00:18:25,400 --> 00:18:28,280
But everyone in the meeting moved to New York

391
00:18:28,280 --> 00:18:29,320
all at the same time.

392
00:18:29,320 --> 00:18:30,520
And we still want it to be at 2 o'clock.

393
00:18:30,520 --> 00:18:32,720
So we're just going to switch the time zone on there

394
00:18:32,720 --> 00:18:34,200
to US Eastern.

395
00:18:34,200 --> 00:18:36,320
It'll retain the, if you use replace,

396
00:18:36,320 --> 00:18:38,640
it'll retain the 2 o'clock portion

397
00:18:38,640 --> 00:18:40,240
and just change the offset.

398
00:18:40,240 --> 00:18:44,400
If you want the same exact time, so for example,

399
00:18:44,400 --> 00:18:46,860
if that first daytime represents a meeting that's

400
00:18:46,860 --> 00:18:50,220
taking place in San Francisco and someone from New York

401
00:18:50,220 --> 00:18:56,180
is calling in, we want to know what time it is in New York.

402
00:18:56,180 --> 00:18:57,500
We use as time zone.

403
00:18:57,500 --> 00:19:01,420
And that will do the conversion for the same absolute time.

404
00:19:01,420 --> 00:19:03,500
So that gives us 5 o'clock.

405
00:19:03,500 --> 00:19:07,060
With PyTZ, you can still use as time zone.

406
00:19:07,060 --> 00:19:09,180
But if you use the constructor or replace,

407
00:19:09,180 --> 00:19:11,100
it fails in this horrible way where

408
00:19:11,100 --> 00:19:14,020
it says LMT, which is local mean time.

409
00:19:14,500 --> 00:19:19,500
The offset is minus 4 hours and 56 minutes.

410
00:19:19,500 --> 00:19:23,020
So why that happens is because PyTZ's time zone model is

411
00:19:23,020 --> 00:19:25,460
actually different than Python's time zone model.

412
00:19:25,460 --> 00:19:29,100
In PyTZ, they expect all TZInfo to be static offsets.

413
00:19:29,100 --> 00:19:31,380
They don't change as a function of the daytime.

414
00:19:31,380 --> 00:19:34,180
And which one gets applied is determined

415
00:19:34,180 --> 00:19:35,460
by the time zone itself.

416
00:19:35,460 --> 00:19:37,620
So instead of attaching things directly,

417
00:19:37,620 --> 00:19:39,620
you would use localize.

418
00:19:39,620 --> 00:19:41,700
You would call the localize method of the time zone.

419
00:19:41,700 --> 00:19:44,900
And it would attach some object to your daytime.

420
00:19:44,900 --> 00:19:46,460
And that will work.

421
00:19:46,460 --> 00:19:48,380
And then if you do anything to it,

422
00:19:48,380 --> 00:19:50,980
you have to normalize it afterwards.

423
00:19:50,980 --> 00:19:53,620
So if you add like six months, it'll

424
00:19:53,620 --> 00:19:55,780
still say that it's in daylight time,

425
00:19:55,780 --> 00:19:59,020
even though it should have transitioned by then.

426
00:19:59,020 --> 00:20:02,660
So you have to call normalize, and then it'll fix that.

427
00:20:02,660 --> 00:20:06,660
This was important back before the fold attribute existed.

428
00:20:06,660 --> 00:20:08,860
And now it is considerably less so.

429
00:20:08,860 --> 00:20:10,980
And what we're left with is something

430
00:20:10,980 --> 00:20:13,140
that is not a great interface.

431
00:20:13,140 --> 00:20:15,700
And I know a lot of people who see this slide,

432
00:20:15,700 --> 00:20:17,900
and they're like, I have to go fix code that's

433
00:20:17,900 --> 00:20:20,420
broken in production today.

434
00:20:20,420 --> 00:20:22,180
And there's more detail on my blog post

435
00:20:22,180 --> 00:20:25,380
called PyTZ, the fastest foot gun in the West,

436
00:20:25,380 --> 00:20:31,420
that explains more about the history and how things work.

437
00:20:31,420 --> 00:20:38,060
OK, so when you're working with ambiguous times,

438
00:20:38,060 --> 00:20:41,220
you may have a couple edge cases to handle.

439
00:20:41,220 --> 00:20:43,780
So if you use as time zone, datutl and PyTZ

440
00:20:43,780 --> 00:20:45,440
will both do the same thing, because it's

441
00:20:45,440 --> 00:20:46,980
taking an absolute time and converting

442
00:20:46,980 --> 00:20:48,580
to another absolute time.

443
00:20:48,580 --> 00:20:49,940
But you'll note that PyTZ does not

444
00:20:49,940 --> 00:20:55,140
set the fold because they don't use the fold or need the fold.

445
00:20:55,140 --> 00:20:59,500
If you want fold support in, say, Python 2.7,

446
00:20:59,500 --> 00:21:04,380
you can use datutl's backwards compatibility method tz.infold.

447
00:21:04,380 --> 00:21:06,140
So in Python 3.6, this just works.

448
00:21:06,140 --> 00:21:07,900
It just attaches a fold.

449
00:21:07,900 --> 00:21:09,660
In Python 2.7, what it'll do is it'll

450
00:21:09,660 --> 00:21:12,380
create a subclass that has fold whenever

451
00:21:12,380 --> 00:21:15,740
you need to use the fold, and then everything will just work.

452
00:21:15,740 --> 00:21:19,120
So datutl's time zones all use and fold internally.

453
00:21:19,120 --> 00:21:23,820
And so datutl will just kind of work even for Python 2.7.

454
00:21:23,820 --> 00:21:26,420
If you need to detect ambiguous times, like for example,

455
00:21:26,420 --> 00:21:28,900
you want to ask the user whether they should be on the daylight

456
00:21:28,900 --> 00:21:34,100
saving time or the standard time side of the transition,

457
00:21:34,100 --> 00:21:37,520
you can use datutl's datetime ambiguous,

458
00:21:37,520 --> 00:21:39,320
and that returns true if something's ambiguous

459
00:21:39,320 --> 00:21:41,600
in a given zone.

460
00:21:41,600 --> 00:21:43,360
And you can use this to selectively attach

461
00:21:43,360 --> 00:21:44,680
the fold if you want.

462
00:21:44,680 --> 00:21:47,100
But you don't actually need to selectively attach the fold.

463
00:21:47,100 --> 00:21:51,080
If you just say fold equals 1 for everything,

464
00:21:51,080 --> 00:21:54,620
it will be ignored for anything that's not ambiguous.

465
00:21:54,620 --> 00:21:57,280
To work with, there's a corresponding method

466
00:21:57,280 --> 00:21:58,720
for handling imaginary times.

467
00:21:58,720 --> 00:22:01,040
It's called datetime exists.

468
00:22:01,040 --> 00:22:05,600
And that will return false if a datetime is imaginary.

469
00:22:05,600 --> 00:22:09,800
And it's not terribly uncommon for you to say,

470
00:22:09,800 --> 00:22:12,960
well, if I land on this datetime, just tell me what time

471
00:22:12,960 --> 00:22:14,120
it is.

472
00:22:14,120 --> 00:22:18,840
Tell me what time it exists that corresponds to whatever time

473
00:22:18,840 --> 00:22:20,640
it would have been if the same amount of time

474
00:22:20,640 --> 00:22:23,320
had elapsed after the transition had happened.

475
00:22:23,320 --> 00:22:27,680
So you can use datutl's resolve imaginary for this.

476
00:22:27,680 --> 00:22:30,100
And if the gap is one hour, it'll

477
00:22:30,100 --> 00:22:32,360
shift your datetime by one hour.

478
00:22:32,360 --> 00:22:35,760
And if the gap is 24 hours or 17 minutes

479
00:22:35,760 --> 00:22:38,080
or some other weird thing, it'll figure that out

480
00:22:38,080 --> 00:22:39,200
and do it correctly.

481
00:22:42,520 --> 00:22:46,960
So in datutl, you can use it has a couple

482
00:22:46,960 --> 00:22:48,680
of different implementations.

483
00:22:48,680 --> 00:22:50,960
It has UTC and static time zones.

484
00:22:50,960 --> 00:22:52,880
Both of these are actually in Python 3.

485
00:22:52,880 --> 00:22:54,640
So after Python 3.2, you really don't

486
00:22:54,640 --> 00:22:59,400
need datutl's tz.utc object or their tz offset.

487
00:22:59,400 --> 00:23:03,200
Those are just available in datetime.

488
00:23:03,200 --> 00:23:05,480
And if you want access to the INA database,

489
00:23:05,480 --> 00:23:08,840
datutl provides a method gettz, which

490
00:23:08,840 --> 00:23:12,480
will try and find the information on the system.

491
00:23:12,480 --> 00:23:16,560
And if it fails to find that, it'll

492
00:23:16,560 --> 00:23:20,320
use its own internal database that it ships.

493
00:23:20,320 --> 00:23:22,560
And this has historical information.

494
00:23:22,560 --> 00:23:24,920
So if it works in a modern context,

495
00:23:24,920 --> 00:23:28,000
it'll just show you Eastern Daylight Time or Standard Time.

496
00:23:28,000 --> 00:23:29,440
If you go back to the 40s, it'll

497
00:23:29,440 --> 00:23:31,120
have stuff like Eastern War Time, which

498
00:23:31,120 --> 00:23:33,760
was Permanent Daylight Saving Time during World War II.

499
00:23:33,760 --> 00:23:36,480
If you go back far enough, you get back to that crazy LMT

500
00:23:36,480 --> 00:23:41,880
minus 4.93 seconds if you miss PyTz.

501
00:23:41,880 --> 00:23:43,800
And just in general, the best way

502
00:23:43,800 --> 00:23:46,600
to get a time zone from datutl is to use tz.gettz.

503
00:23:46,600 --> 00:23:49,180
So if you pass it nothing, it gives you local time.

504
00:23:49,180 --> 00:23:57,920
If you pass it something that is a representation

505
00:23:58,240 --> 00:24:03,560
of your local time zone, like LMT is one of the time zones

506
00:24:03,560 --> 00:24:06,600
abbreviations, it'll give you a local time.

507
00:24:06,600 --> 00:24:09,600
And if you pass it an INA zone, it'll give you this tz file

508
00:24:09,600 --> 00:24:11,240
object.

509
00:24:11,240 --> 00:24:13,760
So I'm just going to wrap up with some time zone tips,

510
00:24:13,760 --> 00:24:16,080
because everyone always wants the silver bullet.

511
00:24:16,080 --> 00:24:17,600
How do I work with time zones?

512
00:24:17,600 --> 00:24:20,160
You have 35 seconds.

513
00:24:20,160 --> 00:24:23,280
And unfortunately, that does not exist.

514
00:24:23,280 --> 00:24:26,280
It really all depends on your context.

515
00:24:26,280 --> 00:24:29,200
I would say one very important difference is civil times

516
00:24:29,200 --> 00:24:30,680
versus timestamps.

517
00:24:30,680 --> 00:24:32,080
A civil time is like a wall time.

518
00:24:32,080 --> 00:24:33,400
It's the time on the wall.

519
00:24:33,400 --> 00:24:37,360
And a timestamp is an absolute time, the time in UTC.

520
00:24:37,360 --> 00:24:40,200
And just know which one you care about

521
00:24:40,200 --> 00:24:41,720
and which one you're going to use.

522
00:24:41,720 --> 00:24:42,800
So if you're using a civil time, that

523
00:24:42,800 --> 00:24:46,000
would be for something like in the future, like a meeting

524
00:24:46,000 --> 00:24:47,720
or some kind of thing.

525
00:24:47,720 --> 00:24:49,320
And the reason why you would want

526
00:24:49,320 --> 00:24:52,520
to store this as the actual civil portion of the time

527
00:24:52,520 --> 00:24:56,600
plus the time zone is that that mapping changes.

528
00:24:56,600 --> 00:25:00,960
So instead of just saying, the meeting is next week at 12.

529
00:25:00,960 --> 00:25:03,920
Let's store it in UTC and just change it back

530
00:25:03,920 --> 00:25:05,240
when the user is going to see it.

531
00:25:05,240 --> 00:25:06,840
You really want to say it's at 12.

532
00:25:06,840 --> 00:25:10,600
Because if you convert it to UTC and then, say,

533
00:25:10,600 --> 00:25:12,160
the president says, daily saving time

534
00:25:12,160 --> 00:25:13,880
is canceled as of tomorrow, which

535
00:25:13,880 --> 00:25:18,680
happens a surprising amount, then you've

536
00:25:18,680 --> 00:25:20,200
just lost that information.

537
00:25:20,200 --> 00:25:21,680
You can't recover it.

538
00:25:21,680 --> 00:25:24,920
So it's best to keep your abstractions close

539
00:25:24,920 --> 00:25:26,840
to what you actually care about.

540
00:25:26,840 --> 00:25:32,680
And then finally, the way that these things are serialized.

541
00:25:32,680 --> 00:25:34,640
Never rely on those three-letter abbreviations.

542
00:25:34,640 --> 00:25:36,560
They're ambiguous.

543
00:25:36,560 --> 00:25:41,160
The keys, like America, New York, or whatever,

544
00:25:41,160 --> 00:25:43,160
those are just lookups in the time zone database.

545
00:25:43,160 --> 00:25:44,640
If you want to show them to a user,

546
00:25:44,640 --> 00:25:47,520
pass them through CLDR, which will localize them,

547
00:25:47,520 --> 00:25:49,320
and say, in the native language,

548
00:25:49,360 --> 00:25:52,240
and they will be something that a user can look at.

549
00:25:52,240 --> 00:25:54,640
All right, so thank you very much for coming to my talk.

550
00:25:54,640 --> 00:25:58,360
And thanks to PyCon for putting on a great conference.

551
00:25:58,360 --> 00:25:58,860
?

552
00:25:58,860 --> 00:26:10,060
All right, we have enough time to take probably two to three

553
00:26:10,060 --> 00:26:10,780
questions.

554
00:26:10,780 --> 00:26:12,940
But I'm guessing Paul will be happy to speak after,

555
00:26:12,940 --> 00:26:15,740
if you're not one of those two to three people.

556
00:26:15,740 --> 00:26:18,940
I can talk to her as long as you need.

557
00:26:18,940 --> 00:26:21,900
So we have this practice of pinning our dependencies

558
00:26:21,900 --> 00:26:25,620
so things don't blow up when we least expect it,

559
00:26:25,620 --> 00:26:28,340
when we're going to be building our thing,

560
00:26:28,340 --> 00:26:30,540
or building our system.

561
00:26:30,540 --> 00:26:33,660
And it sounds like we need to be reinstalling

562
00:26:33,660 --> 00:26:40,780
dateUtil every 30 seconds so that this stuff stays up to date.

563
00:26:40,780 --> 00:26:44,180
Because how does it stay up to date

564
00:26:44,180 --> 00:26:47,460
when something can happen like today,

565
00:26:47,460 --> 00:26:49,820
and we need to be able to adjust to it?

566
00:26:49,820 --> 00:26:50,500
I don't know.

567
00:26:50,500 --> 00:26:51,620
How does that work?

568
00:26:51,620 --> 00:26:55,420
So by default, dateUtil will not use its own.

569
00:26:55,420 --> 00:26:57,380
It ships its own info information.

570
00:26:57,380 --> 00:27:02,020
But that's mainly used on either Windows or on certain cloud

571
00:27:02,020 --> 00:27:03,820
providers, anywhere where the TZ data is not

572
00:27:03,820 --> 00:27:05,220
installed into the system.

573
00:27:05,220 --> 00:27:08,100
By default, dateUtil has a number of paths

574
00:27:08,100 --> 00:27:11,780
that it'll look for the time zone information on.

575
00:27:11,780 --> 00:27:15,980
And it will pull it from the system if it's available.

576
00:27:15,980 --> 00:27:19,460
And I am hoping to, at some point,

577
00:27:19,460 --> 00:27:21,700
pull that data out of dateUtil and have it

578
00:27:21,700 --> 00:27:23,500
be a separate package so you don't

579
00:27:23,500 --> 00:27:25,620
have to upgrade both the data and the code

580
00:27:25,620 --> 00:27:29,260
if you're on Windows or something where it doesn't

581
00:27:29,260 --> 00:27:31,660
know where to find that information.

582
00:27:31,660 --> 00:27:34,460
But yeah, for now, you kind of have to keep it up to date

583
00:27:34,460 --> 00:27:37,900
or make sure that you have TZ data installed on the system.

584
00:27:42,420 --> 00:27:45,300
I actually wanted to defend those leap seconds.

585
00:27:45,300 --> 00:27:48,700
I come from space sciences, and all those leap seconds

586
00:27:48,700 --> 00:27:50,740
mean big deals to me.

587
00:27:50,740 --> 00:27:52,940
Thank you for a prompt for me to talk about leap seconds,

588
00:27:52,940 --> 00:27:56,060
because I have some thoughts.

589
00:27:58,780 --> 00:28:00,940
I have a few bad experiments.

590
00:28:00,940 --> 00:28:04,380
No, I think that my understanding

591
00:28:04,380 --> 00:28:08,340
was that most astronomers use Julian time and TAI

592
00:28:08,340 --> 00:28:10,900
or something, which is monotonic, right?

593
00:28:10,900 --> 00:28:15,420
But this is FPGA experiments for ionospheric disturbances.

594
00:28:15,420 --> 00:28:20,020
And so our data has to be right on.

595
00:28:20,020 --> 00:28:23,500
So those leap seconds are calculated into the position.

596
00:28:23,500 --> 00:28:26,220
Yeah, to me, my main problem with leap seconds

597
00:28:26,220 --> 00:28:29,620
is actually just that it's in civil time,

598
00:28:29,620 --> 00:28:32,660
because if you're in space science

599
00:28:32,660 --> 00:28:36,340
or if you're in navigation or any number of situations

600
00:28:36,340 --> 00:28:38,580
where you need this information, I

601
00:28:38,580 --> 00:28:40,220
think people should be calculating it,

602
00:28:40,220 --> 00:28:41,820
and there should be a reference time that

603
00:28:41,820 --> 00:28:43,380
has leap seconds in it.

604
00:28:43,380 --> 00:28:46,940
But the average person does not need this information.

605
00:28:46,940 --> 00:28:50,380
And it's easy to calculate it as an offset from TAI.

606
00:28:50,380 --> 00:28:54,380
TAI is another reference time that is monotonic,

607
00:28:54,380 --> 00:28:57,580
and it's like 17 or 35 seconds behind UTC.

608
00:28:57,580 --> 00:28:58,340
Who knows?

609
00:29:02,580 --> 00:29:04,860
You can maybe tell that I'm not great with details,

610
00:29:04,860 --> 00:29:08,660
left or right, west, addition and subtraction.

611
00:29:11,700 --> 00:29:13,740
If you want to talk more about Daytime with Paul,

612
00:29:13,740 --> 00:29:15,460
I'm sure he'll be around.

613
00:29:15,460 --> 00:29:17,740
Otherwise, if you want to head down to Hall A,

614
00:29:17,740 --> 00:29:19,300
there are community awards happening,

615
00:29:19,300 --> 00:29:21,620
being presented by AWA, followed by a keynote

616
00:29:21,620 --> 00:29:23,020
and closing remarks.

617
00:29:23,020 --> 00:29:23,860
Thanks, everyone.

618
00:29:23,860 --> 00:29:24,420
Thank you.

619
00:29:24,420 --> 00:29:24,980
Thank you.

620
00:29:24,980 --> 00:29:25,540
Thank you.

621
00:29:25,540 --> 00:29:26,100
Thank you.

622
00:29:26,100 --> 00:29:26,660
Thank you.

623
00:29:26,660 --> 00:29:27,220
Thank you.

