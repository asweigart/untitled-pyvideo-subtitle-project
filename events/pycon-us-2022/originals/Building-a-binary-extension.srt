1
00:00:00,000 --> 00:00:07,120
Good morning, everybody.

2
00:00:07,120 --> 00:00:09,640
Thank you so much for being able to join us this morning.

3
00:00:09,640 --> 00:00:13,840
We have one more talk and then glorious lunch.

4
00:00:13,840 --> 00:00:17,080
I know you're all looking forward to it, but hang tight because this promises to be

5
00:00:17,080 --> 00:00:18,080
really, really cool.

6
00:00:18,080 --> 00:00:23,320
So, today we are going to hear from Henry Schreiner, building a binary extension.

7
00:00:23,320 --> 00:00:27,400
Henry Schreiner is a computational physicist slash research software engineer in high energy

8
00:00:27,400 --> 00:00:29,440
physics at Princeton University.

9
00:00:29,440 --> 00:00:33,320
He specializes in the interface between high performance compiled codes and interactive

10
00:00:33,320 --> 00:00:37,320
computation in Python, in software distribution, and in interface design.

11
00:00:37,320 --> 00:00:41,400
He's previously worked on computational cosmic ray tomography for archaeology and high performance

12
00:00:41,400 --> 00:00:42,780
GPU model fitting.

13
00:00:42,780 --> 00:00:46,960
He's currently a member of the IRIS HEP project, developing tools for the next era of the Large

14
00:00:46,960 --> 00:00:49,960
Hadron Collider, LHC.

15
00:00:49,960 --> 00:00:54,000
Ladies and gentlemen, Henry Schreiner.

16
00:00:54,000 --> 00:00:56,280
Thank you.

17
00:00:56,280 --> 00:01:02,240
So I'm Henry Schreiner, and I'm working with the IRIS HEP project, which is basically

18
00:01:02,240 --> 00:01:11,200
trying to build a set of Python tools to replace and augment the existing C++ that we've been

19
00:01:11,200 --> 00:01:14,680
using in energy physics since the mid-90s.

20
00:01:14,680 --> 00:01:20,160
We actually have a C++ interpreter, if you'd – you probably don't want to know that.

21
00:01:20,160 --> 00:01:23,880
So we've been building up these tools, and one of the things that was really important

22
00:01:24,040 --> 00:01:29,800
with this is we have very high performance requirements in certain areas.

23
00:01:29,800 --> 00:01:33,960
We have the largest academic data set in the world, for example.

24
00:01:33,960 --> 00:01:37,720
And so with this, it becomes really, really important to be able to do some of the things

25
00:01:37,720 --> 00:01:39,560
you'll be seeing today.

26
00:01:39,560 --> 00:01:42,160
So I'm going to start with a question.

27
00:01:42,160 --> 00:01:44,280
Is Python fast?

28
00:01:44,280 --> 00:01:46,560
So of course, this is a completely ambiguous question.

29
00:01:46,560 --> 00:01:48,440
Good way to start.

30
00:01:48,440 --> 00:01:50,720
But let's just take an example here.

31
00:01:50,720 --> 00:01:53,000
This is an article that came out fairly recently.

32
00:01:53,880 --> 00:01:55,600
Well, within the last two years.

33
00:01:55,600 --> 00:01:59,840
And they had this problem where they're projecting a billion cells.

34
00:01:59,840 --> 00:02:06,000
And this had a – they had this Fortran code, 1,500 lines of Fortran code, that did this

35
00:02:06,000 --> 00:02:08,000
in six hours and 30 minutes.

36
00:02:08,000 --> 00:02:11,440
And finally, they decided to rewrite this in Python.

37
00:02:11,440 --> 00:02:15,160
And when they did that, it took four minutes.

38
00:02:15,160 --> 00:02:19,880
And the reason for this was really they had this high-level language.

39
00:02:19,880 --> 00:02:22,160
They had libraries that they could access.

40
00:02:22,160 --> 00:02:23,760
It allowed them to easily explore different algorithms.

41
00:02:23,760 --> 00:02:26,520
If you have a billion cells, you're doing projections.

42
00:02:26,520 --> 00:02:28,080
You really want to use something like a KD tree.

43
00:02:28,080 --> 00:02:30,480
There's one in SciPy, so they just use that.

44
00:02:30,480 --> 00:02:33,200
And so the key behind this is that you have a library.

45
00:02:33,200 --> 00:02:36,640
And in that library, you have compiled code that does the hard work for you, and you're

46
00:02:36,640 --> 00:02:39,400
still able to stay in Python.

47
00:02:39,400 --> 00:02:44,600
So Python has really great performance, as long as you can find a library that has your

48
00:02:44,600 --> 00:02:47,520
desired algorithm in it, like NumPy or Pandas or something like that.

49
00:02:47,520 --> 00:02:48,520
But what do you do if you don't?

50
00:02:48,880 --> 00:02:53,720
What do you do if you have some sort of algorithm that's not already coded up somewhere?

51
00:02:53,720 --> 00:02:55,120
How do you write that yourself?

52
00:02:55,120 --> 00:02:57,400
And that's what we'll be looking at.

53
00:02:57,400 --> 00:02:59,880
So the first possible solution to this would be you could just dump Python.

54
00:02:59,880 --> 00:03:06,680
This is the Twitter and random article on the internet solution.

55
00:03:06,680 --> 00:03:08,200
Maybe you're enticed by these other languages.

56
00:03:08,200 --> 00:03:13,120
Is anybody enticed by C?

57
00:03:13,120 --> 00:03:14,960
But they offer native performance.

58
00:03:14,960 --> 00:03:19,160
Well, Python, though, is really easy to learn.

59
00:03:19,160 --> 00:03:22,480
It's very quick to write.

60
00:03:22,480 --> 00:03:24,080
And it has this massive ecosystem.

61
00:03:24,080 --> 00:03:28,800
I would say each of these three things are equally important and incredibly important.

62
00:03:28,800 --> 00:03:32,320
So you'll see, and this is where we'll get with the final solution, which you might have

63
00:03:32,320 --> 00:03:36,360
already guessed that by the title of the talk, is you can split the driver code.

64
00:03:36,360 --> 00:03:39,600
And that's the stuff that usually takes the most time to work on.

65
00:03:39,600 --> 00:03:41,960
And that's what you're manipulating and working with.

66
00:03:41,960 --> 00:03:43,280
That can still be in Python.

67
00:03:43,280 --> 00:03:49,080
And then you can just move the performance critical code to something else and work together.

68
00:03:49,080 --> 00:03:51,120
Before we go on, though, there's a few other possible solutions.

69
00:03:51,120 --> 00:03:52,120
One is Numba.

70
00:03:52,120 --> 00:03:55,680
This is a just-in-time compiler for Python.

71
00:03:55,680 --> 00:03:59,360
This is just as fast or faster than any other solution you can come up with most of the

72
00:03:59,360 --> 00:04:01,280
time.

73
00:04:01,280 --> 00:04:03,000
But it does have some downsides.

74
00:04:03,000 --> 00:04:06,480
You are going to have to do the just-in-time compiling on the device.

75
00:04:06,480 --> 00:04:10,080
It's a somewhat heavy dependency.

76
00:04:10,080 --> 00:04:11,680
There's plus sides and downsides.

77
00:04:11,680 --> 00:04:15,480
But if you just want to make it faster, this might be the first thing to try.

78
00:04:15,480 --> 00:04:18,440
This would be the first thing I would try.

79
00:04:18,440 --> 00:04:21,320
Another solution is you can just make Python itself faster.

80
00:04:21,320 --> 00:04:24,200
There's a variety of different packages and projects that do this.

81
00:04:24,200 --> 00:04:27,200
You have PyPy, of course, for quite a while.

82
00:04:27,200 --> 00:04:29,920
Pyjama is a bit newer one.

83
00:04:29,920 --> 00:04:33,600
And then there's even forks of CPython to try to make it faster.

84
00:04:33,600 --> 00:04:37,200
And CPython itself is actually interested in getting faster now, too.

85
00:04:37,480 --> 00:04:41,760
These sorts of things are in the, say, 5x performance range.

86
00:04:41,760 --> 00:04:45,320
Maybe get five times faster, at least for CPython.

87
00:04:45,320 --> 00:04:49,600
But they don't really make heavy numeric code faster because that already sits in a

88
00:04:49,600 --> 00:04:50,600
compiled language.

89
00:04:50,600 --> 00:04:53,000
It doesn't need to be made faster.

90
00:04:53,000 --> 00:04:56,960
You may need more algorithms, things like that.

91
00:04:56,960 --> 00:04:59,940
And of course, the solution we'll be looking at today is this one.

92
00:04:59,940 --> 00:05:01,320
You can precompile.

93
00:05:01,320 --> 00:05:03,600
So you can write code using the CPython API.

94
00:05:03,600 --> 00:05:06,760
Or you can have maybe code sitting in an interface somewhere.

95
00:05:06,760 --> 00:05:13,760
And then that can be compiled into an extension.

96
00:05:13,760 --> 00:05:16,080
And you can then distribute that.

97
00:05:16,080 --> 00:05:20,360
And it turns out that a lot of things you use every day are actually, this is actually

98
00:05:20,360 --> 00:05:22,920
done for those things.

99
00:05:22,920 --> 00:05:26,880
And this works very, very well.

100
00:05:26,880 --> 00:05:29,340
So first let's go into a little bit of what a binary extension is.

101
00:05:29,340 --> 00:05:34,100
If you're using Python now, you probably think in terms of you have some code you're

102
00:05:34,100 --> 00:05:35,100
writing.

103
00:05:35,100 --> 00:05:36,100
And then you're using libraries.

104
00:05:36,100 --> 00:05:39,340
And if you were to write your own library, you'd probably start with this first one,

105
00:05:39,340 --> 00:05:41,100
this side on the left here.

106
00:05:41,100 --> 00:05:42,900
You'd put all your library code in Python.

107
00:05:42,900 --> 00:05:46,180
Well, that code in the library can also be compiled code.

108
00:05:46,180 --> 00:05:49,060
It can be a binary extension.

109
00:05:49,060 --> 00:05:52,440
And the first one is really easy.

110
00:05:52,440 --> 00:05:56,260
But the next one traditionally has been viewed as complex.

111
00:05:56,260 --> 00:06:00,860
The examples tended to be rather poor, tended to be things that a really large library like

112
00:06:00,860 --> 00:06:02,900
NumPy would do.

113
00:06:02,900 --> 00:06:08,820
And there are lots of details in building these and distributing them that, for example,

114
00:06:08,820 --> 00:06:12,380
you need to compile on every different platform you support, that sort of thing.

115
00:06:12,380 --> 00:06:13,780
But you can achieve really high performance.

116
00:06:13,780 --> 00:06:17,380
And one of my goals in this talk will be to show you that this is actually not that hard

117
00:06:17,380 --> 00:06:18,380
to do.

118
00:06:18,380 --> 00:06:20,860
You can do this yourself.

119
00:06:20,860 --> 00:06:24,780
And the tooling around this and all that has become very, very good.

120
00:06:24,820 --> 00:06:29,780
And it's really not as complex or as hard as it used to be.

121
00:06:29,780 --> 00:06:33,060
So here's an example of wheels.

122
00:06:33,060 --> 00:06:35,460
So I start my example with wheels for showing you something that's not a wheel.

123
00:06:35,460 --> 00:06:36,940
That's an S-disk.

124
00:06:36,940 --> 00:06:44,220
And that thing has a setup.py or a pyproject.toml or some collection of tools that allow a

125
00:06:44,220 --> 00:06:46,380
backend to build that.

126
00:06:46,380 --> 00:06:49,100
So that's where your source code sits.

127
00:06:49,100 --> 00:06:50,940
Then you have this.

128
00:06:50,940 --> 00:06:52,460
This is a pure Python wheel.

129
00:06:52,540 --> 00:06:55,260
This is something usually that just contains Python.

130
00:06:55,260 --> 00:06:56,260
You'll see the name there.

131
00:06:56,260 --> 00:06:59,020
It has the implementation API and platform.

132
00:06:59,020 --> 00:07:02,700
That's just Py3, none, any.

133
00:07:02,700 --> 00:07:05,100
And this doesn't have compiled extensions.

134
00:07:05,100 --> 00:07:06,700
And then you have wheels that look like this.

135
00:07:06,700 --> 00:07:10,300
These are the ones that have binaries in them.

136
00:07:10,300 --> 00:07:14,780
And you see you have the implementation, the API.

137
00:07:14,780 --> 00:07:18,540
Those have actually been the same most of the time in modern Python.

138
00:07:18,540 --> 00:07:23,500
And then you have a platform, which is your operating system and your architecture.

139
00:07:23,500 --> 00:07:24,940
And pip will actually do the smart thing.

140
00:07:24,940 --> 00:07:27,100
It'll pick the most specific one.

141
00:07:27,100 --> 00:07:30,140
So in mypy's case, they actually have a pure Python wheel.

142
00:07:30,140 --> 00:07:31,420
And they compile.

143
00:07:31,420 --> 00:07:34,420
So that way, if you're not on one of these systems, it will fall back.

144
00:07:34,420 --> 00:07:38,060
But most of you will probably be on one of those systems.

145
00:07:38,060 --> 00:07:41,740
There's only a few cases where you end up falling back.

146
00:07:41,740 --> 00:07:43,540
So things like NumPy are shipped.

147
00:07:43,540 --> 00:07:45,180
There's no pure Python version of NumPy.

148
00:07:45,180 --> 00:07:47,660
And they still ship quite well with this.

149
00:07:48,660 --> 00:07:52,300
And we'll be looking at how to make this third one today.

150
00:07:52,300 --> 00:07:55,220
So I've already gone over one of the two main reasons to compile.

151
00:07:55,220 --> 00:07:56,300
You can get performance.

152
00:07:56,300 --> 00:08:00,100
It's also useful for code reuse.

153
00:08:00,100 --> 00:08:02,300
There's already great libraries out in these other languages.

154
00:08:02,300 --> 00:08:05,820
You can just use those in your compiled extensions.

155
00:08:05,820 --> 00:08:06,980
You don't have to rewrite them.

156
00:08:06,980 --> 00:08:10,780
Or maybe you want to write something that works in both languages.

157
00:08:10,780 --> 00:08:16,660
So this is just a collection of some different libraries that ship binary wheels,

158
00:08:16,660 --> 00:08:19,820
things like PyTorch and mypy, pandas, NumPy.

159
00:08:19,820 --> 00:08:23,940
And you'll see non-scientific and numeric things in there as well.

160
00:08:23,940 --> 00:08:27,460
You see UV loop and twisted web sockets.

161
00:08:30,060 --> 00:08:33,300
So we'll start this talk also with a few disclaimers.

162
00:08:33,300 --> 00:08:34,460
This will be a biased talk.

163
00:08:34,460 --> 00:08:37,340
I'll be showing you things I work on.

164
00:08:37,340 --> 00:08:39,220
But I like those projects enough to join them.

165
00:08:39,220 --> 00:08:41,460
And those are the things I know the most about.

166
00:08:41,460 --> 00:08:44,620
And we'll also be looking at good practices.

167
00:08:44,660 --> 00:08:45,940
Maybe there'll be best practices.

168
00:08:45,940 --> 00:08:48,100
But this is definitely not the only way you do things.

169
00:08:51,900 --> 00:08:54,540
You might be now saying to me, well, but it's hard.

170
00:08:54,540 --> 00:08:56,020
Compiling code is hard.

171
00:08:56,020 --> 00:08:59,820
It requires that you do a lot more than just shipping a Python extension.

172
00:08:59,820 --> 00:09:00,300
That's true.

173
00:09:00,300 --> 00:09:02,620
But let's divide this problem up into three stages.

174
00:09:02,620 --> 00:09:04,020
You've already sort of seen them.

175
00:09:04,020 --> 00:09:07,140
First, you have the actual writing of whatever you're interested in.

176
00:09:07,140 --> 00:09:10,940
So that could be something that's written in C++.

177
00:09:11,500 --> 00:09:16,420
It could be something that is in something, let's say, like MyPyC.

178
00:09:16,420 --> 00:09:18,700
So you write something that looks like Python and you still want to compile it.

179
00:09:20,300 --> 00:09:24,100
And then once you have something you want to compile, then notice I'm skipping

180
00:09:24,100 --> 00:09:29,660
things like here, because those don't fall into this area.

181
00:09:30,940 --> 00:09:33,300
And then you have a build system.

182
00:09:33,300 --> 00:09:37,700
This is something that takes that code and produces the binaries.

183
00:09:37,700 --> 00:09:41,580
Traditionally, this has been set up tools and distutils.

184
00:09:41,580 --> 00:09:46,060
But this is starting to become a more interesting space and

185
00:09:46,060 --> 00:09:49,580
a little less tied to just that one specific view.

186
00:09:49,580 --> 00:09:51,860
You'll see that again in a minute.

187
00:09:51,860 --> 00:09:55,420
And then you need a tool to do the wheel building.

188
00:09:55,420 --> 00:09:58,300
Because once you have these things, you need to produce wheels that are

189
00:09:58,300 --> 00:10:01,100
redistributable that can go out to all the different platforms.

190
00:10:01,100 --> 00:10:06,500
And we'll be focusing primarily on this path through here.

191
00:10:06,500 --> 00:10:08,940
Of course, there's lots of different paths we could take, but

192
00:10:08,940 --> 00:10:11,820
this is the one I'll be focusing on today.

193
00:10:11,820 --> 00:10:14,620
But I like this because it's a mix and match.

194
00:10:14,620 --> 00:10:18,780
You may find some other binding tool or coding tool better for you, but

195
00:10:18,780 --> 00:10:20,700
you might still want to build wheels, that sort of thing.

196
00:10:22,700 --> 00:10:26,140
Okay, so starting with this bindings and codings,

197
00:10:26,140 --> 00:10:27,380
there's sort of two choices here.

198
00:10:27,380 --> 00:10:30,260
You can access existing compiled code.

199
00:10:30,260 --> 00:10:31,940
So some of the tools sort of focus on that.

200
00:10:31,940 --> 00:10:35,300
How do you get C++ or Go or Rust or something out?

201
00:10:36,500 --> 00:10:39,540
And there's also from scratch code, which is code you want to write and

202
00:10:39,540 --> 00:10:40,500
you want to make it faster.

203
00:10:40,500 --> 00:10:42,980
You're not trying to reuse an existing algorithm.

204
00:10:42,980 --> 00:10:45,260
And you probably want something that looks like Python.

205
00:10:45,260 --> 00:10:49,020
So Cython, MyPyC, things like that tend to be in this category.

206
00:10:49,020 --> 00:10:51,340
And you might even be able to make your extension optional a bit easier with

207
00:10:51,340 --> 00:10:52,860
this one, because maybe it's even the same code.

208
00:10:54,900 --> 00:11:01,700
So starting with this idea of interfacing the existing library,

209
00:11:01,700 --> 00:11:04,380
where you're not actually writing the binding.

210
00:11:04,460 --> 00:11:05,860
You have this side.

211
00:11:07,220 --> 00:11:09,260
That's how you would load a library from C types.

212
00:11:09,260 --> 00:11:11,980
And then you have to build that shared object library somewhere.

213
00:11:11,980 --> 00:11:15,220
And you have to do all of the work yourself.

214
00:11:15,220 --> 00:11:16,740
And then Python also provides,

215
00:11:16,740 --> 00:11:21,300
C Python provides this way to write your own extensions.

216
00:11:22,660 --> 00:11:24,220
And that would be writing this.

217
00:11:24,220 --> 00:11:26,740
Most of the time you probably should not be writing this by hand, but

218
00:11:26,740 --> 00:11:30,260
I'm just sort of illustrating what you would need,

219
00:11:30,260 --> 00:11:32,940
what all these binding tools are actually doing behind the scenes.

220
00:11:32,940 --> 00:11:34,900
They're writing stuff that looks like this.

221
00:11:34,900 --> 00:11:37,220
And there's only sort of two important things here.

222
00:11:37,220 --> 00:11:41,900
And it's this, the fact that you have this name,

223
00:11:41,900 --> 00:11:44,420
that's dependent on the name of your module.

224
00:11:44,420 --> 00:11:47,500
And that's how it knows to look up what it has, and then you list what you have.

225
00:11:49,380 --> 00:11:51,220
Staying on the C interface side,

226
00:11:51,220 --> 00:11:54,260
let's just briefly mention a couple options there.

227
00:11:54,260 --> 00:11:55,660
C types is built in.

228
00:11:55,660 --> 00:12:00,780
It's very simple, but you're really, it's up to you to get everything right yourself.

229
00:12:00,780 --> 00:12:04,020
So it's probably a good idea to try to wrap this in something so

230
00:12:04,020 --> 00:12:07,660
that you have some sort of nice interface for your users.

231
00:12:07,660 --> 00:12:10,500
And because it's not going to protect you if you do anything wrong.

232
00:12:10,500 --> 00:12:15,740
This is a good way to get seg faults in C Python, if you make a mistake here.

233
00:12:15,740 --> 00:12:20,180
And CFFI is a tool heavily for that, I think came out of the PyPy there.

234
00:12:21,420 --> 00:12:23,940
They built sort of this tool that reads in the C headers.

235
00:12:23,940 --> 00:12:28,500
It's a library you get on PyPy, PyPI, you know how to do that.

236
00:12:28,500 --> 00:12:32,460
And you can generate some of this automatically and get some extra safety there.

237
00:12:34,100 --> 00:12:37,100
Going back to the sort of traditional ways to do this,

238
00:12:37,100 --> 00:12:39,900
Numba actually also has the ability, besides being a JET,

239
00:12:39,900 --> 00:12:41,780
I remember I said it would not be in this area, but

240
00:12:41,780 --> 00:12:44,660
it also has an ahead of time compile, which looks like this.

241
00:12:44,660 --> 00:12:49,820
Where you can take a little function, you can put an export on the out and

242
00:12:49,820 --> 00:12:51,900
you have to tell it what the module name is.

243
00:12:51,900 --> 00:12:55,740
Remember it has to get that module name in order to produce a extension,

244
00:12:55,740 --> 00:12:58,540
because that's part of the interface.

245
00:12:58,540 --> 00:13:01,380
And you could compile it, they have this extension for

246
00:13:01,380 --> 00:13:08,220
distutils that you can just stick in there.

247
00:13:08,220 --> 00:13:11,100
And then you could actually just run this and compile this ahead of time,

248
00:13:11,100 --> 00:13:12,180
ship it as a wheel.

249
00:13:12,180 --> 00:13:13,180
It would not require Numba.

250
00:13:15,700 --> 00:13:19,020
This is very limited, but it's an option.

251
00:13:19,020 --> 00:13:23,340
And I've seen it used at least once in a real situation.

252
00:13:23,340 --> 00:13:26,300
Another option is mypyc.

253
00:13:26,300 --> 00:13:29,900
So this really piggybacks on top of modern Python typing.

254
00:13:29,900 --> 00:13:33,100
So for example, you see this on the left, you see a little piece of code.

255
00:13:33,100 --> 00:13:34,380
It has type hints.

256
00:13:34,380 --> 00:13:35,260
It's valid Python.

257
00:13:35,260 --> 00:13:36,500
I can run this with Python.

258
00:13:36,500 --> 00:13:37,980
You see Python fib.py.

259
00:13:37,980 --> 00:13:40,180
Or I can compile it with mypyc.

260
00:13:40,180 --> 00:13:43,100
And then I can run it and it'll be ten times faster,

261
00:13:43,100 --> 00:13:46,420
as it's actually compiling the function in the middle.

262
00:13:48,220 --> 00:13:51,620
For comparison, if you did this with the JET, this would be 35 times faster.

263
00:13:51,620 --> 00:13:54,140
You can't do it with the head of time compile because recursive is not

264
00:13:54,140 --> 00:13:58,140
supported in that head of time compile that you saw.

265
00:13:59,860 --> 00:14:05,460
Another popular option is fast not quite Python, Python.

266
00:14:05,460 --> 00:14:06,740
And that's Cython.

267
00:14:06,740 --> 00:14:08,100
This has been around for a very long time.

268
00:14:08,100 --> 00:14:10,700
It's a very good tool for doing this.

269
00:14:10,700 --> 00:14:12,820
You can see some code over on the right.

270
00:14:12,820 --> 00:14:16,580
This is not probably what you are used to seeing with the Cython code, but

271
00:14:16,580 --> 00:14:19,660
this is actually valid Python and Cython code.

272
00:14:19,660 --> 00:14:21,260
There is an interface to do that.

273
00:14:21,340 --> 00:14:25,820
There is also sort of this weird hybrid between C and Python that they provide.

274
00:14:25,820 --> 00:14:27,500
So it also has a custom language.

275
00:14:27,500 --> 00:14:28,940
That's what you see a bit more often.

276
00:14:28,940 --> 00:14:31,620
And there's the code for writing it at the bottom.

277
00:14:31,620 --> 00:14:33,700
And that's nine times faster.

278
00:14:33,700 --> 00:14:37,620
So it's a little bit slower than the mypyc example for this little piece.

279
00:14:39,660 --> 00:14:42,020
And Cython does have some downsides.

280
00:14:42,020 --> 00:14:44,780
It can actually bind C and C++, but it wasn't really built for that.

281
00:14:44,780 --> 00:14:46,580
It will be very verbose if you try to do that.

282
00:14:46,980 --> 00:14:51,420
And it's got a few caveats and drawbacks.

283
00:14:51,420 --> 00:14:52,580
But it's really good.

284
00:14:52,580 --> 00:14:55,020
It was really designed sort of to allow you to write Python and

285
00:14:55,020 --> 00:14:57,100
then make it much faster and compile it.

286
00:14:57,100 --> 00:14:57,860
And it works well for that.

287
00:15:00,420 --> 00:15:04,980
And then PyBind 11 is a header only pure C++ interface.

288
00:15:04,980 --> 00:15:06,380
And just to unpack that a bit,

289
00:15:06,380 --> 00:15:09,780
it means that it's really trivial to add it to a C++ project.

290
00:15:10,940 --> 00:15:12,380
There are no special build requirements.

291
00:15:12,380 --> 00:15:15,620
It's just C++ 11 or newer.

292
00:15:15,620 --> 00:15:17,540
And there's no precompile phase.

293
00:15:17,540 --> 00:15:23,220
You don't have to Cythonize or use one of these other sort of tools to prepare it.

294
00:15:23,220 --> 00:15:25,340
It's just straight C++.

295
00:15:25,340 --> 00:15:28,740
And you can kind of think of it as if it was a C++ API for Python itself.

296
00:15:30,420 --> 00:15:32,780
It was really designed just to do the binding.

297
00:15:32,780 --> 00:15:37,540
It was not designed to do these other things.

298
00:15:39,700 --> 00:15:42,940
So here's a little example of what it looks like to use PyBind 11.

299
00:15:42,940 --> 00:15:44,020
You include it.

300
00:15:44,020 --> 00:15:47,780
You have your C or C++ code that you're interested in binding.

301
00:15:49,180 --> 00:15:50,500
And then you create a module.

302
00:15:50,500 --> 00:15:53,180
Remember, it has to get the name of that module somehow.

303
00:15:53,180 --> 00:15:55,740
So this is how you're telling it what the name of the module is so

304
00:15:55,740 --> 00:15:58,420
it can generate the correct entry point.

305
00:15:58,420 --> 00:16:04,460
And then you just take your, the M is the module object in PyBind 11.

306
00:16:04,460 --> 00:16:07,020
And you just can define an add.

307
00:16:07,020 --> 00:16:09,100
And it will actually infer the signature and

308
00:16:09,100 --> 00:16:11,740
things like that from the thing that you pass in.

309
00:16:12,500 --> 00:16:16,060
Okay, and you can actually compile this yourself if you want.

310
00:16:16,060 --> 00:16:18,500
And this would just work as is.

311
00:16:18,500 --> 00:16:20,340
There's lots of great features of PyBind 11.

312
00:16:20,340 --> 00:16:21,940
I list a few of them here.

313
00:16:21,940 --> 00:16:27,780
I won't go into them in extensive detail, but it's quite powerful.

314
00:16:27,780 --> 00:16:32,820
And it does, even supports WebAssembly with PyDyde now.

315
00:16:32,820 --> 00:16:36,380
And it has a variety of different things that it does.

316
00:16:36,380 --> 00:16:40,580
There is one more I want to go into before we sort of dive in a little bit deeper.

317
00:16:40,580 --> 00:16:43,940
And there is a sort of sequel to PyBind 11 called Nanobind,

318
00:16:43,940 --> 00:16:45,700
written by the same author.

319
00:16:45,700 --> 00:16:49,700
And this is C++ 17 only and it's Python 3.8 only.

320
00:16:49,700 --> 00:16:51,900
It's built on top of the FastCall API.

321
00:16:53,060 --> 00:16:55,860
Very similar API to PyBind 11, intentionally meant to be more limited.

322
00:16:57,100 --> 00:17:01,740
And some of these ideas are being backported to PyBind 11 as well.

323
00:17:01,740 --> 00:17:06,700
And I have some plots here that show that it is much quicker to compile.

324
00:17:06,700 --> 00:17:09,140
It was sort of designed with compilation time in mind,

325
00:17:09,140 --> 00:17:12,220
because header only C++ libraries are really slow to compile.

326
00:17:13,460 --> 00:17:15,340
The binaries are smaller.

327
00:17:15,340 --> 00:17:18,940
Do keep in mind, this is for a very basic example, basically like a class and

328
00:17:18,940 --> 00:17:19,380
a function.

329
00:17:19,380 --> 00:17:23,700
So if your binary size is dominated by your binding tool,

330
00:17:23,700 --> 00:17:26,180
then you're probably not compiling very much.

331
00:17:26,180 --> 00:17:30,340
But smaller binary size, and the runtime performance is faster,

332
00:17:30,340 --> 00:17:32,100
say if you're looping over something.

333
00:17:32,100 --> 00:17:37,420
PyBind 11's a bit slow, because it has a overload dispatch mechanism built in.

334
00:17:37,420 --> 00:17:39,420
Which is very powerful, and you shouldn't be looping over and

335
00:17:39,420 --> 00:17:41,980
calling a function over and over and over in Python probably.

336
00:17:41,980 --> 00:17:45,100
You should try to find some way to wrap the entire thing.

337
00:17:46,980 --> 00:17:50,780
So this is an exciting new project, it's only a few months old now, I think.

338
00:17:52,900 --> 00:17:56,100
So we're gonna dive into an example project.

339
00:17:56,100 --> 00:18:00,700
I'm gonna show you every single line of code you need to create

340
00:18:00,700 --> 00:18:07,260
a compiled extension for all platforms, everything.

341
00:18:08,380 --> 00:18:10,420
I'll have a reasonable amount of code.

342
00:18:10,420 --> 00:18:12,980
The sort of point of this is to show you how much code and

343
00:18:12,980 --> 00:18:14,020
maybe point out a few things.

344
00:18:14,020 --> 00:18:16,540
I'm not gonna walk through every single line.

345
00:18:16,540 --> 00:18:19,300
And I'm gonna try to do something that's not completely trivial.

346
00:18:19,300 --> 00:18:25,060
I'm going to try to take CLI11, which is a command line parser library.

347
00:18:25,060 --> 00:18:26,740
My favorite command line parser library.

348
00:18:26,740 --> 00:18:28,380
I also wrote it, so might be why.

349
00:18:28,380 --> 00:18:30,700
But Microsoft terminal uses it, so.

350
00:18:31,660 --> 00:18:37,660
So we're going to make a little wrapped version of this from Python.

351
00:18:37,660 --> 00:18:40,660
This is not necessarily a good idea, but it's a library I happen to know.

352
00:18:40,660 --> 00:18:42,500
It's a good idea to know the library you're trying to wrap so

353
00:18:42,500 --> 00:18:45,060
you know how it works, so you know how to expose it.

354
00:18:45,060 --> 00:18:48,700
And we're just gonna do sort of this minimal bit here.

355
00:18:48,700 --> 00:18:51,380
So we wanna be able to create an app, we wanna add a flag.

356
00:18:51,380 --> 00:18:54,100
We wanna be able to check and see if that flag exists.

357
00:18:54,100 --> 00:18:57,100
And we want to make sure that sort of basic niceties are there.

358
00:18:57,100 --> 00:18:58,540
So we wanna make sure that we can print the app and

359
00:18:58,540 --> 00:19:02,020
that something nice will print out and that we get a keyer or something that

360
00:19:03,620 --> 00:19:07,260
depends, or will check as a keyer out if we make a mistake.

361
00:19:08,700 --> 00:19:10,100
So this is the entire binding code.

362
00:19:11,740 --> 00:19:14,380
We're going to import PyBind11, and

363
00:19:14,380 --> 00:19:17,660
it also has some wrappers for the standard library things.

364
00:19:17,660 --> 00:19:20,580
And a little bit of setup there.

365
00:19:20,580 --> 00:19:21,820
Here we're creating a new exception.

366
00:19:21,820 --> 00:19:26,580
That exception is going to be, it's gonna come from a keyer.

367
00:19:26,580 --> 00:19:29,540
It'll make a new rmodule.option not found for us.

368
00:19:30,740 --> 00:19:32,820
And then that will automatically wrap the exception, so

369
00:19:32,820 --> 00:19:34,180
we don't need to bother with it down here.

370
00:19:34,180 --> 00:19:39,420
We could, we could throw a py colon colon keyer if we wanted to.

371
00:19:40,460 --> 00:19:43,540
But this is more declarative, which is nice.

372
00:19:43,540 --> 00:19:47,020
And then we create our app, and then in the app we're going to define a few methods.

373
00:19:47,020 --> 00:19:48,220
And so we're defining each one.

374
00:19:48,220 --> 00:19:50,020
Notice we even have some Dunder methods there.

375
00:19:50,020 --> 00:19:52,020
We define get item and stir.

376
00:19:52,020 --> 00:19:55,060
And then the thing on the other side can just be a lambda function.

377
00:19:55,060 --> 00:19:58,220
Sometimes, it's like there in the middle you see that overload cast.

378
00:19:58,220 --> 00:20:01,420
There it's actually wrapped, it's binding to the, to the function itself.

379
00:20:01,420 --> 00:20:04,060
And it's overloaded, so you have to pick which one.

380
00:20:04,060 --> 00:20:07,620
Or you can just use a lambda function in C++, just throw that in there.

381
00:20:07,620 --> 00:20:11,140
And let the compiler figure out which overloaded one you're, you're after.

382
00:20:11,140 --> 00:20:13,740
Or you can do, you know, more work if you want.

383
00:20:13,740 --> 00:20:15,940
So it's, it's really quite nice to be able to just use the,

384
00:20:15,940 --> 00:20:17,180
the lambda functions there.

385
00:20:17,180 --> 00:20:17,860
And that's the binding code.

386
00:20:19,620 --> 00:20:20,180
Okay.

387
00:20:20,180 --> 00:20:22,460
I said I'd show you every line of code, so there's the init.py.

388
00:20:22,460 --> 00:20:27,580
And also tests.

389
00:20:27,580 --> 00:20:30,140
You should always test anything, so let's at least write some tests.

390
00:20:30,140 --> 00:20:33,700
So this is basically the same thing I just showed you, but in, in test form.

391
00:20:33,700 --> 00:20:35,060
Okay?

392
00:20:35,060 --> 00:20:37,460
All right, we're gonna leave that for a minute.

393
00:20:37,460 --> 00:20:40,340
When you go back to the yellow slides, we'll be back in, back in our example.

394
00:20:40,340 --> 00:20:42,180
Let's talk about build systems.

395
00:20:42,180 --> 00:20:47,700
So there are some great examples of pure Python build systems

396
00:20:47,700 --> 00:20:49,700
that are now using pep621.

397
00:20:50,700 --> 00:20:55,500
Things like flit and hatch and, and, and others, including actually setup tools now.

398
00:20:56,940 --> 00:21:00,860
But building binary, your binaries, your choices are somewhat limited.

399
00:21:02,180 --> 00:21:06,740
So setup, setup tools and disutils has a lot of, of drawbacks.

400
00:21:06,740 --> 00:21:15,300
It doesn't, it is capable of building a file from, from C, C or C++.

401
00:21:15,300 --> 00:21:19,020
But it really is, it wasn't extended and, and doesn't add a lot of things.

402
00:21:19,060 --> 00:21:22,660
It's just sort of basic things that most build systems would have, like multi-threaded

403
00:21:22,660 --> 00:21:28,020
builds or partial rebuilds and features of your compiler and just all these things

404
00:21:28,020 --> 00:21:30,780
that are built into tools like CMake and Mason and stuff.

405
00:21:30,780 --> 00:21:32,860
You can't even tell at what C++ standard you want to target.

406
00:21:34,220 --> 00:21:35,780
It does actually have native Cython support though.

407
00:21:38,020 --> 00:21:39,100
Setup tools does.

408
00:21:39,100 --> 00:21:42,540
So this then has been extended by a lot of different packages.

409
00:21:42,540 --> 00:21:44,380
So mypyc extends this.

410
00:21:45,460 --> 00:21:46,340
numpy disutils.

411
00:21:46,340 --> 00:21:50,820
There's lots of examples of things that then write sort of extensions and work with

412
00:21:50,820 --> 00:21:56,740
this even though it's, you're kind of delving into the internals quite a bit.

413
00:21:58,460 --> 00:22:00,580
And then there are a few from scratch.

414
00:22:00,580 --> 00:22:03,740
I don't think, actually, in, in, in scons, I'm not sure if that fully counts because

415
00:22:03,740 --> 00:22:08,340
that's, that's also using at least a little bit of disutils.

416
00:22:08,340 --> 00:22:11,980
I've saw, I saw disutils showing up inside its, its code base.

417
00:22:11,980 --> 00:22:15,940
But I do want to point it out just because it was one of the earliest adopters of

418
00:22:15,980 --> 00:22:18,660
5.17 that supported compiled builds.

419
00:22:18,660 --> 00:22:24,940
But Masonpy is out now and Motrin is one for, for Rust.

420
00:22:24,940 --> 00:22:26,940
So we're starting to see some of those.

421
00:22:26,940 --> 00:22:30,940
There's also Cykit build, which is sort of what we'll focus on today.

422
00:22:30,940 --> 00:22:33,660
Right now, unfortunately, it just wraps setup tools.

423
00:22:33,660 --> 00:22:36,660
But there is a planned move, and I'll talk a little bit about the plans,

424
00:22:36,660 --> 00:22:39,420
to try to get it over into this sort of, onto that side of the screen.

425
00:22:39,420 --> 00:22:46,100
PyBind11 actually has this nice little extension as well for setup tools.

426
00:22:46,100 --> 00:22:51,100
So you can just grab this set of helpers and then you can add the,

427
00:22:51,100 --> 00:22:52,740
or do a PyBind11 extension.

428
00:22:52,740 --> 00:22:55,820
You can tell it what C++ standard you want and just go with that.

429
00:22:55,820 --> 00:22:57,940
If you have something that's simple, you can do that.

430
00:22:59,940 --> 00:23:09,260
So Cykit build is a tool from the makers of CMake to allow you to use CMake from

431
00:23:09,260 --> 00:23:10,660
Python.

432
00:23:10,660 --> 00:23:12,340
And this started back in 2014.

433
00:23:12,340 --> 00:23:13,780
It was announced at SciPy.

434
00:23:13,780 --> 00:23:18,860
It was renamed, it was originally PyCmake, and then it was renamed a bit later.

435
00:23:18,860 --> 00:23:21,940
And two of our most popular packages are the CMake package for Pythons.

436
00:23:21,940 --> 00:23:27,700
If you do pip install CMake, you get CMake for

437
00:23:27,700 --> 00:23:32,220
pretty much all the binary in all these different areas.

438
00:23:32,220 --> 00:23:34,420
It has some really nice tooling.

439
00:23:34,420 --> 00:23:36,140
I helped sort of update some of that.

440
00:23:36,140 --> 00:23:37,460
And you can do the same thing with Ninja.

441
00:23:37,460 --> 00:23:38,660
You can pip install Ninja as well.

442
00:23:40,780 --> 00:23:43,420
And that comes from the Cykit build project.

443
00:23:44,940 --> 00:23:48,780
And this is really exciting because it would allow you to use a very powerful

444
00:23:48,780 --> 00:23:54,020
existing build system, the most popular C++, C, Cuda, etc.

445
00:23:54,020 --> 00:23:56,820
build system directly from Python.

446
00:23:57,940 --> 00:24:03,660
It has a couple new maintainers that joined in the last six months or so.

447
00:24:03,660 --> 00:24:11,180
And it's definitely an exciting example there.

448
00:24:11,180 --> 00:24:12,980
And just also, if you need a refresher on CMake,

449
00:24:12,980 --> 00:24:14,660
I wrote a book on CMake, so you can go check that out.

450
00:24:16,340 --> 00:24:16,940
Years before this.

451
00:24:17,980 --> 00:24:21,180
Okay, as long as you use modern CMake, it's actually quite nice, and

452
00:24:21,180 --> 00:24:21,700
you'll see that.

453
00:24:22,820 --> 00:24:24,220
So there are some plans.

454
00:24:24,220 --> 00:24:27,420
The idea is that we'll try to develop a Cykit build core that will be a PEP 517

455
00:24:27,420 --> 00:24:30,100
builder, avoiding setup tools and distutils.

456
00:24:30,100 --> 00:24:33,780
That will give us, hopefully we can sort of give a compatibility layer,

457
00:24:33,780 --> 00:24:37,220
so the existing users will still work.

458
00:24:37,220 --> 00:24:38,940
We'll also have a way to do a direct build.

459
00:24:40,340 --> 00:24:43,020
And then hopefully a proper setup tools extension,

460
00:24:43,020 --> 00:24:45,860
because currently that's still sort of how you put these things together.

461
00:24:45,860 --> 00:24:49,100
But there might actually be some generalization that's happening in the,

462
00:24:49,100 --> 00:24:51,620
we're gonna talk about this a bit in the packaging summit later.

463
00:24:51,620 --> 00:24:53,900
So it might be nice if we could sort of generalize and

464
00:24:53,900 --> 00:24:58,100
not write an extension for every single system out there like HatchPoetry, etc.

465
00:25:00,180 --> 00:25:03,780
And then also we need an extension discovery mechanism.

466
00:25:03,780 --> 00:25:06,980
We might be working with CMake itself to do this.

467
00:25:06,980 --> 00:25:12,220
Cuz it would be really nice if we could just stick this in our Python requires.

468
00:25:12,220 --> 00:25:15,220
Say I want pi by 11, and then just immediately find it.

469
00:25:15,220 --> 00:25:17,020
Right now you have to do a little bit more work to do that.

470
00:25:17,020 --> 00:25:21,860
And you'll see in the next page that I just avoid this entirely.

471
00:25:21,860 --> 00:25:23,100
In the example we'll be showing.

472
00:25:24,220 --> 00:25:25,700
And you can read more about that proposal there.

473
00:25:26,940 --> 00:25:28,380
All right, so going back to our project.

474
00:25:28,380 --> 00:25:29,460
This is our CMake list.

475
00:25:29,460 --> 00:25:30,660
This is the whole thing.

476
00:25:30,660 --> 00:25:36,260
We're actually just grabbing both pi by 11 and CLI 11 from GitHub.

477
00:25:36,260 --> 00:25:40,860
Because that way we don't have to deal with the fact that we don't have a nice

478
00:25:40,860 --> 00:25:44,020
way to grab where pi by 11 is.

479
00:25:44,020 --> 00:25:46,620
And we have to do this with CLI 11 anyway cuz it's not a Python package.

480
00:25:47,780 --> 00:25:49,260
So we're just grabbing those.

481
00:25:49,260 --> 00:25:50,700
Then we add a module.

482
00:25:50,700 --> 00:25:52,420
This is added by pi by 11.

483
00:25:52,420 --> 00:25:53,020
We link them.

484
00:25:53,020 --> 00:25:57,060
We tell it we need C++ 14 cuz we used one C++ 14 feature.

485
00:25:57,060 --> 00:25:58,220
And then there's install.

486
00:25:58,220 --> 00:25:59,700
And that's the CMake list.

487
00:26:00,700 --> 00:26:03,540
Right now you have to write this setup.py as well.

488
00:26:03,540 --> 00:26:08,500
And this is what I mentioned about the wrapper for the regular setup.

489
00:26:08,500 --> 00:26:11,060
And we have to stick this in.

490
00:26:11,060 --> 00:26:14,300
Some of this does actually have to be inside the setup.py and

491
00:26:14,300 --> 00:26:15,900
can't be pulled out to setup.config.

492
00:26:15,900 --> 00:26:16,900
Not all of it, but some of it does.

493
00:26:18,060 --> 00:26:21,300
Okay, so those are really almost the entire build system.

494
00:26:21,300 --> 00:26:25,220
The only remaining thing is we need to also request scikit build and

495
00:26:25,220 --> 00:26:26,140
our build system requires.

496
00:26:27,100 --> 00:26:30,620
Okay, and we'll actually fill out some more of the PyProject.toml.

497
00:26:30,620 --> 00:26:33,020
We're not done with that yet, but we'll leave it there for now.

498
00:26:34,180 --> 00:26:37,860
The next thing we need to do is to redistribute.

499
00:26:39,100 --> 00:26:40,940
So we need to build wheels.

500
00:26:40,940 --> 00:26:43,020
So you could distribute on conda-forge.

501
00:26:43,020 --> 00:26:45,620
I'm not gonna go into that in detail just because it's really mostly automated.

502
00:26:45,620 --> 00:26:49,580
You just have to go out and write a recipe and their CI will build that for you.

503
00:26:49,580 --> 00:26:53,580
And a lot of the stuff that we do, we really wanna make sure we distribute on both.

504
00:26:54,540 --> 00:26:56,860
But we'll be focusing on PyPI.

505
00:26:58,540 --> 00:27:02,380
And in there we have a variety of different things that we have to deal with.

506
00:27:02,380 --> 00:27:06,020
So on Linux, we need to build inside of a controlled Docker image to make sure that

507
00:27:06,020 --> 00:27:11,220
we're not using something that's not allowed in the mini Linux specification.

508
00:27:11,220 --> 00:27:13,940
We don't wanna pull something in or

509
00:27:13,940 --> 00:27:17,380
use the version of glibc that's too new or something like that.

510
00:27:17,380 --> 00:27:19,180
So there's mini Linux and musilinux images.

511
00:27:20,140 --> 00:27:23,660
And there's also multiple architectures for all of these.

512
00:27:24,940 --> 00:27:27,780
And you really should be running audit wheel afterwards to make sure that this

513
00:27:27,780 --> 00:27:32,580
is packaged up into a nice mini Linux wheel.

514
00:27:32,580 --> 00:27:34,980
Mac OS, you now have to worry about the target version.

515
00:27:34,980 --> 00:27:36,820
You have to pick what version you target.

516
00:27:36,820 --> 00:27:38,980
It's a really nice feature of Mac, but you also have to think about it.

517
00:27:40,300 --> 00:27:43,900
And you also need to make sure your Python was compiled with whatever that target was.

518
00:27:43,900 --> 00:27:45,860
So you really wanna use the python.org Python.

519
00:27:45,860 --> 00:27:47,300
You don't wanna grab the CI or whatever,

520
00:27:47,300 --> 00:27:49,300
cuz that was probably targeting the thing it built on,

521
00:27:49,300 --> 00:27:53,460
which was probably macOS 10.15 or something like that.

522
00:27:53,460 --> 00:27:57,500
But you really wanna use the 10.9, one that targets 10.9 from python.org,

523
00:27:57,500 --> 00:28:00,180
so that you have your choice of what you wanna target.

524
00:28:00,180 --> 00:28:02,740
And then you have to worry about cross compiling for universal.

525
00:28:02,740 --> 00:28:04,740
And there's a separate tool there.

526
00:28:04,740 --> 00:28:06,540
Same thing again for Windows.

527
00:28:06,540 --> 00:28:08,460
Windows is actually the easiest of these,

528
00:28:08,460 --> 00:28:10,780
because you can pretty much grab Python from anywhere and it'll work.

529
00:28:12,700 --> 00:28:14,340
Please make sure you still distribute 32-bit,

530
00:28:14,340 --> 00:28:16,740
cuz you still see some 32-bit Pythons floating around.

531
00:28:18,380 --> 00:28:20,100
And even laptop, I have one.

532
00:28:20,100 --> 00:28:24,820
And then there's beginning to be ARM support on Windows as well.

533
00:28:24,820 --> 00:28:26,740
And then there's also, there's beginning to be,

534
00:28:26,740 --> 00:28:29,240
there's a very, fairly young tool called the Velwheel that's,

535
00:28:29,240 --> 00:28:31,820
that's appearing here that also helps you sort of package and

536
00:28:31,820 --> 00:28:34,700
make sure anything that you use is bundled into your wheel for you.

537
00:28:36,980 --> 00:28:39,940
So I wanna go straight into CI Build Wheel.

538
00:28:39,940 --> 00:28:43,540
This is a tool to do this, all of this for you.

539
00:28:43,540 --> 00:28:46,180
It supports all the major CI providers and it runs locally.

540
00:28:46,180 --> 00:28:49,100
It ran locally for Linux for a long time, but

541
00:28:49,100 --> 00:28:52,340
it actually supports Windows and Mac OS locally now too.

542
00:28:52,340 --> 00:28:58,220
And this tool has really, has really taken off in the last couple years.

543
00:28:59,500 --> 00:29:02,100
I joined it I think in 2020.

544
00:29:02,100 --> 00:29:06,140
And then made a push to get this into the PyPA, it joined.

545
00:29:06,140 --> 00:29:10,780
And we have over, I think we have at least 600 users now,

546
00:29:10,780 --> 00:29:13,340
which include almost everything you saw on that first slide.

547
00:29:13,340 --> 00:29:17,460
Like MyPy and NumPy has just started, has just moved to it.

548
00:29:19,620 --> 00:29:23,100
And so this supports sort of all the different possible wheels that you're

549
00:29:23,100 --> 00:29:23,980
likely to want.

550
00:29:23,980 --> 00:29:26,540
So you can target any version of Mac OS.

551
00:29:26,540 --> 00:29:29,940
You can do Apple Silicon for all the Python versions that support it,

552
00:29:29,940 --> 00:29:30,900
which is 3.8 and newer.

553
00:29:31,980 --> 00:29:35,700
All the variants of MiniLimits, including the ones that you might have to emulate,

554
00:29:35,700 --> 00:29:39,820
or some CI providers have native runners.

555
00:29:39,820 --> 00:29:41,940
Musa Linux was added fairly recently.

556
00:29:42,580 --> 00:29:44,140
PyPy supported.

557
00:29:45,460 --> 00:29:48,740
And this will also go through, do the repair step I showed you.

558
00:29:48,740 --> 00:29:51,580
It will test your wheels if you tell it what command you need to test it.

559
00:29:51,580 --> 00:29:53,100
It'll install it in a brand new environment and

560
00:29:53,100 --> 00:29:56,180
make sure that your wheel actually does what it says it does and

561
00:29:56,180 --> 00:29:59,020
passes your tests pulled directly from the wheel you built.

562
00:30:00,060 --> 00:30:01,740
And the defaults are all pinned.

563
00:30:01,740 --> 00:30:04,620
You can't unpin those, but they're all pinned and updated regularly.

564
00:30:05,900 --> 00:30:09,620
And then there's some new features that have come out recently.

565
00:30:09,620 --> 00:30:12,100
Right after we joined the PyPy, we had CI build wheel two.

566
00:30:12,100 --> 00:30:14,020
That included our PyProject.toml support,

567
00:30:14,020 --> 00:30:18,140
which you'll be seeing in a minute, which I'm quite happy about.

568
00:30:18,140 --> 00:30:22,460
And then over the last few months, we've been adding even more things,

569
00:30:22,460 --> 00:30:25,540
like the overrides, which is powerful, but I won't be showing you today.

570
00:30:26,900 --> 00:30:28,620
And as I mentioned, the local runs.

571
00:30:28,620 --> 00:30:30,820
And experimental Windows arm support,

572
00:30:30,820 --> 00:30:36,140
and we don't have any runners for that yet, in CI, that is.

573
00:30:36,140 --> 00:30:39,100
And in 2.5, which was released this morning,

574
00:30:39,100 --> 00:30:42,260
we also have a support for the stable ABI.

575
00:30:42,260 --> 00:30:45,340
So you can do a limited API, stable ABI build.

576
00:30:45,340 --> 00:30:47,660
And it will build the first wheel and then just test all the rest and

577
00:30:47,660 --> 00:30:49,300
not try to build it again, because it's already built.

578
00:30:50,780 --> 00:30:52,900
And you can also build directly from an S-Dist.

579
00:30:52,900 --> 00:30:57,700
You can just grab an S-Dist off PyPI and then run CI build wheel on it, and

580
00:30:57,700 --> 00:30:58,540
you can produce your wheels.

581
00:31:00,540 --> 00:31:01,860
And we are supporting TomaLib now.

582
00:31:03,100 --> 00:31:04,820
A few tips, this is how you'd run it locally.

583
00:31:04,820 --> 00:31:07,940
When you do it locally, you just have to, and I'm just using PIPX run there, but

584
00:31:07,940 --> 00:31:10,580
any way you like to run it, I would recommend that way.

585
00:31:10,580 --> 00:31:13,060
You just tell it what platform you want to target.

586
00:31:13,060 --> 00:31:16,140
That uses Docker for Linux, so that works on your Mac or Windows or

587
00:31:16,140 --> 00:31:18,820
whatever, wherever you are, as long as you can run Docker.

588
00:31:18,820 --> 00:31:20,620
You can target Linux.

589
00:31:20,620 --> 00:31:22,060
But you always have to tell it the platform, and

590
00:31:22,060 --> 00:31:24,260
that way it knows that you intentionally are trying to build wheels,

591
00:31:24,260 --> 00:31:24,900
cuz it may take a while.

592
00:31:26,060 --> 00:31:30,580
And then this is a really good tip for keeping it up to date.

593
00:31:30,580 --> 00:31:33,620
We do provide an action, and this will keep your action up to date.

594
00:31:36,060 --> 00:31:37,780
All right, so going back to our PyProject.toml,

595
00:31:37,780 --> 00:31:40,060
I can now finish showing it to you.

596
00:31:40,060 --> 00:31:45,180
Here we tell CI build wheel what command to run for testing.

597
00:31:45,180 --> 00:31:46,780
That will turn on the testing feature.

598
00:31:47,940 --> 00:31:50,860
And then we also tell it that I need to install with the bracket test when I

599
00:31:50,860 --> 00:31:54,060
install the wheel, cuz that's where I put the dependencies.

600
00:31:54,060 --> 00:31:58,540
And then this is how you would do this for adding Apple Silicon.

601
00:31:58,540 --> 00:32:03,100
You have to pick for Apple Silicon if you want to use universal wheels,

602
00:32:03,100 --> 00:32:05,900
which have both architectures put into one place, or

603
00:32:05,900 --> 00:32:07,740
if you just want a native wheel.

604
00:32:07,740 --> 00:32:10,780
And so you just opt in for whichever way you want.

605
00:32:11,820 --> 00:32:13,620
Okay, and that's really the configuration.

606
00:32:13,620 --> 00:32:14,900
There's a lot more options here.

607
00:32:14,900 --> 00:32:17,460
You can customize that however you like.

608
00:32:17,460 --> 00:32:19,780
And you can do it through, everything can be done through environment variables,

609
00:32:19,780 --> 00:32:21,860
but this is a lot cleaner and nicer.

610
00:32:23,380 --> 00:32:25,580
And it lets you run it locally without having to redo all your

611
00:32:25,580 --> 00:32:27,940
environment variables, okay?

612
00:32:27,940 --> 00:32:29,020
And there's the PyTest stuff.

613
00:32:30,860 --> 00:32:32,180
Okay, so now I'm gonna show you the workflows.

614
00:32:32,180 --> 00:32:34,660
This is the longest piece, but I think you'll see it's not too bad.

615
00:32:34,660 --> 00:32:37,500
First thing here, for, and I'm doing this in GitHub,

616
00:32:37,500 --> 00:32:39,180
you could do it in some other system if you wanted.

617
00:32:40,580 --> 00:32:45,140
First, we're gonna do this whenever we click Publish, or

618
00:32:45,140 --> 00:32:47,740
do Publish from the GitHub command line, whatever way you like to do that, or

619
00:32:47,740 --> 00:32:48,820
if you want to manually trigger it.

620
00:32:49,860 --> 00:32:52,140
And then, cuz this will probably take a while.

621
00:32:52,140 --> 00:32:53,260
You're gonna be building a lot of wheels.

622
00:32:54,660 --> 00:32:58,820
Then we're going to build an S-Dist, so you can just use build for that.

623
00:32:58,820 --> 00:33:03,700
So PyPA build is a tool that can build wheels and S-Dist, and

624
00:33:03,700 --> 00:33:05,780
you can just use that to build the S-Dist.

625
00:33:05,780 --> 00:33:08,860
And PIPX is built into GitHub Actions, which is really nice and Azure.

626
00:33:10,220 --> 00:33:11,380
So you can just do that one line.

627
00:33:11,380 --> 00:33:12,940
You don't even have to get a version of Python.

628
00:33:12,940 --> 00:33:14,060
You can just use PIPX.

629
00:33:14,060 --> 00:33:16,860
It's a supported platform, which is fantastic.

630
00:33:16,860 --> 00:33:19,300
It's actually used internally inside CI build wheels action.

631
00:33:19,300 --> 00:33:20,460
The action's only about a page long.

632
00:33:22,380 --> 00:33:26,380
All right, and we just added something to Knox that does that too.

633
00:33:26,380 --> 00:33:31,140
Okay, and then you now wanna build your wheels.

634
00:33:31,140 --> 00:33:34,300
I assume that you would think this one would be the most complex one, and

635
00:33:34,340 --> 00:33:37,820
might technically be, but it's not too bad.

636
00:33:37,820 --> 00:33:42,660
We mostly just do PyPA CI build wheel, and then it's a good idea to use an exact

637
00:33:42,660 --> 00:33:46,340
version there, and then use Dependabot to do that update for you.

638
00:33:46,340 --> 00:33:48,420
So every time we release it, it'll then ask you to update.

639
00:33:48,420 --> 00:33:51,420
And that way your wheels don't crash because maybe we changed something.

640
00:33:52,580 --> 00:33:53,460
And that's about it.

641
00:33:53,460 --> 00:33:54,540
We're running on all the platforms.

642
00:33:56,860 --> 00:34:00,900
Okay, and then finally, assuming you wanna upload this to PyPI,

643
00:34:00,940 --> 00:34:03,980
you could also just download it from the interface and

644
00:34:03,980 --> 00:34:07,300
manually upload it yourself, cuz it's an artifact.

645
00:34:07,300 --> 00:34:08,260
But here's how you would upload it.

646
00:34:08,260 --> 00:34:11,300
And you wanna make sure your wheels and your S-Dist are finished before you do that.

647
00:34:13,260 --> 00:34:14,260
And we're done.

648
00:34:14,260 --> 00:34:15,740
This is what comes out.

649
00:34:15,740 --> 00:34:17,220
This is what that produces.

650
00:34:17,220 --> 00:34:22,300
This is every wheel, and we put a minimum version of 3.7.

651
00:34:22,300 --> 00:34:23,540
So this is every wheel.

652
00:34:23,540 --> 00:34:25,300
It supports 3.6 in there.

653
00:34:25,300 --> 00:34:27,940
And that's it.

654
00:34:27,940 --> 00:34:30,380
You can see the Mac OS wheels there.

655
00:34:30,380 --> 00:34:31,140
There's the universal.

656
00:34:31,140 --> 00:34:34,180
There's the one for the Intel architecture.

657
00:34:34,180 --> 00:34:39,020
There's Mini Linux, Mesa Linux, the two different Windows ones.

658
00:34:40,260 --> 00:34:44,620
The PyPI for 3.7, 3.8, and 3.9 are over there.

659
00:34:44,620 --> 00:34:45,740
They're all there.

660
00:34:45,740 --> 00:34:48,740
If you're in the back, the biggest point is there's a lot of things here.

661
00:34:51,860 --> 00:34:54,500
And you saw how much work had to go into that, not that much.

662
00:34:56,020 --> 00:34:58,740
In this scales, this is something you can do on a very small little project.

663
00:34:58,740 --> 00:35:04,180
If you look at the CI build wheel examples page, you'll see small little projects.

664
00:35:04,180 --> 00:35:06,740
You'll see medium sized projects, and you'll see giant ones.

665
00:35:06,740 --> 00:35:08,540
So this scales really, really well.

666
00:35:08,540 --> 00:35:12,420
Simple enough for small projects and powerful enough for complex ones.

667
00:35:12,420 --> 00:35:17,820
Also, maybe now that I've given you this sort of, in terms of what's possible,

668
00:35:17,820 --> 00:35:22,940
maybe you could think outside the box and mix and match these things in unusual ways.

669
00:35:22,940 --> 00:35:25,300
So here's an example of Clang format wheel.

670
00:35:25,300 --> 00:35:29,580
And so that uses scikit build, which actually triggers LLVM's build.

671
00:35:29,580 --> 00:35:33,380
It uses CI build wheel to then build Python independent binary wheels.

672
00:35:33,380 --> 00:35:36,100
You only need one, so it just picks like 3.8 or something.

673
00:35:36,100 --> 00:35:39,060
And then it makes sure that the final names don't have the 3.8 part,

674
00:35:39,060 --> 00:35:43,060
because it doesn't depend on CPython, but it does depend on your platform.

675
00:35:43,060 --> 00:35:47,020
And then these are like one or two megabyte binaries that sit on PyPI.

676
00:35:47,020 --> 00:35:49,460
There's no binding here, this is only an entry point.

677
00:35:49,460 --> 00:35:51,980
But this means you can just redo pipx run clang format, and

678
00:35:51,980 --> 00:35:56,740
you can get clang format in a second or two on pretty much any system that you can run on.

679
00:35:56,740 --> 00:36:00,660
There's even a precommit wheel, you can run this on precommit CI yourself.

680
00:36:00,660 --> 00:36:03,740
Before this project came out, I've been fighting CondaForge to try to get this

681
00:36:03,740 --> 00:36:10,460
thing under, I think it was 500 megabytes to try to get a Conda environment that

682
00:36:10,460 --> 00:36:13,220
would fit in under 500 megabytes with clang format in it so

683
00:36:13,220 --> 00:36:15,820
that it could run it in precommit.ci, because there was a limit.

684
00:36:15,820 --> 00:36:17,780
Maybe it's 250, I don't know.

685
00:36:17,780 --> 00:36:21,180
And this was one to two megabytes per wheel.

686
00:36:22,420 --> 00:36:26,180
So this is a really fantastic use, I think, of some of these things we've been seeing.

687
00:36:27,540 --> 00:36:31,420
If you want to just quickly jump in and start working on this,

688
00:36:31,420 --> 00:36:34,460
I just want to do a little plug for something that I work on.

689
00:36:34,460 --> 00:36:39,180
One of the products from PsychetHEP is this developer pages.

690
00:36:39,180 --> 00:36:43,820
I'm going to try to do a lightning talk on this too, because I really like it.

691
00:36:43,860 --> 00:36:48,180
And you can quickly make a package using even their cookie cutter.

692
00:36:48,180 --> 00:36:50,980
So you could just say, PIPX run cookie cutter, give it there.

693
00:36:50,980 --> 00:36:56,220
PyBind 11, and as of yesterday, now, CICET build our back end choices.

694
00:36:56,220 --> 00:36:57,420
PyBind 11's been there for real.

695
00:36:57,420 --> 00:37:00,380
Pure PyBind 11 setup tools have been there forever, but

696
00:37:00,380 --> 00:37:02,060
Psychet Build just was added yesterday.

697
00:37:03,100 --> 00:37:05,820
So we now have 11 different back ends, a lot of pure Python back ends,

698
00:37:05,820 --> 00:37:09,060
Hatch, Poetry, whatever you'd like.

699
00:37:09,060 --> 00:37:12,420
Setup tools, two different setup tools, one's one for PEP621.

700
00:37:12,820 --> 00:37:16,700
And then for compiled ones, we also have Matron for Rust.

701
00:37:16,700 --> 00:37:20,500
So if you wanted to start a Rust package, this can get you started too.

702
00:37:20,500 --> 00:37:25,660
And all this is tested with Knox and GitHub Actions.

703
00:37:25,660 --> 00:37:29,260
And we even have this also very new repo review page.

704
00:37:29,260 --> 00:37:31,780
So you can just type in the name of a repository, and

705
00:37:31,780 --> 00:37:35,540
you can type in a branch name, click the button.

706
00:37:35,540 --> 00:37:38,940
And then PyIdeID will run Python 3.10 in your browser, and it will then spit out

707
00:37:39,900 --> 00:37:43,260
the, what guidelines you're following and what you're not from the,

708
00:37:43,260 --> 00:37:45,260
from the developer guidelines.

709
00:37:45,260 --> 00:37:47,820
So that's quite, quite fantastic.

710
00:37:47,820 --> 00:37:49,700
I would highly recommend taking a look at the Psychet Hub.

711
00:37:49,700 --> 00:37:51,100
.org developer page.

712
00:37:52,180 --> 00:37:54,700
So, key takeaways here.

713
00:37:54,700 --> 00:37:57,980
The code you just saw is, I've just put that into the repository.

714
00:37:57,980 --> 00:38:01,260
If you wanna look at it, and that's, you can just see exactly,

715
00:38:02,540 --> 00:38:04,500
you can see it work, cuz it's there in the GitHub Actions.

716
00:38:05,740 --> 00:38:06,580
Logs and things are there.

717
00:38:06,580 --> 00:38:11,380
And then if you want to sort of find out a little bit more about this,

718
00:38:11,380 --> 00:38:14,100
my blog is at isignempi.dev.

719
00:38:14,100 --> 00:38:15,820
That includes links to the most important things,

720
00:38:15,820 --> 00:38:17,300
I think, to, that are here as well.

721
00:38:17,300 --> 00:38:20,820
There's a link to, to the Psychet Hub developer pages.

722
00:38:20,820 --> 00:38:26,660
And there's links to the PyBind11 examples, and to the Psychet Build examples.

723
00:38:26,660 --> 00:38:31,460
And PyBind11 has some very nice examples, including just using SetupTools,

724
00:38:31,460 --> 00:38:35,860
using Psychet Build, or wrapping CMake yourself using SetupTools.

725
00:38:37,380 --> 00:38:39,780
Okay, and then finally, to end with a little bit about me,

726
00:38:39,780 --> 00:38:41,020
these are some of the things that I work on.

727
00:38:41,020 --> 00:38:45,420
These are, these are the projects that I'm involved with and

728
00:38:45,420 --> 00:38:49,940
a member in some, in some form or, or some form or way.

729
00:38:49,940 --> 00:38:53,380
If you go to, but most importantly again, my blog link,

730
00:38:53,380 --> 00:38:56,180
which is actually old there, that will take you there too.

731
00:38:56,180 --> 00:38:59,700
But isignempi.dev or isignempi.gitlab.io will take you to my blog.

732
00:39:01,220 --> 00:39:05,660
Okay, and I guess we don't really have any questions, so thanks for your time.

733
00:39:06,580 --> 00:39:12,540
Thank you again.

734
00:39:14,300 --> 00:39:18,340
We do not have any Q&A at this year's PyCon, so if you do have any questions for

735
00:39:18,340 --> 00:39:23,580
the speaker, I encourage you to ask them over here outside of this room.

736
00:39:23,580 --> 00:39:27,660
I also just want to take a moment before you leave for lunch to give a nice shout

737
00:39:27,660 --> 00:39:31,380
out to our audio team and to our transcriptionist for kicking butt today.

