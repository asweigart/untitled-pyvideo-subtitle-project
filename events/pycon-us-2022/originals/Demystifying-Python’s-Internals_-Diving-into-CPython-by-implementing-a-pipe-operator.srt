1
00:00:00,000 --> 00:00:11,640
It's my pleasure to introduce Sebastian Zeff, who will be talking about demystifying Python's

2
00:00:11,640 --> 00:00:15,000
internals, diving into CPython by implementing a pipe operator.

3
00:00:15,000 --> 00:00:17,680
Yes, well, thank you very much.

4
00:00:17,680 --> 00:00:19,400
So you must be hearing this a lot.

5
00:00:19,400 --> 00:00:23,320
This is my first in-person PyCon and my first in-person PyCon talk.

6
00:00:23,320 --> 00:00:25,960
I gave a talk last year, but it was online.

7
00:00:25,960 --> 00:00:28,840
And I'm really happy to be here and to just be able to see you all.

8
00:00:28,960 --> 00:00:33,800
I'm also really happy for all of the people who are joining us from home online.

9
00:00:33,800 --> 00:00:35,400
It's really like a birthday present.

10
00:00:35,400 --> 00:00:37,040
And in fact, today is my birthday.

11
00:00:37,040 --> 00:00:39,560
So this actually is a birthday present for me.

12
00:00:39,560 --> 00:00:44,520
So thank you all for joining my little birthday party today.

13
00:00:45,440 --> 00:00:50,120
So before we dive into Python, I'm first briefly going to introduce myself so you know who I am.

14
00:00:50,120 --> 00:00:52,720
And then we're going to dive right into the talk.

15
00:00:53,560 --> 00:00:55,080
So my name is Sebastian.

16
00:00:56,480 --> 00:00:58,560
You can see my Twitter handle over there.

17
00:00:58,600 --> 00:01:03,400
If you have any angry corrections or you want to ask me questions, just tweet something at me.

18
00:01:03,400 --> 00:01:07,720
And another thing that I would really appreciate is photos.

19
00:01:07,720 --> 00:01:11,720
I don't have a lot of photos of me speaking, especially in the past two years.

20
00:01:11,720 --> 00:01:15,320
Everything has been online, staring into a webcam.

21
00:01:15,320 --> 00:01:20,960
So if you do make a photo, it doesn't matter if it's from close by or far away, please tweet it at me.

22
00:01:20,960 --> 00:01:22,520
So I have the photo as well.

23
00:01:22,520 --> 00:01:23,360
Thank you very much.

24
00:01:24,640 --> 00:01:27,160
So I flew in from the Netherlands last Saturday.

25
00:01:27,160 --> 00:01:30,400
We had a nice road trip here to Salt Lake City.

26
00:01:30,400 --> 00:01:33,920
And in the Netherlands, I work for the Ordina Pythoneers.

27
00:01:33,920 --> 00:01:41,240
And what we do is we use Python and we go out to our customers and we help them with their problems.

28
00:01:41,240 --> 00:01:42,880
We implement solutions.

29
00:01:42,880 --> 00:01:44,240
We do enterprise development.

30
00:01:44,240 --> 00:01:48,040
We do a lot of artificial intelligence and machine learning.

31
00:01:48,040 --> 00:01:52,840
I'm more in the web development and the enterprise side of things.

32
00:01:52,840 --> 00:01:56,200
But that's all that that's part of what we do.

33
00:01:56,240 --> 00:02:02,000
I'm also a part of the code Smith group of the Ordina software development, which means I get to be here.

34
00:02:02,000 --> 00:02:04,480
I get to do stuff with innovation and education.

35
00:02:04,480 --> 00:02:06,240
So really nice.

36
00:02:06,240 --> 00:02:07,720
And I really like that.

37
00:02:07,720 --> 00:02:12,480
In my spare time, I'm a volunteer for EuroPython, which is another great conference.

38
00:02:12,480 --> 00:02:18,160
It's happening in Dublin this year, which might be a little bit far away for a lot of you, but there are hybrid options.

39
00:02:18,160 --> 00:02:20,320
So do consider coming or joining online.

40
00:02:20,320 --> 00:02:21,640
It's going to be awesome.

41
00:02:21,680 --> 00:02:28,680
And I'm also one of the founders or owners of Python Discord, which is a large online Python community.

42
00:02:28,680 --> 00:02:31,600
So right, let's dive into the talk itself.

43
00:02:31,600 --> 00:02:39,040
What we're going to do today, we're going to take a journey all the way from source code to execution.

44
00:02:39,040 --> 00:02:43,800
So what we're going to see, we're going to see a lot of topics like tokens, grammar, the pack parser.

45
00:02:43,800 --> 00:02:46,200
We're going to talk about abstract syntax trees.

46
00:02:46,200 --> 00:02:52,160
We're going to talk a little bit about the compiler that Python has, byte code and op codes or the instructions.

47
00:02:52,160 --> 00:02:55,440
And finally, we will see the evaluation loop.

48
00:02:55,440 --> 00:02:58,200
And this is where really the magic happens.

49
00:02:58,200 --> 00:03:03,760
And I'm not just going to give you a lecture explaining all of those topics, but what we're going to do.

50
00:03:03,760 --> 00:03:07,600
So I'm going to implement a new operator in Python, a pipe operator.

51
00:03:07,600 --> 00:03:12,720
And it will very naturally take us all the way from source code to execution.

52
00:03:12,720 --> 00:03:14,320
There are also some time constraints.

53
00:03:14,320 --> 00:03:15,560
So please excuse me.

54
00:03:15,560 --> 00:03:20,560
This talk will feature blatant emissions and gross oversimplifications.

55
00:03:20,560 --> 00:03:27,640
So if you'd like to know more after this very broad introductions, there are a few great resources.

56
00:03:27,640 --> 00:03:30,720
There's the Python dev guide that you can find online.

57
00:03:30,720 --> 00:03:37,600
It's an excellent resource and it has everything you need to get you started with developing and contributing to see Python.

58
00:03:37,600 --> 00:03:40,080
There's also a guide written by Victor Stinner.

59
00:03:40,080 --> 00:03:40,600
Excellent.

60
00:03:40,600 --> 00:03:41,400
Find it on Google.

61
00:03:41,400 --> 00:03:42,920
I forgot to mention it here.

62
00:03:42,920 --> 00:03:49,680
And then obviously, there's the CPython internals book written by Anthony Shaw and the real Python crew.

63
00:03:49,680 --> 00:03:52,240
Definitely check out that book as well.

64
00:03:52,240 --> 00:04:00,040
So for today, we're going to take the entire journey from source code all the way to execution.

65
00:04:00,040 --> 00:04:03,680
But there's a lot of details in here, a lot of code.

66
00:04:03,680 --> 00:04:04,560
There are a lot of slides.

67
00:04:04,560 --> 00:04:10,280
So if you want to read along or read it after my talk, you can find everything on my GitHub page.

68
00:04:10,320 --> 00:04:13,800
It's over there, Sebastian C slash Python.

69
00:04:13,800 --> 00:04:17,320
I thought it was a nice name for the repository.

70
00:04:17,320 --> 00:04:20,840
And basically, you will find everything that I tell you today.

71
00:04:20,840 --> 00:04:26,040
You also find it in there so you can play around with this new implementation of Python.

72
00:04:26,040 --> 00:04:27,080
Cool.

73
00:04:27,080 --> 00:04:29,600
So what is this new operator that we're going to implement?

74
00:04:29,600 --> 00:04:31,520
It's a new binary operator.

75
00:04:31,520 --> 00:04:36,360
And this means that it takes two operands, one on the left hand side and one on the right hand side.

76
00:04:36,400 --> 00:04:40,240
And then it does something with those two values.

77
00:04:40,240 --> 00:04:43,920
And our pipe operator, it works with very simple functions.

78
00:04:43,920 --> 00:04:46,000
So you have this double function here.

79
00:04:46,000 --> 00:04:49,520
It just takes a single argument and it returns something.

80
00:04:49,520 --> 00:04:55,560
Internally, the function can be quite complex, but it has to take a single argument and it has to return something.

81
00:04:55,560 --> 00:04:57,000
Well, not returning something.

82
00:04:57,000 --> 00:04:59,040
It's very difficult in Python.

83
00:04:59,040 --> 00:05:01,400
So this is the kind of functions that we'll work with.

84
00:05:01,400 --> 00:05:06,160
And what we'll be able to do is to call the function in a new way.

85
00:05:06,160 --> 00:05:13,400
So what we can do is we can first specify the argument, one in this case, use the operator and then name the function.

86
00:05:13,400 --> 00:05:16,240
And then the arguments will be passed to the function.

87
00:05:16,240 --> 00:05:21,280
And the result of this operation will be whatever value the function returns.

88
00:05:21,280 --> 00:05:25,080
So it's equivalent to calling double with one as the argument.

89
00:05:25,080 --> 00:05:27,400
Obviously, this isn't very interesting.

90
00:05:27,400 --> 00:05:32,280
But the thing that this enables us to do is we can now build a pipeline.

91
00:05:32,320 --> 00:05:37,800
So we can start with a single value and then build a pipeline of functions to process that value.

92
00:05:37,800 --> 00:05:42,880
So if you have a data set or a list or a single value, you need to do a number of operations on them.

93
00:05:42,880 --> 00:05:44,640
You can do that in a very functional way.

94
00:05:44,640 --> 00:05:47,480
You can pass the value from function to function.

95
00:05:47,480 --> 00:05:50,720
And eventually, you'll get a return value out of it.

96
00:05:50,720 --> 00:05:52,360
So that's what we're going to do today.

97
00:05:52,360 --> 00:05:55,840
And obviously, this is not a part of Python itself.

98
00:05:55,840 --> 00:05:58,480
And it probably will never be a part of Python.

99
00:05:58,480 --> 00:06:02,600
I know this operator has been proposed a few times.

100
00:06:02,600 --> 00:06:05,760
There are very good reasons not to add it to the language.

101
00:06:05,760 --> 00:06:07,440
There are other ways to call functions.

102
00:06:07,440 --> 00:06:09,320
We might not need the complexity.

103
00:06:09,320 --> 00:06:10,560
But that's not my department.

104
00:06:10,560 --> 00:06:16,080
If you really want such an operator, go discuss it with a core developer or with the steering council.

105
00:06:16,080 --> 00:06:17,960
But just to be sure, this is not in Python.

106
00:06:17,960 --> 00:06:19,640
We're going to implement it here.

107
00:06:19,640 --> 00:06:23,160
And also, the implementation is purely educational.

108
00:06:23,160 --> 00:06:25,920
I'm going to take a few shortcuts, maybe.

109
00:06:25,920 --> 00:06:34,440
I'm going to implement it in a non-efficient way so that I can show you all the parts that we need to change.

110
00:06:34,440 --> 00:06:40,560
And I'm not going to use existing opcodes and things like that just to be able to show you everything.

111
00:06:40,560 --> 00:06:42,160
So it's purely educational.

112
00:06:42,160 --> 00:06:46,160
But if you want, you can download the source code and try to improve it.

113
00:06:46,160 --> 00:06:47,400
Cool.

114
00:06:47,400 --> 00:06:54,560
So what we're going to do, we're going to first start with our source code and produce something called an abstract syntax tree.

115
00:06:54,560 --> 00:06:58,160
An abstract syntax tree is a different representation of your source code.

116
00:06:58,160 --> 00:07:03,840
It's a nice tree structure, which is much easier for the compiler to work with.

117
00:07:03,840 --> 00:07:04,880
So that is the first step.

118
00:07:04,880 --> 00:07:07,800
We want to take the source code with the new operator.

119
00:07:07,800 --> 00:07:15,600
And we want the parser to be able to turn it into such an abstract syntax tree node.

120
00:07:15,600 --> 00:07:19,160
So let's first zoom in on the source code.

121
00:07:19,160 --> 00:07:22,280
So here, we have a piece of source code.

122
00:07:22,320 --> 00:07:25,720
For us humans, we are very good at chunking stuff.

123
00:07:25,720 --> 00:07:27,960
So we immediately see a 10.

124
00:07:27,960 --> 00:07:29,720
We maybe see the name double.

125
00:07:29,720 --> 00:07:34,000
We see kind of a weird operator in the middle that's not part of Python just yet.

126
00:07:34,000 --> 00:07:37,880
But for Python, it just starts with a stream of characters.

127
00:07:37,880 --> 00:07:41,160
So for Python, at first, these are just 12 characters.

128
00:07:41,160 --> 00:07:42,680
Maybe there's a new line at the end.

129
00:07:42,680 --> 00:07:43,800
I've left it out.

130
00:07:43,800 --> 00:07:46,600
These are just 12 characters, two spaces.

131
00:07:46,600 --> 00:07:48,760
And it doesn't quite know what to do with it yet.

132
00:07:48,800 --> 00:07:55,520
So the first step for Python is to turn those characters into a stream of tokens.

133
00:07:55,520 --> 00:07:58,000
And the tokenizer of Python will do that for you.

134
00:07:58,000 --> 00:08:00,760
It will recognize a number token over here.

135
00:08:00,760 --> 00:08:04,880
This is the smallest part that we can divide in our source code.

136
00:08:04,880 --> 00:08:08,280
If we try to separate these characters, we lose meaning.

137
00:08:08,280 --> 00:08:11,080
There's a name token over here, the name double.

138
00:08:11,080 --> 00:08:14,920
And obviously, if we leave out some of the characters, the name changes.

139
00:08:14,920 --> 00:08:17,800
But then there's this weird thing here in the middle.

140
00:08:17,800 --> 00:08:22,360
So the tokenizer doesn't quite recognize this token just yet.

141
00:08:22,360 --> 00:08:25,000
And actually, there are two existing tokens in there.

142
00:08:25,000 --> 00:08:29,240
But we really want the tokenizer to be able to recognize this as a single

143
00:08:29,240 --> 00:08:31,080
token in your source code.

144
00:08:31,080 --> 00:08:32,360
Well, is that difficult to do?

145
00:08:32,360 --> 00:08:33,960
Well, actually not.

146
00:08:33,960 --> 00:08:36,120
This is just a configuration file.

147
00:08:36,120 --> 00:08:39,920
So if you look in the Python repository, there's a folder called grammar.

148
00:08:39,920 --> 00:08:42,040
And in there, there's a file called tokens.

149
00:08:42,040 --> 00:08:43,840
And this is just a text file.

150
00:08:43,840 --> 00:08:47,760
And it maps the name of the token to the character sequence that makes up

151
00:08:47,760 --> 00:08:48,680
the token.

152
00:08:48,680 --> 00:08:50,440
So you'll find a lot of tokens in there.

153
00:08:50,440 --> 00:08:51,760
These are just a few.

154
00:08:51,760 --> 00:08:55,960
And the only thing that we need to do is we need to add a token of our own.

155
00:08:55,960 --> 00:09:00,120
So I'm calling it the V bar grader, because there are not really semantics

156
00:09:00,120 --> 00:09:00,640
at this point.

157
00:09:00,640 --> 00:09:03,040
I just followed the naming convention in here.

158
00:09:03,040 --> 00:09:06,600
And this V bar grader is mapped to the character sequence that we want

159
00:09:06,600 --> 00:09:08,160
the token to have.

160
00:09:08,160 --> 00:09:11,720
Well, at this point, the tokenizer won't actually use it.

161
00:09:11,720 --> 00:09:15,520
Because the tokenizer won't continuously read in this file,

162
00:09:15,520 --> 00:09:18,320
it's actually generated using this file.

163
00:09:18,320 --> 00:09:22,000
So for the tokenizer to actually use this, we have to regenerate it.

164
00:09:22,000 --> 00:09:25,160
And this is going to be something that we'll see a lot in this talk.

165
00:09:25,160 --> 00:09:27,640
We'll have to run a few commands.

166
00:09:27,640 --> 00:09:31,000
On Linux and Mac, that's make regen token.

167
00:09:31,000 --> 00:09:35,400
On Windows, there's a build.bat file in the PC build folder.

168
00:09:35,400 --> 00:09:40,200
And you can run the dash dash regen command, which will actually regenerate

169
00:09:40,200 --> 00:09:42,360
a whole bunch of other stuff as well.

170
00:09:42,360 --> 00:09:46,360
And once you've done this, now you have a tokenizer that knows the token,

171
00:09:46,360 --> 00:09:49,600
that's aware of the token, and can finally parse it and

172
00:09:49,600 --> 00:09:51,040
put it in a stream of tokens.

173
00:09:52,320 --> 00:09:56,360
So after this simple change, we've already went from source code

174
00:09:56,360 --> 00:09:58,040
to a stream of tokens.

175
00:09:58,040 --> 00:10:01,920
And this stream of tokens is the input for the parser.

176
00:10:01,920 --> 00:10:04,520
And this makes the pack parser in Python a little bit weird.

177
00:10:05,440 --> 00:10:09,320
Most pack parsers actually work with raw characters.

178
00:10:09,320 --> 00:10:12,600
But in Python, it works with the tokens that we know.

179
00:10:12,600 --> 00:10:17,440
And this stream of tokens will be put into the parser.

180
00:10:17,440 --> 00:10:21,120
And the parser will output the abstract syntax tree.

181
00:10:21,120 --> 00:10:23,240
And if you've looked at the parser in the past,

182
00:10:23,240 --> 00:10:27,760
the old parser that was in Python, it actually used an intermediate step

183
00:10:27,760 --> 00:10:29,720
called the concrete syntax tree.

184
00:10:29,720 --> 00:10:33,160
With the pack parser that was added to Python in 3.9,

185
00:10:33,160 --> 00:10:38,120
the parser can immediately translate the stream of tokens that it parses into

186
00:10:38,120 --> 00:10:39,600
the abstract syntax tree.

187
00:10:39,600 --> 00:10:41,800
So that's what we need to do.

188
00:10:41,800 --> 00:10:46,480
So we now need to add support in the parser for our new token.

189
00:10:46,480 --> 00:10:50,840
And that's obviously very important because there currently is no syntax

190
00:10:50,840 --> 00:10:51,840
that uses the token.

191
00:10:51,840 --> 00:10:55,520
So if you try to use it, the parser won't recognize it.

192
00:10:55,520 --> 00:10:57,800
And then finally, we also need to add support for

193
00:10:57,800 --> 00:11:00,600
this new operator in the abstract syntax tree.

194
00:11:00,600 --> 00:11:02,600
It needs to have a node on its own.

195
00:11:02,600 --> 00:11:04,880
So that's what we're going to do next.

196
00:11:04,880 --> 00:11:09,320
And to do that, we're going to add a new grammar rule to Python for

197
00:11:09,320 --> 00:11:10,160
our new operator.

198
00:11:11,720 --> 00:11:15,240
And as I just said, Python now uses a pack parser.

199
00:11:15,240 --> 00:11:19,120
So we're going to use the parsing expression grammar syntax to define

200
00:11:19,120 --> 00:11:20,240
our token.

201
00:11:20,240 --> 00:11:22,840
I'm not going to explain all of this syntax to you.

202
00:11:22,840 --> 00:11:25,960
There's an excellent chapter in the dev guide online.

203
00:11:25,960 --> 00:11:29,400
But I am going to zoom in on just a little bit of the parts that we need for

204
00:11:29,400 --> 00:11:30,960
our new operator.

205
00:11:30,960 --> 00:11:35,800
So first of all, here's a very simplified piece of pack grammar.

206
00:11:35,800 --> 00:11:39,040
And you can assume that there are some other statements above there that

207
00:11:39,040 --> 00:11:40,000
define statements.

208
00:11:40,000 --> 00:11:44,400
But these are the only two expressions in my simplified mini language.

209
00:11:44,400 --> 00:11:47,440
And I've left out some noise that we don't need right now.

210
00:11:47,440 --> 00:11:50,960
So and let me just color code it for you because that's important.

211
00:11:50,960 --> 00:11:54,520
In this language defined by this small piece of grammar,

212
00:11:54,520 --> 00:11:56,040
there are just two expressions.

213
00:11:56,040 --> 00:12:00,920
There's a sum expression, which has two alternatives that it might match.

214
00:12:00,920 --> 00:12:05,520
And you can tell that they are alternatives by the vertical bar at the front.

215
00:12:05,520 --> 00:12:10,200
So the first alternative is an atom plus another atom.

216
00:12:10,200 --> 00:12:14,440
And the second alternative for the sum rule is an atom on its own.

217
00:12:14,440 --> 00:12:15,520
Well, what is an atom?

218
00:12:15,520 --> 00:12:19,600
Well, the atom is actually not a rule in our very minified grammar,

219
00:12:19,600 --> 00:12:21,680
which is just a number token.

220
00:12:21,680 --> 00:12:25,720
We're not going to go into how Python recognizes number tokens, but

221
00:12:25,720 --> 00:12:27,720
we can just assume that it does.

222
00:12:27,760 --> 00:12:32,440
And as you can see, the sum rule includes the atom rule at the bottom.

223
00:12:32,440 --> 00:12:35,320
And that's how our grammar kind of flows down.

224
00:12:35,320 --> 00:12:39,040
That's how we get all the alternatives that we might try to parse at

225
00:12:39,040 --> 00:12:42,080
a specific point that we're trying to parse.

226
00:12:42,080 --> 00:12:45,880
So if you have these rules, it's fairly trivial to see that if we have a very

227
00:12:45,880 --> 00:12:49,960
simple one, this will match the second branch in the sum,

228
00:12:49,960 --> 00:12:51,680
which is just an atom on its own.

229
00:12:51,680 --> 00:12:54,520
So we can parse this as a single number.

230
00:12:54,520 --> 00:12:59,600
It's also very easy to see that if we have one plus one with the literal plus

231
00:12:59,600 --> 00:13:02,320
in the middle, that we can parse this one as well.

232
00:13:02,320 --> 00:13:05,440
This is the first rule of the sum rule.

233
00:13:05,440 --> 00:13:06,520
But now what about this one?

234
00:13:08,720 --> 00:13:10,560
So this is an interesting one.

235
00:13:10,560 --> 00:13:15,320
So once the parser gets going, it will consume our characters.

236
00:13:15,320 --> 00:13:17,800
So it's perfectly able to match this first part.

237
00:13:17,800 --> 00:13:20,760
We're not going to worry about the actual order of matching here.

238
00:13:20,840 --> 00:13:25,600
So then it will have consumed these characters for our need sum rule, and

239
00:13:25,600 --> 00:13:28,280
then it's left with plus three.

240
00:13:28,280 --> 00:13:30,720
There's no rule that matches plus three, so

241
00:13:30,720 --> 00:13:33,440
it's not able to parse this expression.

242
00:13:33,440 --> 00:13:35,000
So what should we do?

243
00:13:35,000 --> 00:13:40,040
We can obviously add another rule for atom plus atom plus atom.

244
00:13:40,040 --> 00:13:43,960
But what about four pluses, or three, or six, or eight pluses in an expression?

245
00:13:43,960 --> 00:13:50,520
Do we have to add a rule for each number of pluses that we have?

246
00:13:50,520 --> 00:13:52,000
Luckily, we don't have to.

247
00:13:52,000 --> 00:13:54,560
We can slightly tweak the first rule of sum.

248
00:13:54,560 --> 00:13:58,440
We can replace the first atom by sum itself, and

249
00:13:58,440 --> 00:14:00,760
this will make the rule recursive.

250
00:14:00,760 --> 00:14:05,160
So as you can see now, it's able to match a sum, but

251
00:14:05,160 --> 00:14:09,760
it's also able to match a sum nested in another sum.

252
00:14:09,760 --> 00:14:12,360
And obviously, this is a recursive relationship, so

253
00:14:12,360 --> 00:14:15,720
you can now match an arbitrary number of pluses in a row.

254
00:14:15,720 --> 00:14:20,480
If you think about it, this is precisely what we want to do with our pipe

255
00:14:20,480 --> 00:14:23,560
operator, we want to be able to build pipelines.

256
00:14:23,560 --> 00:14:27,080
So we're going to use this recursive rule in our new grammar rule.

257
00:14:28,280 --> 00:14:29,040
So let's add it.

258
00:14:30,040 --> 00:14:32,560
So this is a section in Python's grammar.

259
00:14:32,560 --> 00:14:35,880
You can find it in grammar slash python.gram.

260
00:14:35,880 --> 00:14:38,000
Just took out a small portion.

261
00:14:38,000 --> 00:14:41,760
I'm going to insert a new grammar rule between these two.

262
00:14:41,760 --> 00:14:44,880
This is actually not the best place to do it for

263
00:14:45,880 --> 00:14:48,000
precedence and all other stuff.

264
00:14:48,000 --> 00:14:51,080
This is a very easy way for me to add a new rule, and

265
00:14:51,080 --> 00:14:52,160
I'll show you why in a minute.

266
00:14:53,720 --> 00:14:55,800
And again, if you'd like to improve on this,

267
00:14:55,800 --> 00:14:59,320
do download the source code and just try to make it better yourself.

268
00:14:59,320 --> 00:15:00,360
So what am I going to do?

269
00:15:00,360 --> 00:15:03,960
I'm going to add a new grammar rule called pipe.

270
00:15:03,960 --> 00:15:05,480
It's an expression type.

271
00:15:05,480 --> 00:15:07,760
You kind of can ignore that for now.

272
00:15:07,760 --> 00:15:10,800
And here in the middle, we have our recursive rule.

273
00:15:10,800 --> 00:15:13,120
So pipe includes pipe itself, and

274
00:15:13,120 --> 00:15:15,960
it includes the sum, which is the rule just below it.

275
00:15:16,720 --> 00:15:18,360
Now we're nearly done.

276
00:15:18,360 --> 00:15:20,320
There's just one problem left.

277
00:15:20,320 --> 00:15:24,800
And that is that our grammar rule isn't referenced by any other grammar rule.

278
00:15:24,800 --> 00:15:29,880
So if you look at the shift rule just above, it only references to sum.

279
00:15:29,880 --> 00:15:31,760
So it will step over our rule.

280
00:15:31,760 --> 00:15:33,120
It's not actually used.

281
00:15:33,120 --> 00:15:34,840
So we have to change those references.

282
00:15:34,840 --> 00:15:36,680
And that's what I'm going to do next.

283
00:15:36,680 --> 00:15:40,680
I'm just going to make the shift expression refer to our new rule, and

284
00:15:40,680 --> 00:15:43,000
then make that rule refer to sum.

285
00:15:43,000 --> 00:15:45,160
And this is why I inserted it here.

286
00:15:45,160 --> 00:15:47,520
Here I only have to change a few references.

287
00:15:47,520 --> 00:15:49,400
I don't have to change a lot of references.

288
00:15:51,080 --> 00:15:57,320
So now, this means that we can now parse this bit of syntax.

289
00:15:57,320 --> 00:15:58,760
That's very cool.

290
00:15:58,760 --> 00:16:00,800
But what about the last step?

291
00:16:00,800 --> 00:16:06,400
We haven't actually told the parser how it can convert what it has just

292
00:16:06,400 --> 00:16:11,400
parsed into an AST node that you see on the right hand side here.

293
00:16:12,320 --> 00:16:15,360
So a bin up node is the representation of our operation.

294
00:16:15,360 --> 00:16:17,880
It has a left hand side, the 10 in this case.

295
00:16:17,880 --> 00:16:19,640
It has the operation in the middle.

296
00:16:19,640 --> 00:16:22,880
And it has the name double on the right hand side.

297
00:16:22,880 --> 00:16:26,080
There's probably going to be a load below that as well.

298
00:16:26,080 --> 00:16:27,640
But I just kept it simple.

299
00:16:27,640 --> 00:16:32,480
So we have to tell the parser how it can get from parsing the syntax to making

300
00:16:32,480 --> 00:16:34,720
such an AST node.

301
00:16:34,720 --> 00:16:38,520
And with the new pack parser, there's a very convenient way to do that.

302
00:16:38,520 --> 00:16:41,160
And it's called grammar actions.

303
00:16:41,160 --> 00:16:46,240
And grammar actions are basically just small pieces of embedded code

304
00:16:46,240 --> 00:16:47,840
within a grammar rule.

305
00:16:47,840 --> 00:16:51,000
So as you can see here, there are two curly braces.

306
00:16:51,000 --> 00:16:53,680
And within there, there's just a tiny bit of C code.

307
00:16:53,680 --> 00:16:55,560
This is calling a function.

308
00:16:55,560 --> 00:16:57,320
And it will pass in some information and

309
00:16:57,320 --> 00:17:01,240
the function will construct the AST node for us.

310
00:17:01,240 --> 00:17:04,840
So as mentioned, it will need the left hand side and the right hand side.

311
00:17:04,840 --> 00:17:07,920
That's why the grammar rule is slightly more complex.

312
00:17:07,920 --> 00:17:11,800
There's the A is sum and B is term in there.

313
00:17:11,800 --> 00:17:15,960
And that's assigning names to the left hand side and the right hand side so

314
00:17:15,960 --> 00:17:20,080
we can pass it into this pi bin op function.

315
00:17:20,080 --> 00:17:21,760
There's also an add in the middle.

316
00:17:21,760 --> 00:17:25,160
We know that this is an add operator because this is the plus rule.

317
00:17:25,160 --> 00:17:27,040
So we just hard code it in here.

318
00:17:27,040 --> 00:17:28,360
There are also some extra bits.

319
00:17:28,360 --> 00:17:30,560
We're not going to talk about them today.

320
00:17:30,560 --> 00:17:33,840
Things like line number, column offset, things like that.

321
00:17:34,960 --> 00:17:37,680
We're just going to assume that they're taken care of for us.

322
00:17:37,680 --> 00:17:43,960
So this is how we can tell the parser how to create a AST node.

323
00:17:43,960 --> 00:17:46,440
So we just copy this approach for our pipe rule.

324
00:17:48,160 --> 00:17:51,480
The only thing that we really need to change is that instead of

325
00:17:51,480 --> 00:17:53,680
specifying that this is an add operator,

326
00:17:53,680 --> 00:17:57,080
we're going to specify that this is a call pipe operator.

327
00:17:57,080 --> 00:17:59,080
Which is how I named this operation.

328
00:18:00,960 --> 00:18:02,480
Just one tiny problem.

329
00:18:03,560 --> 00:18:07,560
There's now a call pipe node in my AST, but it doesn't exist yet.

330
00:18:07,560 --> 00:18:10,240
So we have to create that one as well.

331
00:18:10,240 --> 00:18:12,000
Well, it sounds kind of difficult, but

332
00:18:12,000 --> 00:18:14,960
actually this is just another configuration file.

333
00:18:14,960 --> 00:18:18,640
So if you open the parser slash python.asdl,

334
00:18:18,640 --> 00:18:22,480
which stands for abstract syntax definition language.

335
00:18:22,480 --> 00:18:28,560
This is a file that defines all of the AST nodes that are in Python.

336
00:18:28,560 --> 00:18:33,400
And you can actually generate all of the necessary types from this file.

337
00:18:33,400 --> 00:18:37,080
So you don't really need to write all the classes or types yourself.

338
00:18:37,080 --> 00:18:39,560
You can have them generated for you.

339
00:18:39,560 --> 00:18:43,000
As you can see here, I picked a bit that includes operator.

340
00:18:43,000 --> 00:18:45,800
And operator has a lot of alternatives.

341
00:18:45,800 --> 00:18:47,400
One here is add.

342
00:18:47,400 --> 00:18:51,480
And what the generator will do, it will make a C enum for

343
00:18:51,480 --> 00:18:56,640
us that has a number of members or fields, and add is one of those fields.

344
00:18:56,640 --> 00:19:02,480
So the only thing that we need to do is we need to add our operator at the end.

345
00:19:02,480 --> 00:19:06,680
And then we need to regenerate all the AST nodes with this file.

346
00:19:07,320 --> 00:19:12,160
Then we will magically get another member field in the C enum with a new integer

347
00:19:12,160 --> 00:19:16,480
assigned to it, and then we can use the name, a call pipe.

348
00:19:16,480 --> 00:19:19,880
So after we've done this, we have the grammar rule.

349
00:19:19,880 --> 00:19:22,240
We can now regenerate the parser itself.

350
00:19:23,760 --> 00:19:26,640
And now we can actually use it.

351
00:19:26,640 --> 00:19:31,320
So we can use ast.parse, pass in our expression, and

352
00:19:31,320 --> 00:19:37,760
it will actually be able to build an AST that includes a bin up operation and

353
00:19:37,760 --> 00:19:40,600
a call pipe operator, as you can see here.

354
00:19:40,600 --> 00:19:44,440
Well, this is all very handy, but this doesn't do anything yet.

355
00:19:44,440 --> 00:19:47,600
Now we have a nice tree-like representation of our code, but

356
00:19:47,600 --> 00:19:49,480
there's no execution yet.

357
00:19:49,480 --> 00:19:54,080
And that's what we're going to see in part two.

358
00:19:54,080 --> 00:19:58,520
So what we're going to do in part two, we're going to take the AST,

359
00:19:58,520 --> 00:20:02,880
pass it into the compiler, and then the compiler will pass something to

360
00:20:02,880 --> 00:20:05,880
the evaluation loop, and then we'll get magic.

361
00:20:05,880 --> 00:20:09,120
And I call this magic because it's always been magic to me.

362
00:20:09,120 --> 00:20:12,680
I type in some magic formula or spell into my computer, and

363
00:20:12,680 --> 00:20:13,760
then something happens.

364
00:20:13,760 --> 00:20:14,920
It's really like magic to me.

365
00:20:16,720 --> 00:20:20,960
Cool, so let's zoom in on that second part.

366
00:20:20,960 --> 00:20:22,840
So we have the AST as the input.

367
00:20:22,840 --> 00:20:24,800
We will put it into the compiler, and

368
00:20:24,800 --> 00:20:28,480
the compiler will generate something for us called bytecode.

369
00:20:28,480 --> 00:20:31,240
And this is like an intermediate language, and

370
00:20:31,240 --> 00:20:35,600
it's just a long list of instructions, a long list of bytes or integers,

371
00:20:35,600 --> 00:20:39,560
which is more easy for us to reason about.

372
00:20:39,560 --> 00:20:43,760
And these are really the instructions that the evaluation loop will then perform.

373
00:20:45,560 --> 00:20:51,320
And for those of you who like the discussion about is Python a compiled

374
00:20:51,320 --> 00:20:53,520
language or not, just think about this and

375
00:20:53,520 --> 00:20:56,040
then ignore the discussion because it always gets very toxic.

376
00:20:56,040 --> 00:21:02,360
So first of all, we're going to add some support to the compiler.

377
00:21:02,360 --> 00:21:07,920
And each instruction that we are able to perform has its own opcode or

378
00:21:07,920 --> 00:21:09,240
operation code.

379
00:21:09,240 --> 00:21:14,720
What I'm going to do is I'm going to add a new opcode for our new operator.

380
00:21:14,720 --> 00:21:19,840
Some of you may wonder about the fact that there is already an opcode for

381
00:21:19,840 --> 00:21:21,160
calling functions.

382
00:21:21,160 --> 00:21:24,920
I'm going to ignore that one because I want to show you how to

383
00:21:24,920 --> 00:21:25,760
implement a new one.

384
00:21:27,320 --> 00:21:29,480
So this is purely educational in a way.

385
00:21:30,840 --> 00:21:32,760
So right, this is the first and

386
00:21:32,760 --> 00:21:36,880
probably the only Python file that we'll see today in my talk at least.

387
00:21:36,880 --> 00:21:39,720
And it's in lib slash opcode.py.

388
00:21:39,720 --> 00:21:43,680
And this defines all the operation codes that we have.

389
00:21:43,680 --> 00:21:46,080
And it basically specifies a name and

390
00:21:46,080 --> 00:21:49,880
then the byte or the integer that we have for the operation code.

391
00:21:49,880 --> 00:21:53,920
Now ours doesn't have taken argument, our opcode.

392
00:21:54,320 --> 00:21:57,080
It works with values that are already on the value stack,

393
00:21:57,080 --> 00:21:58,640
more about that later.

394
00:21:58,640 --> 00:22:01,440
So we need to add it for the half argument constant or

395
00:22:01,440 --> 00:22:03,040
the value defined in there.

396
00:22:03,040 --> 00:22:06,680
So I'm just going to add it here with the new integer of 90, and

397
00:22:06,680 --> 00:22:10,560
then increment all the values below that just to make it work again.

398
00:22:10,560 --> 00:22:13,920
That's the issue of working with sequential numbers.

399
00:22:13,920 --> 00:22:16,800
So once we've defined our operation code here,

400
00:22:16,800 --> 00:22:18,960
we can regenerate all the opcodes.

401
00:22:18,960 --> 00:22:23,440
And now we have a new opcode, which is cool.

402
00:22:23,440 --> 00:22:27,240
But the compiler still doesn't know when to use it.

403
00:22:27,240 --> 00:22:28,520
So that's what we'll do next.

404
00:22:28,520 --> 00:22:32,320
We're now going to teach the compiler when to write this opcode into

405
00:22:32,320 --> 00:22:32,960
the bytecode.

406
00:22:35,040 --> 00:22:40,000
So in the compiler, in a file called python slash compile.c,

407
00:22:40,000 --> 00:22:44,480
there are a lot of functions that get called whenever

408
00:22:44,480 --> 00:22:49,680
the compiler encounters a specific type of AST node.

409
00:22:49,680 --> 00:22:52,480
And in our case, we're dealing with an expression.

410
00:22:52,480 --> 00:22:55,400
So we're going to modify the compiler visit,

411
00:22:55,400 --> 00:22:58,000
expression one function.

412
00:22:58,000 --> 00:23:02,320
And this is a function that gets called internally whenever we

413
00:23:02,320 --> 00:23:05,840
get to an expression and node in the AST.

414
00:23:05,840 --> 00:23:09,440
And this function is basically just a large switch case statement.

415
00:23:09,440 --> 00:23:13,280
And it has a case for bin op kind, the binary operations.

416
00:23:13,280 --> 00:23:17,040
And that's the one that will take care of writing our opcodes for

417
00:23:17,040 --> 00:23:19,560
our new binary operation.

418
00:23:19,600 --> 00:23:23,880
And what's important to note here is that there are two visits first.

419
00:23:23,880 --> 00:23:29,920
So it's first going to visit the left hand side of our binary operation.

420
00:23:29,920 --> 00:23:33,440
And that means that it will first write all the instructions to

421
00:23:33,440 --> 00:23:37,920
evaluate the left hand side of our operator to get that value.

422
00:23:37,920 --> 00:23:40,680
Then it will do the same for the right hand side.

423
00:23:40,680 --> 00:23:45,440
So it will write all the instructions it needs to evaluate the right hand side

424
00:23:45,440 --> 00:23:46,560
of the operator.

425
00:23:46,560 --> 00:23:50,560
And that's logical because we need both values before we can actually perform

426
00:23:50,560 --> 00:23:57,280
the operation, before we can write out the new opcode that we have.

427
00:23:57,280 --> 00:24:02,320
Well, taking care of the new opcode is the add op macro that we see here.

428
00:24:02,320 --> 00:24:04,760
It will just write a single opcode.

429
00:24:04,760 --> 00:24:06,240
Now, how does it know which one?

430
00:24:06,240 --> 00:24:09,880
Well, it calls a helper function called bin op.

431
00:24:09,880 --> 00:24:12,960
And bin op is just another switch case statement.

432
00:24:12,960 --> 00:24:17,240
And it has cases for all the operators defined in the AST.

433
00:24:17,240 --> 00:24:18,560
Here we have the add.

434
00:24:18,560 --> 00:24:23,680
And it will just simply return the opcode associated with that operator.

435
00:24:23,680 --> 00:24:27,840
So all we have to do is modify and add another case of our own,

436
00:24:27,840 --> 00:24:31,840
case call pipe, return our new operator, the binary pipe call.

437
00:24:31,840 --> 00:24:36,800
And now the compiler knows that whenever it sees such a call pipe AST node,

438
00:24:38,480 --> 00:24:42,440
it has to write a binary pipe call instruction.

439
00:24:42,440 --> 00:24:44,960
There's one final thing that we have to do here,

440
00:24:44,960 --> 00:24:48,160
which takes care of the stack effect.

441
00:24:48,160 --> 00:24:50,520
I'm going to show you the value stack in a minute.

442
00:24:50,520 --> 00:24:55,560
But we have to specify that our operation pops one value out of the value stack.

443
00:24:55,560 --> 00:25:00,040
So after performing our operation, there's one value less on the value stack,

444
00:25:00,040 --> 00:25:02,400
which is the same as a lot of other binary operations.

445
00:25:02,400 --> 00:25:04,600
So that's why I've added it here.

446
00:25:04,600 --> 00:25:08,240
And this is just something to make the compiler work as well.

447
00:25:08,240 --> 00:25:12,760
So after we've done this, the compiler can now turn the AST

448
00:25:12,760 --> 00:25:16,040
into that intermediate bytecode language.

449
00:25:16,040 --> 00:25:19,560
And now we get to the magical part, the evaluation loop.

450
00:25:19,560 --> 00:25:23,480
And the evaluation loop really is the main loop of Python.

451
00:25:23,480 --> 00:25:25,120
And it's an enormous loop, and

452
00:25:25,120 --> 00:25:29,120
inside of it is an enormous switch case statement.

453
00:25:29,120 --> 00:25:31,840
And it has a case for most of the, or

454
00:25:31,840 --> 00:25:34,520
all of the opcodes that it needs to be able to perform.

455
00:25:34,520 --> 00:25:37,840
And then it has to code that will actually handle that instruction,

456
00:25:37,840 --> 00:25:40,160
that will actually perform that operation.

457
00:25:41,520 --> 00:25:45,680
And just to show you one, I've picked the case for

458
00:25:45,680 --> 00:25:48,480
the binary subtract operation code.

459
00:25:48,480 --> 00:25:51,760
And this is just a case within that huge loop that we have.

460
00:25:53,280 --> 00:25:58,120
And this will perform for us the something minus another thing.

461
00:25:59,160 --> 00:26:03,360
So when you subtract two things, you actually need to know the things.

462
00:26:03,400 --> 00:26:07,920
I just cannot do thing minus thing without knowing what the thing is.

463
00:26:07,920 --> 00:26:11,560
So first, within this case, we need to get the value for

464
00:26:11,560 --> 00:26:14,840
the right hand side and the value for the left hand side.

465
00:26:14,840 --> 00:26:16,840
And that is what happens here.

466
00:26:16,840 --> 00:26:18,480
But where are those values coming from?

467
00:26:19,520 --> 00:26:25,240
As I told you earlier, whenever we have a binary operation,

468
00:26:25,240 --> 00:26:29,840
Python will first write the instructions to evaluate the left hand side

469
00:26:29,840 --> 00:26:31,080
of that operator.

470
00:26:31,080 --> 00:26:34,400
It will evaluate it and it will finally get a value.

471
00:26:34,400 --> 00:26:37,760
And it will put it on the stack so it can keep track of it.

472
00:26:37,760 --> 00:26:41,120
So this four will be evaluated, it will be on the stack.

473
00:26:41,120 --> 00:26:44,560
Then it will evaluate the three on the right hand side,

474
00:26:44,560 --> 00:26:46,280
it will put it on the stack as well.

475
00:26:46,280 --> 00:26:47,360
And just to be sure,

476
00:26:47,360 --> 00:26:49,840
there can be a lot of other values on the stack as well below that.

477
00:26:50,920 --> 00:26:55,360
And once we've evaluated the left hand side and the right hand side,

478
00:26:55,360 --> 00:26:58,320
we now have a three on top, the right hand side, and

479
00:26:58,320 --> 00:27:00,760
a four below that, the left hand side.

480
00:27:00,760 --> 00:27:04,160
So this is our value stack when we're evaluating the two operands,

481
00:27:04,160 --> 00:27:06,640
the left hand side and the right hand side.

482
00:27:06,640 --> 00:27:09,720
So when we get to here, for the right hand side,

483
00:27:09,720 --> 00:27:13,400
we can simply pop the value off of the value stack and

484
00:27:13,400 --> 00:27:17,200
then write points to that right hand side value.

485
00:27:17,200 --> 00:27:20,680
For the left hand side, we're going to do something similar, but

486
00:27:20,680 --> 00:27:23,320
we're going to peak at the top of the value stack,

487
00:27:23,320 --> 00:27:25,440
which is what the top macro does.

488
00:27:25,440 --> 00:27:29,880
And now left points to the four on the value stack.

489
00:27:29,880 --> 00:27:33,480
So now we have right pointing to three, left pointing to four.

490
00:27:33,480 --> 00:27:36,160
Then we can call a function within the C API,

491
00:27:36,160 --> 00:27:41,360
pine number subtract, pass in the two values, and then we get a result back.

492
00:27:41,360 --> 00:27:47,280
And we will make res point to the result of that pine number subtract.

493
00:27:47,280 --> 00:27:49,920
Now we're done with the left hand side and the right hand side, so

494
00:27:49,920 --> 00:27:51,320
we decrease the reference count.

495
00:27:52,520 --> 00:27:56,240
But we still only have the result within this function.

496
00:27:56,240 --> 00:27:57,560
So what do we need to do?

497
00:27:57,560 --> 00:28:00,120
We have to put it back on the value stack.

498
00:28:00,120 --> 00:28:04,720
But instead of putting it as an additional value on the value stack,

499
00:28:04,720 --> 00:28:09,040
we're going to use set top, which replaces the four that we already have.

500
00:28:09,040 --> 00:28:13,520
So this one will move over and it will replace the four that we have.

501
00:28:13,520 --> 00:28:17,720
This also explains the minus one with the stack effect that we saw earlier,

502
00:28:17,720 --> 00:28:20,000
because we started with a three and a four, and

503
00:28:20,000 --> 00:28:23,000
we end up with one value less on the stack.

504
00:28:23,000 --> 00:28:26,760
Then there's some error handling, and then finally we have dispatch,

505
00:28:26,760 --> 00:28:31,560
which tells the evaluation loop to continue to the next instruction.

506
00:28:31,560 --> 00:28:33,280
So this is binary subtract.

507
00:28:33,280 --> 00:28:37,960
Let's copy and paste this one and changes for our new operator.

508
00:28:37,960 --> 00:28:40,440
We have to change the target, binary pipe call.

509
00:28:42,120 --> 00:28:44,760
Obviously we don't want to subtract numbers, but

510
00:28:44,760 --> 00:28:50,080
there's a very convenient new function within the C API starting from Python 3.9,

511
00:28:50,080 --> 00:28:52,280
by object call one arc.

512
00:28:52,280 --> 00:28:55,640
And we can pass in the function and the value, and

513
00:28:55,640 --> 00:28:57,760
remember the function was on the right hand side and

514
00:28:57,760 --> 00:29:00,240
the value on the left hand side of the operator.

515
00:29:00,240 --> 00:29:03,640
Then we get the result, we set it back on the value stack, and

516
00:29:03,640 --> 00:29:05,280
now our operator works.

517
00:29:06,480 --> 00:29:10,800
And we can actually show that, but because the only thing that we now need to do

518
00:29:10,800 --> 00:29:15,600
to get all the way to the magic, we can now, wait, I forgot about this slide.

519
00:29:15,600 --> 00:29:19,480
So now we've completed the entire journey from source code to magic.

520
00:29:19,480 --> 00:29:23,560
The only thing left to do is compiling our new version of Python.

521
00:29:23,560 --> 00:29:24,920
There are a few commands for that.

522
00:29:24,920 --> 00:29:27,160
I'm using two cores to compile it.

523
00:29:27,160 --> 00:29:31,400
But the important message is, I can now define a function,

524
00:29:31,400 --> 00:29:34,240
use the new operator, and actually get values out of it.

525
00:29:35,760 --> 00:29:40,880
So recap and remarks, a lot of Python internals do check out the resources,

526
00:29:40,880 --> 00:29:43,200
so you can have a deep dive into them.

527
00:29:43,200 --> 00:29:46,320
The source code in the slides are available, and if you get weird errors

528
00:29:46,320 --> 00:29:51,280
while working on CPython, try running make clean or clean all on Windows,

529
00:29:51,280 --> 00:29:53,000
just to get rid of all the intermediate and

530
00:29:53,000 --> 00:29:57,120
compiled files that might give you issues, and look into the magic number.

531
00:29:57,120 --> 00:30:01,320
That versions the byte code, because we've changed the byte code, so

532
00:30:01,320 --> 00:30:08,120
all the old pre-compiled PyC files need to be recompiled.

533
00:30:08,120 --> 00:30:08,920
And that's it.

534
00:30:08,920 --> 00:30:11,440
Before we go, EuroPython, check it out.

535
00:30:11,440 --> 00:30:15,040
And Dublin this year, go there either in person or online.

536
00:30:15,040 --> 00:30:16,960
Check it out, really cool conference.

537
00:30:16,960 --> 00:30:17,720
And that was it.

538
00:30:19,120 --> 00:30:19,840
Thank you very much.

539
00:30:20,400 --> 00:30:26,620
Oh,

540
00:30:26,620 --> 00:30:30,400
yeah.

