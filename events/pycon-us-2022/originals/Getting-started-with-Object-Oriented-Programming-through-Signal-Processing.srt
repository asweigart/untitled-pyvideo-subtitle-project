1
00:00:00,000 --> 00:00:08,600
Okay. Thanks for coming and being here.

2
00:00:08,600 --> 00:00:12,020
Okay. It's a story about getting started with OOP,

3
00:00:12,020 --> 00:00:16,000
with signal processing which is a typical different domain.

4
00:00:16,000 --> 00:00:18,620
My name is Francesco Bruni, came from Italy.

5
00:00:18,620 --> 00:00:22,680
This is my first time at PyCon US and first time in America as well.

6
00:00:22,680 --> 00:00:25,220
It's such a big honor that you stayed and choose

7
00:00:25,220 --> 00:00:28,100
this tutorial among all other maybe

8
00:00:28,100 --> 00:00:30,700
much more interesting tutorial that much.

9
00:00:31,260 --> 00:00:34,340
Just a few words about this crash course,

10
00:00:34,340 --> 00:00:35,420
a few words about me.

11
00:00:35,420 --> 00:00:38,220
I'm a Senior Software Engineer in a company that is called

12
00:00:38,220 --> 00:00:41,100
Planetegitalia in the southern part of Italy.

13
00:00:41,100 --> 00:00:42,940
We play with Earth observation.

14
00:00:42,940 --> 00:00:46,780
So we play with extracting data from satellite imagery,

15
00:00:46,780 --> 00:00:50,020
running algorithms capable of running on top of

16
00:00:50,020 --> 00:00:53,220
micro satellites just to look at the Earth.

17
00:00:53,220 --> 00:00:56,140
I'm playing with Python for 15 years.

18
00:00:56,140 --> 00:01:01,540
I'm still repeating myself as intermediate level,

19
00:01:01,540 --> 00:01:05,060
not really expert and I'm not single-tech fanatic.

20
00:01:05,060 --> 00:01:08,180
I typically use multiple technology in my daily routine,

21
00:01:08,180 --> 00:01:10,820
so I'm pretty comfortable working for example with Java.

22
00:01:10,820 --> 00:01:13,580
I'm going to see some difference between Python and Java,

23
00:01:13,580 --> 00:01:15,740
for example, just to make clear

24
00:01:15,740 --> 00:01:18,940
that I'm not that fanatic about the technology.

25
00:01:18,940 --> 00:01:21,580
I typically use the technology to solve a particular issue.

26
00:01:21,580 --> 00:01:25,660
Okay. Just a few words about my town.

27
00:01:25,660 --> 00:01:29,180
Town in Italy are very different from town in America, I notice.

28
00:01:29,180 --> 00:01:31,380
I always looked in the films but in

29
00:01:31,380 --> 00:01:33,820
the reality is much more different.

30
00:01:33,820 --> 00:01:38,220
Barri is located in the southern part of Italy around the sea.

31
00:01:38,220 --> 00:01:40,780
It's pretty known for seeing astronomical.

32
00:01:40,780 --> 00:01:44,980
But my personal point about this is the metropolitan area.

33
00:01:44,980 --> 00:01:47,580
Barri is really interesting if you,

34
00:01:47,580 --> 00:01:50,900
let's say, have some curiosity about the aerospace sector.

35
00:01:50,900 --> 00:01:53,300
In fact, there are multiple companies that play with

36
00:01:53,300 --> 00:01:56,260
this stuff like designing and implementing

37
00:01:56,260 --> 00:01:58,700
electronic for running satellite as

38
00:01:58,700 --> 00:02:00,860
well as software that runs on top of a satellite.

39
00:02:00,860 --> 00:02:06,580
So this place in the southern part of Italy is very active in this sector.

40
00:02:08,380 --> 00:02:12,100
Before beginning, my personal opinion

41
00:02:12,100 --> 00:02:15,460
on why we still need to talk about object-oriented programming.

42
00:02:15,460 --> 00:02:18,700
Object-oriented programming is very old topic.

43
00:02:18,700 --> 00:02:21,540
Okay. So everyone is talking and talked a lot

44
00:02:21,820 --> 00:02:24,060
about object-oriented programming.

45
00:02:24,060 --> 00:02:26,780
My question is, why we still need to talk about

46
00:02:26,780 --> 00:02:29,900
object-oriented programming in the era of artificial intelligence,

47
00:02:29,900 --> 00:02:32,780
Web3, Blockchain, deep learning, whatever.

48
00:02:32,780 --> 00:02:34,700
Just put any buzzword you want.

49
00:02:34,700 --> 00:02:38,060
The main issue is that if you understand the guidelines,

50
00:02:38,060 --> 00:02:40,460
the main principle of object-oriented programming,

51
00:02:40,460 --> 00:02:44,660
which is somehow narrowed to a little small domain,

52
00:02:44,660 --> 00:02:46,420
which deals with computer,

53
00:02:46,420 --> 00:02:49,580
you can try to translate this concept,

54
00:02:49,580 --> 00:02:52,980
this idea to something that is much more challenging,

55
00:02:52,980 --> 00:02:54,940
like for example, software architecture.

56
00:02:54,940 --> 00:02:59,620
So if you find yourself in a way to design systems,

57
00:02:59,620 --> 00:03:02,460
to design for example, microservices architecture,

58
00:03:02,460 --> 00:03:06,060
you can find that much more of the principle that we're going to see during

59
00:03:06,060 --> 00:03:10,780
this crash course can be translated to the microservice architecture as well.

60
00:03:10,780 --> 00:03:14,220
We're going to see samples in a while.

61
00:03:14,940 --> 00:03:17,260
From my point of view,

62
00:03:17,260 --> 00:03:21,820
I always and I say always played with,

63
00:03:21,820 --> 00:03:26,700
learned and played with object-oriented programming through two different things,

64
00:03:26,700 --> 00:03:28,620
animals and outer rooms.

65
00:03:28,620 --> 00:03:34,020
I was very tired of trying to explain and trying to study all these really important stuff

66
00:03:34,020 --> 00:03:38,940
with such boring topic like outer rooms or mammals, humans.

67
00:03:38,940 --> 00:03:40,940
So I asked myself,

68
00:03:40,940 --> 00:03:42,620
what exactly can be,

69
00:03:43,100 --> 00:03:47,900
sort of crash course that tried to explain object-oriented programming and gets you

70
00:03:47,900 --> 00:03:52,100
to get acquainted with some domain that you probably don't know,

71
00:03:52,100 --> 00:03:54,460
but it is somehow overwhelming all of us,

72
00:03:54,460 --> 00:03:57,820
which is signal processing like this one.

73
00:03:57,820 --> 00:04:01,460
By the way, I turned a computer sciences.

74
00:04:01,460 --> 00:04:05,740
I got a master's degree in telecommunication engineering,

75
00:04:05,740 --> 00:04:08,700
so I pretty really changed to this topic,

76
00:04:08,700 --> 00:04:11,220
which I really loves a lot.

77
00:04:11,220 --> 00:04:14,940
The signals are basically analog and digital.

78
00:04:14,940 --> 00:04:17,620
We play with digital obviously because we play with computer,

79
00:04:17,620 --> 00:04:22,660
even if we are going to tell a few stories about the amplitude modulation,

80
00:04:22,660 --> 00:04:26,860
which is applied to analog signal during this crash course.

81
00:04:26,860 --> 00:04:29,180
But this is our topic.

82
00:04:29,500 --> 00:04:32,820
So a few words about this crash course.

83
00:04:32,820 --> 00:04:37,220
You are not expected to know anything about signal processing, obviously,

84
00:04:37,220 --> 00:04:39,900
because this course is much more about,

85
00:04:39,900 --> 00:04:41,940
let's say, object-oriented programming,

86
00:04:41,940 --> 00:04:44,140
but the domain is signal processing.

87
00:04:44,140 --> 00:04:47,060
So I cannot assume obviously that you know something about,

88
00:04:47,060 --> 00:04:48,780
but if you know, that's good.

89
00:04:48,780 --> 00:04:52,820
We're going to just scratch the surface of signal processing.

90
00:04:52,820 --> 00:04:54,620
So we are not going deeper.

91
00:04:54,620 --> 00:04:56,180
There would be a live coding.

92
00:04:56,180 --> 00:04:57,540
For this, I asked them,

93
00:04:57,540 --> 00:05:02,980
and I thank you, to put a table over here because I need to code with you.

94
00:05:02,980 --> 00:05:05,300
You can just copy what you write,

95
00:05:05,300 --> 00:05:06,860
understand, make question,

96
00:05:06,860 --> 00:05:09,700
or you can just download all the code from my website.

97
00:05:09,700 --> 00:05:11,540
So that's totally up to you.

98
00:05:11,540 --> 00:05:15,740
We'll be for different exercise break at the end.

99
00:05:15,740 --> 00:05:20,540
If you feel lazy, you can just look at the solution I uploaded on the website.

100
00:05:20,540 --> 00:05:22,660
You know that Python is required.

101
00:05:22,660 --> 00:05:24,140
We are Python conference.

102
00:05:24,140 --> 00:05:26,540
But if you want to, let's say,

103
00:05:26,540 --> 00:05:28,980
a more in-depth experience with signal and wave,

104
00:05:28,980 --> 00:05:30,980
not with object, with signals and waves,

105
00:05:30,980 --> 00:05:35,900
I strongly suggest you to use Jupiter because you probably are going to listen,

106
00:05:35,900 --> 00:05:38,300
visualize signals as well.

107
00:05:38,420 --> 00:05:41,140
Obviously, all the complexity has been

108
00:05:41,140 --> 00:05:45,300
trapped in the node.utils in the classes module

109
00:05:45,300 --> 00:05:48,820
because you are not required to know anything about signal processing.

110
00:05:48,820 --> 00:05:51,620
So I just take with some implemented function,

111
00:05:51,620 --> 00:05:55,740
all the things that you actually need to play with this code.

112
00:05:55,740 --> 00:06:03,540
Okay. The only piece of theory about signal processing that you need is just this concept.

113
00:06:03,540 --> 00:06:06,620
The difference between signal and wave.

114
00:06:06,620 --> 00:06:11,140
A signal is nothing else than a mathematical formulation of something.

115
00:06:11,140 --> 00:06:13,820
When you play, for example, a note of a piano like a C,

116
00:06:13,820 --> 00:06:17,220
open C, what you have is that you basically can

117
00:06:17,220 --> 00:06:20,220
constrain that sound to that formula.

118
00:06:20,220 --> 00:06:24,180
Where the T, the independent variable is the time,

119
00:06:24,180 --> 00:06:26,580
DA is the amplitude,

120
00:06:26,580 --> 00:06:33,500
which in turn is related to the power of the signal and then to the volume.

121
00:06:33,500 --> 00:06:37,340
So you can consider that scaling up down the value of the A,

122
00:06:37,340 --> 00:06:38,780
which is basically a constant,

123
00:06:38,780 --> 00:06:41,900
you can increase and down the volume of the note of the piano.

124
00:06:41,900 --> 00:06:44,740
So it's pretty easy to be understood what exactly is A.

125
00:06:44,740 --> 00:06:48,420
The F is the frequency of the signal or the wave.

126
00:06:48,420 --> 00:06:51,940
IRF means a more acute sound,

127
00:06:51,940 --> 00:06:55,660
while lower F means a more grave sound.

128
00:06:55,660 --> 00:06:58,140
The phi, which is the last time is the delay.

129
00:06:58,140 --> 00:07:00,340
So if you want that your sound starts,

130
00:07:00,340 --> 00:07:07,020
maybe phi by two radians,

131
00:07:07,020 --> 00:07:08,500
you just change the value.

132
00:07:08,500 --> 00:07:10,580
But in our example,

133
00:07:10,580 --> 00:07:14,100
we can consider that theta is capable of being zero.

134
00:07:14,100 --> 00:07:19,980
When you compute this formula for different distances of time,

135
00:07:19,980 --> 00:07:24,660
you get the diagram on your right, which is called the wave.

136
00:07:24,660 --> 00:07:28,180
So signal is just a nice way to,

137
00:07:28,220 --> 00:07:31,700
let's say, to express something mathematically.

138
00:07:31,700 --> 00:07:38,380
The wave on the right is what exactly your ear is capable to feeling.

139
00:07:38,380 --> 00:07:41,900
The main problem is that when you play, for example, with music,

140
00:07:41,900 --> 00:07:47,180
the signal formulation is impossible because the sound is not very easy.

141
00:07:47,180 --> 00:07:52,660
I forgot to mention that sin is a mathematical function,

142
00:07:52,660 --> 00:07:56,700
which is periodic, so it comes after a period from the beginning,

143
00:07:56,700 --> 00:07:58,580
again, again, again, again.

144
00:07:58,580 --> 00:08:01,740
For this reason, you got the wave on the right when you

145
00:08:01,740 --> 00:08:06,940
compute that formula for different instances of t.

146
00:08:08,540 --> 00:08:12,820
Sometimes, you could work,

147
00:08:12,820 --> 00:08:16,300
obviously, with signals of wave in different domain.

148
00:08:16,300 --> 00:08:18,420
We typically do the different domain.

149
00:08:18,420 --> 00:08:21,700
This domain can be called, for example, a frequency domain.

150
00:08:21,700 --> 00:08:26,940
So instead of visualizing the time and the power,

151
00:08:26,940 --> 00:08:31,180
sorry, the time and the value of that function in the previous slide,

152
00:08:31,180 --> 00:08:34,100
you can obviously perform some plot like this,

153
00:08:34,100 --> 00:08:36,140
where you plot on the x-axis,

154
00:08:36,140 --> 00:08:39,420
the frequency, and on the y-axis, you plot the power itself.

155
00:08:39,420 --> 00:08:44,020
This is very cool representation because this lets you to understand

156
00:08:44,020 --> 00:08:48,660
what exactly is going to happen in terms of frequency itself.

157
00:08:48,660 --> 00:08:50,420
If you play, for example,

158
00:08:50,420 --> 00:08:52,260
because I'm pretty sure that you play wave,

159
00:08:52,260 --> 00:08:53,740
you play an equalizer, for example,

160
00:08:53,740 --> 00:08:57,900
you increase the power of certain range of frequency,

161
00:08:57,900 --> 00:09:02,540
it's much simpler to understand the role and how the equalizer works

162
00:09:02,540 --> 00:09:06,100
if you look at the wave in the frequency domain, not in the time domain.

163
00:09:06,100 --> 00:09:09,780
By the way, you can switch from time domain as well

164
00:09:09,780 --> 00:09:13,620
in frequency domain just reaching from wave to spectrum.

165
00:09:13,620 --> 00:09:14,940
Then after the spectrum,

166
00:09:14,940 --> 00:09:17,660
you can apply some filtering in order to, I don't know,

167
00:09:17,660 --> 00:09:19,860
low-pass filtering to reduce all the voices from

168
00:09:19,860 --> 00:09:23,180
song, for example, and then get back to the wave itself,

169
00:09:23,180 --> 00:09:28,500
which is basically the main interface that you hear is going to fill.

170
00:09:28,500 --> 00:09:32,340
With this introduction, we read the code.

171
00:09:32,340 --> 00:09:39,660
Do you have a question about all this part? Perfect.

172
00:09:39,660 --> 00:09:52,420
Sorry. Can I wear off the mask?

173
00:09:52,420 --> 00:09:55,460
No. Can I remove the mask while talking?

174
00:09:55,460 --> 00:09:56,260
Oh, yeah.

175
00:09:56,260 --> 00:09:58,100
Okay. Thank you.

176
00:10:04,940 --> 00:10:07,820
So just forgot the first part for now.

177
00:10:07,940 --> 00:10:12,380
Okay. So our main issue is that we basically need to explain to

178
00:10:12,380 --> 00:10:15,980
a computer how exactly signal and wave should be treated.

179
00:10:15,980 --> 00:10:19,380
Okay. So we need to find a way to explain all these things,

180
00:10:19,380 --> 00:10:23,540
all the complexity of this word to the computer itself.

181
00:10:23,540 --> 00:10:28,220
And I think it's very common to use the concept of objects and

182
00:10:28,220 --> 00:10:31,020
the concept of class to express all the-

183
00:10:31,020 --> 00:10:36,020
Okay.

184
00:10:36,020 --> 00:10:38,620
That's good.

185
00:10:38,620 --> 00:10:40,100
Okay.

186
00:10:40,100 --> 00:10:44,060
So it's probably nice to introduce the concept of object and

187
00:10:44,060 --> 00:10:45,740
the concept of class.

188
00:10:45,740 --> 00:10:48,700
So we stick with the first definition.

189
00:10:48,700 --> 00:10:51,060
A class is a data type.

190
00:10:51,060 --> 00:10:54,660
So if you have, for example, an integer, a string, or a float,

191
00:10:54,660 --> 00:10:55,980
okay, they are all data types.

192
00:10:55,980 --> 00:10:58,540
A class itself is a data type.

193
00:10:58,860 --> 00:11:02,780
So we need to find some sort of way to define this data type and

194
00:11:02,780 --> 00:11:04,700
put all the logic inside.

195
00:11:04,700 --> 00:11:08,700
So in order to do this, what we can do is using the keyword class,

196
00:11:08,700 --> 00:11:12,540
define, for example, the class itself, like the signal.

197
00:11:12,540 --> 00:11:17,740
Okay. The main two points of a class are basically two different things,

198
00:11:17,740 --> 00:11:19,260
attributes and methods.

199
00:11:19,260 --> 00:11:23,540
Attributes are the intrinsic characteristics of that object,

200
00:11:23,540 --> 00:11:24,420
of that class.

201
00:11:24,420 --> 00:11:26,220
So for example, if you think about a human,

202
00:11:26,260 --> 00:11:28,020
human eyes, two different eyes, but

203
00:11:28,020 --> 00:11:30,740
the color of the eyes is an intrinsic characteristic.

204
00:11:30,740 --> 00:11:34,500
So you can define obviously this attribute inside the definition of

205
00:11:34,500 --> 00:11:35,740
the class.

206
00:11:35,740 --> 00:11:37,500
And the other thing is the methods.

207
00:11:37,500 --> 00:11:41,140
So they are basically actions you can perform on that kind of class,

208
00:11:41,140 --> 00:11:42,420
on that kind of object.

209
00:11:42,420 --> 00:11:45,780
So if you are talking about signal wave, for example,

210
00:11:45,780 --> 00:11:49,060
an action that you perform on wave is listening to the wave or

211
00:11:49,060 --> 00:11:52,780
just looking at the plot domain of the wave in the time domain or

212
00:11:52,780 --> 00:11:54,340
the frequency domain.

213
00:11:54,340 --> 00:11:56,940
So the first thing that we are going to do, so

214
00:11:56,940 --> 00:11:58,380
is defining the attributes.

215
00:11:58,380 --> 00:12:01,220
We just saw that three main attributes are required to

216
00:12:02,900 --> 00:12:04,260
being defined in the signal.

217
00:12:04,260 --> 00:12:06,860
The first one is the amplitude, okay.

218
00:12:08,220 --> 00:12:09,860
Second one is the frequency.

219
00:12:11,900 --> 00:12:13,380
And the third one is the offset.

220
00:12:14,740 --> 00:12:18,780
Okay, for now, let's just forget about the periodic function that's in, okay?

221
00:12:18,780 --> 00:12:22,740
We try to talk a little maybe later.

222
00:12:22,740 --> 00:12:24,860
Okay, those are the attributes.

223
00:12:26,500 --> 00:12:31,340
The main point is that this kind of declaration is abstract, okay?

224
00:12:31,340 --> 00:12:32,380
It does not exist.

225
00:12:32,380 --> 00:12:35,860
You are just saying that the signal is composed by amplitude frequency offset,

226
00:12:35,860 --> 00:12:37,300
but it does not exist.

227
00:12:37,300 --> 00:12:40,820
Because you just say that, okay, man, this is composed by these three

228
00:12:40,820 --> 00:12:41,980
different fields.

229
00:12:41,980 --> 00:12:45,420
So what you need to do is creating an object.

230
00:12:45,420 --> 00:12:47,940
So an object is an instance of the class,

231
00:12:47,940 --> 00:12:51,180
while the class is just the declaration of a particular object.

232
00:12:51,180 --> 00:12:54,100
So consider an object like some sort of template,

233
00:12:54,100 --> 00:12:58,580
while the object is the existing concretization of the template.

234
00:13:00,180 --> 00:13:06,580
In order to, let's say, set up the initial value of the object itself,

235
00:13:06,580 --> 00:13:10,180
we need a special method, so a special action.

236
00:13:10,180 --> 00:13:12,660
An actual data pattern is called init.

237
00:13:12,660 --> 00:13:17,140
So we can define, for example, the init method, okay?

238
00:13:17,140 --> 00:13:21,180
And try to write the implementation of real.

239
00:13:21,180 --> 00:13:27,180
First of all, the solve, okay, is the instance itself.

240
00:13:27,180 --> 00:13:30,140
You will understand it in a while, but think about it.

241
00:13:30,140 --> 00:13:32,820
This is a method that works on instances.

242
00:13:32,820 --> 00:13:36,380
So this is a method that works on the concretization of the signal itself.

243
00:13:36,380 --> 00:13:40,740
So the first element should be the object itself,

244
00:13:40,740 --> 00:13:41,860
the implementation itself.

245
00:13:41,860 --> 00:13:47,500
Like any other method, you can obviously provide some parameters.

246
00:13:47,500 --> 00:13:50,140
And we are going to provide, for example, the amplitude,

247
00:13:50,140 --> 00:13:52,900
the frequency, and the offset.

248
00:13:54,060 --> 00:13:55,220
Okay, that's good.

249
00:13:55,220 --> 00:13:58,940
And our implementation will be pretty easy, because right now,

250
00:13:58,940 --> 00:14:03,580
what we need to do is set up attributes of the instance itself

251
00:14:03,580 --> 00:14:06,340
within this method to set up the amplitude,

252
00:14:06,340 --> 00:14:10,780
to set up the frequency,

253
00:14:16,780 --> 00:14:18,860
And set up the offset.

254
00:14:21,540 --> 00:14:27,220
Okay, so I just can remove this one, because it does no sense.

255
00:14:27,220 --> 00:14:30,380
You can obviously provide some default value, like for example,

256
00:14:30,380 --> 00:14:35,180
the offset is zero, or I don't know, maybe the amplitude is one.

257
00:14:35,180 --> 00:14:38,540
And once you define the template of your object, so

258
00:14:38,540 --> 00:14:42,420
that you define the class itself, we need to create it.

259
00:14:42,420 --> 00:14:46,340
So I can create it, just calling the class itself,

260
00:14:46,340 --> 00:14:52,940
signal, open up parentheses, set the up, for example, amplitude 1.0.

261
00:14:52,940 --> 00:14:54,180
Sorry, this is a float.

262
00:14:56,300 --> 00:15:00,540
Let's put, for example, the fault frequency, okay?

263
00:15:00,540 --> 00:15:07,340
600 and offset 0.

264
00:15:07,340 --> 00:15:09,740
Okay, so if we run this code,

265
00:15:09,740 --> 00:15:11,940
what I get is an instance of the signal itself.

266
00:15:14,900 --> 00:15:18,620
Obviously, you can avoid setting up all these parameters,

267
00:15:18,620 --> 00:15:21,220
because we provided some default value for this one.

268
00:15:21,220 --> 00:15:24,020
Or you can just pass, for example, only the amplitude,

269
00:15:24,020 --> 00:15:28,580
because you want, for example, a louder sound, and

270
00:15:28,580 --> 00:15:33,300
let the constructor set up the other fields, like frequency and offset.

271
00:15:33,300 --> 00:15:34,740
So it is basically the same.

272
00:15:34,740 --> 00:15:35,860
We still got the signal, but

273
00:15:35,860 --> 00:15:38,620
the signal is an object that is different from the first one.

274
00:15:40,620 --> 00:15:45,140
We just say that, okay, the attributes are the first part of the signal, so

275
00:15:45,140 --> 00:15:49,780
we need to identify this kind of object using attributes.

276
00:15:49,780 --> 00:15:54,900
But still, we need to define actions that we can perform over this,

277
00:15:54,900 --> 00:15:58,220
of the instance, once the instance has been created.

278
00:15:58,220 --> 00:16:02,020
So we can, for example, define a new function that is called print period.

279
00:16:02,020 --> 00:16:04,940
Period is just the inverse of the frequency.

280
00:16:04,940 --> 00:16:08,940
And for example, this one is just going to print, for example,

281
00:16:08,940 --> 00:16:17,060
at the period is delta f, okay, which is basically south dot frequency.

282
00:16:17,060 --> 00:16:17,560
Oops, sorry.

283
00:16:20,660 --> 00:16:21,160
Okay.

284
00:16:23,020 --> 00:16:25,900
That's okay.

285
00:16:25,900 --> 00:16:28,820
So we added an action over this class.

286
00:16:28,820 --> 00:16:31,180
So we try to call it to see if it works.

287
00:16:31,180 --> 00:16:35,860
So if I call, for example, the print period, okay.

288
00:16:35,860 --> 00:16:38,360
Oh, sorry.

289
00:16:38,360 --> 00:16:39,140
I just forgot this one.

290
00:16:42,780 --> 00:16:44,180
Okay.

291
00:16:44,180 --> 00:16:45,660
So for example, you get this one.

292
00:16:45,660 --> 00:16:47,340
So we added a period over here.

293
00:16:49,340 --> 00:16:50,260
Okay, that's good.

294
00:16:50,260 --> 00:16:51,260
You got any questions till now?

295
00:16:53,740 --> 00:16:54,460
Perfect.

296
00:16:54,460 --> 00:16:55,140
Way much simpler.

297
00:16:56,300 --> 00:17:02,420
Okay, we just saw the introduction that what we are going to use is not exactly

298
00:17:02,420 --> 00:17:06,140
the signal, it's actually the wave, okay, our concretization of the signal in a way

299
00:17:06,140 --> 00:17:08,300
that we can just listen it.

300
00:17:08,300 --> 00:17:12,660
Okay, so we define, for example, another method that is called create wave.

301
00:17:14,740 --> 00:17:18,020
Okay, first argument is obviously the instance itself.

302
00:17:19,140 --> 00:17:20,540
And we need to create wave here.

303
00:17:20,540 --> 00:17:24,980
In order to create the wave here, we need to set up few arguments to

304
00:17:24,980 --> 00:17:27,460
decreate wave, first of all, the duration, okay.

305
00:17:27,460 --> 00:17:31,460
Like for example, let's consider a duration by default by two seconds.

306
00:17:31,460 --> 00:17:36,260
And the other one is the frame rate, okay.

307
00:17:36,260 --> 00:17:41,700
That we could set up to, let me see, okay, 3000, okay.

308
00:17:43,700 --> 00:17:48,060
So for now, we just define a new function, okay, with some default value.

309
00:17:48,060 --> 00:17:49,700
Nothing complex, good.

310
00:17:51,140 --> 00:17:54,860
Obviously, you don't need to know and remember the formula that we just saw.

311
00:17:54,860 --> 00:18:01,380
So if you go from Alpers, import, create wave samples.

312
00:18:02,660 --> 00:18:04,300
Let me see, yeah, perfect.

313
00:18:04,300 --> 00:18:06,140
Create wave samples.

314
00:18:06,140 --> 00:18:09,820
You can get the wave representation of the signal.

315
00:18:09,820 --> 00:18:15,980
So if I go create wave samples over here, okay.

316
00:18:17,340 --> 00:18:21,740
You can get the duration is the first argument, okay.

317
00:18:21,740 --> 00:18:23,780
Frame rate, frame rate.

318
00:18:25,460 --> 00:18:30,420
Frequency is the south of frequency, okay.

319
00:18:30,420 --> 00:18:33,260
Amplitude is south of the amplitude.

320
00:18:34,700 --> 00:18:36,500
Phase is zero, that's okay.

321
00:18:36,500 --> 00:18:39,540
And the periodic function can be set, okay, that's good.

322
00:18:39,540 --> 00:18:45,500
So this function is going to return me something like the ts, yeah, ys,

323
00:18:45,500 --> 00:18:48,980
sorry, ys and ts, okay, that's fine.

324
00:18:48,980 --> 00:18:54,780
And I can obviously set up to new for fields, south.ts, okay.

325
00:18:57,100 --> 00:18:59,300
And return ys, okay.

326
00:18:59,300 --> 00:19:04,020
So what we did, we just call a function defining the Alpers module.

327
00:19:04,020 --> 00:19:07,180
The module that I made you download from the website and

328
00:19:07,180 --> 00:19:10,980
I sent you via the introduction markdown file.

329
00:19:10,980 --> 00:19:14,340
We call this method create wave sample that takes different kind of arguments.

330
00:19:14,340 --> 00:19:17,220
It's not very relevant right now to know what exactly they are.

331
00:19:17,220 --> 00:19:20,140
But if you're free, we can obviously talk later.

332
00:19:20,140 --> 00:19:21,860
This is going to return ys and ts.

333
00:19:21,860 --> 00:19:25,660
Ys and ts are basically the y value and

334
00:19:25,660 --> 00:19:28,100
the x value of the wave representation of the signal.

335
00:19:28,100 --> 00:19:32,500
So if you go back, for example, the implementation, this one,

336
00:19:32,500 --> 00:19:38,140
the ys is the value of the amplitude itself, while the ts is the time.

337
00:19:38,140 --> 00:19:43,940
So ts stands for time instances, while ys is the value on top of the y axis.

338
00:19:44,940 --> 00:19:51,660
And we can obviously add a new kind of attribute, which is ys.

339
00:19:51,660 --> 00:19:56,860
So I decided to, once I get the ys array, which is basically an array of points,

340
00:19:56,860 --> 00:19:59,820
I try to set up as a new attribute, okay, that's ys.

341
00:19:59,820 --> 00:20:01,260
And the same for ts.

342
00:20:01,260 --> 00:20:05,620
So if I go over here, for example, and I call instead of printing period,

343
00:20:05,620 --> 00:20:06,820
I call the create wave.

344
00:20:09,340 --> 00:20:12,180
Okay, what you have is this one.

345
00:20:12,180 --> 00:20:14,980
Obviously, you got this one, this is an array,

346
00:20:14,980 --> 00:20:20,300
because basically I'm returning the ys.

347
00:20:20,300 --> 00:20:26,620
So for example, if I define another method that is called plot, okay,

348
00:20:26,620 --> 00:20:28,860
first argument is always the self.

349
00:20:28,860 --> 00:20:35,940
This is going to return plot, sorry, return plot,

350
00:20:36,020 --> 00:20:40,820
self ys from 0 to 100,

351
00:20:40,820 --> 00:20:45,300
self dot ts from 0 to 100, sorry.

352
00:20:48,580 --> 00:20:50,940
First argument is the yx, okay, it's the x.

353
00:20:53,020 --> 00:20:55,860
This one, and I can import plot from here.

354
00:20:55,860 --> 00:20:59,380
So if I write again, yeah?

355
00:20:59,380 --> 00:20:59,880
Okay.

356
00:20:59,880 --> 00:21:05,700
So the create wave function is not important problem, so what do we need to import?

357
00:21:05,700 --> 00:21:10,300
No, create wave function is defined by me, so it cannot be imported.

358
00:21:11,940 --> 00:21:14,140
Yeah, that was created by me.

359
00:21:14,140 --> 00:21:16,660
What is important is the create wave samples function.

360
00:21:16,660 --> 00:21:17,580
This is important.

361
00:21:17,580 --> 00:21:18,940
That's important?

362
00:21:18,940 --> 00:21:20,620
Yeah, from Alpers.

363
00:21:20,620 --> 00:21:23,700
So Alpers is-

364
00:21:23,700 --> 00:21:25,900
Because you probably are missing the Alpers module.

365
00:21:25,900 --> 00:21:29,340
Yeah, let me see.

366
00:21:31,660 --> 00:21:33,260
The one that you download from the website.

367
00:21:35,260 --> 00:21:36,380
Let's go, let me see.

368
00:21:40,380 --> 00:21:43,020
So I cannot find that one, because I'm missing Alpers.

369
00:21:46,300 --> 00:21:48,900
Because, but did you upload the Alpers file?

370
00:21:48,900 --> 00:21:50,620
That's all, that's the issue.

371
00:21:50,620 --> 00:21:54,300
Okay, before using, I just remember for all of you,

372
00:21:54,300 --> 00:21:57,140
before using all this file and the library that I provided to you,

373
00:21:57,140 --> 00:22:00,060
you need to upload them first in the Jupyter.

374
00:22:00,060 --> 00:22:04,860
And then, lots in Jupyter using the percent lots instruction,

375
00:22:04,860 --> 00:22:08,380
like I point out in the description, and then you import it, okay?

376
00:22:08,380 --> 00:22:12,700
If you're not following all these things, you can use the upper file.

377
00:22:12,700 --> 00:22:15,020
Everyone has the same issue, I'm going to repeat it.

378
00:22:16,460 --> 00:22:18,100
Okay, so everyone is working in scope?

379
00:22:18,100 --> 00:22:20,060
I didn't get the mail until you played.

380
00:22:20,060 --> 00:22:22,540
I think it's been long since I played before.

381
00:22:22,540 --> 00:22:24,580
But did you sign up?

382
00:22:24,580 --> 00:22:26,300
Yes. It's very strange.

383
00:22:26,300 --> 00:22:29,380
By the way, go to, open up your browser.

384
00:22:38,820 --> 00:22:39,340
This one.

385
00:22:39,340 --> 00:22:48,340
This one.

386
00:22:48,340 --> 00:22:50,940
Just download the Alpers file from here, okay?

387
00:22:50,940 --> 00:22:53,620
You upload, then I new load, okay.

388
00:22:53,620 --> 00:22:56,700
Okay, I try to rephrase again, just to be sure that everyone is on track.

389
00:22:58,940 --> 00:23:02,900
What you need to do is when you go over here, you click for example on the,

390
00:23:02,900 --> 00:23:06,900
this is a call up Google, okay, but it's basically the same if you are running

391
00:23:06,900 --> 00:23:08,940
a local instance of the Jupyter.

392
00:23:08,940 --> 00:23:12,140
You need to click on the upload.

393
00:23:12,140 --> 00:23:15,180
You need to select the file, like the Alpers or the classes.

394
00:23:15,180 --> 00:23:18,340
That's another file that I provided to you in the website, but

395
00:23:18,340 --> 00:23:22,060
not in the getting started introduction and material that I sent.

396
00:23:22,060 --> 00:23:27,340
And when you do this, you can just write something like,

397
00:23:27,340 --> 00:23:33,460
load Alpers, okay, and then run the import.

398
00:23:33,460 --> 00:23:37,420
And when you do this way, basically the Python module located system path of

399
00:23:37,420 --> 00:23:40,660
Python has been updated to include also this module and then the function.

400
00:23:43,180 --> 00:23:46,300
Okay, so we were playing with this one.

401
00:23:46,300 --> 00:23:50,900
Okay, so once we create the wave, we can call obviously the plot function, okay?

402
00:23:50,900 --> 00:23:52,380
And the plot function, sorry.

403
00:23:55,540 --> 00:23:57,040
Let me see, sorry.

404
00:24:07,420 --> 00:24:17,420
Okay,

405
00:24:17,420 --> 00:24:32,820
here you find the plot representation of our wave samples.

406
00:24:32,820 --> 00:24:36,460
So what we did so far is basically defined the signal,

407
00:24:36,460 --> 00:24:38,500
defined functions, defined attributes.

408
00:24:38,500 --> 00:24:42,860
What exactly are the attributes that are going to identify almost uniquely

409
00:24:42,860 --> 00:24:46,220
our concretization of the signal, okay?

410
00:24:46,220 --> 00:24:49,420
Then we add two different methods, okay, create wave and

411
00:24:49,420 --> 00:24:51,660
maybe the plot in order to create wave samples.

412
00:24:51,660 --> 00:24:54,860
Thus creating the array of values in terms of time,

413
00:24:54,860 --> 00:24:57,700
in terms of amplitude for the waves and then plot them.

414
00:24:59,260 --> 00:25:03,100
Let's try to update the print period function in order to print something else.

415
00:25:03,460 --> 00:25:07,980
Like for example, let's print the YS size, okay?

416
00:25:14,980 --> 00:25:18,940
It's good, sub.YS, okay?

417
00:25:21,700 --> 00:25:25,100
Okay, so if I'm going to plot the print period.

418
00:25:30,500 --> 00:25:31,500
Okay, that's one.

419
00:25:32,500 --> 00:25:36,620
So I just updated the print period function in order to print

420
00:25:36,620 --> 00:25:38,780
the size of the array, the YS.

421
00:25:38,780 --> 00:25:41,140
The size of the array is 6,000, that's good.

422
00:25:42,300 --> 00:25:45,020
But with this kind of implementation, there is a problem.

423
00:25:45,020 --> 00:25:50,100
And the main problem is that the print period function won't work

424
00:25:50,100 --> 00:25:53,420
if I not created the wave first.

425
00:25:53,420 --> 00:25:59,660
So if I try to, for example, maybe, yeah, command this one, try again.

426
00:25:59,660 --> 00:26:02,740
It's saying that signal object has not YS.

427
00:26:02,740 --> 00:26:04,380
That's totally normal.

428
00:26:04,380 --> 00:26:08,700
Because we basically have committed some errors.

429
00:26:08,700 --> 00:26:14,460
Mixing up the concept of wave with signals is helping to the same class.

430
00:26:14,460 --> 00:26:16,380
And make the methods, the pants, and

431
00:26:16,380 --> 00:26:19,980
work on two different kind of pieces of the domain.

432
00:26:19,980 --> 00:26:25,780
The signal from one side and the wave from the other side.

433
00:26:25,780 --> 00:26:28,460
So this is maybe the issue.

434
00:26:30,020 --> 00:26:34,220
Okay, this first part completes the get-start introduction to

435
00:26:34,220 --> 00:26:36,020
object-oriented programming.

436
00:26:36,020 --> 00:26:41,140
Now, what you basically can do is picking up the,

437
00:26:41,140 --> 00:26:45,100
if you want, obviously, picking up the exercises, okay?

438
00:26:45,100 --> 00:26:50,580
Like this one, okay, which is the file I loaded into my website,

439
00:26:50,580 --> 00:26:52,820
users.com, okay, download it.

440
00:26:52,820 --> 00:26:55,140
And you try to solve, for example, the exercise one.

441
00:26:55,140 --> 00:26:58,580
If you feel lazy, absolutely, do not worry about it.

442
00:26:58,580 --> 00:27:02,100
Because they probably have the solution file that you can find on the website

443
00:27:02,100 --> 00:27:03,580
that show you the solution.

444
00:27:03,580 --> 00:27:08,780
Let's just see the problem you're trying to solve.

445
00:27:08,780 --> 00:27:14,460
Obviously, we forgot to add the periodic function to the definition of our signal.

446
00:27:14,460 --> 00:27:15,540
Yeah?

447
00:27:15,540 --> 00:27:19,900
Yeah, always the same website, exercise PDF file.

448
00:27:22,540 --> 00:27:23,300
Exercise PDF.

449
00:27:25,180 --> 00:27:25,700
Ah, sorry.

450
00:27:25,700 --> 00:27:30,380
Yes, that was the beginning, sorry.

451
00:27:30,380 --> 00:27:31,780
Okay, let me see.

452
00:27:33,100 --> 00:27:34,460
Website is this one.

453
00:27:36,260 --> 00:27:36,820
Website is this one.

454
00:27:44,620 --> 00:27:45,780
Mm-hm.

455
00:27:45,780 --> 00:27:48,340
This is website.

456
00:27:48,340 --> 00:27:52,740
I just scrolled onto the conference page.

457
00:27:52,820 --> 00:27:56,700
I just, okay, I make them notice at the beginning of this talk.

458
00:27:56,700 --> 00:28:00,540
You go under the conference page, okay, just go up and go up and up.

459
00:28:00,540 --> 00:28:03,340
Up and up and up and up and up and up and up and up and up and up.

460
00:28:03,340 --> 00:28:04,380
There's one, click on this one.

461
00:28:05,580 --> 00:28:06,580
Yeah, click on this one.

462
00:28:08,020 --> 00:28:10,020
Yes, exactly.

463
00:28:10,020 --> 00:28:13,300
And these solve the material you basically are going to need to go through

464
00:28:13,300 --> 00:28:14,940
this course, okay?

465
00:28:14,940 --> 00:28:16,860
Yes, that was my fault, okay?

466
00:28:16,860 --> 00:28:18,300
I just said at the beginning of this talk.

467
00:28:18,300 --> 00:28:23,740
So once you download the exercise PDF, you basically are going to

468
00:28:24,820 --> 00:28:28,340
see four different kind of exercise, one for each module.

469
00:28:28,340 --> 00:28:32,300
Okay, we are going to use four different modules to explain these things about

470
00:28:32,300 --> 00:28:37,940
object-oriented programming, and the first exercise would be about,

471
00:28:37,940 --> 00:28:38,620
just one moment.

472
00:28:41,780 --> 00:28:45,660
Okay, would be about changing the definition of our signal,

473
00:28:45,660 --> 00:28:49,340
because if you remember well, we forgot to add another piece of the signal,

474
00:28:49,340 --> 00:28:51,740
which was the periodic function, okay?

475
00:28:51,740 --> 00:28:57,860
So you need to try a way to add the params to the constructor itself in order

476
00:28:57,860 --> 00:29:02,500
to update our signal definition to include this new thing.

477
00:29:02,500 --> 00:29:07,980
And we saw that we mixed up signal and waves together.

478
00:29:07,980 --> 00:29:10,340
We saw the issue of the print period function.

479
00:29:10,340 --> 00:29:15,140
So what you need to do is trying to apply the same logic to the final wave class,

480
00:29:15,140 --> 00:29:16,220
okay?

481
00:29:16,220 --> 00:29:20,380
They should be basically two different things, YS and TS.

482
00:29:20,380 --> 00:29:26,860
The time instances and the amplitude values.

483
00:29:26,860 --> 00:29:27,620
Those are the least.

484
00:29:27,620 --> 00:29:29,940
Do not consider the non-py and the array.

485
00:29:29,940 --> 00:29:32,060
Just consider them least, okay?

486
00:29:32,060 --> 00:29:36,940
And you obviously need to refactor print stats method in order to overcome the issue.

487
00:29:38,620 --> 00:29:42,940
Once you're done, you can download the other file,

488
00:29:42,980 --> 00:29:45,620
which you can find on the website, classes,

489
00:29:45,620 --> 00:29:50,180
which contain the implementation of the new version of the signal.

490
00:29:50,180 --> 00:29:53,020
And so we are going to use that kind of definition to go to the rest of

491
00:29:53,020 --> 00:29:55,100
the course itself, okay?

492
00:29:55,100 --> 00:29:59,540
In general, on the classes file, you can find other definition of classes that we

493
00:29:59,540 --> 00:30:01,900
are going to use throughout the whole course.

494
00:30:01,900 --> 00:30:04,900
So there's no need to write again and again and again.

495
00:30:04,900 --> 00:30:05,860
That's all.

496
00:30:05,860 --> 00:30:09,420
You got 15 minutes.

497
00:30:09,420 --> 00:30:12,540
By the way, I'm here, so if you want any question, you ask me.

498
00:30:12,940 --> 00:30:17,740
Yeah, let me put the mask on.

499
00:30:17,740 --> 00:30:18,260
Okay.

500
00:30:18,260 --> 00:30:25,140
Orgain helpers.

501
00:30:25,140 --> 00:30:28,020
Because there's no need to open up this file.

502
00:30:28,020 --> 00:30:28,540
Okay, look.

503
00:30:30,860 --> 00:30:31,360
Okay.

504
00:30:33,540 --> 00:30:36,940
Okay, let me see what this one is useless.

505
00:30:37,940 --> 00:30:43,380
Okay, so what you need to do is load helpers like this way.

506
00:30:45,060 --> 00:30:45,560
Okay.

507
00:30:46,740 --> 00:30:48,700
Okay, perfect.

508
00:30:48,700 --> 00:30:54,340
So, Okay, because you need to install map.lib and

509
00:30:54,340 --> 00:30:55,780
map.py, okay?

510
00:30:55,780 --> 00:30:56,380
Go here, type in.

511
00:30:56,380 --> 00:30:57,300
No, no, no problem.

512
00:30:57,300 --> 00:30:59,860
You can start just here over here.

513
00:30:59,860 --> 00:31:00,620
Just like this.

514
00:31:00,620 --> 00:31:05,900
Sorry, your keyboard is different than mine.

515
00:31:05,900 --> 00:31:09,340
Pip, install.

516
00:31:09,340 --> 00:31:12,380
I'm using pip3.

517
00:31:12,380 --> 00:31:14,220
I'm writing keys the same.

518
00:31:14,220 --> 00:31:16,260
Math plot lib, no, py.

519
00:31:16,260 --> 00:31:18,340
Oops.

520
00:31:20,740 --> 00:31:23,220
Okay, okay, it's installing.

521
00:31:24,620 --> 00:31:26,540
Okay, now you execute this one.

522
00:31:30,620 --> 00:31:35,060
New model, map plot lib.

523
00:31:35,060 --> 00:31:38,380
So the helpers.py file is looking in the same directory as this.

524
00:31:38,380 --> 00:31:41,660
But this is very odd.

525
00:31:43,660 --> 00:31:45,220
Because we just installed map plot lib here.

526
00:31:51,940 --> 00:31:53,460
No, not the name, map plot lib.

527
00:32:00,620 --> 00:32:15,860
I don't know exactly what is happening because we actually.

528
00:32:15,860 --> 00:32:18,060
I'd rather not use a Jupyter Notebook and

529
00:32:18,060 --> 00:32:23,260
just do regular import on the Python file.

530
00:32:23,260 --> 00:32:23,860
I think that should work.

531
00:32:25,740 --> 00:32:28,980
But did you do something that I'm missing now?

532
00:32:30,620 --> 00:32:34,940
This is fine.

533
00:32:34,940 --> 00:32:36,060
The file appers is here.

534
00:32:37,780 --> 00:32:39,500
So it seems correct to me.

535
00:32:39,500 --> 00:32:44,820
But you have this strange issue, but no model name map plot lib.

536
00:32:44,820 --> 00:32:46,820
Give me one sec.

537
00:32:53,340 --> 00:32:56,180
But you're not using the virtual environment?

538
00:32:56,180 --> 00:32:57,220
No.

539
00:32:57,220 --> 00:32:58,540
This probably be the issue.

540
00:32:58,540 --> 00:32:59,500
It's a global install.

541
00:33:00,700 --> 00:33:03,420
I can create a virtual environment and run it there locally.

542
00:33:04,460 --> 00:33:07,500
But I haven't had a local on the global installation.

543
00:33:09,340 --> 00:33:10,300
I don't know.

544
00:33:10,300 --> 00:33:11,180
Here, I'll get it.

545
00:33:11,180 --> 00:33:12,660
Can you use the Google Colab?

546
00:33:12,660 --> 00:33:14,140
Can we try using our Google Colab?

547
00:33:14,140 --> 00:33:16,260
The what?

548
00:33:16,260 --> 00:33:17,340
Google Calendar?

549
00:33:17,340 --> 00:33:18,940
No, Colab, this one.

550
00:33:19,940 --> 00:33:22,260
This one is a very nice way to use Jupyter Notebook.

551
00:33:22,260 --> 00:33:23,660
We've done installing all the files, okay?

552
00:33:24,980 --> 00:33:26,220
You got a Gmail account?

553
00:33:26,220 --> 00:33:26,720
Yeah.

554
00:33:26,720 --> 00:33:27,220
Okay.

555
00:33:27,220 --> 00:33:29,900
Okay, we try this way.

556
00:33:30,620 --> 00:33:31,120
Okay.

557
00:33:45,180 --> 00:33:48,140
That's probably someone related to the environment.

558
00:33:48,140 --> 00:33:48,660
I don't know.

559
00:34:00,620 --> 00:34:05,380
Okay, that's fine.

560
00:34:05,380 --> 00:34:09,020
New Notebook?

561
00:34:09,020 --> 00:34:12,100
Okay, it's basically the same, huh?

562
00:34:12,100 --> 00:34:12,620
Yeah.

563
00:34:12,620 --> 00:34:13,620
You will.

564
00:34:13,620 --> 00:34:29,140
You might typically use this one, because this one lets me do not install all the files

565
00:34:29,140 --> 00:34:30,140
that I basically need.

566
00:34:30,140 --> 00:34:31,740
So you go over here.

567
00:34:31,740 --> 00:34:33,780
You disconnect it.

568
00:34:33,780 --> 00:34:34,780
One moment.

569
00:34:35,900 --> 00:34:37,900
Once connected, you upload the file here.

570
00:34:37,900 --> 00:34:38,900
Okay.

571
00:34:38,900 --> 00:34:43,740
So where do you have the helpers?

572
00:34:43,740 --> 00:34:45,220
Helpers, this one.

573
00:34:45,220 --> 00:34:46,060
Open up.

574
00:34:46,060 --> 00:34:46,900
Okay.

575
00:34:46,900 --> 00:34:48,420
Yeah.

576
00:34:48,420 --> 00:34:50,620
Okay, we install again.

577
00:34:50,620 --> 00:34:53,620
We install matplotlnp.

578
00:34:56,860 --> 00:34:58,540
Okay.

579
00:34:58,580 --> 00:34:59,580
Matplotlnp.

580
00:34:59,580 --> 00:35:00,580
Okay.

581
00:35:00,580 --> 00:35:01,580
From helpers.

582
00:35:01,580 --> 00:35:02,580
Import all.

583
00:35:02,580 --> 00:35:03,580
Sorry.

584
00:35:03,580 --> 00:35:04,580
Right.

585
00:35:04,580 --> 00:35:05,580
Create with samples.

586
00:35:05,580 --> 00:35:06,580
Just to be sure that it's good.

587
00:35:06,580 --> 00:35:07,580
Yeah.

588
00:35:07,580 --> 00:35:08,580
That's it.

589
00:35:08,580 --> 00:35:09,580
It suggests you.

590
00:35:09,580 --> 00:35:10,580
Just put enter.

591
00:35:10,580 --> 00:35:11,580
Okay.

592
00:35:11,580 --> 00:35:12,580
Which one is the shortcut to run?

593
00:35:12,580 --> 00:35:13,580
Shift, enter.

594
00:35:13,580 --> 00:35:14,580
Shift, enter.

595
00:35:14,580 --> 00:35:15,580
Okay.

596
00:35:15,580 --> 00:35:16,580
That's perfect.

597
00:35:16,580 --> 00:35:17,580
Okay.

598
00:35:17,580 --> 00:35:18,580
Now copy and paste the code.

599
00:35:18,580 --> 00:35:19,580
You just use this because you can see the code.

600
00:35:19,580 --> 00:35:20,580
You can see the code.

601
00:35:20,580 --> 00:35:21,580
You can see the code.

602
00:35:21,580 --> 00:35:22,580
You can see the code.

603
00:35:22,580 --> 00:35:23,580
You can see the code.

604
00:35:23,580 --> 00:35:24,580
You can see the code.

605
00:35:24,580 --> 00:35:25,580
You can see the code.

606
00:35:25,580 --> 00:35:26,580
You can see the code.

607
00:35:26,580 --> 00:35:27,580
You can see the code.

608
00:35:27,620 --> 00:35:31,940
You just use this because you probably messed up something with the global installation.

609
00:35:31,940 --> 00:35:36,020
This is a very, my personal point, do not take it as an offense.

610
00:35:36,020 --> 00:35:39,580
It's very bad practice to not use Python Virtual Lamp.

611
00:35:39,580 --> 00:35:40,580
Okay.

612
00:35:40,580 --> 00:35:43,660
Because otherwise you're going to mess up all the things in the EU system.

613
00:35:43,660 --> 00:35:47,220
So if you want to play Python locally, use the Virtual Lamp.

614
00:35:47,220 --> 00:35:50,220
You got issues?

615
00:35:50,860 --> 00:35:58,540
No, I didn't understand what you were asking us to do.

616
00:35:58,540 --> 00:35:59,540
As exercise.

617
00:35:59,540 --> 00:36:02,220
Do you want me to rephrase the exercise?

618
00:36:02,220 --> 00:36:07,220
No, no, if you want a problem.

619
00:36:07,220 --> 00:36:10,220
Open up the exercise.

620
00:36:10,220 --> 00:36:12,100
Okay.

621
00:36:12,100 --> 00:36:17,500
So when we define the signal, the signal class, okay, we forgot to add the periodic function

622
00:36:17,500 --> 00:36:18,500
attribute.

623
00:36:18,500 --> 00:36:19,500
Okay.

624
00:36:19,500 --> 00:36:21,820
The periodic function is a very important piece of the signal definition because it

625
00:36:21,820 --> 00:36:24,620
defines how the signal, the wave form.

626
00:36:24,620 --> 00:36:25,620
Okay.

627
00:36:25,620 --> 00:36:29,660
So you need to change the implementation of the signal with class in order to want this

628
00:36:29,660 --> 00:36:37,020
periodic function as well as adding and defining a new class for mapping the wave.

629
00:36:37,020 --> 00:36:40,820
Because in this case, look, you will just look at the solution because in this wave

630
00:36:40,820 --> 00:36:46,580
decreed with samples, the decreed with metadata encoded, okay, was returning the array, was

631
00:36:46,740 --> 00:36:48,460
returning the list of values.

632
00:36:48,460 --> 00:36:52,660
But you need to return an object, an instance of the wave class that you need to define.

633
00:36:52,660 --> 00:36:53,660
That's exercise.

634
00:36:53,660 --> 00:36:54,660
Is that clear?

635
00:36:54,660 --> 00:36:55,660
Yeah.

636
00:36:55,660 --> 00:36:56,660
Exactly.

637
00:36:56,660 --> 00:36:57,660
Exactly.

638
00:36:57,660 --> 00:37:04,660
You just need to define a new wave class.

639
00:37:16,580 --> 00:37:23,580
Now, this is useless for you.

640
00:37:24,700 --> 00:37:27,260
You just need to define.

641
00:37:27,260 --> 00:37:33,180
You just need to define a new wave class as we did for signals.

642
00:37:33,180 --> 00:37:40,180
But instead of containing attributes for signals, you should contain attributes for waves.

643
00:37:46,780 --> 00:37:53,780
Yeah, because I'm trying to stick with the mandatory broke.

644
00:37:53,780 --> 00:37:54,780
Okay.

645
00:37:54,780 --> 00:37:55,780
Sure.

646
00:37:55,780 --> 00:37:58,780
You got a question for me?

647
00:37:58,780 --> 00:38:03,780
Yeah, because you didn't upload maybe.

648
00:38:03,780 --> 00:38:04,780
Over here.

649
00:38:04,780 --> 00:38:05,780
No, no, no.

650
00:38:05,780 --> 00:38:06,780
Don't care about this.

651
00:38:06,780 --> 00:38:07,780
Let me close this one.

652
00:38:07,780 --> 00:38:08,780
Close.

653
00:38:08,780 --> 00:38:09,780
Okay.

654
00:38:09,980 --> 00:38:14,980
Go over here.

655
00:38:14,980 --> 00:38:19,980
And for this one.

656
00:38:19,980 --> 00:38:20,980
Ah, okay.

657
00:38:20,980 --> 00:38:21,980
This one.

658
00:38:21,980 --> 00:38:28,980
So once you did this, so you just need to load out this one.

659
00:38:28,980 --> 00:38:33,980
Load out this dot.

660
00:38:33,980 --> 00:38:36,980
Okay.

661
00:38:37,180 --> 00:38:40,180
Okay, that's good.

662
00:38:40,180 --> 00:38:41,180
You know why?

663
00:38:41,180 --> 00:38:44,180
Because you are in the wrong directory.

664
00:38:44,180 --> 00:38:47,180
Yeah, I couldn't find it.

665
00:38:47,180 --> 00:38:48,180
Let me see.

666
00:38:48,180 --> 00:38:49,180
You're here.

667
00:38:49,180 --> 00:38:50,180
You're in the content.

668
00:38:50,180 --> 00:38:52,180
You're over here, no?

669
00:38:52,180 --> 00:38:59,180
So we can move out first dot PI on the...

670
00:38:59,180 --> 00:39:00,180
Oh, sorry.

671
00:39:00,180 --> 00:39:05,180
We have this different content.

672
00:39:05,180 --> 00:39:06,180
Okay.

673
00:39:06,380 --> 00:39:09,380
Oh, sorry.

674
00:39:09,380 --> 00:39:12,380
What's like show?

675
00:39:12,380 --> 00:39:15,380
This one.

676
00:39:15,380 --> 00:39:18,380
There you go.

677
00:39:18,380 --> 00:39:19,380
Lot.

678
00:39:19,380 --> 00:39:20,380
Oof.

679
00:39:20,380 --> 00:39:21,380
Albers.

680
00:39:21,380 --> 00:39:22,380
Yeah.

681
00:39:22,380 --> 00:39:23,380
Did you find it?

682
00:39:23,380 --> 00:39:24,380
Okay.

683
00:39:24,380 --> 00:39:25,380
That's fine.

684
00:39:25,380 --> 00:39:32,380
Remember to work always in the content and on the in the...

685
00:39:32,380 --> 00:39:33,380
So move.

686
00:39:33,380 --> 00:39:34,380
Just move.

687
00:39:34,380 --> 00:39:35,380
Okay.

688
00:39:35,580 --> 00:39:36,580
So move.

689
00:39:36,580 --> 00:39:37,580
Just move.

690
00:39:37,580 --> 00:39:38,580
Do the same with classes.

691
00:39:38,580 --> 00:39:41,580
Or you can upload directly into the content in the root for...

692
00:39:41,580 --> 00:39:42,580
In the root partition.

693
00:39:42,580 --> 00:39:43,580
Okay.

694
00:39:50,580 --> 00:39:53,580
You got issues?

695
00:39:53,580 --> 00:39:54,580
Perfect.

696
00:39:54,580 --> 00:39:57,580
You solve the exercise?

697
00:39:57,580 --> 00:39:58,580
You're trying to.

698
00:39:58,580 --> 00:39:59,580
Okay.

699
00:39:59,580 --> 00:40:00,580
Absolutely.

700
00:40:00,580 --> 00:40:02,580
That's fine.

701
00:40:02,580 --> 00:40:04,580
But at least write, huh?

702
00:40:04,780 --> 00:40:05,780
Okay.

703
00:40:08,780 --> 00:40:11,780
Please don't use this as the simplest part ever of the crash course.

704
00:40:22,780 --> 00:40:23,780
Yeah.

705
00:40:23,780 --> 00:40:24,780
Exactly.

706
00:40:24,780 --> 00:40:25,780
Exactly.

707
00:40:25,780 --> 00:40:26,780
Yeah.

708
00:40:27,780 --> 00:40:30,780
You probably missed the introduction part where it's...

709
00:40:30,780 --> 00:40:31,780
Okay, okay, okay.

710
00:40:31,780 --> 00:40:32,780
That's clear now.

711
00:40:32,980 --> 00:40:39,280
So you can just download the introduction already from the website in order to get understood

712
00:40:39,280 --> 00:40:41,780
what exactly a signal is and a way it is.

713
00:40:41,780 --> 00:40:42,780
Okay.

714
00:40:42,780 --> 00:40:43,780
Sorry.

715
00:40:43,780 --> 00:40:44,780
I didn't understand.

716
00:40:44,780 --> 00:40:45,780
Exactly.

717
00:40:45,780 --> 00:40:46,780
Excellent.

718
00:40:46,780 --> 00:41:08,180
Oh, printstats is the method that is capable of printing the period of a function as well

719
00:41:08,180 --> 00:41:09,180
as the size.

720
00:41:09,180 --> 00:41:10,180
No, no.

721
00:41:10,180 --> 00:41:13,500
It's a printstats because it's not printing just the period.

722
00:41:13,500 --> 00:41:18,020
It's printing different things like I show in the tutorial because it's printing the

723
00:41:18,020 --> 00:41:20,500
size of the array as well as the period.

724
00:41:20,500 --> 00:41:25,100
So you need to refine it because basically the size of the array belongs to the wave

725
00:41:25,100 --> 00:41:26,100
class on the signal.

726
00:41:26,100 --> 00:41:27,100
Yes.

727
00:41:27,100 --> 00:41:28,100
Okay.

728
00:41:28,100 --> 00:41:29,100
Okay.

729
00:41:29,100 --> 00:41:30,100
Okay.

730
00:41:30,100 --> 00:41:31,100
Yeah.

731
00:41:31,100 --> 00:41:32,100
Yeah.

732
00:41:32,100 --> 00:41:33,100
Yeah.

733
00:41:33,100 --> 00:41:34,100
Yeah.

734
00:41:34,100 --> 00:41:35,100
Yeah.

735
00:41:35,100 --> 00:41:36,100
Okay.

736
00:41:36,100 --> 00:41:37,100
Okay.

737
00:41:37,100 --> 00:41:38,100
Yeah.

738
00:41:38,100 --> 00:41:39,100
Yeah.

739
00:41:39,100 --> 00:41:40,100
Yeah.

740
00:41:40,100 --> 00:41:41,100
Yeah.

741
00:41:41,100 --> 00:41:42,100
Okay.

742
00:41:42,100 --> 00:41:43,100
Yeah.

743
00:41:43,100 --> 00:41:44,100
Sorry.

744
00:41:44,100 --> 00:41:45,100
That's correct.

745
00:41:45,100 --> 00:42:03,300
So as your friend here is noticing, I did not implement the print period function in my

746
00:42:03,300 --> 00:42:04,780
implementation of the signal.

747
00:42:04,780 --> 00:42:09,020
I implemented a method that is called a plain stats which is much more generic.

748
00:42:09,020 --> 00:42:14,180
So you need to adapt that method and call it print period or you can choose the implementation

749
00:42:14,180 --> 00:42:15,180
of the printstats.

750
00:42:15,180 --> 00:42:16,180
It's basically the same.

751
00:42:46,180 --> 00:42:48,180
Yeah.

752
00:42:48,180 --> 00:42:50,180
Mm-hmm.

753
00:42:50,180 --> 00:42:55,380
But did you receive the instruction when registering to the form?

754
00:42:55,380 --> 00:42:56,380
I did.

755
00:42:56,380 --> 00:42:57,380
I did.

756
00:42:57,380 --> 00:42:58,380
Let's go here.

757
00:42:58,380 --> 00:42:59,380
There we go.

758
00:42:59,380 --> 00:43:00,380
You showed the material getting started, this instruction.

759
00:43:00,380 --> 00:43:05,380
I did all of that, but it didn't contain any more than the help of PY and this.

760
00:43:05,380 --> 00:43:06,380
Mm-hmm.

761
00:43:06,380 --> 00:43:07,380
Mm-hmm.

762
00:43:07,380 --> 00:43:08,380
Mm-hmm.

763
00:43:08,540 --> 00:43:09,540
And this.

764
00:43:09,540 --> 00:43:10,540
Okay.

765
00:43:10,540 --> 00:43:11,540
That's perfect.

766
00:43:11,540 --> 00:43:12,540
That's all I got.

767
00:43:12,540 --> 00:43:13,540
Okay.

768
00:43:13,540 --> 00:43:14,540
That's perfect because you, okay, this is the implementation.

769
00:43:14,540 --> 00:43:15,540
So you all sat.

770
00:43:15,540 --> 00:43:16,540
You all sat.

771
00:43:16,540 --> 00:43:17,540
You just need to call the, try to solve the exercise.

772
00:43:17,540 --> 00:43:18,540
You all sat.

773
00:43:18,540 --> 00:43:19,540
Everything is working.

774
00:43:19,540 --> 00:43:20,540
So what's your issue?

775
00:43:20,540 --> 00:43:21,540
Yes.

776
00:43:21,540 --> 00:43:22,540
I didn't have any of that information.

777
00:43:22,540 --> 00:43:23,540
I didn't have any of this information.

778
00:43:23,540 --> 00:43:24,540
Okay.

779
00:43:24,540 --> 00:43:25,540
So what's your issue?

780
00:43:25,540 --> 00:43:26,540
We did some testing.

781
00:43:26,540 --> 00:43:27,540
So you're not sure that you've got something?

782
00:43:27,540 --> 00:43:28,540
Yeah.

783
00:43:28,540 --> 00:43:29,540
Okay.

784
00:43:29,540 --> 00:43:30,540
So if you have a question, just let me know.

785
00:43:30,540 --> 00:43:31,540
I'm going to take another question.

786
00:43:31,540 --> 00:43:33,540
So what's your issue?

787
00:43:33,540 --> 00:43:35,540
Yes, I didn't have any of that information.

788
00:43:35,540 --> 00:43:37,540
I didn't have any of this information.

789
00:43:54,540 --> 00:43:56,540
About what?

790
00:43:56,540 --> 00:43:58,540
Wave.

791
00:43:58,540 --> 00:44:01,540
Yes, you maybe did not load the wave.

792
00:44:01,540 --> 00:44:03,540
Did you load the wave module?

793
00:44:03,540 --> 00:44:05,540
No, still missing.

794
00:44:05,540 --> 00:44:07,540
By the way, you do the same.

795
00:44:07,540 --> 00:44:11,540
You upload the classes file here, load it, and import that.

796
00:44:11,540 --> 00:44:13,540
The wave?

797
00:44:13,540 --> 00:44:15,540
No, classes.

798
00:44:15,540 --> 00:44:17,540
Yeah, exactly.

799
00:44:17,540 --> 00:44:19,540
Exactly.

800
00:44:19,540 --> 00:44:21,540
Like this one.

801
00:44:25,540 --> 00:44:27,540
Mm-hmm.

802
00:44:27,540 --> 00:44:29,540
Okay.

803
00:44:29,540 --> 00:44:31,540
Yeah.

804
00:44:31,540 --> 00:44:33,540
I don't know why it's throwing an error,

805
00:44:33,540 --> 00:44:35,540
self not defined, but it's correct.

806
00:44:35,540 --> 00:44:37,540
Self, well, frequency is a parameter for this.

807
00:44:37,540 --> 00:44:39,540
Yeah.

808
00:44:39,540 --> 00:44:41,540
This is maybe an indent problem.

809
00:44:41,540 --> 00:44:43,540
Indent problem?

810
00:44:43,540 --> 00:44:45,540
Yeah, maybe.

811
00:44:45,540 --> 00:44:47,540
Okay.

812
00:44:47,540 --> 00:44:49,540
So, yeah, I don't know.

813
00:44:49,540 --> 00:44:51,540
I don't know.

814
00:44:51,540 --> 00:44:53,540
I don't know.

815
00:44:53,540 --> 00:44:55,540
Is it an indent problem?

816
00:44:55,540 --> 00:44:57,540
Yeah, maybe.

817
00:44:57,540 --> 00:44:59,540
I know, you miss out.

818
00:44:59,540 --> 00:45:01,540
The first argument of a function is self.

819
00:45:01,540 --> 00:45:03,540
So for this reason, it's saying that you miss out.

820
00:45:03,540 --> 00:45:05,540
That's all.

821
00:45:05,540 --> 00:45:07,540
Okay.

822
00:45:07,540 --> 00:45:09,540
Time's up.

823
00:45:23,540 --> 00:45:25,540
Okay.

824
00:45:25,540 --> 00:45:27,540
Okay.

825
00:45:27,540 --> 00:45:29,540
This is what you find on the solution PIFI.

826
00:45:29,540 --> 00:45:31,540
Okay.

827
00:45:31,540 --> 00:45:33,540
It's just an example of solution.

828
00:45:33,540 --> 00:45:35,540
Okay.

829
00:45:35,540 --> 00:45:37,540
Do not consider that there are no other solution ever.

830
00:45:37,540 --> 00:45:39,540
You basically have to split the wave from signal.

831
00:45:39,540 --> 00:45:41,540
Then define a class that is called, for example,

832
00:45:41,540 --> 00:45:43,540
a wave that takes three different parameters,

833
00:45:43,540 --> 00:45:45,540
YSTS and frame rate.

834
00:45:45,540 --> 00:45:47,540
Frame rate is not mandatory because we just set up

835
00:45:47,540 --> 00:45:49,540
in fixed wave.

836
00:45:49,540 --> 00:45:51,540
So you have to set up a frame rate.

837
00:45:51,540 --> 00:45:53,540
You just set up in fixed wave.

838
00:45:53,540 --> 00:45:55,540
So what you really need to do

839
00:45:55,540 --> 00:45:57,540
is YSTS.

840
00:45:57,540 --> 00:45:59,540
Then define again, for example, a method for playing.

841
00:45:59,540 --> 00:46:01,540
Okay, I'm playing the sound itself.

842
00:46:01,540 --> 00:46:03,540
That's called...

843
00:46:03,540 --> 00:46:05,540
It's going to call another function

844
00:46:05,540 --> 00:46:07,540
to find the outburst module, like the create audio.

845
00:46:07,540 --> 00:46:09,540
The method plot.

846
00:46:09,540 --> 00:46:11,540
Because you're plotting the wave.

847
00:46:11,540 --> 00:46:13,540
You are not plotting the signal.

848
00:46:13,540 --> 00:46:15,540
So it's maybe much more better to put the plot method

849
00:46:15,540 --> 00:46:17,540
not in the signal, but in the wave.

850
00:46:17,540 --> 00:46:19,540
And then the implementation

851
00:46:19,540 --> 00:46:21,540
of the signal itself is pretty similar

852
00:46:21,540 --> 00:46:23,540
aside from adding these other parameters,

853
00:46:23,540 --> 00:46:25,540
which is the function,

854
00:46:25,540 --> 00:46:27,540
which is the periodic function.

855
00:46:27,540 --> 00:46:29,540
Everything is basically the same.

856
00:46:33,540 --> 00:46:35,540
Let me see, let me see, let me see.

857
00:46:35,540 --> 00:46:37,540
Okay, so the create wave samples...

858
00:46:37,540 --> 00:46:39,540
Sorry, the create wave method,

859
00:46:39,540 --> 00:46:41,540
instead of returning directly the array,

860
00:46:41,540 --> 00:46:43,540
it returns an instance of the wave

861
00:46:43,540 --> 00:46:45,540
where the wave is classed

862
00:46:45,540 --> 00:46:47,540
that you should have declared first.

863
00:46:47,540 --> 00:46:49,540
Is the solution clear?

864
00:46:53,540 --> 00:46:55,540
I'll take it as a yes.

865
00:46:55,540 --> 00:46:57,540
Okay, good.

866
00:47:01,540 --> 00:47:03,540
Good.

867
00:47:09,540 --> 00:47:11,540
So let's get back.

868
00:47:17,540 --> 00:47:19,540
Okay, instead of using your own implementation

869
00:47:19,540 --> 00:47:21,540
of the wave and the signals,

870
00:47:21,540 --> 00:47:23,540
you can just load the classes module,

871
00:47:23,540 --> 00:47:25,540
okay, that you already uploaded

872
00:47:25,540 --> 00:47:27,540
to the Jupyter Notebook.

873
00:47:27,540 --> 00:47:29,540
Okay, and you can obviously import

874
00:47:29,540 --> 00:47:31,540
from classes import signal and wave.

875
00:47:31,540 --> 00:47:33,540
And you can use my implementation

876
00:47:33,540 --> 00:47:35,540
of the object itself.

877
00:47:35,540 --> 00:47:37,540
Okay.

878
00:47:37,540 --> 00:47:39,540
The main point

879
00:47:39,540 --> 00:47:41,540
that I want to talk about

880
00:47:41,540 --> 00:47:43,540
is the way to create a wave.

881
00:47:43,540 --> 00:47:45,540
So, let's say,

882
00:47:45,540 --> 00:47:47,540
the main point here

883
00:47:47,540 --> 00:47:49,540
is, okay,

884
00:47:49,540 --> 00:47:51,540
you needed to change

885
00:47:51,540 --> 00:47:53,540
the implementation

886
00:47:53,540 --> 00:47:55,540
of the single class in order to add

887
00:47:55,540 --> 00:47:57,540
another parameter to the constructor.

888
00:47:57,540 --> 00:47:59,540
But this is not correct.

889
00:47:59,540 --> 00:48:01,540
Suppose that code comes from your colleague

890
00:48:01,540 --> 00:48:03,540
or comes from some legacy framework.

891
00:48:03,540 --> 00:48:05,540
You can change that code itself in order to add

892
00:48:05,540 --> 00:48:07,540
another attribute that someone

893
00:48:07,540 --> 00:48:09,540
just misled or

894
00:48:09,540 --> 00:48:11,540
you're not happy with or probably

895
00:48:11,540 --> 00:48:13,540
you just forgot.

896
00:48:13,540 --> 00:48:15,540
We need to find another way to, let's say,

897
00:48:15,540 --> 00:48:17,540
augmenting the power

898
00:48:17,540 --> 00:48:19,540
of the definition, the declaration

899
00:48:19,540 --> 00:48:21,540
of the object itself.

900
00:48:21,540 --> 00:48:23,540
And for this reason, object-oriented programming

901
00:48:23,540 --> 00:48:25,540
has really an elegant way for solving

902
00:48:25,540 --> 00:48:27,540
this kind of issue, which is called

903
00:48:27,540 --> 00:48:29,540
inheritance.

904
00:48:29,540 --> 00:48:31,540
Inheritance means basically

905
00:48:31,540 --> 00:48:33,540
let's start from a base class, okay,

906
00:48:33,540 --> 00:48:35,540
let's drive a new class that

907
00:48:35,540 --> 00:48:37,540
inherits everything from

908
00:48:37,540 --> 00:48:39,540
the base class, okay, as well as

909
00:48:39,540 --> 00:48:41,540
attributes method as well.

910
00:48:41,540 --> 00:48:43,540
And we need to customize

911
00:48:43,540 --> 00:48:45,540
in terms of, for example,

912
00:48:45,540 --> 00:48:47,540
adding other attributes

913
00:48:47,540 --> 00:48:49,540
or other methods to this

914
00:48:49,540 --> 00:48:51,540
new derived class. So if you are

915
00:48:51,540 --> 00:48:53,540
not happy with the implementation of the

916
00:48:53,540 --> 00:48:55,540
signal, because I just forgot to add the periodic

917
00:48:55,540 --> 00:48:57,540
function, you can obviously change it.

918
00:48:57,540 --> 00:48:59,540
But this is wrong because this could be

919
00:48:59,540 --> 00:49:01,540
somehow related to some legacy framework

920
00:49:01,540 --> 00:49:03,540
or you can extend

921
00:49:03,540 --> 00:49:05,540
the signal base class in order to

922
00:49:05,540 --> 00:49:07,540
define a new version of the signal class.

923
00:49:07,540 --> 00:49:09,540
Let's do it this way.

924
00:49:09,540 --> 00:49:11,540
So let's consider, for example,

925
00:49:11,540 --> 00:49:13,540
the scene waveform,

926
00:49:13,540 --> 00:49:15,540
okay, so instead of considering

927
00:49:15,540 --> 00:49:17,540
the scene waveform, let's consider the scene

928
00:49:17,540 --> 00:49:19,540
waveform. So I define, for example,

929
00:49:19,540 --> 00:49:21,540
a new class here that is called

930
00:49:21,540 --> 00:49:23,540
scene-based.

931
00:49:23,540 --> 00:49:25,540
Now, just let me

932
00:49:25,540 --> 00:49:27,540
see.

933
00:49:27,540 --> 00:49:29,540
Yeah.

934
00:49:29,540 --> 00:49:31,540
Scene-wave-4-based

935
00:49:31,540 --> 00:49:33,540
signal, okay,

936
00:49:33,540 --> 00:49:35,540
that inherits from

937
00:49:35,540 --> 00:49:37,540
signal, okay,

938
00:49:37,540 --> 00:49:39,540
and it defines a new

939
00:49:39,540 --> 00:49:41,540
attribute that is called, for example, a function,

940
00:49:41,540 --> 00:49:43,540
okay, which is

941
00:49:43,540 --> 00:49:45,540
the np-scene.

942
00:49:45,540 --> 00:49:47,540
Okay. What we did,

943
00:49:47,540 --> 00:49:49,540
we basically

944
00:49:49,540 --> 00:49:51,540
defined a new class that is called

945
00:49:51,540 --> 00:49:53,540
scene-wave-4-based signal,

946
00:49:53,540 --> 00:49:55,540
okay, that inherits

947
00:49:55,540 --> 00:49:57,540
from signal, so

948
00:49:57,540 --> 00:49:59,540
inherits everything from signal, attributes

949
00:49:59,540 --> 00:50:01,540
and methods, and define a new attribute

950
00:50:01,540 --> 00:50:03,540
that is called n-poison.

951
00:50:03,540 --> 00:50:05,540
In order to make this work, you need

952
00:50:05,540 --> 00:50:07,540
to import np, so import

953
00:50:07,540 --> 00:50:09,540
numpy as np.

954
00:50:11,540 --> 00:50:13,540
Okay, so you can obviously

955
00:50:13,540 --> 00:50:15,540
create an instance of the subject,

956
00:50:15,540 --> 00:50:17,540
okay, like this way,

957
00:50:17,540 --> 00:50:19,540
and now you got

958
00:50:19,540 --> 00:50:21,540
obviously the scene-for-

959
00:50:21,540 --> 00:50:23,540
waveform-based signal,

960
00:50:23,540 --> 00:50:25,540
and you can call, obviously, all the methods

961
00:50:25,540 --> 00:50:27,540
defined in signal, like,

962
00:50:27,540 --> 00:50:29,540
for example, the print-period

963
00:50:29,540 --> 00:50:31,540
method, print-period,

964
00:50:31,540 --> 00:50:33,540
okay.

965
00:50:33,540 --> 00:50:35,540
We didn't define the print-period

966
00:50:35,540 --> 00:50:37,540
inside this class, but since we

967
00:50:37,540 --> 00:50:39,540
are inheriting everything from signal,

968
00:50:39,540 --> 00:50:41,540
we still are going to use the

969
00:50:41,540 --> 00:50:43,540
print-period defined in the parent class,

970
00:50:43,540 --> 00:50:45,540
which is the, just prints

971
00:50:45,540 --> 00:50:47,540
the period, the inverse of the frequency,

972
00:50:47,540 --> 00:50:49,540
the frequency itself.

973
00:50:49,540 --> 00:50:51,540
This is very important behavior,

974
00:50:51,540 --> 00:50:53,540
because what you probably are

975
00:50:53,540 --> 00:50:55,540
going to do now is that you

976
00:50:55,540 --> 00:50:57,540
are delegating

977
00:50:57,540 --> 00:50:59,540
to somewhere else, to someone

978
00:50:59,540 --> 00:51:01,540
else, okay, the

979
00:51:01,540 --> 00:51:03,540
scope, the task of printing the period

980
00:51:03,540 --> 00:51:05,540
itself. In fact,

981
00:51:05,540 --> 00:51:07,540
what we can say is basically that

982
00:51:07,540 --> 00:51:09,540
when you inherit something from a

983
00:51:09,540 --> 00:51:11,540
base class, which is signal right now,

984
00:51:11,540 --> 00:51:13,540
you're delegating everything,

985
00:51:13,540 --> 00:51:15,540
every responsibility to that class,

986
00:51:15,540 --> 00:51:17,540
if not explicitly,

987
00:51:17,540 --> 00:51:19,540
obviously, defined

988
00:51:19,540 --> 00:51:21,540
inside the new definition

989
00:51:21,540 --> 00:51:23,540
of the class.

990
00:51:23,540 --> 00:51:25,540
The main problem

991
00:51:25,540 --> 00:51:27,540
with this implementation

992
00:51:27,540 --> 00:51:29,540
is that if you look at the create

993
00:51:29,540 --> 00:51:31,540
wave samples provided in my library,

994
00:51:31,540 --> 00:51:33,540
the periodic function

995
00:51:33,540 --> 00:51:35,540
is the NP-COS.

996
00:51:35,540 --> 00:51:37,540
COS and SIN are similar, but

997
00:51:37,540 --> 00:51:39,540
they are equal. COS and SIN are just

998
00:51:39,540 --> 00:51:41,540
offset based on 90 degrees.

999
00:51:41,540 --> 00:51:43,540
So we need to,

1000
00:51:43,540 --> 00:51:45,540
we are not very happy with

1001
00:51:45,540 --> 00:51:47,540
the default implementation of the create

1002
00:51:47,540 --> 00:51:49,540
wave samples provided by the common library,

1003
00:51:49,540 --> 00:51:51,540
and in general, we are not happy

1004
00:51:51,540 --> 00:51:53,540
with the create wave method

1005
00:51:53,540 --> 00:51:55,540
provided by the signal,

1006
00:51:55,540 --> 00:51:57,540
okay, because in the create wave

1007
00:51:57,540 --> 00:51:59,540
method, we didn't pass the

1008
00:51:59,540 --> 00:52:01,540
periodic function as well. We just used

1009
00:52:01,540 --> 00:52:03,540
the default one. So what we need to do

1010
00:52:03,540 --> 00:52:05,540
is overwrite the

1011
00:52:05,540 --> 00:52:07,540
method, define it again,

1012
00:52:07,540 --> 00:52:09,540
keeping equal

1013
00:52:09,540 --> 00:52:11,540
the same name,

1014
00:52:11,540 --> 00:52:13,540
because we don't want to break the code

1015
00:52:13,540 --> 00:52:15,540
because someone changed the name of the method

1016
00:52:15,540 --> 00:52:17,540
of the parent class. We still are going to use

1017
00:52:17,540 --> 00:52:19,540
the method of the parent class,

1018
00:52:19,540 --> 00:52:21,540
but we are going to use our personal

1019
00:52:21,540 --> 00:52:23,540
version of it. So we need to define

1020
00:52:23,540 --> 00:52:25,540
again the create wave method.

1021
00:52:25,540 --> 00:52:27,540
So if I go over here,

1022
00:52:27,540 --> 00:52:29,540
define create wave,

1023
00:52:29,540 --> 00:52:31,540
okay,

1024
00:52:31,540 --> 00:52:33,540
first argument is obviously

1025
00:52:33,540 --> 00:52:35,540
self, okay,

1026
00:52:35,540 --> 00:52:37,540
ys,

1027
00:52:37,540 --> 00:52:39,540
ds equals create

1028
00:52:39,540 --> 00:52:41,540
wave samples, okay,

1029
00:52:41,540 --> 00:52:43,540
and so the

1030
00:52:43,540 --> 00:52:45,540
signature obviously needs to

1031
00:52:45,540 --> 00:52:47,540
be the same of the previous one

1032
00:52:47,540 --> 00:52:49,540
and the, let me see, just one thing,

1033
00:52:51,540 --> 00:52:53,540
this one,

1034
00:52:53,540 --> 00:52:55,540
okay, this was our general implementation.

1035
00:52:55,540 --> 00:52:57,540
What we need to add obviously

1036
00:52:57,540 --> 00:52:59,540
is another parameter here, that is

1037
00:52:59,540 --> 00:53:01,540
the function as well, function.

1038
00:53:03,540 --> 00:53:05,540
Okay, so

1039
00:53:05,540 --> 00:53:07,540
if I, okay, execute this code,

1040
00:53:07,540 --> 00:53:09,540
instead of calling the print period,

1041
00:53:09,540 --> 00:53:11,540
I call for example the plot method,

1042
00:53:11,540 --> 00:53:13,540
okay,

1043
00:53:13,540 --> 00:53:15,540
sorry, sorry, sorry, sorry, plot,

1044
00:53:15,540 --> 00:53:17,540
oh,

1045
00:53:17,540 --> 00:53:19,540
sorry,

1046
00:53:19,540 --> 00:53:21,540
I call the create wave method,

1047
00:53:21,540 --> 00:53:23,540
okay, and then the plot wave.

1048
00:53:29,540 --> 00:53:31,540
Let me see the other,

1049
00:53:31,540 --> 00:53:33,540
oh, yeah,

1050
00:53:33,540 --> 00:53:35,540
sure.

1051
00:53:35,540 --> 00:53:37,540
Okay.

1052
00:53:37,540 --> 00:53:39,540
As you know,

1053
00:53:39,540 --> 00:53:41,540
he's complaining about the fact that

1054
00:53:41,540 --> 00:53:43,540
he cannot find the frequency

1055
00:53:43,540 --> 00:53:45,540
because frequency is an attribute,

1056
00:53:45,540 --> 00:53:47,540
an attribute defined in the parent class.

1057
00:53:47,540 --> 00:53:49,540
But we are not creating an instance

1058
00:53:49,540 --> 00:53:51,540
of the parent class, we are creating an instance

1059
00:53:51,540 --> 00:53:53,540
of the derived class. So we

1060
00:53:53,540 --> 00:53:55,540
still need to explain Python

1061
00:53:55,540 --> 00:53:57,540
how to set up

1062
00:53:57,540 --> 00:53:59,540
our basic attributes, frequency,

1063
00:53:59,540 --> 00:54:01,540
amplitude, and offset.

1064
00:54:01,540 --> 00:54:03,540
So what we need to do is obviously

1065
00:54:03,540 --> 00:54:05,540
define a new

1066
00:54:05,540 --> 00:54:07,540
constructor method.

1067
00:54:07,540 --> 00:54:09,540
Okay, solve,

1068
00:54:09,540 --> 00:54:11,540
okay,

1069
00:54:11,540 --> 00:54:13,540
and let's use this syntax.

1070
00:54:13,540 --> 00:54:15,540
Works and

1071
00:54:15,540 --> 00:54:17,540
works.

1072
00:54:19,540 --> 00:54:21,540
Okay, and then

1073
00:54:21,540 --> 00:54:23,540
let's do this one.

1074
00:54:29,540 --> 00:54:31,540
Oops, sorry.

1075
00:54:31,540 --> 00:54:33,540
Oops.

1076
00:54:33,540 --> 00:54:35,540
Oops.

1077
00:54:43,540 --> 00:54:45,540
Bum, bum, bum, bum, bum.

1078
00:54:45,540 --> 00:54:47,540
Let me see.

1079
00:54:57,540 --> 00:54:59,540
I'm sorry.

1080
00:55:01,540 --> 00:55:03,540
Oh, sorry, didn't get it.

1081
00:55:15,540 --> 00:55:17,540
No, sorry.

1082
00:55:25,540 --> 00:55:27,540
Underscore?

1083
00:55:27,540 --> 00:55:29,540
No,

1084
00:55:29,540 --> 00:55:31,540
sorry, one moment.

1085
00:55:31,540 --> 00:55:33,540
Just one moment.

1086
00:55:33,540 --> 00:55:35,540
Oh, super

1087
00:55:35,540 --> 00:55:37,540
neat.

1088
00:55:37,540 --> 00:55:39,540
Sorry.

1089
00:55:45,540 --> 00:55:47,540
Sorry.

1090
00:55:49,540 --> 00:55:51,540
No, it's not the issue.

1091
00:56:03,540 --> 00:56:05,540
Sorry,

1092
00:56:05,540 --> 00:56:07,540
I committed an error.

1093
00:56:07,540 --> 00:56:09,540
The field is called frac.

1094
00:56:09,540 --> 00:56:11,540
It's not called frequency.

1095
00:56:11,540 --> 00:56:13,540
Yeah, exactly.

1096
00:56:13,540 --> 00:56:15,540
And this one is called

1097
00:56:15,540 --> 00:56:17,540
amp.

1098
00:56:17,540 --> 00:56:19,540
Okay.

1099
00:56:21,540 --> 00:56:23,540
Let me see this error.

1100
00:56:29,540 --> 00:56:31,540
Okay.

1101
00:56:35,540 --> 00:56:37,540
Okay,

1102
00:56:37,540 --> 00:56:39,540
periodic function.

1103
00:56:39,540 --> 00:56:41,540
Yeah.

1104
00:56:41,540 --> 00:56:43,540
Should be correct.

1105
00:56:49,540 --> 00:56:51,540
Flat and API function.

1106
00:56:51,540 --> 00:56:53,540
Okay.

1107
00:56:53,540 --> 00:56:55,540
The function

1108
00:56:55,540 --> 00:56:57,540
while it

1109
00:56:59,540 --> 00:57:01,540
Okay.

1110
00:57:01,540 --> 00:57:03,540
Okay.

1111
00:57:03,540 --> 00:57:05,540
NumPy is not plot, obviously.

1112
00:57:07,540 --> 00:57:09,540
Because the create wave should not return this one,

1113
00:57:09,540 --> 00:57:11,540
but should return a wave.

1114
00:57:11,540 --> 00:57:13,540
ts, ys.

1115
00:57:13,540 --> 00:57:15,540
Yeah.

1116
00:57:15,540 --> 00:57:17,540
Frame rate.

1117
00:57:17,540 --> 00:57:19,540
Frame rate.

1118
00:57:19,540 --> 00:57:21,540
Okay.

1119
00:57:23,540 --> 00:57:25,540
Okay, that's perfect.

1120
00:57:25,540 --> 00:57:27,540
So if you plot now.

1121
00:57:27,540 --> 00:57:29,540
Okay.

1122
00:57:29,540 --> 00:57:31,540
Okay.

1123
00:57:31,540 --> 00:57:33,540
So we did

1124
00:57:33,540 --> 00:57:35,540
We basically defined a new constructor.

1125
00:57:35,540 --> 00:57:37,540
Thanks for the suggestion. I didn't say it.

1126
00:57:37,540 --> 00:57:39,540
What we call the super.

1127
00:57:39,540 --> 00:57:41,540
Super is a very important keyword in Python.

1128
00:57:41,540 --> 00:57:43,540
Because it's saying, okay,

1129
00:57:43,540 --> 00:57:45,540
call some method, okay,

1130
00:57:45,540 --> 00:57:47,540
in the parent class.

1131
00:57:47,540 --> 00:57:49,540
So call the constructor method

1132
00:57:49,540 --> 00:57:51,540
in the signal class.

1133
00:57:51,540 --> 00:57:53,540
And provide all the arguments

1134
00:57:53,540 --> 00:57:55,540
that could be passed.

1135
00:57:55,540 --> 00:57:57,540
For example, when you declare a scene waveform

1136
00:57:57,540 --> 00:57:59,540
in the scene waveform base signal.

1137
00:57:59,540 --> 00:58:01,540
So if I provide, for example, amplitude and frequency here,

1138
00:58:01,540 --> 00:58:03,540
all these parameters get passed

1139
00:58:03,540 --> 00:58:05,540
to the constructor of the parent class.

1140
00:58:05,540 --> 00:58:07,540
Since I call this super.init method.

1141
00:58:07,540 --> 00:58:09,540
And obviously,

1142
00:58:09,540 --> 00:58:11,540
the create wave

1143
00:58:11,540 --> 00:58:13,540
implementation is this one.

1144
00:58:13,540 --> 00:58:15,540
It is basically the same as before.

1145
00:58:15,540 --> 00:58:17,540
But the main difference

1146
00:58:17,540 --> 00:58:19,540
is that you need to pass the

1147
00:58:19,540 --> 00:58:21,540
you need to pass the period

1148
00:58:21,540 --> 00:58:23,540
function as well as the last parameters.

1149
00:58:23,540 --> 00:58:25,540
Because the default

1150
00:58:25,540 --> 00:58:27,540
implementation of the Alpers library

1151
00:58:27,540 --> 00:58:29,540
does not accept a periodic function.

1152
00:58:29,540 --> 00:58:31,540
Okay. Or you provide out the

1153
00:58:31,540 --> 00:58:33,540
default periodic function that is different

1154
00:58:33,540 --> 00:58:35,540
from our one.

1155
00:58:35,540 --> 00:58:37,540
So there's an issue. I committed another error.

1156
00:58:37,540 --> 00:58:39,540
Because this one is ys,

1157
00:58:39,540 --> 00:58:41,540
yes.

1158
00:58:41,540 --> 00:58:43,540
Let me see.

1159
00:58:43,540 --> 00:58:45,540
Okay. Now it's good. Now it's fine.

1160
00:58:45,540 --> 00:58:47,540
So this is a plot.

1161
00:58:47,540 --> 00:58:49,540
So what we've seen so far

1162
00:58:49,540 --> 00:58:51,540
is basically you are going to

1163
00:58:51,540 --> 00:58:53,540
let's say delegate

1164
00:58:53,540 --> 00:58:55,540
some behavior to the parent class

1165
00:58:55,540 --> 00:58:57,540
like we did in the constructor.

1166
00:58:57,540 --> 00:58:59,540
And we were not happy

1167
00:58:59,540 --> 00:59:01,540
with the default implementation provided by the

1168
00:59:01,540 --> 00:59:03,540
parent class about the create wave, for example.

1169
00:59:03,540 --> 00:59:05,540
So what we did is implementing

1170
00:59:05,540 --> 00:59:07,540
them again, okay, providing

1171
00:59:07,540 --> 00:59:09,540
our personalized, customized

1172
00:59:09,540 --> 00:59:11,540
version of the create wave sample

1173
00:59:11,540 --> 00:59:13,540
scoring method.

1174
00:59:13,540 --> 00:59:15,540
But

1175
00:59:15,540 --> 00:59:17,540
there is actually another way you can

1176
00:59:17,540 --> 00:59:19,540
use to increase,

1177
00:59:19,540 --> 00:59:21,540
let's say, the model, the complexity

1178
00:59:21,540 --> 00:59:23,540
of your object, okay.

1179
00:59:23,540 --> 00:59:25,540
We use this one, which is basically

1180
00:59:25,540 --> 00:59:27,540
is, okay, inherit everything from

1181
00:59:27,540 --> 00:59:29,540
a parent class. But

1182
00:59:29,540 --> 00:59:31,540
there is some cases where this approach cannot

1183
00:59:31,540 --> 00:59:33,540
work. But you can use another approach

1184
00:59:33,540 --> 00:59:35,540
provided by the

1185
00:59:35,540 --> 00:59:37,540
object-oriented programming, which is called

1186
00:59:37,540 --> 00:59:39,540
the composition.

1187
00:59:39,540 --> 00:59:41,540
So you are going to compose

1188
00:59:41,540 --> 00:59:43,540
the final class

1189
00:59:43,540 --> 00:59:45,540
with pieces coming from

1190
00:59:45,540 --> 00:59:47,540
other classes. So

1191
00:59:47,540 --> 00:59:49,540
think about it.

1192
00:59:49,540 --> 00:59:51,540
A scene waveform based signal

1193
00:59:51,540 --> 00:59:53,540
is a signal.

1194
00:59:53,540 --> 00:59:55,540
So that's okay, inheriting

1195
00:59:55,540 --> 00:59:57,540
everything from the

1196
00:59:57,540 --> 00:59:59,540
signal itself because we can

1197
00:59:59,540 --> 01:00:01,540
probably reuse the print

1198
01:00:01,540 --> 01:00:03,540
period. Period is always the same.

1199
01:00:03,540 --> 01:00:05,540
Scene, cosine, it's a difference.

1200
01:00:05,540 --> 01:00:07,540
But the main issue here is that

1201
01:00:07,540 --> 01:00:09,540
if we can set up,

1202
01:00:09,540 --> 01:00:11,540
for example, the waveform, the scene

1203
01:00:11,540 --> 01:00:13,540
waveform, so setting up

1204
01:00:13,540 --> 01:00:15,540
a different waveform for the wave,

1205
01:00:15,540 --> 01:00:17,540
that attribute

1206
01:00:17,540 --> 01:00:19,540
is some sort of

1207
01:00:19,540 --> 01:00:21,540
a feature, okay.

1208
01:00:21,540 --> 01:00:23,540
So the waveform is a feature

1209
01:00:23,540 --> 01:00:25,540
of a signal.

1210
01:00:25,540 --> 01:00:27,540
So the scene waveform is

1211
01:00:27,540 --> 01:00:29,540
a signal, but it has

1212
01:00:29,540 --> 01:00:31,540
obviously a waveform.

1213
01:00:31,540 --> 01:00:33,540
So what we can do now,

1214
01:00:33,540 --> 01:00:35,540
we can compose this function in a different

1215
01:00:35,540 --> 01:00:37,540
way. If you notice

1216
01:00:37,540 --> 01:00:39,540
here,

1217
01:00:39,540 --> 01:00:41,540
I define a function

1218
01:00:41,540 --> 01:00:43,540
mpSine. mpSine is another

1219
01:00:43,540 --> 01:00:45,540
object. It's just an instance of something

1220
01:00:45,540 --> 01:00:47,540
that someone created for us,

1221
01:00:47,540 --> 01:00:49,540
Lumpai, in this case.

1222
01:00:49,540 --> 01:00:51,540
So we are composing

1223
01:00:51,540 --> 01:00:53,540
this scene waveform

1224
01:00:53,540 --> 01:00:55,540
based signal, inherits everything

1225
01:00:55,540 --> 01:00:57,540
from signal because they belong to the same family.

1226
01:00:57,540 --> 01:00:59,540
But at the same time,

1227
01:00:59,540 --> 01:01:01,540
we define, we compose

1228
01:01:01,540 --> 01:01:03,540
this class using another

1229
01:01:03,540 --> 01:01:05,540
attribute that is the same, that is

1230
01:01:05,540 --> 01:01:07,540
the scene waveform. So from

1231
01:01:07,540 --> 01:01:09,540
one side, it obviously

1232
01:01:09,540 --> 01:01:11,540
inherits something from someone,

1233
01:01:11,540 --> 01:01:13,540
okay, because its response

1234
01:01:13,540 --> 01:01:15,540
to the verb is, the verb

1235
01:01:15,540 --> 01:01:17,540
be, and from the other side,

1236
01:01:17,540 --> 01:01:19,540
it can be composed by something

1237
01:01:19,540 --> 01:01:21,540
else because it responds to the verb

1238
01:01:21,540 --> 01:01:23,540
have. This is a very,

1239
01:01:23,540 --> 01:01:25,540
let's say, this is a trick that I

1240
01:01:25,540 --> 01:01:27,540
typically use in order to understand

1241
01:01:27,540 --> 01:01:29,540
the difference between delegation,

1242
01:01:31,540 --> 01:01:33,540
delegation to the composition.

1243
01:01:35,540 --> 01:01:37,540
At this point, you

1244
01:01:37,540 --> 01:01:39,540
can obviously,

1245
01:01:39,540 --> 01:01:41,540
let's say,

1246
01:01:41,540 --> 01:01:43,540
think about inheriting

1247
01:01:43,540 --> 01:01:45,540
from multiple classes.

1248
01:01:45,540 --> 01:01:47,540
So suppose that

1249
01:01:47,540 --> 01:01:49,540
your object, your final object, like the scene

1250
01:01:49,540 --> 01:01:51,540
waveform based signal,

1251
01:01:51,540 --> 01:01:53,540
belongs to multiple families.

1252
01:01:53,540 --> 01:01:55,540
This is not the case, but just

1253
01:01:55,540 --> 01:01:57,540
suppose it. It would be good.

1254
01:01:57,540 --> 01:01:59,540
Okay.

1255
01:01:59,540 --> 01:02:01,540
But there is an issue. There is

1256
01:02:01,540 --> 01:02:03,540
an issue with this kind of implementation.

1257
01:02:03,540 --> 01:02:05,540
Think about the print period.

1258
01:02:05,540 --> 01:02:07,540
We know that when we

1259
01:02:07,540 --> 01:02:09,540
call the print period over the

1260
01:02:09,540 --> 01:02:11,540
scene waveform based signal,

1261
01:02:11,540 --> 01:02:13,540
okay, Python looks

1262
01:02:13,540 --> 01:02:15,540
at that name inside

1263
01:02:15,540 --> 01:02:17,540
this class.

1264
01:02:17,540 --> 01:02:19,540
It didn't find it, and then looks in

1265
01:02:19,540 --> 01:02:21,540
the parent class. But if

1266
01:02:21,540 --> 01:02:23,540
you have the multiple inheritance

1267
01:02:23,540 --> 01:02:25,540
and both classes

1268
01:02:25,540 --> 01:02:27,540
implement the print period,

1269
01:02:27,540 --> 01:02:29,540
which is the version that Python

1270
01:02:29,540 --> 01:02:31,540
will call?

1271
01:02:31,540 --> 01:02:33,540
Obviously, there is a rule, okay.

1272
01:02:33,540 --> 01:02:35,540
So Python will

1273
01:02:35,540 --> 01:02:37,540
won't pick up it

1274
01:02:37,540 --> 01:02:39,540
obviously, okay. There is a rule.

1275
01:02:39,540 --> 01:02:41,540
But this is a big issue, because if

1276
01:02:41,540 --> 01:02:43,540
you don't remember this rule, you

1277
01:02:43,540 --> 01:02:45,540
maybe can delegate to a parent

1278
01:02:45,540 --> 01:02:47,540
class that this is not exactly what

1279
01:02:47,540 --> 01:02:49,540
exactly you're expecting to call.

1280
01:02:49,540 --> 01:02:51,540
So in general, the

1281
01:02:51,540 --> 01:02:53,540
multiple inheritance in other

1282
01:02:53,540 --> 01:02:55,540
programming languages is just forbidden.

1283
01:02:55,540 --> 01:02:57,540
So the compiler won't work, like

1284
01:02:57,540 --> 01:02:59,540
Java, for example. For this reason, this problem

1285
01:02:59,540 --> 01:03:01,540
is called the diamond problem.

1286
01:03:01,540 --> 01:03:03,540
So you've got basically two varicatoxial triangles.

1287
01:03:03,540 --> 01:03:05,540
Okay. The

1288
01:03:05,540 --> 01:03:07,540
existing vertex is the, let's say,

1289
01:03:07,540 --> 01:03:09,540
the upper vertex is maybe the

1290
01:03:09,540 --> 01:03:11,540
final class, and the other vertex

1291
01:03:11,540 --> 01:03:13,540
are the implementation, the existing implementation.

1292
01:03:13,540 --> 01:03:15,540
So Python won't know exactly

1293
01:03:15,540 --> 01:03:17,540
how the method

1294
01:03:17,540 --> 01:03:19,540
you want to call. It tries to call the first one.

1295
01:03:19,540 --> 01:03:21,540
The first one that tries is group free.

1296
01:03:21,540 --> 01:03:23,540
But this is probably not the

1297
01:03:23,540 --> 01:03:25,540
best implementation ever.

1298
01:03:25,540 --> 01:03:27,540
Actually,

1299
01:03:27,540 --> 01:03:29,540
in multiple inheritance

1300
01:03:29,540 --> 01:03:31,540
works pretty well for solving

1301
01:03:31,540 --> 01:03:33,540
other issues. Okay.

1302
01:03:33,540 --> 01:03:35,540
For example, if you use Django,

1303
01:03:35,540 --> 01:03:37,540
Django framework is full of

1304
01:03:37,540 --> 01:03:39,540
mixin. A mixin

1305
01:03:39,540 --> 01:03:41,540
is a class that

1306
01:03:41,540 --> 01:03:43,540
has some custom behavior.

1307
01:03:43,540 --> 01:03:45,540
Okay. And this

1308
01:03:45,540 --> 01:03:47,540
behavior has not any

1309
01:03:47,540 --> 01:03:49,540
parental relationship within the

1310
01:03:49,540 --> 01:03:51,540
final class. So

1311
01:03:51,540 --> 01:03:53,540
supposed to have, for example, a function,

1312
01:03:53,540 --> 01:03:55,540
supposed to have, for example, a class that

1313
01:03:55,540 --> 01:03:57,540
is a mixin that helps us to

1314
01:03:57,540 --> 01:03:59,540
scale the wave,

1315
01:03:59,540 --> 01:04:01,540
reduce the amplitude of the wave.

1316
01:04:01,540 --> 01:04:03,540
Okay. There is no relationship

1317
01:04:03,540 --> 01:04:05,540
within this class and the

1318
01:04:05,540 --> 01:04:07,540
wave itself. This class, all the signals

1319
01:04:07,540 --> 01:04:09,540
itself. But it

1320
01:04:09,540 --> 01:04:11,540
can offer you some APIs

1321
01:04:11,540 --> 01:04:13,540
to do the job.

1322
01:04:13,540 --> 01:04:15,540
Let's see an example.

1323
01:04:17,540 --> 01:04:19,540
Let's go here. Let's create, for example,

1324
01:04:19,540 --> 01:04:21,540
a, oh, sorry.

1325
01:04:23,540 --> 01:04:25,540
Okay. Let's create, for example, another class

1326
01:04:25,540 --> 01:04:27,540
that is called scale by

1327
01:04:27,540 --> 01:04:29,540
to mixin.

1328
01:04:29,540 --> 01:04:31,540
Okay.

1329
01:04:33,540 --> 01:04:35,540
Okay. This class

1330
01:04:35,540 --> 01:04:37,540
defines a method that is called scale.

1331
01:04:37,540 --> 01:04:39,540
Okay. First argument is

1332
01:04:39,540 --> 01:04:41,540
obviously solve. Okay.

1333
01:04:41,540 --> 01:04:43,540
And it returns basically

1334
01:04:43,540 --> 01:04:45,540
solve.yS.

1335
01:04:47,540 --> 01:04:49,540
Yeah.

1336
01:04:49,540 --> 01:04:51,540
Okay. Sorry.

1337
01:04:53,540 --> 01:04:55,540
Okay.

1338
01:04:55,540 --> 01:04:57,540
So let's define a class that is called scale by to mixin.

1339
01:04:57,540 --> 01:04:59,540
It defines a method that is called scale

1340
01:04:59,540 --> 01:05:01,540
which takes the array

1341
01:05:01,540 --> 01:05:03,540
of the samples and just

1342
01:05:03,540 --> 01:05:05,540
divides them by two. So it

1343
01:05:05,540 --> 01:05:07,540
scales down the amplitude of the wave

1344
01:05:07,540 --> 01:05:09,540
itself. So

1345
01:05:09,540 --> 01:05:11,540
if we define, for example, a new

1346
01:05:11,540 --> 01:05:13,540
version of the wave, let's call it augmented

1347
01:05:13,540 --> 01:05:15,540
wave. Augmented wave.

1348
01:05:15,540 --> 01:05:17,540
The itinerary is from wave.

1349
01:05:17,540 --> 01:05:19,540
Okay.

1350
01:05:19,540 --> 01:05:21,540
What we can do is that

1351
01:05:21,540 --> 01:05:23,540
it obviously, that's the follow method

1352
01:05:23,540 --> 01:05:25,540
that is called scale. Okay.

1353
01:05:25,540 --> 01:05:27,540
And it returns

1354
01:05:27,540 --> 01:05:29,540
super

1355
01:05:29,540 --> 01:05:31,540
dot scale.

1356
01:05:33,540 --> 01:05:35,540
Self dot yS.

1357
01:05:37,540 --> 01:05:39,540
Okay.

1358
01:05:39,540 --> 01:05:41,540
So we extended the wave,

1359
01:05:41,540 --> 01:05:43,540
our wave implementation

1360
01:05:43,540 --> 01:05:45,540
with a new class.

1361
01:05:45,540 --> 01:05:47,540
Define a new method, a new API,

1362
01:05:47,540 --> 01:05:49,540
generic API that is called scale

1363
01:05:49,540 --> 01:05:51,540
that in turns equals

1364
01:05:51,540 --> 01:05:53,540
something like the scale. In order to

1365
01:05:53,540 --> 01:05:55,540
make this super work, we need to

1366
01:05:55,540 --> 01:05:57,540
extend the augmented wave

1367
01:05:57,540 --> 01:05:59,540
with the scale by to mixin.

1368
01:05:59,540 --> 01:06:01,540
So what we can do

1369
01:06:01,540 --> 01:06:03,540
is that basically go over here

1370
01:06:03,540 --> 01:06:05,540
and add this class.

1371
01:06:07,540 --> 01:06:09,540
Okay.

1372
01:06:09,540 --> 01:06:11,540
And now we need to define again

1373
01:06:11,540 --> 01:06:13,540
the signal class.

1374
01:06:13,540 --> 01:06:15,540
Let me see.

1375
01:06:23,540 --> 01:06:25,540
Let's call, for example,

1376
01:06:25,540 --> 01:06:27,540
a new signal.

1377
01:06:27,540 --> 01:06:29,540
Okay.

1378
01:06:29,540 --> 01:06:31,540
Sorry.

1379
01:06:31,540 --> 01:06:33,540
Def create wave.

1380
01:06:33,540 --> 01:06:35,540
Okay.

1381
01:06:37,540 --> 01:06:39,540
Let's take the implementation

1382
01:06:39,540 --> 01:06:41,540
from here.

1383
01:06:41,540 --> 01:06:43,540
Okay.

1384
01:06:45,540 --> 01:06:47,540
But instead of returning the wave, it returns

1385
01:06:47,540 --> 01:06:49,540
the augmented wave.

1386
01:06:49,540 --> 01:06:51,540
Okay.

1387
01:06:51,540 --> 01:06:53,540
So what you can do is this one.

1388
01:06:53,540 --> 01:06:55,540
You create a signal.

1389
01:06:55,540 --> 01:06:57,540
Okay. You call the method create wave.

1390
01:06:57,540 --> 01:06:59,540
It returns the wave.

1391
01:06:59,540 --> 01:07:01,540
And you

1392
01:07:01,540 --> 01:07:03,540
can call the wave dot scale method.

1393
01:07:03,540 --> 01:07:05,540
Okay.

1394
01:07:07,540 --> 01:07:09,540
Wave dot

1395
01:07:09,540 --> 01:07:11,540
offset yS.

1396
01:07:11,540 --> 01:07:13,540
Okay.

1397
01:07:13,540 --> 01:07:15,540
Is this one. Wave dot plot.

1398
01:07:15,540 --> 01:07:17,540
Wave dot plot.

1399
01:07:21,540 --> 01:07:23,540
But

1400
01:07:23,540 --> 01:07:25,540
what is this?

1401
01:07:25,540 --> 01:07:27,540
Yeah.

1402
01:07:27,540 --> 01:07:29,540
Sure. This one.

1403
01:07:31,540 --> 01:07:33,540
Oh, it's basically the same.

1404
01:07:33,540 --> 01:07:35,540
Just one moment.

1405
01:07:41,540 --> 01:07:43,540
Okay.

1406
01:07:43,540 --> 01:07:45,540
Let's see.

1407
01:07:45,540 --> 01:07:47,540
Signal.

1408
01:07:49,540 --> 01:07:51,540
Okay.

1409
01:07:51,540 --> 01:07:53,540
Yeah. Sure.

1410
01:07:53,540 --> 01:07:55,540
This is a function.

1411
01:07:55,540 --> 01:07:57,540
And this one.

1412
01:08:03,540 --> 01:08:05,540
Perfect.

1413
01:08:05,540 --> 01:08:07,540
So let's look at the code.

1414
01:08:07,540 --> 01:08:09,540
We define a scale by tubing same.

1415
01:08:09,540 --> 01:08:11,540
Which offer an API that is capable of

1416
01:08:11,540 --> 01:08:13,540
scaling something. Okay.

1417
01:08:13,540 --> 01:08:15,540
It's doing something. It's not very relevant now.

1418
01:08:15,540 --> 01:08:17,540
We define a new version of the wave.

1419
01:08:17,540 --> 01:08:19,540
Okay. That is called augmented wave.

1420
01:08:19,540 --> 01:08:21,540
But we

1421
01:08:21,540 --> 01:08:23,540
let's say from two different classes.

1422
01:08:23,540 --> 01:08:25,540
But the main problem, the main issue

1423
01:08:25,540 --> 01:08:27,540
or the main difference is scaled by two mixin

1424
01:08:27,540 --> 01:08:29,540
is not related by any parental

1425
01:08:29,540 --> 01:08:31,540
relation with the wave or

1426
01:08:31,540 --> 01:08:33,540
the augmented wave. Which we

1427
01:08:33,540 --> 01:08:35,540
just added this mixin

1428
01:08:35,540 --> 01:08:37,540
in order to add some custom

1429
01:08:37,540 --> 01:08:39,540
behavior to the augmented wave.

1430
01:08:39,540 --> 01:08:41,540
We then define an API that is called

1431
01:08:41,540 --> 01:08:43,540
scale. That in turn is called the

1432
01:08:43,540 --> 01:08:45,540
scale by two mixin scale method.

1433
01:08:45,540 --> 01:08:47,540
We then define a new signal that

1434
01:08:47,540 --> 01:08:49,540
in turn

1435
01:08:49,540 --> 01:08:51,540
is not going to call the signal

1436
01:08:51,540 --> 01:08:53,540
okay, it's not in reads from the signal

1437
01:08:53,540 --> 01:08:55,540
but in reads from the same wave form

1438
01:08:55,540 --> 01:08:57,540
based signal that we just

1439
01:08:57,540 --> 01:08:59,540
augmented with new feature like

1440
01:08:59,540 --> 01:09:01,540
defining the periodic function.

1441
01:09:01,540 --> 01:09:03,540
And then we define again the create wave.

1442
01:09:03,540 --> 01:09:05,540
Okay. Returning this time

1443
01:09:05,540 --> 01:09:07,540
an instance of augmented wave.

1444
01:09:07,540 --> 01:09:09,540
Obviously of this one. And then

1445
01:09:09,540 --> 01:09:11,540
you create a signal here and then

1446
01:09:11,540 --> 01:09:13,540
you call the scale and then you call the plot.

1447
01:09:13,540 --> 01:09:15,540
And you get all the things.

1448
01:09:15,540 --> 01:09:17,540
So the thing that I want to notice

1449
01:09:17,540 --> 01:09:19,540
is that the

1450
01:09:19,540 --> 01:09:21,540
inheritance is transitive.

1451
01:09:21,540 --> 01:09:23,540
So new signal in reads from

1452
01:09:23,540 --> 01:09:25,540
same wave form based

1453
01:09:25,540 --> 01:09:27,540
signal that in reads from

1454
01:09:27,540 --> 01:09:29,540
signal. So you are going to

1455
01:09:29,540 --> 01:09:31,540
let's say make an object

1456
01:09:31,540 --> 01:09:33,540
much much more complex until the

1457
01:09:33,540 --> 01:09:35,540
your complexity of the world evolves.

1458
01:09:35,540 --> 01:09:37,540
You want to try to explain

1459
01:09:37,540 --> 01:09:39,540
better to the computer itself

1460
01:09:39,540 --> 01:09:41,540
defining these classes, okay.

1461
01:09:41,540 --> 01:09:43,540
And you still in reading everything

1462
01:09:43,540 --> 01:09:45,540
from all the

1463
01:09:45,540 --> 01:09:47,540
ancestors. So what you have

1464
01:09:47,540 --> 01:09:49,540
here is that basically you

1465
01:09:49,540 --> 01:09:51,540
in reads from the same wave

1466
01:09:51,540 --> 01:09:53,540
waveform but the method print period

1467
01:09:53,540 --> 01:09:55,540
for example that does not be defined in this

1468
01:09:55,540 --> 01:09:57,540
class is defined in the signal would be

1469
01:09:57,540 --> 01:09:59,540
always available. So if I call

1470
01:09:59,540 --> 01:10:01,540
for example this method.

1471
01:10:05,540 --> 01:10:07,540
Okay.

1472
01:10:11,540 --> 01:10:13,540
Okay.

1473
01:10:13,540 --> 01:10:15,540
So if I call the print period, the print period

1474
01:10:15,540 --> 01:10:17,540
has not been defined in the same wave base form

1475
01:10:17,540 --> 01:10:19,540
but is defined in the signal. And that's fine

1476
01:10:19,540 --> 01:10:21,540
because the inheritance is transitive.

1477
01:10:21,540 --> 01:10:23,540
So Python looks

1478
01:10:23,540 --> 01:10:25,540
for every ancestor until it finds

1479
01:10:25,540 --> 01:10:27,540
the method we are going to call.

1480
01:10:29,540 --> 01:10:31,540
This concludes

1481
01:10:31,540 --> 01:10:33,540
our second part about object

1482
01:10:33,540 --> 01:10:35,540
oriented programming. So let's try

1483
01:10:35,540 --> 01:10:37,540
to recap just two different things.

1484
01:10:37,540 --> 01:10:39,540
First of all is the diamond problem.

1485
01:10:39,540 --> 01:10:41,540
In this case

1486
01:10:41,540 --> 01:10:43,540
the

1487
01:10:43,540 --> 01:10:45,540
multiprogram inheritance

1488
01:10:45,540 --> 01:10:47,540
works pretty well because there is no

1489
01:10:47,540 --> 01:10:49,540
relationship between wave and scale to mix in.

1490
01:10:49,540 --> 01:10:51,540
Because scale to mix in

1491
01:10:51,540 --> 01:10:53,540
has no relation at all with wave.

1492
01:10:53,540 --> 01:10:55,540
So you can't have basically

1493
01:10:55,540 --> 01:10:57,540
some sort of methods that

1494
01:10:57,540 --> 01:10:59,540
have been called the same. So Python

1495
01:10:59,540 --> 01:11:01,540
cannot be wrong about this.

1496
01:11:01,540 --> 01:11:03,540
And we obviously

1497
01:11:03,540 --> 01:11:05,540
showed that

1498
01:11:05,540 --> 01:11:07,540
using the multiple inheritance and

1499
01:11:07,540 --> 01:11:09,540
stating that an object belongs to two different

1500
01:11:09,540 --> 01:11:11,540
families can lead to the

1501
01:11:11,540 --> 01:11:13,540
diamond problem. So Python doesn't know exactly

1502
01:11:13,540 --> 01:11:15,540
what methods you are meant to call.

1503
01:11:15,540 --> 01:11:17,540
Okay, because there are multiple versions

1504
01:11:17,540 --> 01:11:19,540
of the same method defined in the

1505
01:11:19,540 --> 01:11:21,540
parent class. But a

1506
01:11:21,540 --> 01:11:23,540
nice usage for example

1507
01:11:23,540 --> 01:11:25,540
in multiple inheritance, it is

1508
01:11:25,540 --> 01:11:27,540
mixing. It is very widely, widely,

1509
01:11:27,540 --> 01:11:29,540
widely used in all the framework around the web

1510
01:11:29,540 --> 01:11:31,540
in Python for example like Django.

1511
01:11:31,540 --> 01:11:33,540
If you want in Django for example add the support for

1512
01:11:33,540 --> 01:11:35,540
get trickest, pause trickest,

1513
01:11:35,540 --> 01:11:37,540
delete trickest. What you need to do

1514
01:11:37,540 --> 01:11:39,540
is just adding to your controller

1515
01:11:39,540 --> 01:11:41,540
to your view

1516
01:11:41,540 --> 01:11:43,540
mixing, different kind of mixing. Delete mixing,

1517
01:11:43,540 --> 01:11:45,540
update mixing, etc, etc,

1518
01:11:45,540 --> 01:11:47,540
etc. So even if the

1519
01:11:47,540 --> 01:11:49,540
form is the same, I want to stress you out about this

1520
01:11:49,540 --> 01:11:51,540
concept. Even if the form is

1521
01:11:51,540 --> 01:11:53,540
the same, the meaning

1522
01:11:53,540 --> 01:11:55,540
of wave and scale by

1523
01:11:55,540 --> 01:11:57,540
to mix in inside the definition of

1524
01:11:57,540 --> 01:11:59,540
the parented wave is profoundly different.

1525
01:11:59,540 --> 01:12:01,540
Because this one

1526
01:12:01,540 --> 01:12:03,540
implies a relationship between them.

1527
01:12:03,540 --> 01:12:05,540
Parental relationship.

1528
01:12:05,540 --> 01:12:07,540
While the scale to mix in has

1529
01:12:07,540 --> 01:12:09,540
only the same syntax, but

1530
01:12:09,540 --> 01:12:11,540
it expresses a very different concept.

1531
01:12:13,540 --> 01:12:15,540
Questions?

1532
01:12:19,540 --> 01:12:21,540
Okay, second exercise.

1533
01:12:21,540 --> 01:12:23,540
And then we have a pause.

1534
01:12:23,540 --> 01:12:25,540
Okay.

1535
01:12:25,540 --> 01:12:27,540
So your exercise

1536
01:12:27,540 --> 01:12:29,540
would be

1537
01:12:29,540 --> 01:12:31,540
number two. You need to

1538
01:12:31,540 --> 01:12:33,540
write up dictionaries, serializers,

1539
01:12:33,540 --> 01:12:35,540
and mixin. So a

1540
01:12:35,540 --> 01:12:37,540
class that should

1541
01:12:37,540 --> 01:12:39,540
implement a method that is called

1542
01:12:39,540 --> 01:12:41,540
serialize.

1543
01:12:41,540 --> 01:12:43,540
That this in turn is going to print

1544
01:12:43,540 --> 01:12:45,540
the amplitude, the phase, and frequency

1545
01:12:45,540 --> 01:12:47,540
of a signal as a dictionary.

1546
01:12:47,540 --> 01:12:49,540
So take a dictionary,

1547
01:12:49,540 --> 01:12:51,540
you need to compose it using this class.

1548
01:12:51,540 --> 01:12:53,540
Then you need to

1549
01:12:53,540 --> 01:12:55,540
extend the scene wave form based

1550
01:12:55,540 --> 01:12:57,540
signal that you can find on the classes

1551
01:12:57,540 --> 01:12:59,540
module

1552
01:12:59,540 --> 01:13:01,540
to include a new method

1553
01:13:01,540 --> 01:13:03,540
that call the mixin serialize

1554
01:13:03,540 --> 01:13:05,540
method, like we did with scale.

1555
01:13:05,540 --> 01:13:07,540
Obviously you can import the scene

1556
01:13:07,540 --> 01:13:09,540
wave form based signal from classes

1557
01:13:09,540 --> 01:13:11,540
module. That's all.

1558
01:13:11,540 --> 01:13:13,540
So if you have questions,

1559
01:13:13,540 --> 01:13:15,540
you ask me.

1560
01:13:21,540 --> 01:13:23,540
Okay.

1561
01:13:23,540 --> 01:13:25,540
Okay.

1562
01:13:49,540 --> 01:13:51,540
I don't need this. I'm okay with this.

1563
01:13:53,540 --> 01:13:55,540
Okay.

1564
01:14:09,540 --> 01:14:11,540
Is the exercise clear now?

1565
01:14:11,540 --> 01:14:13,540
No.

1566
01:14:23,540 --> 01:14:25,540
Okay.

1567
01:14:53,540 --> 01:14:55,540
Okay.

1568
01:14:55,540 --> 01:14:57,540
Okay.

1569
01:15:21,540 --> 01:15:23,540
Sorry.

1570
01:15:23,540 --> 01:15:25,540
Sorry.

1571
01:15:25,540 --> 01:15:27,540
Sorry.

1572
01:15:27,540 --> 01:15:29,540
Equals.

1573
01:15:29,540 --> 01:15:31,540
Equals.

1574
01:15:31,540 --> 01:15:33,540
Equals.

1575
01:15:33,540 --> 01:15:35,540
Equals.

1576
01:15:35,540 --> 01:15:37,540
Equals.

1577
01:15:53,540 --> 01:15:55,540
Okay.

1578
01:16:23,540 --> 01:16:25,540
Okay.

1579
01:16:31,540 --> 01:16:33,540
Problems? Questions?

1580
01:16:33,540 --> 01:16:35,540
Yeah.

1581
01:16:35,540 --> 01:16:37,540
Okay.

1582
01:16:37,540 --> 01:16:39,540
Did you

1583
01:16:39,540 --> 01:16:41,540
load the class module?

1584
01:16:41,540 --> 01:16:43,540
Yeah.

1585
01:16:43,540 --> 01:16:45,540
You load it with the percent

1586
01:16:45,540 --> 01:16:47,540
load command.

1587
01:16:47,540 --> 01:16:49,540
Right here.

1588
01:16:49,540 --> 01:16:51,540
When I was able to

1589
01:16:51,540 --> 01:16:53,540
import the scene wave.

1590
01:16:53,540 --> 01:16:55,540
Let me see the error.

1591
01:17:07,540 --> 01:17:09,540
Yeah.

1592
01:17:09,540 --> 01:17:11,540
Just look for it.

1593
01:17:21,540 --> 01:17:23,540
Okay.

1594
01:17:51,540 --> 01:17:53,540
Okay.

1595
01:18:21,540 --> 01:18:23,540
Yeah.

1596
01:18:23,540 --> 01:18:25,540
Sorry.

1597
01:18:25,540 --> 01:18:27,540
I spotted another error.

1598
01:18:27,540 --> 01:18:29,540
That class is not

1599
01:18:29,540 --> 01:18:31,540
defined in the

1600
01:18:31,540 --> 01:18:33,540
UTS. So you need to

1601
01:18:33,540 --> 01:18:35,540
maybe copy or just wait for me.

1602
01:18:35,540 --> 01:18:37,540
I push the code down just now.

1603
01:18:37,540 --> 01:18:39,540
You want to copy or push the code?

1604
01:18:39,540 --> 01:18:41,540
Yeah.

1605
01:18:41,540 --> 01:18:43,540
Push the code.

1606
01:18:43,540 --> 01:18:45,540
Okay.

1607
01:18:45,540 --> 01:18:47,540
Okay.

1608
01:18:47,540 --> 01:18:49,540
Okay.

1609
01:18:49,540 --> 01:18:51,540
Okay.

1610
01:19:19,540 --> 01:19:21,540
Okay.

1611
01:19:45,540 --> 01:19:47,540
What class is?

1612
01:20:17,540 --> 01:20:21,380
I pushed the scene wave form definition to the classes file,

1613
01:20:21,380 --> 01:20:23,900
so you just need to download it again and load it again.

1614
01:20:23,900 --> 01:20:25,980
Otherwise you can copy from the code.

1615
01:20:25,980 --> 01:20:28,180
Yes, sure.

1616
01:20:28,180 --> 01:20:29,180
Yeah.

1617
01:20:29,180 --> 01:20:30,180
Mm-hm, mm-hm.

1618
01:20:30,180 --> 01:20:31,180
This one.

1619
01:20:31,180 --> 01:20:32,180
One moment.

1620
01:20:32,180 --> 01:20:33,180
Okay.

1621
01:21:03,180 --> 01:21:16,900
You solved the issue?

1622
01:21:16,900 --> 01:21:17,900
You solved the exercise?

1623
01:21:17,900 --> 01:21:20,900
Let me see.

1624
01:21:20,900 --> 01:21:23,900
Yeah, perfect.

1625
01:21:23,900 --> 01:21:30,940
But you need to define, you need to add a new API over here that is calling the serializer

1626
01:21:30,940 --> 01:21:31,940
function.

1627
01:21:31,940 --> 01:21:32,940
Okay.

1628
01:21:32,940 --> 01:21:33,940
That's all.

1629
01:21:33,940 --> 01:21:48,460
Yes, it's not mandatory, but honestly my personal opinion is much more clear that you need to

1630
01:21:48,460 --> 01:21:53,940
call basically an API that is not taking any kind of parameters and call the serialized

1631
01:21:53,940 --> 01:21:55,500
function that takes all the parameters.

1632
01:21:55,500 --> 01:21:59,020
Because in this way, if you offer this one, serialized method would be available to the

1633
01:22:00,020 --> 01:22:03,020
client, but client needs to know that you need to provide you the AMP, Face, and Frac.

1634
01:22:03,020 --> 01:22:07,300
My AMP, Face, and Frac are the state of the object, so you have it.

1635
01:22:07,300 --> 01:22:10,500
So if you offer, you get the idea.

1636
01:22:10,500 --> 01:22:15,500
Oh, by the way, this is openable.

1637
01:22:15,500 --> 01:22:16,500
This is my personal point.

1638
01:22:16,500 --> 01:22:19,500
I typically prefer looking at this.

1639
01:22:19,500 --> 01:22:24,300
Yeah, the idea would be that you offer the user the simplest API ever.

1640
01:22:24,780 --> 01:22:30,780
Okay, so if you require that user can type your parameters, you make his life much more complex.

1641
01:22:30,780 --> 01:22:35,780
If you offer an API that takes not parameter as well, okay, it's much more simple.

1642
01:22:49,780 --> 01:22:51,780
We got a pause in 10 minutes, no?

1643
01:22:51,780 --> 01:22:53,780
We got a pause in 10 minutes.

1644
01:22:54,780 --> 01:22:56,780
10 and 30.

1645
01:23:03,780 --> 01:23:05,780
Sorry.

1646
01:23:05,780 --> 01:23:07,780
Ah, yeah, yeah.

1647
01:23:07,780 --> 01:23:09,780
As you want.

1648
01:23:24,300 --> 01:23:26,780
Okay.

1649
01:23:54,300 --> 01:23:56,780
Okay.

1650
01:24:24,780 --> 01:24:26,780
Okay.

1651
01:24:34,780 --> 01:24:35,780
Just one thing.

1652
01:24:35,780 --> 01:24:40,780
On the Wave, there is another method, an ether API that can offer you the library I sent to you

1653
01:24:40,780 --> 01:24:42,780
that is going to play the sound, okay?

1654
01:24:42,780 --> 01:24:46,780
So if you're going to play, you should have something like this.

1655
01:24:46,780 --> 01:24:49,780
If you press play here, you listen to some sound.

1656
01:24:54,780 --> 01:24:56,780
Okay.

1657
01:25:18,780 --> 01:25:19,780
You fixed it?

1658
01:25:19,780 --> 01:25:21,780
Did you solve the exercise?

1659
01:25:21,780 --> 01:25:23,780
Okay.

1660
01:25:23,780 --> 01:25:26,260
Do the exercise.

1661
01:25:53,780 --> 01:25:56,260
Okay.

1662
01:26:23,780 --> 01:26:26,260
Okay.

1663
01:26:53,780 --> 01:26:56,260
Okay.

1664
01:27:23,780 --> 01:27:26,260
Okay.

1665
01:27:53,780 --> 01:27:56,260
Okay.

1666
01:28:23,780 --> 01:28:26,260
Okay.

1667
01:28:53,780 --> 01:28:56,260
Okay.

1668
01:29:24,260 --> 01:29:26,260
Okay.

1669
01:29:40,260 --> 01:29:42,260
Okay.

1670
01:29:53,780 --> 01:29:56,260
Okay.

1671
01:30:23,780 --> 01:30:26,260
Okay.

1672
01:30:53,780 --> 01:30:56,260
Okay.

1673
01:31:23,780 --> 01:31:26,260
Okay.

1674
01:31:53,780 --> 01:31:56,260
Okay.

1675
01:32:24,260 --> 01:32:26,260
Okay.

1676
01:32:50,260 --> 01:32:52,260
And I'll work until getting a gain.

1677
01:32:52,740 --> 01:32:54,740
Okay.

1678
01:32:54,740 --> 01:32:58,740
But I see my personal solution of the exercise.

1679
01:32:58,740 --> 01:33:00,740
And I want to add just a few different things.

1680
01:33:00,740 --> 01:33:04,740
First of all, the definition of the dictionary serializer mixing is pretty easy.

1681
01:33:04,740 --> 01:33:06,740
Okay.

1682
01:33:06,740 --> 01:33:10,740
It implements an API that is called serialize that takes amplitude, frequency, and phase

1683
01:33:10,740 --> 01:33:16,740
as arguments and just returns the serialization as a dictionary of those attributes.

1684
01:33:17,220 --> 01:33:23,220
And then you define the class that extends our base signal, function base signal,

1685
01:33:23,220 --> 01:33:29,220
that offers you a custom API that is called serialize that takes no parameters.

1686
01:33:29,220 --> 01:33:35,220
And it is capable to call the serialized method of the mixing itself.

1687
01:33:35,220 --> 01:33:39,220
So this is not actually the only solution ever.

1688
01:33:39,220 --> 01:33:43,220
Because if you think about it, you can try to do not implement the serialized function

1689
01:33:43,700 --> 01:33:47,700
inside the extended version of the signal.

1690
01:33:47,700 --> 01:33:53,700
You can call directly the serialized function of the dictionary serialized mixing.

1691
01:33:53,700 --> 01:33:57,700
But there is an issue using this approach.

1692
01:33:57,700 --> 01:34:03,700
If you call directly this function itself without implementing some sort of proxy over here,

1693
01:34:03,700 --> 01:34:05,700
you need to provide all these parameters.

1694
01:34:05,700 --> 01:34:09,700
But all these parameters are part of the state, the state of the object itself.

1695
01:34:09,700 --> 01:34:15,060
So you don't need as a client to know that you need to provide this kind of parameters.

1696
01:34:15,060 --> 01:34:17,940
Because it is inside the object itself.

1697
01:34:17,940 --> 01:34:25,100
I was just saying that general rule is offering client the much simpler API ever.

1698
01:34:25,100 --> 01:34:29,300
So if you can avoid to provide parameters, it's always better.

1699
01:34:29,300 --> 01:34:34,340
And hide all the complexity of calling something with parameters inside,

1700
01:34:34,340 --> 01:34:34,940
under the hood.

1701
01:34:36,620 --> 01:34:37,120
One more thing.

1702
01:34:37,120 --> 01:34:40,640
Yeah.

1703
01:34:40,640 --> 01:34:48,640
Yeah, it's a extended version of the signal.

1704
01:34:48,640 --> 01:34:54,640
Yeah.

1705
01:34:54,640 --> 01:34:58,640
Yeah.

1706
01:34:58,640 --> 01:35:04,640
Yeah, because this one is missing.

1707
01:35:04,640 --> 01:35:06,640
Yeah, correct.

1708
01:35:06,640 --> 01:35:10,640
I fixed the code and pushed out the line.

1709
01:35:10,640 --> 01:35:12,640
I'm sorry, this is how live coding so good.

1710
01:35:12,640 --> 01:35:22,640
Why does a person with a serialized not have a cell-amplifier frequently tell phase?

1711
01:35:22,640 --> 01:35:24,640
That's a fine question.

1712
01:35:24,640 --> 01:35:30,640
I tried to, at the very beginning, we got a break here, so feel free to leave, obviously.

1713
01:35:30,640 --> 01:35:34,640
At the very beginning, we talked about the difference between signal and wave.

1714
01:35:34,640 --> 01:35:40,640
And we state that a class for modeling signals and a class for modeling wave.

1715
01:35:40,640 --> 01:35:42,640
So you are a class for one single responsibility basically.

1716
01:35:42,640 --> 01:35:46,640
Which is a very important principle of object-oriented programming.

1717
01:35:46,640 --> 01:35:54,640
So I'm going to ask you, is the Dictionary Satellizer Mixin needs to know the internal state of the object?

1718
01:35:54,640 --> 01:35:56,640
In my opinion, no.

1719
01:35:56,640 --> 01:36:02,640
Because the Dictionary Satellizer Mixin is just an helper class to provide a way to serialize something.

1720
01:36:02,640 --> 01:36:06,640
And the thing is, they are just parameters.

1721
01:36:06,640 --> 01:36:10,640
I could write here, instead of amp, freq, phase, I could a, b, c.

1722
01:36:10,640 --> 01:36:12,640
It's totally the same.

1723
01:36:12,640 --> 01:36:18,640
Because the Dictionary Satellizer object in my mind has no knowledge at all of signal or waves.

1724
01:36:18,640 --> 01:36:20,640
It's just a new class that offered me a service.

1725
01:36:20,640 --> 01:36:22,640
And the service is serialization.

1726
01:36:22,640 --> 01:36:28,640
For this reason, there is no self-amp inside the Dictionary Satellizer Mixin.

1727
01:36:28,640 --> 01:36:34,640
Otherwise, if you think, it would be not a mixin anymore.

1728
01:36:34,640 --> 01:36:40,640
Because in this case, there was some sort of parental relationship between the signal and the Dictionary Satellizer Mixin.

1729
01:36:40,640 --> 01:36:42,640
But we say that mixin had nothing to do.

1730
01:36:42,640 --> 01:36:50,640
They just had some behavior, some other function, some helper's methods to solve a particular issue.

1731
01:36:50,640 --> 01:36:52,640
Other question? Yeah.

1732
01:36:52,640 --> 01:36:54,640
Is, sorry, I didn't get it.

1733
01:36:54,640 --> 01:36:56,640
Yeah, yeah, they are the same.

1734
01:36:56,640 --> 01:36:58,640
Yeah, they are synonymous.

1735
01:36:58,640 --> 01:37:00,640
Yeah.

1736
01:37:00,640 --> 01:37:04,640
If you study telecommunication engineering, the right name is phase.

1737
01:37:04,640 --> 01:37:06,640
It's not offset.

1738
01:37:06,640 --> 01:37:08,640
But in order to be understood offset, it's just the delay.

1739
01:37:08,640 --> 01:37:12,640
But if you talk delay for telecommunication engineering, they probably won't understand.

1740
01:37:12,640 --> 01:37:14,640
Okay, so talk with phase.

1741
01:37:14,640 --> 01:37:16,640
Yeah, obviously not.

1742
01:37:16,640 --> 01:37:18,640
This is the most generalized one.

1743
01:37:18,640 --> 01:37:20,640
I want to say one more thing.

1744
01:37:20,640 --> 01:37:22,640
Okay.

1745
01:37:22,640 --> 01:37:41,940
A method

1746
01:37:42,100 --> 01:37:46,500
that can be noticed,

1747
01:37:46,500 --> 01:37:48,500
whatever,

1748
01:37:48,500 --> 01:37:51,800
is Dictionary Satellite Mixin.

1749
01:37:51,800 --> 01:37:56,460
A method like this is somehow useless,

1750
01:37:56,460 --> 01:37:59,160
because it's basically using that constructor

1751
01:37:59,160 --> 01:38:03,120
takes every kind of arguments, it wraps inside arcs and quarks,

1752
01:38:03,120 --> 01:38:07,580
and calls the constructor method of the init class.

1753
01:38:07,580 --> 01:38:10,880
So actually, you can remove it.

1754
01:38:10,880 --> 01:38:13,480
But they just make this a sample to explain

1755
01:38:13,480 --> 01:38:16,320
the importance of the super, which

1756
01:38:16,320 --> 01:38:19,480
calls a method that comes from some ancestors.

1757
01:38:19,480 --> 01:38:22,720
It could be direct parent of another ancestor.

1758
01:38:22,720 --> 01:38:23,720
That's all.

1759
01:38:23,720 --> 01:38:26,040
So we have a bracket we see at 11.

1760
01:38:30,840 --> 01:38:31,340
Yeah?

1761
01:38:31,340 --> 01:38:31,840
Yeah.

1762
01:38:43,180 --> 01:38:44,380
Yeah.

1763
01:38:44,380 --> 01:38:49,020
So there's a concept in Python that is called method resolution order.

1764
01:38:49,020 --> 01:38:51,180
We basically state this thing.

1765
01:38:51,180 --> 01:38:55,220
If you have a method that has been defined into different two parent classes,

1766
01:38:55,220 --> 01:38:58,020
okay, Python, just look the first one.

1767
01:38:58,060 --> 01:39:01,460
So you basically go over the first parent class,

1768
01:39:01,460 --> 01:39:04,060
you look for the method, the method exists, okay, stop it.

1769
01:39:04,060 --> 01:39:07,180
If the method does not exist, you go for the fourth parent class, and

1770
01:39:07,180 --> 01:39:08,620
you look at the other methods.

1771
01:39:08,620 --> 01:39:10,900
If you find okay, if you're not fine,

1772
01:39:10,900 --> 01:39:14,620
you get the method not found exception that you basically are.

1773
01:39:14,620 --> 01:39:15,380
Yeah.

1774
01:39:15,380 --> 01:39:16,460
Yes.

1775
01:39:16,460 --> 01:39:18,940
Yeah, yes, the order of the parent classes, yeah.

1776
01:39:24,140 --> 01:39:27,900
But in general, it's not really, at least in my personal experience,

1777
01:39:27,900 --> 01:39:34,860
I do not ever feel this wave of using the multiple in a written slacking this way.

1778
01:39:34,860 --> 01:39:39,140
I always use mixin because there's probably there are some changes into

1779
01:39:39,140 --> 01:39:42,740
the Python version, so they change the real law of resoluting methods.

1780
01:39:42,740 --> 01:39:46,700
And this logic that you get used to, let's say,

1781
01:39:46,700 --> 01:39:49,060
to stick with is probably not applicable anymore.

1782
01:39:49,060 --> 01:39:52,980
So if you update the Python, you'll find that some code,

1783
01:39:52,980 --> 01:39:55,580
some piece of code doesn't work anymore because they just change the method

1784
01:39:55,580 --> 01:39:56,100
they resolve.

1785
01:39:56,100 --> 01:40:00,260
So for this reason, for this reason, if you are going to use the multiple in a

1786
01:40:00,260 --> 01:40:03,300
written, you can use the composition.

1787
01:40:03,300 --> 01:40:07,900
So instead of in a written, extending everything from the parent class,

1788
01:40:07,900 --> 01:40:12,260
you create a new class that is as an attribute that is an instance of another

1789
01:40:12,260 --> 01:40:15,300
class, so you compose a new class.

1790
01:40:17,900 --> 01:40:22,260
So think about the difference between composition and delegation.

1791
01:40:22,260 --> 01:40:27,540
You are delegating if you inherit from, but you can compose at the same time.

1792
01:40:27,540 --> 01:40:30,740
Java, for example, does not support, exactly for this reason,

1793
01:40:30,740 --> 01:40:32,460
the multiple inheritance.

1794
01:40:32,460 --> 01:40:34,460
So in Java, you can inherit just one class.

1795
01:40:34,460 --> 01:40:37,300
So Java has not concept of mixin, for example.

1796
01:40:37,300 --> 01:40:40,100
Mixin in Java can be implemented in other ways.

1797
01:40:44,500 --> 01:40:45,260
We have a bracket.

1798
01:40:50,300 --> 01:40:51,460
I cannot force to stay here.

1799
01:40:53,220 --> 01:40:53,980
11.

1800
01:40:55,500 --> 01:40:57,380
Half an hour, actually, but we lost 10 minutes.

1801
01:41:22,260 --> 01:41:30,380
Okay, so in this third part of this crash course, you're going to see something very

1802
01:41:30,380 --> 01:41:34,780
relevant that is not very widely used in Python itself.

1803
01:41:34,780 --> 01:41:38,940
If you came from other languages, you can find much more intense representation,

1804
01:41:38,940 --> 01:41:40,820
much more intense usage.

1805
01:41:40,820 --> 01:41:46,460
But in Python, it is somehow relevant to introduce this concept because it can

1806
01:41:46,500 --> 01:41:52,660
leave you some sort of, let's say, another guideline to be used when you develop

1807
01:41:52,660 --> 01:41:56,020
software using the object for the anti-programming part.

1808
01:41:56,020 --> 01:41:58,140
Let's start from the real world example.

1809
01:41:59,940 --> 01:42:04,700
We played with the note piano, but note piano is very boring.

1810
01:42:06,220 --> 01:42:08,860
At some point, you want to transmit, for example, an audio transmission to

1811
01:42:08,860 --> 01:42:11,660
somewhere else, to someone else.

1812
01:42:11,660 --> 01:42:18,020
But the channel, the wire, the air is capable of adding so much noise and make

1813
01:42:18,020 --> 01:42:23,780
the sound itself not being capable of understood when you reach the final destination.

1814
01:42:23,780 --> 01:42:29,740
So what we typically do as engineers is implementing a modulation system.

1815
01:42:29,740 --> 01:42:34,020
So a modulation system is just a system that is capable to add some sort of

1816
01:42:34,020 --> 01:42:36,620
transformation to the original wave.

1817
01:42:38,260 --> 01:42:40,700
It basically has two different areas.

1818
01:42:40,740 --> 01:42:44,100
One's for modulating and one's for demodulating.

1819
01:42:44,100 --> 01:42:49,180
So you take the original wave, you modulate it, you get the modulated wave,

1820
01:42:49,180 --> 01:42:55,380
and in order to, let's say, listen the modulated wave, you need to demodulate it.

1821
01:42:56,620 --> 01:42:59,380
So what we are trying to do now is defining this behavior.

1822
01:43:00,700 --> 01:43:04,020
Okay, let's try to define a new class.

1823
01:43:04,020 --> 01:43:05,660
Okay, this class is called modulator.

1824
01:43:07,180 --> 01:43:09,740
Okay, and you have two different methods.

1825
01:43:10,700 --> 01:43:15,300
Modulate and demodulate.

1826
01:43:15,300 --> 01:43:17,900
Okay, first argument is always self.

1827
01:43:28,740 --> 01:43:30,140
So first argument is the self.

1828
01:43:33,460 --> 01:43:37,900
And the second argument, this is the, let's call it information wave.

1829
01:43:37,900 --> 01:43:44,220
Information wave, okay.

1830
01:43:44,220 --> 01:43:48,340
And in order to modulate, in order to apply this kind of transformation to the signal

1831
01:43:48,340 --> 01:43:51,940
that you want to send, you need to have another wave.

1832
01:43:51,940 --> 01:43:55,020
A wave that helps you out to apply this kind of transformation.

1833
01:43:55,020 --> 01:43:57,020
This wave is called modulating wave.

1834
01:43:57,020 --> 01:44:01,820
Modulating, sorry, let's call it carrier wave.

1835
01:44:01,820 --> 01:44:05,820
Okay, and the same applies for demodulate,

1836
01:44:05,820 --> 01:44:09,780
which in turn takes the modulated wave as the input.

1837
01:44:11,500 --> 01:44:12,540
And the carrier wave.

1838
01:44:15,420 --> 01:44:20,020
Okay, wave, okay, pass, oops.

1839
01:44:21,820 --> 01:44:26,900
Okay, so instead of implementing the methods now,

1840
01:44:26,900 --> 01:44:30,140
we are just defining the behavior.

1841
01:44:30,140 --> 01:44:35,340
So we are just defining how this kind of modulation system will work from

1842
01:44:35,340 --> 01:44:36,900
external point of view.

1843
01:44:36,900 --> 01:44:40,340
We are not providing this now, the implementation of the modulation,

1844
01:44:40,340 --> 01:44:45,020
because I did not say which exactly modulation type we are going to use

1845
01:44:45,020 --> 01:44:47,700
to send the signal to your friend.

1846
01:44:47,700 --> 01:44:53,140
So what we can do now is, instead of implementing something, we raise an error.

1847
01:44:54,820 --> 01:44:57,620
Raise, not implemented, okay.

1848
01:44:57,620 --> 01:45:06,540
You need to implement this method before calling.

1849
01:45:06,540 --> 01:45:08,540
You'll understand everything in a while.

1850
01:45:08,540 --> 01:45:09,300
Just stick with me.

1851
01:45:10,980 --> 01:45:14,740
So if the user is going to use the modulator, he's going to get an error,

1852
01:45:14,740 --> 01:45:16,700
because he can't use directly the modulate and

1853
01:45:16,700 --> 01:45:20,020
then the modulate methods, because they are not implemented actually.

1854
01:45:21,540 --> 01:45:27,420
In order to enforce this kind of behavior of this strange class,

1855
01:45:27,420 --> 01:45:32,020
we need to import something from the library of Python itself.

1856
01:45:32,020 --> 01:45:38,380
From ABC, import abstract class method.

1857
01:45:40,220 --> 01:45:41,260
Abstract method, sorry.

1858
01:45:42,300 --> 01:45:47,100
And we can add a decorator over here that this method is called abstract.

1859
01:45:49,580 --> 01:45:55,500
Okay, what we define here is called in other language an interface or a contract.

1860
01:45:55,500 --> 01:46:01,220
You're just saying that, man, a modulation system should implement,

1861
01:46:01,220 --> 01:46:03,580
it should respect this signature.

1862
01:46:03,580 --> 01:46:08,420
But you can call directly this class, so you can create the object,

1863
01:46:08,420 --> 01:46:10,780
the instance of the modulator class and call the modulate and

1864
01:46:10,780 --> 01:46:14,860
the modulate method, because we need to provide some kind of implementation.

1865
01:46:14,860 --> 01:46:18,820
That could be different depending on the kind of modulation

1866
01:46:18,820 --> 01:46:21,660
we're trying to work with, okay?

1867
01:46:21,660 --> 01:46:24,100
So in order to enforce this at, let's say,

1868
01:46:24,100 --> 01:46:27,980
Python level, we added a decorator that comes from the ABC model.

1869
01:46:27,980 --> 01:46:31,380
ABC stands for abstract base class.

1870
01:46:31,380 --> 01:46:34,300
Instead of before, this class is abstract, so

1871
01:46:34,300 --> 01:46:36,340
it does not provide an implementation.

1872
01:46:36,340 --> 01:46:38,020
It cannot be used directly.

1873
01:46:38,020 --> 01:46:41,300
You need to provide some sort of implementation first.

1874
01:46:41,300 --> 01:46:46,420
And we just decorated all these two methods with this nice decorator.

1875
01:46:48,260 --> 01:46:53,340
The simplest modulation system ever is called the amplitude modulation.

1876
01:46:53,340 --> 01:46:57,740
You probably, if you have an old car, you find EM modulation.

1877
01:46:57,740 --> 01:47:00,780
Is the way that you can transform the original signal.

1878
01:47:02,500 --> 01:47:10,740
Let's say mapping the signal itself into variation of the amplitude, okay?

1879
01:47:10,740 --> 01:47:13,740
But there are other ways of modulating signal,

1880
01:47:13,740 --> 01:47:18,060
like the frequency modulation, FM, or the phase modulation, PM.

1881
01:47:19,540 --> 01:47:23,180
Actually, AM is the most simplest form of modulation,

1882
01:47:23,180 --> 01:47:26,660
because it requires very simple device in order to modulate and demodulate.

1883
01:47:26,660 --> 01:47:31,420
While on the other side, FM is much more efficient in terms of span power,

1884
01:47:31,420 --> 01:47:36,540
in terms of, let's say, resistance and resilience to the noise of the channel.

1885
01:47:36,540 --> 01:47:39,140
It could be a wire, it could be the, etc., etc.

1886
01:47:39,140 --> 01:47:41,620
But the amplitude modulation is the simplest form of modulation ever.

1887
01:47:42,900 --> 01:47:47,020
Obviously, we are talking about modulation of analog signal,

1888
01:47:47,020 --> 01:47:51,340
not the digital signal, because we're playing with, let's say, analog,

1889
01:47:51,340 --> 01:47:52,780
with old radio, okay?

1890
01:47:53,260 --> 01:47:56,220
But you can apply all these things to digital signal, but

1891
01:47:56,220 --> 01:47:58,100
obviously this is out of scope.

1892
01:47:58,100 --> 01:48:04,140
So what we need to do now is implementing the amplitude modulator.

1893
01:48:04,140 --> 01:48:09,220
So my amplitude modulator, amplitude modulator, would be a class, okay,

1894
01:48:09,220 --> 01:48:12,700
that extends the modulator, okay?

1895
01:48:12,700 --> 01:48:16,420
And it defines two different methods.

1896
01:48:17,620 --> 01:48:21,100
Okay, I need to remove this one, because it's useless.

1897
01:48:21,140 --> 01:48:24,900
I need to remove this one, this one, this one, okay.

1898
01:48:26,140 --> 01:48:30,300
The modulating method is very, very easy in amplitude modulation,

1899
01:48:30,300 --> 01:48:35,020
because it's just about multiplication between the carrier wave and

1900
01:48:35,020 --> 01:48:36,140
the signal wave.

1901
01:48:36,140 --> 01:48:38,620
So what I can write is this one.

1902
01:48:38,620 --> 01:48:41,900
Information wave, star, carrier wave.

1903
01:48:43,380 --> 01:48:45,780
And the demodulation is basically the same, but

1904
01:48:45,780 --> 01:48:49,860
instead of considering the information wave, you consider the modulated wave.

1905
01:48:49,860 --> 01:48:50,360
Good.

1906
01:48:51,100 --> 01:48:57,500
Okay, so now, let's import something from the Alpers.

1907
01:48:57,500 --> 01:49:05,300
Alpers import, let me see, create audio, okay?

1908
01:49:07,860 --> 01:49:15,140
Create audio, okay, takes a wave.

1909
01:49:15,140 --> 01:49:16,780
So you can provide your own wave, or

1910
01:49:16,780 --> 01:49:19,220
you can provide a sample wave that they sent you.

1911
01:49:19,260 --> 01:49:25,500
And if I run this code, okay, the creative audio is capable of,

1912
01:49:25,500 --> 01:49:26,500
just one moment.

1913
01:49:26,500 --> 01:49:27,980
Buh, buh, buh, buh, buh.

1914
01:49:40,980 --> 01:49:46,060
Sorry, it's not the creative audio, it's the get wave samples,

1915
01:49:46,060 --> 01:49:48,260
get wave samples, okay.

1916
01:49:49,900 --> 01:49:51,180
Okay, good.

1917
01:49:51,180 --> 01:49:54,980
So if you run this code, basically, you are going to use this function that

1918
01:49:54,980 --> 01:49:58,460
is defining the Alpers function called get wave samples.

1919
01:49:58,460 --> 01:50:01,540
You pass the audio that you want to read, and

1920
01:50:01,540 --> 01:50:03,740
this is going to return you some data.

1921
01:50:03,740 --> 01:50:08,700
You remember well, this is the S, this is YS, this is the frame rate, okay?

1922
01:50:08,700 --> 01:50:11,340
So frame rate is this one, just a few words about the frame rate.

1923
01:50:11,340 --> 01:50:14,180
We always play the frame rate of 3,000, okay?

1924
01:50:14,180 --> 01:50:16,460
But in general, for digital signal processing,

1925
01:50:16,460 --> 01:50:22,620
in order to be able to reconstruct the signal after it has been digitalized,

1926
01:50:22,620 --> 01:50:26,820
you need to work with the frequency of frame rate that is at least

1927
01:50:26,820 --> 01:50:30,300
double the frequency of the wave itself.

1928
01:50:30,300 --> 01:50:34,780
So if you know that our voice stands from 20 hertz or 20 kilohertz,

1929
01:50:34,780 --> 01:50:38,060
the frame rate is higher than the double.

1930
01:50:38,060 --> 01:50:42,940
So this is a very typical value, okay, because it's able to,

1931
01:50:42,940 --> 01:50:45,460
let's say, handling all the voice, just all the voice.

1932
01:50:45,460 --> 01:50:48,380
This would be maybe not sufficient for all the music.

1933
01:50:48,380 --> 01:50:51,980
So for example, if you work with this frame rate with the music,

1934
01:50:51,980 --> 01:50:56,300
you could lose, for example, some components in term of frequency.

1935
01:50:56,300 --> 01:50:59,740
And maybe you can sound your song in a different way.

1936
01:50:59,740 --> 01:51:04,020
But for voices, this frame rate is pretty good.

1937
01:51:04,020 --> 01:51:07,660
So this function is able to read the wave and get the array of YS,

1938
01:51:07,660 --> 01:51:10,740
the array of TS, as well as the frame rate.

1939
01:51:10,740 --> 01:51:19,180
So TS, YS, frame rate.

1940
01:51:21,660 --> 01:51:22,420
Okay, this one.

1941
01:51:23,900 --> 01:51:25,140
Perfect.

1942
01:51:25,140 --> 01:51:28,700
So we can create, for example, the wave, okay.

1943
01:51:28,700 --> 01:51:30,340
TS, oh, sorry.

1944
01:51:30,340 --> 01:51:34,660
YS, TS, frame rate, okay?

1945
01:51:35,900 --> 01:51:38,660
So we just created the instance of our wave.

1946
01:51:38,660 --> 01:51:39,580
Nothing complicated.

1947
01:51:40,580 --> 01:51:44,220
Okay, so this is our information wave.

1948
01:51:44,220 --> 01:51:47,900
So information wave is this one.

1949
01:51:47,900 --> 01:51:49,340
We need a carrier wave.

1950
01:51:49,340 --> 01:51:52,140
A carrier wave is another wave.

1951
01:51:52,140 --> 01:51:53,540
Carrier wave, okay.

1952
01:51:54,660 --> 01:51:56,060
So let's start from signal.

1953
01:51:57,380 --> 01:52:00,300
Let's consider, for example, a frequency of,

1954
01:52:03,060 --> 01:52:08,700
let's put the, for example, 100,000, yeah, 100,000 hertz.

1955
01:52:08,740 --> 01:52:10,100
Okay, that's good.

1956
01:52:10,100 --> 01:52:11,300
Call the method create wave.

1957
01:52:15,580 --> 01:52:19,100
Okay, so the carrier wave is another wave.

1958
01:52:20,620 --> 01:52:21,260
Everything clear?

1959
01:52:22,820 --> 01:52:23,320
Perfect.

1960
01:52:24,540 --> 01:52:29,340
So now we are going to use our modulation system.

1961
01:52:29,340 --> 01:52:32,740
So we create the instance of the amplitude modulator.

1962
01:52:32,740 --> 01:52:37,780
Look, the amplitude modulator, not the modulator abstract base class over here.

1963
01:52:37,780 --> 01:52:41,220
The implementation of the contract.

1964
01:52:41,220 --> 01:52:44,180
And we can call, obviously, the modulator, okay?

1965
01:52:45,220 --> 01:52:48,220
If you call, for example, the modulator, what do you get?

1966
01:52:48,220 --> 01:52:52,500
You pass the information wave and the carrier wave.

1967
01:52:54,620 --> 01:52:55,740
And you execute this code.

1968
01:52:55,740 --> 01:52:56,240
Good.

1969
01:52:57,740 --> 01:52:59,300
You get the seller.

1970
01:52:59,300 --> 01:53:03,460
Unsupported operand four star, wave.wave.

1971
01:53:03,460 --> 01:53:08,580
But the main issue is that how Python can know how exactly

1972
01:53:08,580 --> 01:53:10,940
it will be able to multiplicate waves.

1973
01:53:12,180 --> 01:53:14,780
You can expect that Python knows how to multiplicate flaws,

1974
01:53:14,780 --> 01:53:18,060
integers, maybe strings, I don't know, but now waves.

1975
01:53:19,780 --> 01:53:22,380
Because there is no concept of wave multiplication.

1976
01:53:22,380 --> 01:53:26,540
So we need to instruct Python to do this kind of operation.

1977
01:53:27,660 --> 01:53:31,180
And in order to do this, what we need to do?

1978
01:53:31,180 --> 01:53:33,100
We need to define another class.

1979
01:53:33,900 --> 01:53:38,900
The class we need to define is called, for example, let me put here.

1980
01:53:38,900 --> 01:53:39,900
Blah, blah, blah.

1981
01:53:43,460 --> 01:53:46,140
Okay, let's define for example a new class.

1982
01:53:46,140 --> 01:53:48,060
Class wave with mall.

1983
01:53:49,460 --> 01:53:54,940
Okay, so this is a class that basically implements the multiplication logic

1984
01:53:54,940 --> 01:53:56,580
that we see in a while.

1985
01:53:56,580 --> 01:54:00,820
That obviously, in reads from the wave, because we know that this is still a wave.

1986
01:54:00,860 --> 01:54:05,700
So we just need behavior, but can change the original code.

1987
01:54:05,700 --> 01:54:06,540
That's fine.

1988
01:54:06,540 --> 01:54:09,100
And the method we are going to implement is called mall.

1989
01:54:10,700 --> 01:54:12,100
Okay, solve.

1990
01:54:12,100 --> 01:54:15,820
And the only parameter that takes these methods is the other wave.

1991
01:54:15,820 --> 01:54:18,100
Okay, let's look at this definition.

1992
01:54:19,900 --> 01:54:21,500
We created a new class.

1993
01:54:21,500 --> 01:54:25,540
In everything from the wave, because we still know that the wave with mall is

1994
01:54:25,540 --> 01:54:26,060
still a wave.

1995
01:54:27,020 --> 01:54:32,860
With a finite method, we start with the double underscored that is called mall.

1996
01:54:32,860 --> 01:54:35,940
Okay, that takes just one parameter, the other.

1997
01:54:37,300 --> 01:54:40,860
Which is basically the second factor in the multiplication.

1998
01:54:40,860 --> 01:54:43,540
So the first factor is self, second one is the other.

1999
01:54:43,540 --> 01:54:44,040
Good.

2000
01:54:45,220 --> 01:54:48,940
If you notice well, mule starts with a double underscore like the unit,

2001
01:54:48,940 --> 01:54:50,380
like the constructor method.

2002
01:54:50,380 --> 01:54:54,460
Which means that this method can be called magic.

2003
01:54:54,460 --> 01:54:55,540
They are reserved.

2004
01:54:55,540 --> 01:54:58,540
They cannot be used for whatever task it is.

2005
01:54:58,540 --> 01:55:04,300
Because Python, when you write a wave with mall star,

2006
01:55:04,300 --> 01:55:07,740
another wave with mall, will execute this method.

2007
01:55:07,740 --> 01:55:10,980
And thus, the multiplication will work magically.

2008
01:55:10,980 --> 01:55:12,500
So the implementation is very easy.

2009
01:55:12,500 --> 01:55:20,100
What we do is just returning a wave, an instance of itself, okay?

2010
01:55:20,100 --> 01:55:29,820
Where you have the self.y s star.other, okay?

2011
01:55:29,820 --> 01:55:37,860
This is s, and so this is self.ts, self.frame rate.

2012
01:55:39,500 --> 01:55:40,540
Okay?

2013
01:55:40,540 --> 01:55:44,420
So the new samples will be just the multiplication of the

2014
01:55:44,500 --> 01:55:50,340
left factor multiplication, y s, and self.other.y s, sorry.

2015
01:55:52,820 --> 01:55:54,820
This one is wrong, y s.

2016
01:55:56,740 --> 01:55:58,300
The argument, dot y s.

2017
01:55:58,300 --> 01:56:00,380
So you take the, those array, you multiply it down.

2018
01:56:01,540 --> 01:56:05,820
Obviously, multiplication between array is not defined by Python.

2019
01:56:05,820 --> 01:56:09,300
But if you are going, if we use numpy,

2020
01:56:09,300 --> 01:56:13,740
in numpy someone defined the operation of multiplication.

2021
01:56:13,740 --> 01:56:17,300
So someone in numpy has implemented the same way of

2022
01:56:17,300 --> 01:56:19,860
multiplicating waves, by just under the hoods.

2023
01:56:21,540 --> 01:56:24,140
So if you run this code, yeah, let me check, is it correct?

2024
01:56:30,460 --> 01:56:35,980
Yes, so if you run this code, you get this one.

2025
01:56:37,300 --> 01:56:41,780
The main problem is that the, let me see, just one moment.

2026
01:56:41,900 --> 01:56:46,860
Yeah, the main problem is that the information wave is a web

2027
01:56:46,860 --> 01:56:50,780
instance, it's not a wave with mall instance.

2028
01:56:50,780 --> 01:56:53,780
So we need to transform it.

2029
01:56:53,780 --> 01:56:58,460
You could obviously change this signature in order to add

2030
01:56:58,460 --> 01:57:00,540
the wave with mall instead of calling wave.

2031
01:57:00,540 --> 01:57:02,500
But we are going to see another way.

2032
01:57:03,700 --> 01:57:06,900
Let's go back to our implementation of wave with mall.

2033
01:57:06,900 --> 01:57:10,900
Okay, let's define a new method that is called, for example, convert.

2034
01:57:12,620 --> 01:57:17,500
Okay, convert, so, okay.

2035
01:57:17,500 --> 01:57:22,780
But this time, instead of passing the instance as the first argument,

2036
01:57:22,780 --> 01:57:26,820
we are going to pass another object, an object that is totally different,

2037
01:57:26,820 --> 01:57:29,860
an object that is wave, okay?

2038
01:57:29,860 --> 01:57:33,300
So instead of passing the self, like we always do,

2039
01:57:33,300 --> 01:57:36,260
we pass the wave, which is another object.

2040
01:57:36,260 --> 01:57:41,180
So this method will return an instance of wave with mall,

2041
01:57:41,780 --> 01:57:47,780
okay, where you have the ys equals to wave ys,

2042
01:57:47,780 --> 01:57:52,780
ts, wave ts, and frame rate,

2043
01:57:52,780 --> 01:57:57,780
frame rate, wave, frame rate.

2044
01:58:06,780 --> 01:58:10,980
Okay, so we're basically accepting an instance of type wave.

2045
01:58:11,780 --> 01:58:18,060
An instance of type wave, okay?

2046
01:58:19,700 --> 01:58:23,180
And returning an instance of type with mall with this strange method that

2047
01:58:23,180 --> 01:58:26,780
does not accept self as parameter, so distance.

2048
01:58:26,780 --> 01:58:29,420
A method like this is called static.

2049
01:58:31,220 --> 01:58:35,780
And in order to let Python know that this method behaves differently from

2050
01:58:35,780 --> 01:58:39,060
other ones, we need to add another annotation.

2051
01:58:39,060 --> 01:58:40,620
Sorry, another decorator.

2052
01:58:40,620 --> 01:58:43,620
The decorator is the static method.

2053
01:58:43,620 --> 01:58:47,500
Okay, if you execute this code, you got no errors.

2054
01:58:47,500 --> 01:58:54,500
So we provide a static method that does not depend on the context of the object.

2055
01:58:54,500 --> 01:58:59,420
This takes in place the only task of converting an incoming

2056
01:58:59,420 --> 01:59:04,380
wave instance to itself, to an instance of itself, basically.

2057
01:59:04,380 --> 01:59:08,380
This is not very mandatory, you know, because we could have changed just

2058
01:59:08,380 --> 01:59:11,900
the definition of rear, okay?

2059
01:59:11,900 --> 01:59:15,460
The definition of rear, because we know that wave away with mall,

2060
01:59:15,460 --> 01:59:20,100
aside from defining the mall methods, are basically the same.

2061
01:59:20,100 --> 01:59:21,060
It's basically the same.

2062
01:59:21,060 --> 01:59:24,620
So if you can call the constructor passing the wave with mall,

2063
01:59:24,620 --> 01:59:25,820
everything is gonna work.

2064
01:59:25,820 --> 01:59:30,260
But in order to make you aware of the fact that there are other kinds of

2065
01:59:30,260 --> 01:59:33,820
type of methods that Python supports, this is static one.

2066
01:59:33,820 --> 01:59:37,220
This is typically usage of a static method.

2067
01:59:37,220 --> 01:59:40,300
Convert something into other one.

2068
01:59:40,300 --> 01:59:45,420
Because if you think about it, it's a static because it does not depend

2069
01:59:45,420 --> 01:59:47,660
of the state of the object itself.

2070
01:59:47,660 --> 01:59:49,620
It's some sort of an upper method.

2071
01:59:49,620 --> 01:59:52,180
It helps you just to map one thing to another one.

2072
01:59:53,420 --> 01:59:56,060
So if you run the code, okay.

2073
01:59:57,780 --> 01:59:59,940
So we need to adapt, obviously, this code.

2074
01:59:59,940 --> 02:00:04,740
Because now we need to call wave with mall, okay?

2075
02:00:04,780 --> 02:00:08,180
We call it the convert, okay?

2076
02:00:08,180 --> 02:00:11,540
We pass the information wave, okay?

2077
02:00:11,540 --> 02:00:17,220
And this is the information wave with mall, okay.

2078
02:00:17,220 --> 02:00:17,900
Sorry for the name.

2079
02:00:19,020 --> 02:00:20,380
Okay, we do the same here.

2080
02:00:21,900 --> 02:00:22,940
I know, sorry, one moment.

2081
02:00:24,260 --> 02:00:26,420
Okay, let's see this object.

2082
02:00:27,620 --> 02:00:29,700
Just to see if it's correct.

2083
02:00:29,700 --> 02:00:34,660
Okay, so this is an instance of main wave with mall.

2084
02:00:35,420 --> 02:00:38,460
So we need to do the same with the carrier wave.

2085
02:00:41,220 --> 02:00:47,180
With mall equals this one.

2086
02:00:48,780 --> 02:00:51,100
But instead of this one, this one, okay?

2087
02:00:52,500 --> 02:00:54,580
Okay, so if you run the modulation now.

2088
02:00:54,580 --> 02:01:04,580
You need to adapt this one with this one.

2089
02:01:08,340 --> 02:01:09,860
They're different, yeah, that's correct.

2090
02:01:12,860 --> 02:01:13,860
Signal.

2091
02:01:13,860 --> 02:01:21,980
Okay, because the duration.

2092
02:01:25,180 --> 02:01:31,900
Yeah, okay, sorry, one moment.

2093
02:01:33,900 --> 02:01:34,900
Duration.

2094
02:01:38,660 --> 02:01:40,020
Now they got different shape.

2095
02:01:44,220 --> 02:01:45,220
Let me see.

2096
02:01:55,580 --> 02:01:56,580
Just one moment.

2097
02:01:56,580 --> 02:01:59,580
Boom, boom, boom, boom.

2098
02:01:59,580 --> 02:02:23,580
Okay, create wave.

2099
02:02:29,580 --> 02:02:32,580
What's the issue?

2100
02:02:32,580 --> 02:02:33,580
Mm-hm.

2101
02:02:37,580 --> 02:02:38,580
Wave with mall.

2102
02:02:54,580 --> 02:02:55,580
Okay, that's fine.

2103
02:02:55,580 --> 02:02:56,580
That's fine.

2104
02:02:56,580 --> 02:03:02,060
Okay, we obviously need to have some constraints between the carrier wave and

2105
02:03:02,060 --> 02:03:05,340
the information wave, so we can just create a carrier wave from scratch.

2106
02:03:05,340 --> 02:03:07,580
We need to be sure that the direction is the same, and

2107
02:03:07,580 --> 02:03:10,100
also the frame rate is the same, otherwise the operation of

2108
02:03:10,100 --> 02:03:14,620
multiplicating waves doesn't work because they got different sides in terms of values.

2109
02:03:14,620 --> 02:03:15,380
So that was the issue.

2110
02:03:15,380 --> 02:03:20,380
So if I execute this code, I got this one, okay?

2111
02:03:20,380 --> 02:03:23,460
The obviously an instance of wave with mall, so

2112
02:03:23,460 --> 02:03:27,460
the modulate function is returning a wave with mall.

2113
02:03:27,460 --> 02:03:34,460
Modulated wave, okay, and if you modulated wave.plot.

2114
02:03:34,460 --> 02:03:39,460
Okay, fantastic.

2115
02:03:39,460 --> 02:03:40,460
It's totally wrong.

2116
02:03:40,460 --> 02:03:42,460
Now let me see, just one moment.

2117
02:03:53,460 --> 02:03:54,460
Okay, now this is wrong.

2118
02:03:54,460 --> 02:03:57,460
The ration.

2119
02:03:57,460 --> 02:04:08,460
Yes, okay, that's fine.

2120
02:04:23,460 --> 02:04:33,460
Okay.

2121
02:04:33,460 --> 02:04:35,460
Yeah, just let me, just one moment.

2122
02:04:35,460 --> 02:04:45,460
Sorry?

2123
02:04:45,460 --> 02:04:51,460
No,

2124
02:04:51,460 --> 02:05:03,460
it should be okay this one.

2125
02:05:03,460 --> 02:05:11,460
Yes, here?

2126
02:05:11,460 --> 02:05:14,460
No.

2127
02:05:14,460 --> 02:05:22,460
Okay, here.

2128
02:05:22,460 --> 02:05:30,460
Okay, let me see.

2129
02:05:30,460 --> 02:05:35,460
No, just one moment.

2130
02:05:35,460 --> 02:05:37,460
Okay.

2131
02:05:37,460 --> 02:05:41,460
So information wave.

2132
02:05:41,460 --> 02:05:48,460
Okay.

2133
02:05:48,460 --> 02:05:58,460
Okay, now let's go.

2134
02:05:58,460 --> 02:06:02,460
Okay, was messing up with the, yeah,

2135
02:06:02,460 --> 02:06:07,460
the constraint between the carrier wave and the zero wave.

2136
02:06:07,460 --> 02:06:11,460
So what you basically learned is that,

2137
02:06:11,460 --> 02:06:13,460
okay, was messing up with the, yeah,

2138
02:06:13,460 --> 02:06:17,460
the constraint between the carrier wave and the zero wave.

2139
02:06:17,460 --> 02:06:19,460
So what you basically have to do, I will see,

2140
02:06:19,460 --> 02:06:23,460
just look at this one, you see something that the amplitude,

2141
02:06:23,460 --> 02:06:27,460
okay, is varying in according to the same function.

2142
02:06:27,460 --> 02:06:31,460
So it basically, the amplitude modulation shapes the information

2143
02:06:31,460 --> 02:06:34,460
it needs to send in according to the carrier wave,

2144
02:06:34,460 --> 02:06:35,460
which was the same.

2145
02:06:35,460 --> 02:06:38,460
And you see that basically here you got this something like that

2146
02:06:38,460 --> 02:06:40,460
looks like the same, obviously.

2147
02:06:40,460 --> 02:06:42,460
It's not the same, actually.

2148
02:06:42,460 --> 02:06:44,460
So this was the example.

2149
02:06:44,460 --> 02:06:49,460
And if you plot this now, if you remember the first part

2150
02:06:49,460 --> 02:06:53,460
of the introduction, I say that time to time is better to look

2151
02:06:53,460 --> 02:06:58,460
at the wave in the frequency domain, not in the time domain.

2152
02:06:58,460 --> 02:07:00,460
So if instead of calling the plot method,

2153
02:07:00,460 --> 02:07:05,460
you call the plot full FFT methods, okay,

2154
02:07:05,460 --> 02:07:08,460
you see basically this one, which is in this case

2155
02:07:08,460 --> 02:07:12,460
is the spectrum of the modulated wave,

2156
02:07:12,460 --> 02:07:15,460
actually the full one.

2157
02:07:15,460 --> 02:07:19,460
Okay, if you want to demodulate it, okay,

2158
02:07:19,460 --> 02:07:25,460
you can demodulate the wave, okay.

2159
02:07:25,460 --> 02:07:28,460
So let me take this one.

2160
02:07:28,460 --> 02:07:33,460
Amplitude.

2161
02:07:33,460 --> 02:07:38,460
Modulator, okay.

2162
02:07:42,460 --> 02:07:49,460
And the, sorry, first function is demodulate this one,

2163
02:07:49,460 --> 02:07:54,460
carrier wave.

2164
02:07:54,460 --> 02:07:59,460
Okay.

2165
02:07:59,460 --> 02:08:04,460
Plot.

2166
02:08:11,460 --> 02:08:14,460
Okay, and there was the original signal.

2167
02:08:14,460 --> 02:08:19,460
So what is basically needs to be understood is just as the part

2168
02:08:19,460 --> 02:08:23,460
about signal processing, but the part about defining class.

2169
02:08:23,460 --> 02:08:27,460
We start in defining an interface, a contract,

2170
02:08:27,460 --> 02:08:31,460
a template, something that cannot be directly used

2171
02:08:31,460 --> 02:08:35,460
because it's abstract, okay, and you can read it just

2172
02:08:35,460 --> 02:08:37,460
because we decorated all the methods,

2173
02:08:37,460 --> 02:08:40,460
adding the abstract method decorator.

2174
02:08:40,460 --> 02:08:44,460
So the user cannot use obviously this one,

2175
02:08:44,460 --> 02:08:49,460
but is forced to implement demodulator abstract by class,

2176
02:08:49,460 --> 02:08:52,460
providing for example the amplitude modulator,

2177
02:08:52,460 --> 02:08:55,460
which is just a way of modulating things.

2178
02:08:55,460 --> 02:08:59,460
So obviously the signature of the implementation

2179
02:08:59,460 --> 02:09:02,460
should be the same, needs to be the same

2180
02:09:02,460 --> 02:09:05,460
of the one defined in the abstract class.

2181
02:09:05,460 --> 02:09:10,460
And once you do this one, you can obviously play with the code

2182
02:09:10,460 --> 02:09:12,460
and get this one.

2183
02:09:12,460 --> 02:09:15,460
At the same point, we notice that we don't know how exactly

2184
02:09:15,460 --> 02:09:18,460
to multiply waves together.

2185
02:09:18,460 --> 02:09:20,460
Just one moment.

2186
02:09:20,460 --> 02:09:22,460
Multiply them together.

2187
02:09:22,460 --> 02:09:25,460
So we can apply a new instance of the wave with mall

2188
02:09:25,460 --> 02:09:28,460
with a cost-adding method capable of converting

2189
02:09:28,460 --> 02:09:32,460
an existing wave to a wave with mall method.

2190
02:09:32,460 --> 02:09:37,460
And then after that, what we need to do is just

2191
02:09:37,460 --> 02:09:40,460
instantiating the object over here,

2192
02:09:40,460 --> 02:09:44,460
call the modulator providing the converted version of the wave,

2193
02:09:44,460 --> 02:09:47,460
converted version of the carrier wave,

2194
02:09:47,460 --> 02:09:50,460
and then get back to using the demodulator.

2195
02:09:50,460 --> 02:09:52,460
Please.

2196
02:09:52,460 --> 02:10:13,460
Yeah, you can find it in the classes module as well.

2197
02:10:22,460 --> 02:10:25,460
Yeah, sure, sure, sure.

2198
02:10:25,460 --> 02:10:28,460
But in the context of object-oriented programming,

2199
02:10:28,460 --> 02:10:31,460
let's say you are not free to use functions

2200
02:10:31,460 --> 02:10:33,460
that are not related to objects.

2201
02:10:33,460 --> 02:10:35,460
So this is the issue.

2202
02:10:35,460 --> 02:10:37,460
So if you play with Java, you cannot define, for example,

2203
02:10:37,460 --> 02:10:40,460
functions that are not dependent on objects or classes.

2204
02:10:40,460 --> 02:10:43,460
Okay, so for this reason, we code it this way.

2205
02:10:43,460 --> 02:10:46,460
But yes, you can code a function, a general function,

2206
02:10:46,460 --> 02:10:49,460
in some sort of a model that takes an object and converts it.

2207
02:10:49,460 --> 02:10:54,460
We saw in this implementation declined in the object-oriented paradigm.

2208
02:10:54,460 --> 02:10:56,460
This is the issue.

2209
02:10:56,460 --> 02:10:59,460
So you can do whatever you want, but this is the, let's say,

2210
02:10:59,460 --> 02:11:03,460
the right way to do with objects in the object-oriented programming.

2211
02:11:03,460 --> 02:11:06,460
So in Java, your solution won't work, for example,

2212
02:11:06,460 --> 02:11:10,460
because Java is somehow pure.

2213
02:11:10,460 --> 02:11:12,460
Okay, thank you.

2214
02:11:12,460 --> 02:11:14,460
So the exercise.

2215
02:11:14,460 --> 02:11:18,460
Other questions?

2216
02:11:18,460 --> 02:11:23,460
Okay, so part three of the exercise.

2217
02:11:26,460 --> 02:11:32,460
Okay, in the classes module, you'll find a filter class.

2218
02:11:32,460 --> 02:11:34,460
A filter class is an interface.

2219
02:11:34,460 --> 02:11:36,460
It's not a class, so you can't use it directly.

2220
02:11:36,460 --> 02:11:40,460
What you need to do is implementing the high-pass filtering,

2221
02:11:40,460 --> 02:11:44,460
which is basically is a filter that is capable of cutting off

2222
02:11:44,460 --> 02:11:49,460
all the components, okay, greater than a threshold.

2223
02:11:49,460 --> 02:11:51,460
So if you go back, for example, to the spectrum,

2224
02:11:51,460 --> 02:11:56,460
so you have the spectrum on the x-axis and the value of the power on the y-axis,

2225
02:11:56,460 --> 02:12:00,460
an high-pass filter removes part of the spectrum, okay,

2226
02:12:00,460 --> 02:12:03,460
starting from a cutoff frequency.

2227
02:12:03,460 --> 02:12:06,460
So your first exercise would be look at the filter interface

2228
02:12:06,460 --> 02:12:12,460
I defined in the classes and implement the high-pass filtering method.

2229
02:12:12,460 --> 02:12:17,460
Second part of the exercise would be more complex, okay, it requires time.

2230
02:12:17,460 --> 02:12:19,460
So I'm not expecting that you can fix it.

2231
02:12:19,460 --> 02:12:21,460
You can solve it now, okay.

2232
02:12:21,460 --> 02:12:27,460
But what you basically have to do is this one.

2233
02:12:27,460 --> 02:12:29,460
I want to explain it.

2234
02:12:29,460 --> 02:12:32,460
This one is the wave in the frequency domain, the original wave.

2235
02:12:32,460 --> 02:12:35,460
So it's the signal that you want to send.

2236
02:12:35,460 --> 02:12:36,460
Good.

2237
02:12:36,460 --> 02:12:43,460
Once you modulate, you get this one, which is the same signal,

2238
02:12:43,460 --> 02:12:47,460
but you got a really bad product of amplitude modulation,

2239
02:12:47,460 --> 02:12:50,460
which is of course sidebands for replicas.

2240
02:12:50,460 --> 02:12:54,460
You see, those are basically the same as this, but they are being scalded.

2241
02:12:54,460 --> 02:12:59,460
Okay, this is a problem for just one issue because they consume so much power, okay,

2242
02:12:59,460 --> 02:13:02,460
that you can try to, let's say, avoid when you're sending

2243
02:13:02,460 --> 02:13:05,460
because you want to reduce the amount of power sent.

2244
02:13:05,460 --> 02:13:11,460
So your implementation, okay, and after you get back to the modulation,

2245
02:13:11,460 --> 02:13:13,460
you should have something like this,

2246
02:13:13,460 --> 02:13:17,460
which should be something like the signal you sent at the very beginning.

2247
02:13:17,460 --> 02:13:25,460
So the implementation, the task would be doing this.

2248
02:13:25,460 --> 02:13:30,460
Implementing an amplitude modulation with low-pass filtering.

2249
02:13:30,460 --> 02:13:32,460
That overrides the demodulate,

2250
02:13:32,460 --> 02:13:36,460
so you need to implement the modulator interface again, basically.

2251
02:13:36,460 --> 02:13:42,460
But you are not happy with the demodulation method that I provided to you.

2252
02:13:42,460 --> 02:13:46,460
So you need to override that method in the amplitude modulator,

2253
02:13:46,460 --> 02:13:49,460
not in the units, but in the class.

2254
02:13:49,460 --> 02:13:52,460
The new implementation should remove the sidebands,

2255
02:13:52,460 --> 02:13:55,460
so the bands that are laterally, okay.

2256
02:13:55,460 --> 02:13:59,460
And this modulated wave, okay, sorry,

2257
02:13:59,460 --> 02:14:05,460
these sidebands are totally useless when the wave reaches the destination.

2258
02:14:05,460 --> 02:14:10,460
Talking in code, did you understand the domain problem?

2259
02:14:10,460 --> 02:14:13,460
Or I'm going to repeat it.

2260
02:14:13,460 --> 02:14:15,460
I take a yes.

2261
02:14:15,460 --> 02:14:17,460
But by the way, if you did not understand the domain problem,

2262
02:14:17,460 --> 02:14:19,460
I try to rephrase it again.

2263
02:14:19,460 --> 02:14:24,460
Talking in code, you need to call the original demodulate method

2264
02:14:24,460 --> 02:14:28,460
of the existing amplitude modulator.

2265
02:14:28,460 --> 02:14:31,460
But you need to add something.

2266
02:14:31,460 --> 02:14:33,460
You need to add the filter part.

2267
02:14:33,460 --> 02:14:37,460
In order to add the filter part, you need to, first of all,

2268
02:14:37,460 --> 02:14:40,460
convert the wave to the spectrum.

2269
02:14:40,460 --> 02:14:43,460
At the very beginning, we saw that you got a wave in time domain.

2270
02:14:43,460 --> 02:14:48,460
You can get, using some custom function, the spectrum,

2271
02:14:48,460 --> 02:14:51,460
which is the same wave, but in the frequency domain.

2272
02:14:51,460 --> 02:14:56,460
So instead of considering the independent variable as the T, it's the X.

2273
02:14:56,460 --> 02:15:01,460
Once you compute the spectrum, okay, you can define, sorry,

2274
02:15:01,460 --> 02:15:04,460
these instance of the spectrum after you call this method,

2275
02:15:04,460 --> 02:15:07,460
basically are these fields, which is very similar to the wave one,

2276
02:15:07,460 --> 02:15:10,460
HS, FS, and frame rate.

2277
02:15:10,460 --> 02:15:15,460
And when you do this, so when you have the spectrum,

2278
02:15:15,460 --> 02:15:18,460
you can import the low-pass filter.

2279
02:15:18,460 --> 02:15:21,460
This has been already implemented to you, that implements the filter.

2280
02:15:21,460 --> 02:15:26,460
Call the make wave after filtering has been applied, and

2281
02:15:26,460 --> 02:15:31,460
then you should get the original representation of the wave.

2282
02:15:33,460 --> 02:15:36,460
So first part is very easy.

2283
02:15:36,460 --> 02:15:40,460
Take the filter interface, define in the classes file, and

2284
02:15:40,460 --> 02:15:44,460
implement a version of high-pass filtering, okay?

2285
02:15:44,460 --> 02:15:48,460
Obviously, in the upper side, you find the high-pass function, so

2286
02:15:48,460 --> 02:15:50,460
you cannot just write it, okay?

2287
02:15:50,460 --> 02:15:53,460
You need just to import it, it should be easy.

2288
02:15:53,460 --> 02:15:57,460
Second part is not very easy, because you need to understand the domain

2289
02:15:57,460 --> 02:15:59,460
problem first, and then apply it later.

2290
02:15:59,460 --> 02:16:01,460
By the way, I'm here to the conference, so

2291
02:16:01,460 --> 02:16:04,460
if you wanna solve it, we can obviously discuss maybe later.

2292
02:16:04,460 --> 02:16:09,460
But as always, you find the implementation inside the solutions file.

2293
02:16:09,460 --> 02:16:14,460
Okay, you got 30 minutes.

2294
02:16:21,460 --> 02:16:23,460
So be focused on the first part of the exercise.

2295
02:16:23,460 --> 02:16:27,460
The second part, we can discuss maybe later if the domain problem is not clear.

2296
02:16:30,460 --> 02:16:31,460
Yeah.

2297
02:16:39,460 --> 02:16:44,460
Okay.

2298
02:17:09,460 --> 02:17:14,460
Okay.

2299
02:17:39,460 --> 02:17:44,460
Okay.

2300
02:18:09,460 --> 02:18:14,460
Okay.

2301
02:18:39,460 --> 02:18:44,460
Okay.

2302
02:19:09,460 --> 02:19:14,460
Okay.

2303
02:19:39,460 --> 02:19:44,460
Okay.

2304
02:20:09,460 --> 02:20:14,460
Okay.

2305
02:20:39,460 --> 02:20:44,460
Okay.

2306
02:21:09,460 --> 02:21:14,460
Okay.

2307
02:21:14,460 --> 02:21:18,460
Okay.

2308
02:21:18,460 --> 02:21:21,460
We are first before getting to code.

2309
02:21:33,460 --> 02:21:34,460
Yeah.

2310
02:21:34,460 --> 02:21:39,460
Where is it?

2311
02:21:39,460 --> 02:21:42,460
In the classes, classes module.

2312
02:21:42,460 --> 02:21:45,460
From classes, import filter.

2313
02:21:45,460 --> 02:21:47,460
Thank you.

2314
02:22:04,460 --> 02:22:09,460
Okay.

2315
02:22:34,460 --> 02:22:39,460
Okay.

2316
02:22:39,460 --> 02:22:44,460
Okay.

2317
02:22:44,460 --> 02:22:49,460
Okay.

2318
02:22:49,460 --> 02:22:54,460
Okay.

2319
02:22:54,460 --> 02:22:59,460
Okay.

2320
02:22:59,460 --> 02:23:04,460
Okay.

2321
02:23:04,460 --> 02:23:09,460
Okay.

2322
02:23:09,460 --> 02:23:14,460
Okay.

2323
02:23:14,460 --> 02:23:19,460
Okay.

2324
02:23:19,460 --> 02:23:24,460
Okay.

2325
02:23:24,460 --> 02:23:29,460
Okay.

2326
02:23:29,460 --> 02:23:34,460
Okay.

2327
02:23:34,460 --> 02:23:39,460
Okay.

2328
02:23:39,460 --> 02:23:44,460
Okay.

2329
02:23:44,460 --> 02:23:49,460
Okay.

2330
02:23:49,460 --> 02:23:54,460
Okay.

2331
02:23:54,460 --> 02:23:59,460
Okay.

2332
02:23:59,460 --> 02:24:04,460
Okay.

2333
02:24:04,460 --> 02:24:09,460
Okay.

2334
02:24:09,460 --> 02:24:14,460
Okay.

2335
02:24:14,460 --> 02:24:19,460
Okay.

2336
02:24:19,460 --> 02:24:24,460
Okay.

2337
02:24:24,460 --> 02:24:29,460
Okay.

2338
02:24:29,460 --> 02:24:34,460
Okay.

2339
02:24:34,460 --> 02:24:39,460
Okay.

2340
02:24:39,460 --> 02:24:44,460
Okay.

2341
02:24:44,460 --> 02:24:49,460
Okay.

2342
02:24:49,460 --> 02:24:54,460
For the second part, if you, I repeat, if you want to solve it, you need to be sure you understand the domain problem first.

2343
02:24:54,460 --> 02:24:57,460
And then talking about the code.

2344
02:24:57,460 --> 02:25:01,460
So if you want to have some doubts, we can obviously discuss maybe privately.

2345
02:25:01,460 --> 02:25:06,460
I just, I didn't, I know that this issue was, sorry, this problem was a bit more complex.

2346
02:25:06,460 --> 02:25:11,460
Okay.

2347
02:25:11,460 --> 02:25:16,460
So this leads us to the final part of our, of our crash course in object-oriented programming.

2348
02:25:16,460 --> 02:25:21,460
There is one more thing that you need to know to getting start with object-oriented programming.

2349
02:25:21,460 --> 02:25:26,460
Is the concept of design patterns.

2350
02:25:26,460 --> 02:25:31,460
Design patterns are solutions to recurrent problems.

2351
02:25:32,460 --> 02:25:37,460
Which means that when you play with object-oriented programming, you have grasped that it's all about defining class,

2352
02:25:37,460 --> 02:25:42,460
establishing relation between them, override methods, call supermetals, whatever.

2353
02:25:42,460 --> 02:25:47,460
You can't reinvent the wheel in order to solve something.

2354
02:25:47,460 --> 02:25:52,460
So there are these standardized solutions that help you work with object-oriented programming in a very standardized way.

2355
02:25:52,460 --> 02:25:57,460
So there are these standardized solutions that help you work with object-oriented programming in a very standardized way.

2356
02:25:57,460 --> 02:26:02,460
I want to stress you out about the fact that it would be maybe much easier to reinvent the wheel all again in order to play with objects.

2357
02:26:02,460 --> 02:26:07,460
I want to stress you out about the fact that it would be maybe much easier to reinvent the wheel all again in order to play with objects.

2358
02:26:07,460 --> 02:26:12,460
But this probably is a design pattern that have been designed and proved to be correct, proved to be scalable,

2359
02:26:12,460 --> 02:26:17,460
proved to be very interesting, very smart, okay, for solving your own issue.

2360
02:26:17,460 --> 02:26:22,460
But we're going to see an example now.

2361
02:26:22,460 --> 02:26:26,460
Design patterns are typically divided into three main categories.

2362
02:26:26,460 --> 02:26:31,460
Design patterns creationals that deals with creation of object.

2363
02:26:31,460 --> 02:26:36,460
If you remember well, at the very beginning, we defined a constructor with four different parameters,

2364
02:26:36,460 --> 02:26:41,460
Sorry, four different parameters, amplitude, phase, frequency, periodic function.

2365
02:26:41,460 --> 02:26:46,460
But it's a very, I don't like that much, that kind of implementation.

2366
02:26:47,460 --> 02:26:52,460
Because if your model obviously evolves and evolves and evolves,

2367
02:26:52,460 --> 02:26:57,460
you can end up obviously adding more elements of the constructor signature as well as

2368
02:26:57,460 --> 02:27:02,460
obviously implementing classes that in a risk from the previous implementation.

2369
02:27:02,460 --> 02:27:07,460
That's fine. But there are some design patterns that we play with objects in order to make,

2370
02:27:07,460 --> 02:27:12,460
to make their list of parameters not fixed at all and be ready to evolve.

2371
02:27:12,460 --> 02:27:17,460
So we reinvented the wheel, defining four different parameters in the constructor,

2372
02:27:17,460 --> 02:27:22,460
but we didn't know nothing about design patterns.

2373
02:27:22,460 --> 02:27:27,460
Behavioral pattern deals with how object behaves from the outside.

2374
02:27:27,460 --> 02:27:32,460
So suppose you want to hide some business logic, okay?

2375
02:27:32,460 --> 02:27:37,460
Okay, like the one we did for example, the serialize.

2376
02:27:37,460 --> 02:27:42,460
You did not want to force users to provide you the amplitude, the frequency at the offset

2377
02:27:42,460 --> 02:27:47,460
when you call the serialize method, because you hide that business logic inside the class itself.

2378
02:27:47,460 --> 02:27:52,460
So behavioral design patterns, response to this problem,

2379
02:27:52,460 --> 02:27:57,460
they establish some ways to wrap the behavior inside

2380
02:27:57,460 --> 02:28:02,460
let's say a series of the class in order to change how they appear at the site.

2381
02:28:02,460 --> 02:28:07,460
And last category, structural design pattern.

2382
02:28:07,460 --> 02:28:12,460
You got for example a different list of algorithms

2383
02:28:12,460 --> 02:28:17,460
that always belong to the same family.

2384
02:28:17,460 --> 02:28:22,460
Consider the modulation. The modulation is family of algorithms, okay?

2385
02:28:22,460 --> 02:28:27,460
But you have amplitude modulation, frequency modulation, phase modulation.

2386
02:28:28,460 --> 02:28:33,460
Structural patterns deals with the finding way to try

2387
02:28:33,460 --> 02:28:38,460
find out some solution to wrap up all these things

2388
02:28:38,460 --> 02:28:42,460
inside a common container, let's put this way.

2389
02:28:42,460 --> 02:28:47,460
And help the client define which algorithm should be used

2390
02:28:47,460 --> 02:28:52,460
without letting me know how the algorithm itself will work.

2391
02:28:52,460 --> 02:28:57,460
We are going to see one of this, one of the

2392
02:28:57,460 --> 02:29:02,460
design patterns. And let's say the one that we are going to see is called the

2393
02:29:02,460 --> 02:29:07,460
iterator. Iterator probably sounds familiar to you because Python

2394
02:29:07,460 --> 02:29:12,460
offers it natively. But the

2395
02:29:12,460 --> 02:29:17,460
we're going to see the orthodox implementation of the iterator using design patterns.

2396
02:29:17,460 --> 02:29:22,460
And we are going to see how Python implements it.

2397
02:29:22,460 --> 02:29:27,460
Before seeing how to implement the iterator design pattern, let me say what an iterator is.

2398
02:29:27,460 --> 02:29:32,460
Suppose you have a collection. So you have something that could be

2399
02:29:32,460 --> 02:29:37,460
iterated, okay? So something that is by definition iterable.

2400
02:29:37,460 --> 02:29:42,460
Like a list, like a graph, like a chart, like a tree for example.

2401
02:29:42,460 --> 02:29:47,460
So you can use it to create a list. List is very simple data structure. Think about

2402
02:29:47,460 --> 02:29:52,460
tree or graphs. Okay.

2403
02:29:52,460 --> 02:29:57,460
So you want to wrap the logic of traversing this iterable

2404
02:29:57,460 --> 02:30:02,460
inside the object and offer the final user just the way

2405
02:30:02,460 --> 02:30:07,460
to traverse this object. So you can find an object that can help you traverse, for example, the list

2406
02:30:07,460 --> 02:30:12,460
that you want. But you can have another object that can help you to traverse

2407
02:30:12,460 --> 02:30:17,460
the list from end to begin. Or another one that goes for the first to the last

2408
02:30:17,460 --> 02:30:22,460
to the second to the second last, et cetera, et cetera, et cetera. That's good. So you want to hide

2409
02:30:22,460 --> 02:30:27,460
this kind of complexity, okay, and let the user just choose the way

2410
02:30:27,460 --> 02:30:32,460
he wants to traverse the list itself, all the chart, the graph itself.

2411
02:30:32,460 --> 02:30:37,460
So what we are going to do, sorry, what we are going to need basically are two different

2412
02:30:37,460 --> 02:30:42,460
classes. An iterator, okay, this is the interface

2413
02:30:42,460 --> 02:30:47,460
of this object. The iterable, which is the interface that makes an object

2414
02:30:47,460 --> 02:30:52,460
iterable. So an object that can be looped through. So let's define

2415
02:30:52,460 --> 02:30:57,460
this one, for example, the iterator. Okay, that's good. And let's define

2416
02:30:57,460 --> 02:31:02,460
for example the iterable. Okay.

2417
02:31:02,460 --> 02:31:07,460
We should know that basically they are abstract classes, so they

2418
02:31:07,460 --> 02:31:12,460
are going to be treated like abstract, okay. So

2419
02:31:12,460 --> 02:31:17,460
if you think about it, what exactly an iterator is going to work?

2420
02:31:17,460 --> 02:31:22,460
It should support two different methods. A method for getting the nest element of the

2421
02:31:22,460 --> 02:31:27,460
collection and a method to check if the collection has been completed looped.

2422
02:31:27,460 --> 02:31:32,460
Okay, if I've been looped completely. So define, for example,

2423
02:31:32,460 --> 02:31:37,460
a method that is called next, okay, and a method

2424
02:31:37,460 --> 02:31:42,460
that is called as next, as next.

2425
02:31:42,460 --> 02:31:47,460
Okay, those methods are obviously abstract. Good.

2426
02:31:47,460 --> 02:31:52,460
And this one is abstract. Okay.

2427
02:31:52,460 --> 02:31:57,460
These rights are not implemented there, we know.

2428
02:31:57,460 --> 02:32:02,460
Okay, and this one. Good. So let's start from an implementation

2429
02:32:02,460 --> 02:32:07,460
of iterator. Let's consider the most simplest iterator ever. An iterator that goes,

2430
02:32:07,460 --> 02:32:12,460
that traverses this object from beginning to end. So let's call, for example, a sequential

2431
02:32:12,460 --> 02:32:17,460
iterator. Okay, that implements the iterator.

2432
02:32:17,460 --> 02:32:22,460
Okay, it does the same signature as well.

2433
02:32:22,460 --> 02:32:27,460
Okay.

2434
02:32:27,460 --> 02:32:32,460
Okay. So the first thing is

2435
02:32:32,460 --> 02:32:37,460
we need an object to be iterated. So let's define, for example, a collection.

2436
02:32:37,460 --> 02:32:42,460
Okay. And let's put up some known for now. Define, for example,

2437
02:32:42,460 --> 02:32:47,460
a unit constructor, so constructor self, collection.

2438
02:32:47,460 --> 02:32:52,460
Okay. Self dot collection.

2439
02:32:52,460 --> 02:32:57,460
Plus collection. Good. We can move this one.

2440
02:32:57,460 --> 02:33:02,460
Perfect. So the method next

2441
02:33:02,460 --> 02:33:07,460
should be able, when called, to return the next element of the iteration.

2442
02:33:07,460 --> 02:33:12,460
Okay. So what it's going to do is, I define an index,

2443
02:33:12,460 --> 02:33:17,460
for example, I index, set up to zero, and check.

2444
02:33:17,460 --> 02:33:22,460
Sorry. Element equals to

2445
02:33:22,460 --> 02:33:27,460
self, self dot collection.

2446
02:33:27,460 --> 02:33:32,460
Okay.

2447
02:33:32,460 --> 02:33:37,460
One return element.

2448
02:33:37,460 --> 02:33:42,460
So the implementation of the...

2449
02:33:42,460 --> 02:33:47,460
Okay.

2450
02:33:47,460 --> 02:33:52,460
So the implementation of the next method will be pretty easy.

2451
02:33:52,460 --> 02:33:57,460
Okay. It's looking for the hit element

2452
02:33:57,460 --> 02:34:02,460
of the collection, the collection interval. Okay.

2453
02:34:02,460 --> 02:34:07,460
Increment the and return the element itself. So the first time this method will be called,

2454
02:34:07,460 --> 02:34:12,460
it's on the first element. Second time, you return the second element, et cetera, et cetera, et cetera.

2455
02:34:12,460 --> 02:34:17,460
But still, we need to implement some sort of method to check if the collection has been completely

2456
02:34:17,460 --> 02:34:22,460
iterated in order to not rise an index error, because otherwise if we provide

2457
02:34:22,460 --> 02:34:27,460
an index that is bigger than the length of the collection itself,

2458
02:34:27,460 --> 02:34:32,460
it will fail, obviously. So the implementation of the as next

2459
02:34:32,460 --> 02:34:37,460
would be something like, return e is

2460
02:34:37,460 --> 02:34:42,460
less than length of the self collection.

2461
02:34:42,460 --> 02:34:47,460
Sorry.

2462
02:34:47,460 --> 02:34:52,460
Okay.

2463
02:34:52,460 --> 02:34:57,460
Does it sound correct to you? Okay.

2464
02:34:57,460 --> 02:35:02,460
From the other side, the iterable class.

2465
02:35:02,460 --> 02:35:07,460
It's very generic. Okay. It's just saying that

2466
02:35:07,460 --> 02:35:12,460
okay, this class has this kind of strange behavior. It can be iterated, but

2467
02:35:12,460 --> 02:35:17,460
it can add no more methods, no action, nothing. So it could define, for example,

2468
02:35:17,460 --> 02:35:22,460
our signal. Okay. So let's start from signal. Let's call the create wave.

2469
02:35:22,460 --> 02:35:27,460
Good. Wave.

2470
02:35:27,460 --> 02:35:32,460
Perfect. We need to state somehow

2471
02:35:32,460 --> 02:35:37,460
that the wave is iterable. So what we do? We do the same.

2472
02:35:37,460 --> 02:35:42,460
We define a new class, iterable wave, that extends from

2473
02:35:42,460 --> 02:35:47,460
iterable. Okay.

2474
02:35:47,460 --> 02:35:52,460
So we define a new class that is called iterable wave.

2475
02:35:52,460 --> 02:35:57,460
Inner is from wave. It does the iterable, which is basically just now a placeholder.

2476
02:35:57,460 --> 02:36:02,460
Okay. It says that, hey man, this iterable wave is iterable, so you can iterate

2477
02:36:02,460 --> 02:36:07,460
through. But the definition is basically empty. Okay. It has no method as well.

2478
02:36:07,460 --> 02:36:12,460
And from the other side, we can define, obviously, a sequential iterator.

2479
02:36:12,460 --> 02:36:17,460
Okay. Okay. So

2480
02:36:17,460 --> 02:36:22,460
suppose now you create the

2481
02:36:22,460 --> 02:36:27,460
iterable wave.

2482
02:36:27,460 --> 02:36:32,460
Okay.

2483
02:36:32,460 --> 02:36:37,460
Let's do this way.

2484
02:36:37,460 --> 02:36:42,460
Iterable wave.

2485
02:36:42,460 --> 02:36:47,460
Okay. Just creating an instance of iterable wave from the wave.

2486
02:36:47,460 --> 02:36:52,460
Perfect. Once you got the iterable wave, you can

2487
02:36:52,460 --> 02:36:57,460
create an instance of the sequential iterator.

2488
02:36:57,460 --> 02:37:02,460
Okay. That's here. And the constructor of the sequential iterator

2489
02:37:02,460 --> 02:37:07,460
gets called with a collection. So something that is iterable.

2490
02:37:07,460 --> 02:37:12,460
In order to do this, we are going to pass, for example, the Y samples.

2491
02:37:12,460 --> 02:37:17,460
Okay. Good. Sequential iterator.

2492
02:37:17,460 --> 02:37:22,460
Okay. So now when you have this subject,

2493
02:37:22,460 --> 02:37:27,460
you can start iterating things. So you can start iterate

2494
02:37:27,460 --> 02:37:32,460
each value inside the array of samples in the wave.

2495
02:37:32,460 --> 02:37:37,460
So what we can do is,

2496
02:37:37,460 --> 02:37:42,460
let's say, some school code.

2497
02:37:42,460 --> 02:37:47,460
So while sequential iterator has next,

2498
02:37:47,460 --> 02:37:52,460
sequential iterator.next.

2499
02:37:52,460 --> 02:37:57,460
So we check until the sequential

2500
02:37:57,460 --> 02:38:02,460
iterator has next,

2501
02:38:02,460 --> 02:38:07,460
so we check until the sequential iterator has next

2502
02:38:07,460 --> 02:38:12,460
element. And we know that has next element check if the

2503
02:38:12,460 --> 02:38:17,460
iterable collection has been looped through completely. And if we found it,

2504
02:38:17,460 --> 02:38:22,460
obviously, we can call the next method in order to get the next element of the

2505
02:38:22,460 --> 02:38:27,460
iterator. So if we run this code,

2506
02:38:27,460 --> 02:38:32,460
we can see that the iterator has been looped through completely.

2507
02:38:32,460 --> 02:38:37,460
And we can see that the next element has been looped through completely.

2508
02:38:37,460 --> 02:38:42,460
So we can see that the next element has been looped through completely.

2509
02:38:42,460 --> 02:38:47,460
So we can see that the next element has been looped through completely.

2510
02:38:47,460 --> 02:38:52,460
So we can see that the next element has been looped through completely.

2511
02:38:52,460 --> 02:38:57,460
Just one moment.

2512
02:38:57,460 --> 02:39:02,460
Yeah.

2513
02:39:02,460 --> 02:39:07,460
Yeah.

2514
02:39:07,460 --> 02:39:12,460
One moment. Let me see the code.

2515
02:39:12,460 --> 02:39:17,460
Just restarting everything. So let's load the game.

2516
02:39:17,460 --> 02:39:22,460
Okay. Load classes.

2517
02:39:22,460 --> 02:39:27,460
Okay.

2518
02:39:27,460 --> 02:39:32,460
Yeah. Sure.

2519
02:39:32,460 --> 02:39:37,460
Correct.

2520
02:39:37,460 --> 02:39:42,460
Okay.

2521
02:39:42,460 --> 02:39:47,460
Okay. In a way that it prints just the first 10 elements.

2522
02:39:47,460 --> 02:39:52,460
So is this code okay for you?

2523
02:39:52,460 --> 02:39:57,460
But did you get the general idea of the iterator?

2524
02:39:57,460 --> 02:40:02,460
Okay. Obviously, we define a sequential iterator because we want to start from the first, second, third, blah, blah, blah.

2525
02:40:02,460 --> 02:40:07,460
But you can define whatever logic you want in the sequential iterator. You just need to

2526
02:40:07,460 --> 02:40:12,460
Okay. You want to traverse from beginning to end? Good. Use the sequential iterator.

2527
02:40:12,460 --> 02:40:17,460
You want to traverse in reverse order? Okay. I will provide you a reverse iterator that obviously

2528
02:40:17,460 --> 02:40:22,460
implements the same interface as the sequential iterator one, which is the iterator.

2529
02:40:22,460 --> 02:40:27,460
This is pretty good. So this is the orthodox implementation of the iterator design pattern.

2530
02:40:27,460 --> 02:40:32,460
But actually, Python is much more elegant and much more simpler than this.

2531
02:40:32,460 --> 02:40:37,460
So we try to simplify all the things.

2532
02:40:37,460 --> 02:40:42,460
Let's change this code. First of all, there is a radia class, abstract class, that is called iterator.

2533
02:40:42,460 --> 02:40:47,460
So we don't need to implement it. We don't need to define it.

2534
02:40:47,460 --> 02:40:52,460
But we just need to import it from collections.abc import

2535
02:40:52,460 --> 02:40:57,460
iterator.

2536
02:40:57,460 --> 02:41:02,460
And the same applies for iterable. So all these things

2537
02:41:02,460 --> 02:41:07,460
are basically, oh, just one moment.

2538
02:41:07,460 --> 02:41:12,460
Let's copy and paste this code here. Okay. So this class is totally useless.

2539
02:41:12,460 --> 02:41:17,460
Okay? Because it just repeated. If you look at the implementation of the iterator now

2540
02:41:17,460 --> 02:41:22,460
inside the collection.abc is similar to mine. It's not equal.

2541
02:41:22,460 --> 02:41:27,460
So we're going to see why in a while.

2542
02:41:27,460 --> 02:41:32,460
So your sequential iterator now extends or implements the abstract

2543
02:41:32,460 --> 02:41:37,460
base class provided by Python. At the same time, the iterable

2544
02:41:37,460 --> 02:41:42,460
wave extends the iterable base classes provided by Python. So till now,

2545
02:41:42,460 --> 02:41:47,460
if you execute this code, you see strange error.

2546
02:41:47,460 --> 02:41:52,460
So we implement this class with abstract method next.

2547
02:41:52,460 --> 02:41:57,460
What is saying Python? It's saying, hey, man, you are implementing the

2548
02:41:57,460 --> 02:42:02,460
iterator abstract base class, but you are not defining a double, double,

2549
02:42:02,460 --> 02:42:07,460
and the score next method. There is an interface. There is a template. There is a contract.

2550
02:42:07,460 --> 02:42:12,460
It is being cloned. So you need to, if you want to use the iterator, you need to implement

2551
02:42:12,460 --> 02:42:17,460
it. So basically it is the same. Instead of using next method,

2552
02:42:17,460 --> 02:42:22,460
this one should be called next.

2553
02:42:22,460 --> 02:42:27,460
Let's run the code again.

2554
02:42:27,460 --> 02:42:32,460
Okay.

2555
02:42:32,460 --> 02:42:37,460
It's equal, no? Perfect.

2556
02:42:37,460 --> 02:42:42,460
Problem.

2557
02:42:42,460 --> 02:42:47,460
The main problem is that method that starts with the double underscore we saw are called

2558
02:42:47,460 --> 02:42:52,460
by Python under the hood. They are not meant to be public. So they cannot be

2559
02:42:52,460 --> 02:42:57,460
used by the client itself. So if they are not going to use by the client itself,

2560
02:42:57,460 --> 02:43:02,460
how can we print the next element of the collection? We can call this

2561
02:43:02,460 --> 02:43:07,460
one. Well, Python does a very wonderful solution,

2562
02:43:07,460 --> 02:43:12,460
which says for,

2563
02:43:12,460 --> 02:43:17,460
just one moment. Let's go back to

2564
02:43:17,460 --> 02:43:22,460
iterable. No, no, no.

2565
02:43:22,460 --> 02:43:27,460
For element in sequential iterator,

2566
02:43:27,460 --> 02:43:32,460
print element.

2567
02:43:32,460 --> 02:43:37,460
Is this syntax familiar to you? Good. It's much better than the while loop, no?

2568
02:43:37,460 --> 02:43:42,460
Good. So let's see this code.

2569
02:43:42,460 --> 02:43:47,460
Okay. In the sequential

2570
02:43:47,460 --> 02:43:52,460
iterator.

2571
02:43:52,460 --> 02:43:57,460
What is the error? Index 10 is out of bounds.

2572
02:43:57,460 --> 02:44:02,460
Because we forgot to add the as next check.

2573
02:44:02,460 --> 02:44:07,460
So Python did from the first to the

2574
02:44:07,460 --> 02:44:12,460
element and then it failed because there is no 10 elements. So we don't know Python

2575
02:44:12,460 --> 02:44:17,460
that needs to call the as next method before checking and increasing, always increasing

2576
02:44:17,460 --> 02:44:22,460
the element. We use a nice way of doing

2577
02:44:22,460 --> 02:44:27,460
this stuff. Let's refactor the method next. Okay.

2578
02:44:27,460 --> 02:44:32,460
You should be familiar with the try accept logic.

2579
02:44:32,460 --> 02:44:37,460
Accept X.

2580
02:44:37,460 --> 02:44:42,460
Let's try this way.

2581
02:44:42,460 --> 02:44:47,460
Let's try to get the element. If we catch this error,

2582
02:44:47,460 --> 02:44:52,460
so if this one is not valid because it cannot index the array,

2583
02:44:52,460 --> 02:44:57,460
we catch this error. What we do? We rise another error.

2584
02:44:57,460 --> 02:45:02,460
We rise a stop iteration, which is another

2585
02:45:02,460 --> 02:45:07,460
exception. Let's execute the code now.

2586
02:45:07,460 --> 02:45:12,460
It worked. Because Python

2587
02:45:12,460 --> 02:45:17,460
when called this method, try to get the first one. It reached

2588
02:45:17,460 --> 02:45:22,460
the ninth one. Okay. Then at the tenth it goes to the accept branch

2589
02:45:22,460 --> 02:45:27,460
and it raises the stop iteration. Python knows then when stop iteration is

2590
02:45:27,460 --> 02:45:32,460
raised, the for loop should stop. This is

2591
02:45:32,460 --> 02:45:37,460
the native implementation of the iterated design pattern defined before in the

2592
02:45:37,460 --> 02:45:42,460
orthodox way using the while, the interfaces, the as next, the next method, et cetera, et cetera,

2593
02:45:42,460 --> 02:45:47,460
in a much more elegant way. Python method. This is Python method.

2594
02:45:47,460 --> 02:45:52,460
I want to just add a little notice about this one.

2595
02:45:52,460 --> 02:45:57,460
Look, the implementation of this method is very different

2596
02:45:57,460 --> 02:46:02,460
from the original one. This goes under the name that

2597
02:46:02,460 --> 02:46:07,460
it's better to ask forgiveness than permission. Instead of

2598
02:46:07,460 --> 02:46:12,460
checking if there is another element in the collection, let's bet that

2599
02:46:12,460 --> 02:46:17,460
there is another element on the collection. And if not, let's catch the error

2600
02:46:17,460 --> 02:46:22,460
and then handle the error itself. Which is exactly the opposite

2601
02:46:22,460 --> 02:46:27,460
if compared with this one. You check first if there is an

2602
02:46:27,460 --> 02:46:32,460
X method and then if this condition is true, you call the next method.

2603
02:46:32,460 --> 02:46:37,460
This approach is very, very, very

2604
02:46:37,460 --> 02:46:42,460
widely used in Python. On the contrary, on other languages it uses the other one.

2605
02:46:42,460 --> 02:46:47,460
But in Python you will find that this approach rules. This approach is very, very

2606
02:46:47,460 --> 02:46:52,460
important to know. Remember, it's much easier to ask forgiveness, catch the error

2607
02:46:52,460 --> 02:46:57,460
instead of just putting an if than asking permission. So if we

2608
02:46:57,460 --> 02:47:02,460
refactor this one, the as next method is totally useless.

2609
02:47:02,460 --> 02:47:07,460
So the code obviously works. Questions? Otherwise I need

2610
02:47:07,460 --> 02:47:12,460
one more thing. Okay.

2611
02:47:12,460 --> 02:47:17,460
One more thing.

2612
02:47:17,460 --> 02:47:22,460
This variable has an underscore.

2613
02:47:22,460 --> 02:47:27,460
This is not the case. This is not the case. I put an underscore because this

2614
02:47:27,460 --> 02:47:32,460
variable in my mind is private. I want to offer

2615
02:47:32,460 --> 02:47:37,460
this variable outside the sequential iterator. I don't want that the user

2616
02:47:37,460 --> 02:47:42,460
knows this variable. Because this variable maps just the state of this object.

2617
02:47:42,460 --> 02:47:47,460
It helps me just to track how exactly the looping operation

2618
02:47:47,460 --> 02:47:52,460
has reached through. It's not meant to be public. This concept of

2619
02:47:52,460 --> 02:47:57,460
keeping public information accessible to the client and private information

2620
02:47:57,460 --> 02:48:02,460
not accessible to the client is very important in object oriented programming and goes under

2621
02:48:02,460 --> 02:48:07,460
the name and the concept of data hiding. You hide some data which is not

2622
02:48:07,460 --> 02:48:12,460
necessary, mandatory, useful for the client itself.

2623
02:48:12,460 --> 02:48:17,460
And you offer the user itself just the public part of the function itself.

2624
02:48:17,460 --> 02:48:22,460
So remember this one. Obviously there is no problem publishing,

2625
02:48:22,460 --> 02:48:27,460
offering to the user the state of the sequential iterator. But

2626
02:48:27,460 --> 02:48:32,460
let's suppose that instead of having just a simple expression like this one,

2627
02:48:32,460 --> 02:48:37,460
you've got a very complex algorithm that applies some sort of breadth first search

2628
02:48:37,460 --> 02:48:42,460
on graphs of trees. Okay, this variable would be much, much more complex.

2629
02:48:42,460 --> 02:48:47,460
And maybe could reveal the

2630
02:48:47,460 --> 02:48:52,460
data inside your database. If you apply this method to the database, offering this

2631
02:48:52,460 --> 02:48:57,460
information outside the class, making public to the class itself,

2632
02:48:57,460 --> 02:49:02,460
could expose you to a data leak. So think in mind about

2633
02:49:02,460 --> 02:49:07,460
these things. If you remember well at the beginning I said if you know concept of object

2634
02:49:07,460 --> 02:49:12,460
oriented programming, you can translate them to somewhere else. Like this one. You can translate the fact that

2635
02:49:12,460 --> 02:49:17,460
dividing some data and offering to the user a way to navigate this data.

2636
02:49:17,460 --> 02:49:22,460
But the way has been defined by you and you only.

2637
02:49:22,460 --> 02:49:27,460
Okay, questions? Yeah. Good.

2638
02:49:27,460 --> 02:49:32,460
Yeah.

2639
02:49:32,460 --> 02:49:37,460
No, don't think so. I think it's basically

2640
02:49:37,460 --> 02:49:42,460
the same. Yeah.

2641
02:49:42,460 --> 02:49:47,460
Okay.

2642
02:49:47,460 --> 02:49:52,460
Now can you rephrase? Sorry, I didn't understand.

2643
02:49:52,460 --> 02:49:57,460
Yeah.

2644
02:49:57,460 --> 02:50:02,460
Yeah.

2645
02:50:02,460 --> 02:50:07,460
It's not self

2646
02:50:07,460 --> 02:50:12,460
because outside the function self

2647
02:50:12,460 --> 02:50:17,460
can be used. So since I has been defined outside the function itself

2648
02:50:17,460 --> 02:50:22,460
can be used. Okay. I would have put basically on the constructor method.

2649
02:50:22,460 --> 02:50:27,460
Okay. I could have done self dot underscore I equals zero.

2650
02:50:27,460 --> 02:50:32,460
But think about it. Is why

2651
02:50:32,460 --> 02:50:37,460
are parameters that the user should let you know?

2652
02:50:37,460 --> 02:50:42,460
Why is internal state? It's not correct.

2653
02:50:42,460 --> 02:50:47,460
It takes part as constructor arguments because this is private.

2654
02:50:47,460 --> 02:50:52,460
Because otherwise the user can say.

2655
02:50:52,460 --> 02:50:57,460
So for this way it has no self but it takes part of the object obviously.

2656
02:50:57,460 --> 02:51:02,460
So it takes part of the object. It has no self because it's outside

2657
02:51:02,460 --> 02:51:07,460
of a function and that's all. If you want to use a self you want to put in the

2658
02:51:07,460 --> 02:51:12,460
constructor. But if you put in the constructor you let the client define the way.

2659
02:51:12,460 --> 02:51:17,460
Define the variables. But this is wrong because you don't want that client mess up with the

2660
02:51:17,460 --> 02:51:22,460
state of the object. This is just yours. Okay.

2661
02:51:22,460 --> 02:51:27,460
Okay.

2662
02:51:27,460 --> 02:51:32,460
You could do something like this.

2663
02:51:52,460 --> 02:51:57,460
Okay.

2664
02:51:57,460 --> 02:52:02,460
Sorry. Thank you.

2665
02:52:02,460 --> 02:52:07,460
Okay. Propose you ten minutes for the exercise.

2666
02:52:14,460 --> 02:52:19,460
Okay.

2667
02:52:19,460 --> 02:52:24,460
So before in this part the exercise can be split into two main different parts.

2668
02:52:24,460 --> 02:52:29,460
Okay. The first part should be easy while the second one requires some thinking about.

2669
02:52:29,460 --> 02:52:34,460
So obviously as always we can discuss maybe later because you need to understand the domain problem first.

2670
02:52:34,460 --> 02:52:39,460
Then code. First part is defining an iterator

2671
02:52:39,460 --> 02:52:44,460
looping in reverse order. So instead just letting the client looping in

2672
02:52:44,460 --> 02:52:49,460
sequential order you want to offer the client another type of iterator that implements

2673
02:52:49,460 --> 02:52:54,460
the same interface that can help you out to loop in the

2674
02:52:54,460 --> 02:52:59,460
reverse order. Okay. The iterator is the abstract

2675
02:52:59,460 --> 02:53:04,460
mix class. You can find it in the classes module so you just need to implement it.

2676
02:53:04,460 --> 02:53:09,460
Okay.

2677
02:53:09,460 --> 02:53:14,460
Should be very easy. Just changing the way you

2678
02:53:14,460 --> 02:53:19,460
change the I. That's clear. No. While the second part if you're curious about

2679
02:53:19,460 --> 02:53:24,460
this. Suppose that you want to offer

2680
02:53:24,460 --> 02:53:29,460
a client a way to let him to say to you what kind of

2681
02:53:29,460 --> 02:53:34,460
iterator should be used. Because now you're offering a sequential order iterator and a

2682
02:53:34,460 --> 02:53:39,460
reverse iterator. But you want to offer a user a much more let's say human understandable

2683
02:53:39,460 --> 02:53:44,460
API that is capable of let's say saying you what

2684
02:53:44,460 --> 02:53:49,460
exactly iterator you should be able to provide to him. So instead

2685
02:53:49,460 --> 02:53:54,460
letting the client use directly the sequential iterator or the reverse iterator

2686
02:53:54,460 --> 02:53:59,460
you want to offer a client an API that under the hoods computes the fact

2687
02:53:59,460 --> 02:54:04,460
that the user wants the sequential one of the reverse one. And then you

2688
02:54:04,460 --> 02:54:09,460
implement it. So you define an iterator creator

2689
02:54:09,460 --> 02:54:14,460
interface so an iterator creator abstract mix class

2690
02:54:14,460 --> 02:54:19,460
with that create iterator method that accept a string

2691
02:54:19,460 --> 02:54:24,460
that say which kind of iterator should be requested by the user. Sequential or reverse.

2692
02:54:24,460 --> 02:54:29,460
You need to implement the interface because interface is abstract

2693
02:54:29,460 --> 02:54:34,460
so you can be used. And once you implement it

2694
02:54:34,460 --> 02:54:39,460
if the condition equals to sequential

2695
02:54:39,460 --> 02:54:44,460
then you need to return the sequential iterator. Otherwise

2696
02:54:44,460 --> 02:54:49,460
you return the reverse iterator. So you need to reflect the wave sample

2697
02:54:49,460 --> 02:54:54,460
collection class which is basically our augmented version

2698
02:54:54,460 --> 02:54:59,460
of the wave that takes and changes the role of the iterator

2699
02:54:59,460 --> 02:55:04,460
that you can find on the classes module.

2700
02:55:04,460 --> 02:55:09,460
You got eight minutes.

2701
02:55:19,460 --> 02:55:24,460
.

2702
02:55:24,460 --> 02:55:29,460
.

2703
02:55:29,460 --> 02:55:34,460
.

2704
02:55:34,460 --> 02:55:39,460
.

2705
02:55:49,460 --> 02:55:54,460
.

2706
02:55:54,460 --> 02:55:59,460
.

2707
02:55:59,460 --> 02:56:04,460
.

2708
02:56:04,460 --> 02:56:09,460
.

2709
02:56:09,460 --> 02:56:14,460
.

2710
02:56:14,460 --> 02:56:19,460
.

2711
02:56:19,460 --> 02:56:24,460
.

2712
02:56:24,460 --> 02:56:29,460
.

2713
02:56:29,460 --> 02:56:34,460
.

2714
02:56:34,460 --> 02:56:39,460
.

2715
02:56:39,460 --> 02:56:44,460
.

2716
02:56:44,460 --> 02:56:49,460
.

2717
02:56:49,460 --> 02:56:54,460
.

2718
02:56:54,460 --> 02:56:59,460
.

2719
02:56:59,460 --> 02:57:04,460
.

2720
02:57:04,460 --> 02:57:09,460
.

2721
02:57:09,460 --> 02:57:14,460
.

2722
02:57:14,460 --> 02:57:19,460
.

2723
02:57:19,460 --> 02:57:24,460
.

2724
02:57:24,460 --> 02:57:29,460
So you should have understood that defining interfaces or define these

2725
02:57:29,460 --> 02:57:34,460
abstract based classes is not a matter of let's say

2726
02:57:34,460 --> 02:57:39,460
uselessness. It's very important to define this kind of interface

2727
02:57:39,460 --> 02:57:44,460
because if you define this interface you know at the client side that that code

2728
02:57:44,460 --> 02:57:49,460
will work because every implementation of that interface will respect exactly

2729
02:57:49,460 --> 02:57:54,460
the same signature of the methods. So that's the idea

2730
02:57:54,460 --> 02:57:59,460
of interfaces. That's the idea of abstract based classes.

2731
02:57:59,460 --> 02:58:04,460
.

2732
02:58:04,460 --> 02:58:09,460
.

2733
02:58:09,460 --> 02:58:14,460
.

2734
02:58:14,460 --> 02:58:19,460
.

2735
02:58:20,460 --> 02:58:25,460
.

2736
02:58:25,460 --> 02:58:30,460
.

2737
02:58:30,460 --> 02:58:35,460
.

2738
02:58:35,460 --> 02:58:40,460
.

2739
02:58:40,460 --> 02:58:45,460
.

2740
02:58:45,460 --> 02:58:50,460
.

2741
02:58:50,460 --> 02:58:55,460
.

2742
02:58:55,460 --> 02:59:00,460
.

2743
02:59:00,460 --> 02:59:05,460
.

2744
02:59:05,460 --> 02:59:10,460
.

2745
02:59:10,460 --> 02:59:15,460
.

2746
02:59:15,460 --> 02:59:20,460
.

2747
02:59:20,460 --> 02:59:25,460
.

2748
02:59:25,460 --> 02:59:30,460
.

2749
02:59:30,460 --> 02:59:35,460
.

2750
02:59:35,460 --> 02:59:40,460
.

2751
02:59:40,460 --> 02:59:45,460
.

2752
02:59:45,460 --> 02:59:50,460
.

2753
02:59:50,460 --> 02:59:55,460
.

2754
02:59:55,460 --> 03:00:00,460
.

2755
03:00:00,460 --> 03:00:05,460
.

2756
03:00:05,460 --> 03:00:10,460
.

2757
03:00:10,460 --> 03:00:15,460
.

2758
03:00:15,460 --> 03:00:20,460
.

2759
03:00:20,460 --> 03:00:25,460
.

2760
03:00:25,460 --> 03:00:30,460
.

2761
03:00:30,460 --> 03:00:35,460
.

2762
03:00:35,460 --> 03:00:40,460
.

2763
03:00:40,460 --> 03:00:45,460
.

2764
03:00:45,460 --> 03:00:50,460
.

2765
03:00:50,460 --> 03:00:55,460
.

2766
03:00:55,460 --> 03:01:00,460
.

2767
03:01:00,460 --> 03:01:05,460
.

2768
03:01:05,460 --> 03:01:10,460
.

2769
03:01:10,460 --> 03:01:15,460
.

2770
03:01:15,460 --> 03:01:20,460
.

2771
03:01:20,460 --> 03:01:25,460
.

2772
03:01:25,460 --> 03:01:30,460
.

2773
03:01:30,460 --> 03:01:35,460
.

2774
03:01:35,460 --> 03:01:40,460
.

2775
03:01:40,460 --> 03:01:45,460
.

2776
03:01:45,460 --> 03:01:50,460
.

2777
03:01:50,460 --> 03:01:55,460
.

2778
03:01:55,460 --> 03:02:00,460
.

2779
03:02:00,460 --> 03:02:05,460
.

2780
03:02:05,460 --> 03:02:10,460
.

2781
03:02:10,460 --> 03:02:15,460
.

2782
03:02:15,460 --> 03:02:20,460
.

2783
03:02:20,460 --> 03:02:25,460
.

2784
03:02:25,460 --> 03:02:30,460
.

2785
03:02:30,460 --> 03:02:35,460
.

2786
03:02:35,460 --> 03:02:40,460
.

2787
03:02:40,460 --> 03:02:45,460
.

2788
03:02:45,460 --> 03:02:50,460
.

2789
03:02:50,460 --> 03:02:55,460
.

2790
03:02:55,460 --> 03:03:00,460
.

2791
03:03:00,460 --> 03:03:05,460
.

2792
03:03:05,460 --> 03:03:10,460
.

2793
03:03:10,460 --> 03:03:15,460
.

2794
03:03:15,460 --> 03:03:20,460
.

2795
03:03:20,460 --> 03:03:25,460
.

2796
03:03:25,460 --> 03:03:30,460
.

2797
03:03:30,460 --> 03:03:35,460
.

2798
03:03:35,460 --> 03:03:40,460
.

2799
03:03:40,460 --> 03:03:45,460
.

2800
03:03:45,460 --> 03:03:50,460
.

2801
03:03:50,460 --> 03:03:55,460
.

2802
03:03:55,460 --> 03:04:00,460
.

2803
03:04:00,460 --> 03:04:05,460
.

2804
03:04:05,460 --> 03:04:10,460
.

2805
03:04:10,460 --> 03:04:15,460
.

2806
03:04:15,460 --> 03:04:20,460
.

2807
03:04:20,460 --> 03:04:25,460
.

2808
03:04:25,460 --> 03:04:30,460
.

2809
03:04:30,460 --> 03:04:35,460
.

2810
03:04:35,460 --> 03:04:40,460
.

2811
03:04:40,460 --> 03:04:45,460
.

2812
03:04:45,460 --> 03:04:50,460
.

2813
03:04:50,460 --> 03:04:55,460
.

2814
03:04:55,460 --> 03:05:00,460
.

2815
03:05:00,460 --> 03:05:05,460
.

2816
03:05:05,460 --> 03:05:10,460
.

2817
03:05:10,460 --> 03:05:15,460
.

2818
03:05:15,460 --> 03:05:20,460
.

2819
03:05:20,460 --> 03:05:25,460
.

2820
03:05:25,460 --> 03:05:30,460
.

2821
03:05:30,460 --> 03:05:35,460
.

2822
03:05:35,460 --> 03:05:40,460
.

2823
03:05:40,460 --> 03:05:45,460
.

2824
03:05:45,460 --> 03:05:50,460
.

2825
03:05:50,460 --> 03:05:55,460
.

2826
03:05:55,460 --> 03:06:00,460
.

2827
03:06:00,460 --> 03:06:05,460
.

2828
03:06:05,460 --> 03:06:10,460
.

2829
03:06:10,460 --> 03:06:15,460
.

2830
03:06:15,460 --> 03:06:20,460
.

2831
03:06:20,460 --> 03:06:25,460
.

2832
03:06:25,460 --> 03:06:30,460
.

2833
03:06:30,460 --> 03:06:35,460
.

2834
03:06:35,460 --> 03:06:40,460
.

2835
03:06:40,460 --> 03:06:45,460
.

2836
03:06:45,460 --> 03:06:50,460
.

2837
03:06:50,460 --> 03:06:55,460
.

2838
03:06:55,460 --> 03:07:00,460
.

2839
03:07:00,460 --> 03:07:05,460
.

2840
03:07:05,460 --> 03:07:10,460
.

2841
03:07:10,460 --> 03:07:15,460
.

2842
03:07:15,460 --> 03:07:20,460
.

2843
03:07:20,460 --> 03:07:25,460
.

2844
03:07:25,460 --> 03:07:30,460
.

2845
03:07:30,460 --> 03:07:35,460
.

2846
03:07:35,460 --> 03:07:40,460
.

2847
03:07:40,460 --> 03:07:45,460
.

2848
03:07:45,460 --> 03:07:50,460
.

2849
03:07:50,460 --> 03:07:55,460
.

2850
03:07:55,460 --> 03:08:00,460
.

2851
03:08:00,460 --> 03:08:05,460
.

2852
03:08:05,460 --> 03:08:10,460
.

2853
03:08:10,460 --> 03:08:15,460
.

2854
03:08:15,460 --> 03:08:20,460
.

2855
03:08:20,460 --> 03:08:25,460
.

2856
03:08:25,460 --> 03:08:30,460
.

2857
03:08:30,460 --> 03:08:35,460
.

2858
03:08:35,460 --> 03:08:40,460
.

2859
03:08:40,460 --> 03:08:45,460
.

2860
03:08:45,460 --> 03:08:50,460
.

2861
03:08:50,460 --> 03:08:55,460
.

2862
03:08:55,460 --> 03:09:00,460
.

2863
03:09:00,460 --> 03:09:05,460
.

2864
03:09:05,460 --> 03:09:10,460
.

2865
03:09:10,460 --> 03:09:15,460
.

2866
03:09:15,460 --> 03:09:20,460
.

2867
03:09:20,460 --> 03:09:25,460
.

2868
03:09:25,460 --> 03:09:30,460
.

2869
03:09:30,460 --> 03:09:35,460
.

2870
03:09:35,460 --> 03:09:40,460
.

2871
03:09:40,460 --> 03:09:45,460
.

2872
03:09:45,460 --> 03:09:50,460
.

2873
03:09:50,460 --> 03:09:55,460
.

2874
03:09:55,460 --> 03:10:00,460
.

2875
03:10:00,460 --> 03:10:05,460
.

2876
03:10:05,460 --> 03:10:10,460
.

2877
03:10:10,460 --> 03:10:15,460
.

2878
03:10:15,460 --> 03:10:20,460
.

2879
03:10:20,460 --> 03:10:25,460
.

2880
03:10:25,460 --> 03:10:30,460
.

2881
03:10:30,460 --> 03:10:35,460
.

2882
03:10:35,460 --> 03:10:40,460
.

2883
03:10:40,460 --> 03:10:45,460
.

2884
03:10:45,460 --> 03:10:50,460
.

2885
03:10:50,460 --> 03:10:55,460
.

2886
03:10:55,460 --> 03:11:00,460
.

2887
03:11:00,460 --> 03:11:05,460
.

2888
03:11:05,460 --> 03:11:10,460
.

2889
03:11:10,460 --> 03:11:15,460
.

2890
03:11:15,460 --> 03:11:20,460
.

2891
03:11:20,460 --> 03:11:25,460
.

2892
03:11:25,460 --> 03:11:30,460
.

2893
03:11:30,460 --> 03:11:35,460
.

2894
03:11:35,460 --> 03:11:40,460
.

2895
03:11:40,460 --> 03:11:45,460
.

2896
03:11:45,460 --> 03:11:50,460
.

2897
03:11:50,460 --> 03:11:55,460
.

2898
03:11:55,460 --> 03:12:00,460
.

2899
03:12:00,460 --> 03:12:05,460
.

2900
03:12:05,460 --> 03:12:10,460
.

2901
03:12:10,460 --> 03:12:15,460
.

2902
03:12:15,460 --> 03:12:20,460
.

2903
03:12:20,460 --> 03:12:25,460
.

2904
03:12:25,460 --> 03:12:30,460
.

2905
03:12:30,460 --> 03:12:35,460
.

2906
03:12:35,460 --> 03:12:40,460
.

2907
03:12:40,460 --> 03:12:45,460
.

2908
03:12:45,460 --> 03:12:50,460
.

2909
03:12:50,460 --> 03:12:55,460
.

2910
03:12:55,460 --> 03:13:00,460
.

2911
03:13:00,460 --> 03:13:05,460
.

2912
03:13:05,460 --> 03:13:10,460
.

2913
03:13:10,460 --> 03:13:15,460
.

2914
03:13:15,460 --> 03:13:20,460
.

2915
03:13:20,460 --> 03:13:25,460
.

2916
03:13:25,460 --> 03:13:30,460
.

