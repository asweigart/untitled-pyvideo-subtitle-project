1
00:00:00,000 --> 00:00:07,000
Muy buenas tardes nuevamente. Creo que suena mejor cuando no tengo el... La siguiente presentación

2
00:00:14,760 --> 00:00:21,760
va a ser de mano de Ariel Ortiz, Ariel Ortiz que tiene ya, que está en la Ciudad de Monterrey,

3
00:00:23,200 --> 00:00:23,400
¿verdad?

4
00:00:23,400 --> 00:00:24,920
En la Ciudad de México.

5
00:00:25,680 --> 00:00:32,680
Tiene ya muchos años como facilitador y ha trabajado con Python desde el 2001. Ariel,

6
00:00:34,480 --> 00:00:40,480
la tarde de hoy, aún es de tarde, nos va a hablar sobre Match Case para principiantes.

7
00:00:40,480 --> 00:00:43,480
Un aplauso para Ariel.

8
00:00:43,480 --> 00:00:50,480
Muy bien, pues muy buenas tardes. Es un gusto estar aquí en las charlas. Esta es de hecho

9
00:00:51,480 --> 00:00:58,480
la primera vez que me toca participar en las charlas. Recuerdo haber estado como asistente

10
00:00:59,480 --> 00:01:06,480
en el... En 2018, si mal no recuerdo. Creo que fue cuando se hizo el primer track de charlas

11
00:01:06,480 --> 00:01:13,480
en español. Entonces, para mí es un gusto el poder estar aquí ya de este lado. Sí,

12
00:01:13,480 --> 00:01:19,480
he participado y he dado tutoriales y pláticas en inglés. Incluso el día de ayer tuve un

13
00:01:19,480 --> 00:01:26,480
tutorial. Y bueno, pues poderlo hacer ahora en español para mí es un tremendo gusto.

14
00:01:26,480 --> 00:01:33,480
Muy bien, pues esta es la plática de Match Case para principiantes. Les comento si gustan

15
00:01:34,640 --> 00:01:41,640
ahí copiar la liga o ver ahí el código QR. Ahí está la presentación. Esta misma presentación

16
00:01:42,600 --> 00:01:46,680
la pueden ahí consultar y hay algunas ligas adicionales que pueden resultar de su interés.

17
00:01:46,880 --> 00:01:53,880
Vamos a quitarnos el cubrebocas. Creo que se escucha mejor. Muy bien. Y bueno. Mi nombre

18
00:01:59,400 --> 00:02:05,960
es Ariel Ortiz. Soy profesor de tiempo completo, profesor de planta del tecnológico de Monterrey.

19
00:02:05,960 --> 00:02:08,920
No estoy yo en Monterrey. Mucha gente cree que estoy en Monterrey porque trabajo en el

20
00:02:08,920 --> 00:02:13,440
Tecnológico de Monterrey, pero no. Estoy al norte de la ciudad de México. El campus

21
00:02:13,440 --> 00:02:18,560
de los Estados de México está en el municipio de Atizapán de Zaragoza. Y bueno, ahí tenemos

22
00:02:18,560 --> 00:02:25,560
ya bastantes años ahí trabajando. Comencé, como lo mencionó Andrés, en el 2001. De

23
00:02:25,760 --> 00:02:31,280
hecho, comencé yo a trabajar con Python. Lo empecé aprendiendo por mi cuenta y pues

24
00:02:31,280 --> 00:02:36,280
casi de manera inmediata comencé yo a utilizarlo. Fue un lenguaje que desde el principio me

25
00:02:36,280 --> 00:02:42,120
gustó, me llamó mucho la atención. No tenía yo idea en ese entonces que iba a tomar la

26
00:02:42,120 --> 00:02:46,960
popularidad que hasta el momento ha tomado. Los últimos cinco años han sido una época

27
00:02:46,960 --> 00:02:52,120
de crecimiento fenomenal para Python. Y la verdad es que ha sido padrísimo ser parte

28
00:02:52,120 --> 00:02:58,440
de todo este fenómeno. Y pues les agradezco mucho a todos. Yo sé que es un momento complicado.

29
00:02:58,440 --> 00:03:02,800
Ya son más de las cinco de la tarde en viernes. Entonces, como que sí se antoja ya a lo mejor

30
00:03:02,800 --> 00:03:09,800
estar en otro lugar. Pero les agradezco mucho que estén aquí. Muy bien. Un poquito de

31
00:03:10,320 --> 00:03:15,360
mí. Yo soy el autor de algo que he llamado la referencia incompleta de Python 3. Este

32
00:03:15,360 --> 00:03:19,960
fue un documento que realicé para ayudar a alumnos que estaban aprendiendo a programar

33
00:03:19,960 --> 00:03:25,040
en Python en español. Básicamente con toda la información que a mí me gustaría que

34
00:03:25,040 --> 00:03:32,040
hubiera una referencia rápida y que no encontré yo algo totalmente de mi gusto, de mi interés.

35
00:03:32,240 --> 00:03:36,000
Entonces me puse yo a escribirlo. Y bueno, ahí está. Todavía está en una versión

36
00:03:36,000 --> 00:03:42,160
1.0. Pero yo creo que en cualquier momento ya liberamos la versión final. Hay algunos

37
00:03:42,160 --> 00:03:48,720
pequeños ajustes que espero hacerle próximamente. Y también tengo un blog que se llama EduPython.

38
00:03:48,720 --> 00:03:55,720
Estos dos documentos o dos sitios están en español. EduPython, pues han sido algunas

39
00:03:56,280 --> 00:04:00,880
cosas que he escrito a través de los años. Sí tiene un rato que no he escrito ahí,

40
00:04:00,880 --> 00:04:05,880
pero lo que ahí se encuentra creo que es de calidad bastante buena. Y bueno, puede

41
00:04:05,880 --> 00:04:09,920
ser que encuentren algo que les resulte interesante.

42
00:04:09,920 --> 00:04:16,920
Pues comencemos ya ahora sí con lo que es la plática en sí. ¿Qué es eso de Matchcase?

43
00:04:16,920 --> 00:04:21,280
Este es un tema que se ha platicado. De hecho hubo una plática también en la mañana en

44
00:04:21,280 --> 00:04:25,760
inglés de uno de los autores justamente de esta tecnología. Tuve la oportunidad de estar

45
00:04:25,760 --> 00:04:30,800
ahí. Muy interesante conociendo a la gente que está directamente a cargo de esto.

46
00:04:30,800 --> 00:04:37,800
Y bueno, Matchcase fue algo que se introdujo en Python 3.10, que fue oficialmente liberado

47
00:04:38,000 --> 00:04:42,760
en octubre del año pasado. Entonces, pues ¿de qué se trata?

48
00:04:42,760 --> 00:04:49,760
Bueno, una primera respuesta es la búsqueda de coincidencias de patrones estructurales.

49
00:04:49,760 --> 00:04:55,640
Espero que con eso quede súper claro exactamente qué es. Y si no, una segunda respuesta podría

50
00:04:55,640 --> 00:05:00,200
ser esta. Es como un switch case. Se han trabajado en algunos otros lenguajes. Pues

51
00:05:00,200 --> 00:05:07,200
es parecido. Sin embargo, el Matchcase de Python está bien hecho. El switch case realmente

52
00:05:08,800 --> 00:05:14,640
que vemos en otros lenguajes, en C, en C++, en Java, en C Sharp, en JavaScript. La verdad

53
00:05:14,640 --> 00:05:19,440
es que es una de las peores construcciones que se ha hecho a través de la historia.

54
00:05:19,440 --> 00:05:23,560
En particular, si han llegado a usar el switch case en otros lenguajes, sabrán que cada

55
00:05:23,560 --> 00:05:28,360
case si ustedes omiten poner la instrucción break, continúe ejecutándose. Es lo que

56
00:05:28,360 --> 00:05:32,840
en inglés se llaman el fall through. Ese es un tremendo error de diseño en el lenguaje.

57
00:05:32,840 --> 00:05:38,320
Sé lo introdujo. Los creadores de C consideraron que era muy buena idea. Pero en la práctica

58
00:05:38,320 --> 00:05:44,600
ha costado literalmente miles, 200 de miles o hasta millones de dólares porque es muy

59
00:05:44,600 --> 00:05:50,800
fácil que se les olvide poner el break ahí en un case. Y de repente el programa empieza

60
00:05:50,800 --> 00:05:55,200
a hacer cosas medias, medias raras. A mí me ha pasado múltiples ocasiones. Digo, yo

61
00:05:55,200 --> 00:06:00,680
empecé a usar C en el 88. Estábamos hablando un chorro de años atrás. Y todavía a la

62
00:06:00,680 --> 00:06:06,480
fecha me pasa el mismo error. Se me olvida ponerles el break. Entonces, ya el Matchcase

63
00:06:06,480 --> 00:06:13,480
de Python afortunadamente no lo basaron en el DEC. Y es mucho más sofisticado. Y aparte

64
00:06:13,880 --> 00:06:19,200
que está bien hecho realmente es una instrucción que está en esteroides. Realmente tiene una

65
00:06:19,200 --> 00:06:25,560
funcionalidad brutal. Es muy, muy, muy completo. Muy interesante. Podríamos decir realmente

66
00:06:25,560 --> 00:06:31,520
que el Matchcase es azúcar sintáctica. Realmente no hay nada que no pudiéramos hacer antes.

67
00:06:31,520 --> 00:06:36,320
Pero el Matchcase en algunas ocasiones nos va a permitir hacerlo de manera más breve,

68
00:06:36,320 --> 00:06:43,320
de manera más sencilla, de manera más bonita. No siempre, pero en muchas ocasiones sí.

69
00:06:43,720 --> 00:06:49,720
Y quiero en el resto ahorita de la plática, de la charla, me interesa que veamos algunos

70
00:06:49,720 --> 00:06:54,760
ejemplos. Si les hago aquí la aclaración, esta plática está diseñada realmente para

71
00:06:54,760 --> 00:07:01,760
gente que está empezando a programar. No sé si es el caso de la mayoría. Pero la idea

72
00:07:01,840 --> 00:07:06,080
era ver algunos ejemplos de cómo se podría utilizar de manera interesante, de manera

73
00:07:06,080 --> 00:07:10,280
efectiva. No busca o ser exhaustivo. O sea, en el sentido de que no voy a dar todos los

74
00:07:10,280 --> 00:07:13,880
pormenores de cómo usarlo. Al final, nada más les voy a dar alguna recomendación

75
00:07:13,880 --> 00:07:17,880
si quieren revisarlo con un poquito más de detalle, dónde pueden aprender. Ahora sí

76
00:07:17,880 --> 00:07:24,880
que todo. Pero aquí simplemente voy a poner algunos ejemplos muy puntuales, muy escogiditos.

77
00:07:24,880 --> 00:07:29,640
La verdad es que sí me tardé un rato decidiendo qué iba a poner o no. Y espero que los ejemplos

78
00:07:29,640 --> 00:07:34,640
que veamos aquí les resulten interesantes, pero de ninguna manera es completo. La verdad

79
00:07:34,640 --> 00:07:40,200
es que sí hay muchos detallitos que estoy omitiendo para cumplir con el enfoque que

80
00:07:40,200 --> 00:07:44,120
se quiera ahorita que quiero yo tener aquí en la charla. Y también por cuestión de

81
00:07:44,120 --> 00:07:51,120
tiempo. Vamos a ver siete ejemplos, algunos con algunas variaciones. Y estas están disponibles

82
00:07:53,080 --> 00:07:58,840
en un cuaderno de Jupyter que pueden consultar ahí en esta liga. Cuando accedan a las filminas,

83
00:07:58,840 --> 00:08:04,120
pueden también tener ahí la liga para el notebook de Jupyter.

84
00:08:04,120 --> 00:08:08,640
Comenzamos. Vamos a ver el primer problema, el problema 1. Vamos a suponer que queremos

85
00:08:08,720 --> 00:08:13,720
traducir palabras de español a inglés utilizando el léxico de la canción de pollito chicken.

86
00:08:13,720 --> 00:08:20,120
Si se sabe la canción de pollito chicken. Por lo menos en México y por lo menos en

87
00:08:20,120 --> 00:08:24,760
mi época cuando era niño, es tan solo un día, un chorro de años atrás, esto es lo

88
00:08:24,760 --> 00:08:29,760
que te enseñaban en el kinder como parte de tu formación del idioma inglés. Entonces,

89
00:08:29,760 --> 00:08:36,760
es una cancioncita que dice pollito, chicken, gallina, hen. Tiene varias frases de... Se

90
00:08:37,760 --> 00:08:43,760
dice la palabra en español y luego como va en inglés. Veamos justamente cómo podríamos

91
00:08:43,760 --> 00:08:50,760
tener eso en Python sin usar el match case. Entonces, ahí está. ¿Sí se alcanza a ver

92
00:08:50,760 --> 00:08:57,760
el texto? Sí. Gracias. Entonces, bueno, aquí de hecho nada más estamos usando las primeras

93
00:08:58,760 --> 00:09:03,760
cuatro palabritas de la canción. Entonces, esta es una funcioncita que recibe la palabra.

94
00:09:03,760 --> 00:09:08,760
Si la palabra es pollito, pues regresa la cadena chicken. Si la palabra es gallina,

95
00:09:08,760 --> 00:09:14,760
regresa hen. Si es lápiz, regresa pencil. Si es pluma, regresa pen. Y si no, puse aquí

96
00:09:14,760 --> 00:09:19,760
cepalabola. No sé si esta expresión les resulta familiar. En México es así como

97
00:09:19,760 --> 00:09:24,760
que... ¿Quién sabe? De todo saber qué es. Cepalabola es una expresión así muy coloquial.

98
00:09:24,760 --> 00:09:28,760
Que ya no la he escuchado tanto recientemente, pero sí me acuerdo de una época en la que

99
00:09:28,760 --> 00:09:34,760
era muy común decirla. Y bueno, lo podemos probar aquí. Entonces, si traduzco aquí

100
00:09:34,760 --> 00:09:40,760
en esta primera versión pollito, pues me regresa aquí chicken. Si pongo alguna palabra

101
00:09:40,760 --> 00:09:46,760
que no está, pues me regresa cepalabola. Veamos una segunda versión. Esta versión

102
00:09:46,760 --> 00:09:52,760
está usando ya el match case. Si se vean, no es muy distinta en cuanto a la cantidad

103
00:09:52,760 --> 00:09:58,760
de líneas de código que requiere. Aquí cambiamos el if. Podemos omitir el tener que

104
00:09:59,760 --> 00:10:03,760
estar escribiendo aquí palabra en cada expresión. Simplemente la escribimos hasta arriba y

105
00:10:03,760 --> 00:10:08,760
aquí se ve la sintaxis de forma general. Simplemente tenemos el match, tenemos la palabra

106
00:10:08,760 --> 00:10:14,760
y por cada caso en particular, pues tenemos el case y el valor que regresa. Entonces,

107
00:10:14,760 --> 00:10:20,760
con eso nos evita tener que escribir un poquito a diferencia de lo que está aquí. No es

108
00:10:20,760 --> 00:10:26,760
así una ganancia así tremenda, pero puede resultar conveniente y queda claro cuando

109
00:10:26,760 --> 00:10:32,760
estamos en un match que todos se está revisando en contra de una misma expresión, en este

110
00:10:32,760 --> 00:10:38,760
caso lo que es palabra, a diferencia de este if con los Celsius, en donde realmente las

111
00:10:38,760 --> 00:10:43,760
preguntas podrían ser cosas totalmente independientes. Ahora sí que hay que inspeccionar uno por

112
00:10:43,760 --> 00:10:48,760
uno para darse cuenta. Aquí queda claro realmente que cada case se encuentra justamente en la

113
00:10:48,760 --> 00:10:54,760
expresión del match. Entonces, puede ser un poquito más inmediatamente visible lo que

114
00:10:54,760 --> 00:10:59,760
estamos intentando hacer. Sin embargo, la verdad es que ni la versión del if ni la versión

115
00:10:59,760 --> 00:11:04,760
con match considero que es la ideal. Realmente aquí cuando hay una relación tan estrecha

116
00:11:04,760 --> 00:11:10,760
de una palabra con otra, pues justamente para eso están los diccionarios. Aquí nada más

117
00:11:10,760 --> 00:11:14,760
revisando, bueno, si le evalúan, es exactamente lo mismo. Entonces, aquí viene una versión

118
00:11:14,760 --> 00:11:19,760
que usa el diccionario y aquí la moraleja de ese asunto es que el match case pues no

119
00:11:19,760 --> 00:11:24,760
es para siempre. O sea, tiene sus casos de usos interesantes. Vamos a ver, yo creo,

120
00:11:24,760 --> 00:11:29,760
algunas situaciones donde sí es muy conveniente usar el match case, pero aquí en este ejemplo

121
00:11:29,760 --> 00:11:34,760
en particular, aunque es muy fácil, muy conveniente para introducir el concepto, ya en la práctica

122
00:11:34,760 --> 00:11:40,760
no es como, pues realmente lo haríamos en términos de Python idiomático. Aquí definimos

123
00:11:40,760 --> 00:11:45,760
nuestro diccionario donde está uno a uno la llave y el valor asociado con las palabras

124
00:11:45,760 --> 00:11:51,760
en español y en inglés que estamos asociando. Y la traducción aquí consiste en usar el

125
00:11:51,760 --> 00:11:56,760
diccionario, usar este metodito que se llama get, que va a buscar justamente en el diccionario

126
00:11:56,760 --> 00:12:01,760
la palabra que estamos nosotros requiriendo. Y si no la encuentra simplemente pues regresa

127
00:12:01,760 --> 00:12:07,760
ese palabola, que era el default que teníamos al final. Entonces, igual aquí si lo ponemos

128
00:12:07,760 --> 00:12:11,760
con cualquiera de las llaves que están aquí en el diccionario pues las encuentra sin problema.

129
00:12:11,760 --> 00:12:17,760
Si aquí ponemos otra palabra que no está aquí, aquí para más bien sería algo así

130
00:12:17,760 --> 00:12:23,760
como maestra, este nos da ese palabola que es el valor que está devolviendo aquí cuando

131
00:12:23,760 --> 00:12:29,760
no encuentra la llave que estamos buscando específica. Muy bien, entonces ese es el primer

132
00:12:29,760 --> 00:12:36,760
ejemplo. Vamos al primer, digo, al segundo problema. Tenemos aquí, cómo detenemos

133
00:12:37,760 --> 00:12:43,760
y terminar, cuántos días tiene un cierto mes. Hay una rima, creo que la he escuchado en inglés también,

134
00:12:43,760 --> 00:12:50,760
pero en español dice 30 días trae noviembre con abril, junio y septiembre. De 28 solo hay uno,

135
00:12:50,760 --> 00:12:58,760
los demás tienen, los demás de 31. O sea, esta es una forma en que uno puede enseñarle a los niños

136
00:12:58,760 --> 00:13:04,760
cuántos meses tiene cada meso en particular sin tener que buscar en un calendario o en tu teléfono

137
00:13:04,760 --> 00:13:12,760
y ahí ves exactamente cuánto son. Entonces, este es un ejemplo que también podemos hacer con if

138
00:13:12,760 --> 00:13:18,760
y el if. Entonces aquí recibimos un mes, vamos a manejarlo no por nombre sino por

139
00:13:18,760 --> 00:13:25,760
el número de mes. Entonces aquí el mes pues lo checamos, hacemos un in para ver si es alguno de los

140
00:13:25,760 --> 00:13:32,760
meses que están en la rima. Recuerden ahí que la rima dice que 30 días tiene noviembre, que es el mes 11,

141
00:13:32,760 --> 00:13:37,760
así mismo abril, junio y septiembre. Entonces si es cualquiera de esos meses regresamos 30.

142
00:13:37,760 --> 00:13:43,760
Si el mes es 2, que es febrero, bueno, febrero tiene 28 días excepto en años bisiestos, lo sé,

143
00:13:43,760 --> 00:13:48,760
pero bueno, para mantener el código más simple vamos a dejarlo así. Y cualquier otro mes que nos manden es 31,

144
00:13:48,760 --> 00:13:55,760
no estamos haciendo validaciones que los meses sean del 1 al 12. Entonces aquí me mandan el mes 13 o el mes 15 o el mes 999,

145
00:13:55,760 --> 00:14:01,760
pues me va a decir que tiene 31 días, pero bueno, ahí ejemplifica otra vez cómo lo escribiríamos usando un if.

146
00:14:01,760 --> 00:14:11,760
Y aquí, bueno, si lo probamos, el mes 3, que es marzo, tiene 31 días. El mes 4, que es abril, pues tiene solamente 30.

147
00:14:11,760 --> 00:14:19,760
Esto con un match case se podría escribir así. Entonces vean que aquí lo nuevo que estamos introduciendo

148
00:14:19,760 --> 00:14:26,760
a diferencia del ejemplo anterior, estamos haciendo aquí la barrita vertical que normalmente entendemos como una operación or.

149
00:14:26,760 --> 00:14:33,760
Entonces si el mes es 11 o 4 o 6 o 9, cualquiera son las posibles opciones, regresa 30.

150
00:14:33,760 --> 00:14:38,760
Si el mes es 2, exclusivamente regresa 28. Y aquí estamos agregando un guión bajo.

151
00:14:38,760 --> 00:14:44,760
El guión bajo significa, haz la coincidencia, el match con cualquiera.

152
00:14:44,760 --> 00:14:54,760
El guión bajo es una forma de hacer justamente el pattern matching ahí, específicamente la coincidencia del patrón.

153
00:14:54,760 --> 00:15:00,760
Esto es con cualquier cosa, sin generar enlaces con alguna variable en particular.

154
00:15:00,760 --> 00:15:05,760
Entonces cualquier otro mes que no sea alguno de los que entró aquí se va por esta opción.

155
00:15:05,760 --> 00:15:12,760
Recuerden que esto en inglés le llaman wildcard en español, pues normalmente lo he escuchado referido como comodín,

156
00:15:12,760 --> 00:15:17,760
pensando así como en las barajas.

157
00:15:17,760 --> 00:15:22,760
Al joker se le llama también comodín y es también este concepto de wildcard.

158
00:15:22,760 --> 00:15:24,760
Entonces cualquiera que no sea de estos regresa 31.

159
00:15:24,760 --> 00:15:30,760
Entonces igual aquí lo podemos probar. Aquí el mes 2 me regresa 28.

160
00:15:30,760 --> 00:15:36,760
Pero por ejemplo si aquí le ponemos el mes 12, pues me regresa 31.

161
00:15:36,760 --> 00:15:41,760
Aquí entraría justamente por el comodín.

162
00:15:41,760 --> 00:15:46,760
Vamos a un tercer ejemplo, un tercer problema.

163
00:15:46,760 --> 00:15:53,760
¿Cómo convertimos cualquier número entero del 1 al 1000 a su correspondiente valor como número romano?

164
00:15:53,760 --> 00:15:58,760
Este es un ejercicio que a menudo se deja en un primer curso de programación.

165
00:15:59,760 --> 00:16:04,760
Aquí el match case puede utilizarse de manera abusiva.

166
00:16:04,760 --> 00:16:07,760
Y esto sí lo he llegado a ver.

167
00:16:07,760 --> 00:16:09,760
A lo mejor ustedes también lo han llegado a ver.

168
00:16:09,760 --> 00:16:12,760
Pero una primera solución es una cosa como esta.

169
00:16:17,760 --> 00:16:22,760
Muy bien, noten aquí, hay justamente una observación que este es un muy mal ejemplo del uso de match case.

170
00:16:22,760 --> 00:16:26,760
Recuerden que esos son los números del 1 al 1000 los que quiero yo convertir.

171
00:16:26,760 --> 00:16:29,760
Entonces aquí de repente los alumnos dicen, ah, pues muy fácil.

172
00:16:29,760 --> 00:16:36,760
Case 1 regresa ahí. Case 2 regresa a 2, 2. Case 3 regresa a 3 y así.

173
00:16:36,760 --> 00:16:38,760
¿Hasta qué número queremos llegar?

174
00:16:43,760 --> 00:16:45,760
Hasta el 1000.

175
00:16:47,760 --> 00:16:49,760
¿Ustedes creen que yo tecleé este problema?

176
00:16:50,760 --> 00:16:52,760
¿Qué opinan?

177
00:16:52,760 --> 00:16:55,760
Pues sí, ayer no dormí tecleándolo.

178
00:16:55,760 --> 00:17:00,760
No, no es cierto, de hecho lo que hice fue un programa que genere ese código.

179
00:17:00,760 --> 00:17:04,760
Eso se llama metaprogramación, programas que generan programas.

180
00:17:04,760 --> 00:17:06,760
Entonces ahí está.

181
00:17:06,760 --> 00:17:08,760
Y si funciona.

182
00:17:08,760 --> 00:17:10,760
Y si hay alumnos que lo llegan a escribir así.

183
00:17:10,760 --> 00:17:15,760
Me llevo 5 horas pero por lo menos no tengo que pensar en cosas complicadas.

184
00:17:15,760 --> 00:17:19,760
Bueno, esto se pudo haber hecho también muy fácil con if y el ifs y demás.

185
00:17:19,760 --> 00:17:25,760
Pero bueno, esto es un ejemplo de cómo se puede mal usar y abusar el match case.

186
00:17:25,760 --> 00:17:32,760
Se usa como siempre, aquí el número romano 999, pues es este.

187
00:17:32,760 --> 00:17:35,760
C, M, X, C, U, Y, X.

188
00:17:35,760 --> 00:17:37,760
Bueno, esto es nada más para no dejarlo.

189
00:17:37,760 --> 00:17:40,760
No usa switch, switch, switch, switch.

190
00:17:40,760 --> 00:17:44,760
Este sería una forma más óptima de hacer el código.

191
00:17:44,760 --> 00:17:48,760
Nuevamente, aquí los diccionarios son nuestra mejor ayuda.

192
00:17:48,760 --> 00:17:52,760
Y aquí simplemente con un while y con el uso aquí del diccionario.

193
00:17:52,760 --> 00:17:55,760
Se logra hacer justamente lo mismo.

194
00:17:55,760 --> 00:17:57,760
Con muchísimo menos líneas de código.

195
00:17:57,760 --> 00:18:00,760
Vean que aquí quedaron en 2007 líneas de código.

196
00:18:00,760 --> 00:18:02,760
Esta tiene 14 líneas de código.

197
00:18:02,760 --> 00:18:05,760
Entonces hay una diferencia bastante grande.

198
00:18:05,760 --> 00:18:09,760
Pero al final le cuentas que el resultado es exactamente el mismo en cuanto a la funcionalidad.

199
00:18:09,760 --> 00:18:13,760
De hecho, esta versión de aquí incluso funciona con números del 1 al...

200
00:18:13,760 --> 00:18:17,760
Pues me parece que el último número válido sería el 3999.

201
00:18:17,760 --> 00:18:21,760
Esto que serían 3M, que creo que es lo más que se permite.

202
00:18:21,760 --> 00:18:24,760
No estoy muy seguro en eso, pero bueno.

203
00:18:24,760 --> 00:18:29,760
Aquí nuevamente, este es un ejemplo donde se puede usar el match case.

204
00:18:29,760 --> 00:18:33,760
Pero seguramente no es definitivamente la mejor opción.

205
00:18:33,760 --> 00:18:37,760
Vamos al siguiente problema.

206
00:18:37,760 --> 00:18:39,760
El problema 4.

207
00:18:39,760 --> 00:18:45,760
A partir de una carta de una baraja inglesa, representada en una tupla de la forma rango y palo.

208
00:18:45,760 --> 00:18:49,760
Aquí como está en color verdecito.

209
00:18:49,760 --> 00:18:51,760
Determinaron su valor numérico.

210
00:18:51,760 --> 00:18:55,760
Vamos a suponer que queremos que la baraja inglesa sea la mejor.

211
00:18:55,760 --> 00:18:59,760
El rango puede ser los números del 2 al 10.

212
00:18:59,760 --> 00:19:02,760
2, 3, 4, 5, 6, 7, 8, 9, 10.

213
00:19:02,760 --> 00:19:05,760
Los demás van a utilizar un string.

214
00:19:05,760 --> 00:19:09,760
En el caso de la carta del A, va a ser la letra A.

215
00:19:09,760 --> 00:19:13,760
La J va a ser la letra J.

216
00:19:13,760 --> 00:19:17,760
La reina va a ser la letra Q.

217
00:19:17,760 --> 00:19:20,760
Y el rey va a ser la letra A.

218
00:19:20,760 --> 00:19:24,760
El palo puede ser uno de los nombres que usamos para determinar los palos.

219
00:19:24,760 --> 00:19:28,760
Pueden ser treble, diamante, corazón, picas.

220
00:19:28,760 --> 00:19:32,760
Los diferentes palos que tenemos.

221
00:19:32,760 --> 00:19:38,760
A partir de esto queremos que nos de un valor numérico.

222
00:19:38,760 --> 00:19:42,760
Vamos a ver cómo podemos hacer esto.

223
00:19:42,760 --> 00:19:46,760
Las reglas son muy sencillas.

224
00:19:46,760 --> 00:19:50,760
Si la carta representa una carta con número.

225
00:19:50,760 --> 00:19:54,760
2, 3, 4, 5, 6, 7, 8, 9, 10.

226
00:19:54,760 --> 00:19:58,760
Ese es su valor numérico.

227
00:19:58,760 --> 00:20:02,760
A la J le vamos a dar el valor de 11.

228
00:20:02,760 --> 00:20:06,760
A la reina el valor de 12.

229
00:20:06,760 --> 00:20:10,760
A la reina 13.

230
00:20:10,760 --> 00:20:14,760
A la reina 14.

231
00:20:14,760 --> 00:20:18,760
A la reina 15.

232
00:20:18,760 --> 00:20:22,760
A la reina 16.

233
00:20:22,760 --> 00:20:26,760
A la reina 17.

234
00:20:26,760 --> 00:20:30,760
A la reina 18.

235
00:20:30,760 --> 00:20:34,760
A la reina 19.

236
00:20:34,760 --> 00:20:38,760
A la reina 20.

237
00:20:38,760 --> 00:20:42,760
A la reina 21.

238
00:20:42,760 --> 00:20:46,760
A la reina 22.

239
00:20:46,760 --> 00:20:50,760
A la reina 23.

240
00:20:50,760 --> 00:20:54,760
A la reina 24.

241
00:20:54,760 --> 00:20:58,760
A la reina 25.

242
00:20:58,760 --> 00:21:02,760
A la reina 26.

243
00:21:02,760 --> 00:21:06,760
A la reina 27.

244
00:21:06,760 --> 00:21:10,760
A la reina 28.

245
00:21:10,760 --> 00:21:14,760
A la reina 29.

246
00:21:14,760 --> 00:21:18,760
A la reina 30.

247
00:21:18,760 --> 00:21:22,760
A la reina 31.

248
00:21:22,760 --> 00:21:26,760
A la reina 32.

249
00:21:26,760 --> 00:21:30,760
A la reina 33.

250
00:21:30,760 --> 00:21:34,760
Y aquí nada más checamos, le decimos X.

251
00:21:34,760 --> 00:21:38,760
Cuando ustedes incluyen aquí en el case cualquier cosa que pueda ser considerada una variable,

252
00:21:38,760 --> 00:21:42,760
esa variable se va a instanciar o se va a enlazar al valor

253
00:21:42,760 --> 00:21:46,760
que está en esa posición. Y luego podemos añadirla acá.

254
00:21:46,760 --> 00:21:50,760
Este es un IF dentro del case. Este IF en particular se le llama una guardia.

255
00:21:50,760 --> 00:21:54,760
No solamente basta con que haga la coincidencia

256
00:21:54,760 --> 00:21:58,760
con la estructura, tiene también que cumplir con la condición que estoy colocando aquí.

257
00:21:58,760 --> 00:22:02,760
Estoy pidiendo que X sea un entero

258
00:22:02,760 --> 00:22:06,760
usando aquí el instance. Y además también que X

259
00:22:06,760 --> 00:22:10,760
esté en el rango del 2 al 10 inclusive.

260
00:22:10,760 --> 00:22:14,760
Entonces si cumple todo eso, entonces esta es una carta válida cuyo valor numérico

261
00:22:14,760 --> 00:22:18,760
es justamente X. No hay que hacerle aquí nada más, pero nada más hay que verificar

262
00:22:18,760 --> 00:22:22,760
que sí sea lo que queremos. Y si no, aquí estamos arrojando una excepción

263
00:22:22,760 --> 00:22:26,760
indicando que la carta no es válida. Entonces aquí por ejemplo

264
00:22:26,760 --> 00:22:30,760
si le pido cuál es el rango de la carta de la J

265
00:22:30,760 --> 00:22:34,760
de picas. Aquí la J, pues vimos de este lado,

266
00:22:34,760 --> 00:22:38,760
es 11 sin importar realmente el palo.

267
00:22:38,760 --> 00:22:42,760
Si aquí cambiamos y le ponemos un 5, pues su rango

268
00:22:42,760 --> 00:22:46,760
va a ser 5. Cuando aquí tenemos un número del 2 al 10,

269
00:22:46,760 --> 00:22:50,760
ese es el valor, el rango de la carta. Nada más como detrás

270
00:22:50,760 --> 00:22:54,760
interesante, imagínense que tengo yo una baraja que es una lista

271
00:22:54,760 --> 00:22:58,760
de las cartas. Aquí tengo la reina de corazones,

272
00:22:58,760 --> 00:23:02,760
aquí tengo el 5 de tréboles, la J de pica,

273
00:23:02,760 --> 00:23:06,760
el 7 de diamantes. Y vamos a suponer que quiero yo ordenarlos de acuerdo a su

274
00:23:06,760 --> 00:23:10,760
rango. Entonces pues podemos usar aquí la operación sorted,

275
00:23:10,760 --> 00:23:14,760
la función ya predefinida sorted. Y esta simplemente le decimos que queremos

276
00:23:14,760 --> 00:23:18,760
ordenar, en este caso baraja. Y hay un parámetro muy padre,

277
00:23:18,760 --> 00:23:22,760
muy interesante que se llama Key. En donde le digo

278
00:23:22,760 --> 00:23:26,760
antes de hacer la comparación a cada uno de mis valores

279
00:23:26,760 --> 00:23:30,760
mandales, o sea aplica esta función que se llama rango-carta

280
00:23:30,760 --> 00:23:34,760
y mandale de parámetro ese valor que en ese momento se va a comparar.

281
00:23:34,760 --> 00:23:38,760
Entonces va a usar mi función que definimos aquí. Entonces nos va a

282
00:23:38,760 --> 00:23:42,760
permitir ordenar justamente mi baraja, mi objeto baraja

283
00:23:42,760 --> 00:23:46,760
justamente por rango. Entonces cuando nosotros

284
00:23:46,760 --> 00:23:50,760
evaluamos aquí, vean que está los mismos elementos

285
00:23:50,760 --> 00:23:54,760
de acá pero ya en rango. Está primero el 5, el 7 y luego la J

286
00:23:54,760 --> 00:23:58,760
y la reina. Entonces hay un caso

287
00:23:58,760 --> 00:24:02,760
interesante de cómo ordenamos ahí nuestras cartas.

288
00:24:02,760 --> 00:24:06,760
Tenemos

289
00:24:06,760 --> 00:24:10,760
aquí un problema, el cuarto problema. A partir de

290
00:24:10,760 --> 00:24:14,760
una carta de una baraja, perdón, este es el 5,

291
00:24:14,760 --> 00:24:18,760
imprimir los números del 1 al 100, pero en lugar de

292
00:24:18,760 --> 00:24:22,760
imprimir el número, hay que colocar

293
00:24:22,760 --> 00:24:26,760
algunos números en especial, los que sean divisibles entre 3,

294
00:24:26,760 --> 00:24:32,760
entre 5 y entre 3 y 5, entre los dos. Cuando encuentro yo un 3, quiero que en lugar de imprimir el número,

295
00:24:32,760 --> 00:24:36,760
imprima Fizz. Cuando encuentre un número múltiplo de 5, en lugar de imprimir ese número que imprima

296
00:24:36,760 --> 00:24:42,760
Buzz y cuando es múltiplo de ambos, que imprima Fizz-Buzz. Hace algunos años, de hecho no sé si llegaron a escuchar,

297
00:24:42,760 --> 00:24:46,760
por ahí alguien se le ocurrió hacer un blog donde decía

298
00:24:46,760 --> 00:24:50,760
que yo quería a 200 personas, 200 programadores

299
00:24:50,760 --> 00:24:54,760
para un puesto que tengo en mi empresa y resulta que de los 200,

300
00:24:54,760 --> 00:24:58,760
creo que decía así como 190 no sabían resolver este problema,

301
00:24:58,760 --> 00:25:02,760
el famoso problema del Fizz-Buzz. Este está inspirado en un juego infantil,

302
00:25:02,760 --> 00:25:06,760
inglés me parece.

303
00:25:06,760 --> 00:25:10,760
Entonces ya se volvió así como que canónica, como de las primeras preguntas

304
00:25:10,760 --> 00:25:14,760
que te hacen en una entrevista de trabajo, pudiera ser esta, la del Fizz-Buzz.

305
00:25:14,760 --> 00:25:18,760
Este es un caso donde de hecho el uso del

306
00:25:18,760 --> 00:25:22,760
match y case viene bastante bien,

307
00:25:22,760 --> 00:25:26,760
muy conveniente. Vean aquí, estoy usando un 4

308
00:25:26,760 --> 00:25:30,760
de un rango que va del 1 hasta el 100.

309
00:25:30,760 --> 00:25:34,760
El 101 es un límite superior exclusivo. Entonces aquí llega hasta el 100.

310
00:25:34,760 --> 00:25:38,760
Hacemos un match y aquí creamos justamente una tupla,

311
00:25:38,760 --> 00:25:42,760
donde el primer valor es el módulo de INT3 y

312
00:25:42,760 --> 00:25:46,760
el segundo elemento es el módulo de I entre 5. Entonces ahí estamos haciendo la

313
00:25:46,760 --> 00:25:50,760
división de I entre estos dos números. Me va a dar pues

314
00:25:50,760 --> 00:25:54,760
dos valores. Si es 0 tanto en la primera posición como la segunda posición,

315
00:25:54,760 --> 00:25:58,760
quiere decir que el número es divisible tanto por 5 como por 3,

316
00:25:58,760 --> 00:26:02,760
que es este caso que está aquí. Y en este caso imprime justamente

317
00:26:02,760 --> 00:26:06,760
Fizz-Buzz seguido de una coma y un espacio en lugar de un salto al iniesto

318
00:26:06,760 --> 00:26:10,760
para que aparezca todo corrido y no así de

319
00:26:10,760 --> 00:26:14,760
cada resultado en su propia línea.

320
00:26:14,760 --> 00:26:18,760
Digo, si quisiéramos que fuera así, pues le quitamos el N y ya lo hace.

321
00:26:18,760 --> 00:26:22,760
En este caso cheque esta situación en donde es divisible entre

322
00:26:22,760 --> 00:26:26,760
los dos, entonces imprime Fizz-Buzz. Si está aquí, de hecho aquí es importante

323
00:26:26,760 --> 00:26:30,760
ver los case se revisan en el orden en que están.

324
00:26:30,760 --> 00:26:34,760
Si aquí le decimos que es 0 y aquí no importa, quiere decir

325
00:26:34,760 --> 00:26:38,760
para llegar a este punto, este que está acá que no importa, pues no fue 0, porque si no

326
00:26:38,760 --> 00:26:42,760
se había ido acá. Entonces en ese caso quiere decir que es divisible, si fue divisible entre 3,

327
00:26:42,760 --> 00:26:46,760
pero no entre 5, imprimimos Fizz y acá es cuando no fue divisible

328
00:26:46,760 --> 00:26:50,760
entre 3, pero si entre 5, entonces aquí imprimimos Buzz. Y si no fue ninguno de estos,

329
00:26:50,760 --> 00:26:54,760
pues imprimimos el valor de I. Entonces si aquí ya lo

330
00:26:54,760 --> 00:26:58,760
vemos corriendo, ahí tenemos

331
00:26:58,760 --> 00:27:02,760
la solución de este problema de una manera muy compacta,

332
00:27:02,760 --> 00:27:06,760
muy elegante. Entonces ahí está el 1, 2. El siguiente número

333
00:27:06,760 --> 00:27:10,760
es divisible entre 3, entonces imprime Fizz, 4. El siguiente número es divisible

334
00:27:10,760 --> 00:27:14,760
entre 5, entonces imprime Buzz. Aquí el 6, pues es divisible entre 3.

335
00:27:14,760 --> 00:27:18,760
Aquí los que son divisibles entre los dos, de hecho son múltiplos de 15. Entonces el 15,

336
00:27:18,760 --> 00:27:22,760
el 30, el 45, esos son los que aparecen

337
00:27:22,760 --> 00:27:26,760
con Fizz-Buzz como pueden ver aquí.

338
00:27:26,760 --> 00:27:30,760
Siguiente tenemos el

339
00:27:30,760 --> 00:27:34,760
problema número 6. Este es el problema del cuadro mágico.

340
00:27:34,760 --> 00:27:38,760
Un cuadro mágico, en este caso lo vamos a representar como una lista con listas anidadas

341
00:27:38,760 --> 00:27:42,760
y va a representar esta matriz. Acá si ustedes suman

342
00:27:42,760 --> 00:27:46,760
los renglones, 8 más 1 más 6, 3 más 5 más 7,

343
00:27:46,760 --> 00:27:50,760
4 más 9 más 2, cada renglón individual, sus elementos individuales,

344
00:27:50,760 --> 00:27:54,760
lo suman y les debe dar 15. Lo mismo, las columnas si suman los valores,

345
00:27:54,760 --> 00:27:58,760
8 más 3 más 4, 1 más 5 más 9, 6 más 7 más 2, cada columna

346
00:27:58,760 --> 00:28:02,760
independientemente suma 15. Y las diagonales,

347
00:28:02,760 --> 00:28:06,760
8 más 5 más 2 nos da 15 y 6 más 5 más 4 nos da 15.

348
00:28:06,760 --> 00:28:10,760
Entonces el código correspondiente para eso, usando

349
00:28:10,760 --> 00:28:14,760
el match. Podría verse así, un poquito extenso, pero funciona bien.

350
00:28:14,760 --> 00:28:18,760
Estoy agregándole aquí nada más al principio

351
00:28:18,760 --> 00:28:22,760
generando una lista con los elementos de los tableros como, si quieren vamos a ver

352
00:28:22,760 --> 00:28:26,760
hasta acá bajito, viene la forma en que este cuadrito se representaría.

353
00:28:26,760 --> 00:28:30,760
Es una lista de listas, entonces estamos colocando el primer renglón, segundo renglón,

354
00:28:30,760 --> 00:28:34,760
tercer renglón. Entonces lo primero que hacemos de hecho aquí en este código

355
00:28:34,760 --> 00:28:38,760
es ponerlo todo en una sola lista.

356
00:28:38,760 --> 00:28:42,760
La vamos a ordenar por conveniencia,

357
00:28:42,760 --> 00:28:46,760
para que ahorita hagamos una verificación, necesitamos para checar que tenemos los datos que esperamos.

358
00:28:46,760 --> 00:28:50,760
La lista ya al final generada tiene que tener exactamente 9 elementos.

359
00:28:50,760 --> 00:28:54,760
Si lo convierte en un set, el set no permite repeticiones,

360
00:28:54,760 --> 00:28:58,760
entonces después de convertirlo en un set, debe seguir habiendo 9 elementos.

361
00:28:58,760 --> 00:29:02,760
En cualquier momento, si en cualquier de estos valores no se da,

362
00:29:02,760 --> 00:29:06,760
regresa falso, no es un cuadro mágico.

363
00:29:06,760 --> 00:29:10,760
Finalmente, checo que el primer elemento sea 1 y que el último elemento sea 9.

364
00:29:10,760 --> 00:29:14,760
Esta es una validación previa nada más para checar que estemos partiendo de datos válidos.

365
00:29:14,760 --> 00:29:18,760
Luego aquí está, si se fijan, vamos a hacer un case en donde colocamos estas variables

366
00:29:18,760 --> 00:29:22,760
aquí en esta estructura que espera encontrar.

367
00:29:22,760 --> 00:29:26,760
Si encuentra que los valores del primer renglón a b y c, si sumados dan diferente de 15,

368
00:29:26,760 --> 00:29:30,760
entonces esto no es un cuadro mágico.

369
00:29:30,760 --> 00:29:34,760
Lo mismo aquí, checamos con respecto al segundo renglón, al tercer renglón,

370
00:29:34,760 --> 00:29:38,760
a la primera columna, la segunda columna, la tercera columna, si alguno de ellos

371
00:29:38,760 --> 00:29:42,760
su suma es distinta de 15, pues regresa falso.

372
00:29:42,760 --> 00:29:46,760
Y lo mismo aquí, checamos las diagonales. Y finalmente aquí, esta última,

373
00:29:46,760 --> 00:29:50,760
checa que realmente sea un cuadro lo que tenemos, porque puede ser que a lo mejor

374
00:29:50,760 --> 00:29:54,760
sí teníamos tres listas iniciales, pero no tenían esa estructura.

375
00:29:54,760 --> 00:29:58,760
Y luego a este punto quiere decir, si es un cuadro, si es un cuadro mágico,

376
00:29:58,760 --> 00:30:02,760
porque en algún momento dado alguno de estas, o bueno, dio todas estas que fueron

377
00:30:02,760 --> 00:30:06,760
igual a 15, las sumas de renglones, columnas y diagonales.

378
00:30:06,760 --> 00:30:10,760
Y si me mandaron otra cosa totalmente distinta, pues regresamos falso.

379
00:30:10,760 --> 00:30:14,760
Aquí checamos este cuadro mágico, es el mismo que estaba en la ilustración, aquí regresa verdadero.

380
00:30:14,760 --> 00:30:18,760
Pero aquí por ejemplo hay otro que si no tuviera la última validación de aquí,

381
00:30:18,760 --> 00:30:22,760
sí cumpliría con todo lo que estamos viendo.

382
00:30:22,760 --> 00:30:26,760
Es un cuadro mágico. Y de hecho también, si aquí le mandan alguna cosa

383
00:30:26,760 --> 00:30:30,760
que es un número, que no se parece a nada a lo que estamos esperando,

384
00:30:30,760 --> 00:30:34,760
ah no, aquí sí marca un error. Sí, es que aquí, como estamos nosotros

385
00:30:34,760 --> 00:30:38,760
al principio, suponiendo que si hay tres elementos en la lista,

386
00:30:38,760 --> 00:30:42,760
marca un error, pero bueno, ahí podríamos tener un poquito más de cuidado

387
00:30:42,760 --> 00:30:46,760
para evitar nada más esta parte.

388
00:30:46,760 --> 00:30:50,760
Y ya, la última, el último problema que vamos a ver, el problema 7,

389
00:30:50,760 --> 00:30:54,760
es una función que se llama aplana, que va a aplanar una lista

390
00:30:54,760 --> 00:30:58,760
compuesta de listas anidadas a cualquier nivel de profundidad.

391
00:30:58,760 --> 00:31:02,760
Este es digamos que el ejemplo un poquito más complicado porque requiere recursión, como que sí, sí, no es necesariamente

392
00:31:02,760 --> 00:31:06,760
algo trivial para el que está aprendiendo a programar, a menos de que digo, ya haya

393
00:31:06,760 --> 00:31:10,760
aprendido esa recursión, pero lo vemos muy rápidamente.

394
00:31:10,760 --> 00:31:14,760
Aquí, para que vean, una lista con listas anidadas sería un ejemplo como esto.

395
00:31:14,760 --> 00:31:18,760
Lo que queremos es regresar a una lista que nada más tenga los puros elementos,

396
00:31:18,760 --> 00:31:22,760
en este caso los números, 1, 2, 3, 4, 5 y 6,

397
00:31:22,760 --> 00:31:26,760
sin listas anidadas. Entonces, la plana queremos que regrese esto.

398
00:31:26,760 --> 00:31:30,760
Muy bien, ¿cómo se podría definir esto?

399
00:31:30,760 --> 00:31:34,760
Pues podría ser así. Hacemos un match de la lista

400
00:31:34,760 --> 00:31:38,760
y aquí, algo nuevo que no habíamos usado antes es este asterisco.

401
00:31:38,760 --> 00:31:42,760
Básicamente hace coincidencia, hace match,

402
00:31:42,760 --> 00:31:46,760
en este caso, bueno, con una lista que tiene un primer elemento y luego la cola es

403
00:31:46,760 --> 00:31:50,760
todo lo que sigue en la lista, cualquier otro elemento. Podría ser incluso vacío

404
00:31:50,760 --> 00:31:54,760
si la lista nada más tiene un elemento, pero si hay más elementos, todos

405
00:31:54,760 --> 00:31:58,760
quedan aquí en esta variable cola. Entonces, si cabeza

406
00:31:58,760 --> 00:32:02,760
a su vez es una lista, entonces el aplanamiento, aquí es donde usamos la recursión,

407
00:32:02,760 --> 00:32:06,760
consiste en aplanar la cabeza, que es una lista, y la cola, que también sabemos que es una lista.

408
00:32:06,760 --> 00:32:10,760
Y luego simplemente las concatenamos aquí con el más.

409
00:32:10,760 --> 00:32:14,760
Si no es el caso, aquí se ve el mismo patrón, pero aquí ya no está

410
00:32:14,760 --> 00:32:18,760
restringido a lo que el guardia está marcando. Cualquier valor que

411
00:32:18,760 --> 00:32:22,760
sea cabeza simplemente lo metemos en una listita y se lo concatenamos al aplanado

412
00:32:22,760 --> 00:32:26,760
de la cola, porque la cola siempre va a ser una lista. Y si me dan cualquier otra cosa,

413
00:32:26,760 --> 00:32:30,760
incluyendo una lista vacía, regreso una lista vacía. Pero si también me dan alguna cosa

414
00:32:30,760 --> 00:32:34,760
que no es una lista, pues aquí también regresa la lista vacía. Entonces, con esto

415
00:32:34,760 --> 00:32:38,760
funciona justamente bien así como lo tenemos. También

416
00:32:38,760 --> 00:32:42,760
me parece que es una solución bastante interesante y elegante respecto

417
00:32:42,760 --> 00:32:48,760
al uso de Match Case. Y bueno, pues nada más aquí ya para cerrar.

418
00:32:48,760 --> 00:32:52,760
¿Qué aprendizajes obtenemos aquí a partir de estos ejemplos que estamos viendo?

419
00:32:52,760 --> 00:32:56,760
Pues que el Match Case es expresivo, es fácil de usar. En algunas situaciones

420
00:32:56,760 --> 00:33:00,760
puede resultar más conveniente que usar IFS o alguna otra situación.

421
00:33:00,760 --> 00:33:04,760
Sin embargo, también es muy fácil de abusar si no conocemos

422
00:33:04,760 --> 00:33:08,760
a usar correctamente las alternativas. Entonces, aquí en particular,

423
00:33:08,760 --> 00:33:12,760
pues para la gente que está aprendiendo, se les recomienda que aprendan también

424
00:33:12,760 --> 00:33:16,760
a usar bien diccionarios. En algunas ocasiones el uso de un diccionario es preferible al Match Case.

425
00:33:16,760 --> 00:33:20,760
Vimos ya un par de ejemplos de estas circunstancias en particular.

426
00:33:20,760 --> 00:33:24,760
Y también recuerden que Python soporta esto que es desestructuramiento,

427
00:33:24,760 --> 00:33:28,760
o como lo quieran traducir, ese es el término de destructuring.

428
00:33:28,760 --> 00:33:34,760
En español podría ser, digo la palabra, me parece que realmente no existe

429
00:33:34,760 --> 00:33:40,760
desestructuramiento, o como la quieran llamar, desestructuración o desestructurancia.

430
00:33:40,760 --> 00:33:44,760
Pero bueno, el destructuring que llamamos en inglés me permite tomar una lista,

431
00:33:44,760 --> 00:33:48,760
una secuencia y partirla en varias variables de manera muy conveniente.

432
00:33:48,760 --> 00:33:52,760
Les recomiendo que lo revisen. Y si quieren conocer más,

433
00:33:52,760 --> 00:33:58,760
mis recomendaciones, revisen el PEP 636. Es un tutorial justamente para el Match Case.

434
00:33:58,760 --> 00:34:02,760
Está bastante bien. La verdad es que me gusta ahí como lo que está.

435
00:34:02,760 --> 00:34:06,760
Como le explican, trae una apéndice donde va muy al grano,

436
00:34:06,760 --> 00:34:14,760
pero el resto del tutorial va poniendo como caso hipotético la escritura de un programa de ficción interactiva,

437
00:34:14,760 --> 00:34:18,760
que son estos programas de aventura. A lo mejor algunos llegaron a usarlos en donde

438
00:34:18,760 --> 00:34:24,760
les describía el programa. Estás en un bosque oscuro y al lado izquierdo hay un castillo,

439
00:34:24,760 --> 00:34:28,760
y del lado derecho hay otro camino que te lleva más adentro del bosque.

440
00:34:28,760 --> 00:34:32,760
¿Qué quieres hacer? Y ustedes podrían escribir. Quiero ir al castillo.

441
00:34:32,760 --> 00:34:38,760
Trae un ejemplo así de ese estilo. Está interesante, está entretenido,

442
00:34:38,760 --> 00:34:42,760
está bastante completa la explicación de este PEP.

443
00:34:42,760 --> 00:34:46,760
Revísenlo si quieren conocer más al respecto.

444
00:34:46,760 --> 00:34:52,760
Y por mi parte, eso sería todo. Soy Ariel Ortiz. Muchas gracias por estar aquí.

445
00:34:52,760 --> 00:34:54,760
Muy buena tarde.

446
00:34:58,760 --> 00:35:06,760
Si no tienen prisa, yo voy a estar aquí. Si quieren preguntar de una vez, lo pueden hacer ahora.

447
00:35:06,760 --> 00:35:10,760
Si no, me pueden abordar aquí en cortito.

448
00:35:10,760 --> 00:35:12,760
Sí, adelante.

449
00:35:20,760 --> 00:35:26,760
Fíjate que no desconozco si ya hay benchmarks. En la práctica de la mañana comentaban que están buscando...

450
00:35:26,760 --> 00:35:32,760
Bueno, más bien, que habían introducido, de hecho, instrucciones nuevas ya en el código generado.

451
00:35:32,760 --> 00:35:36,760
Recuerden que Python se traduce internamente a un código intermedio interno.

452
00:35:36,760 --> 00:35:42,760
Introdujeron algunos códigos especiales para ser un poco más rápido que usando IFS convencionales.

453
00:35:42,760 --> 00:35:48,760
No sé si a estas alturas lo sea, pero me parece que alguna de las cosas que se intentará en el futuro

454
00:35:48,760 --> 00:35:55,760
sí es garantizar que cuando usas un match case sea lo más rápido que pueda, más que si usas IFS, por lo menos.

455
00:35:55,760 --> 00:36:00,760
Probablemente nunca va a ser más rápido que los diccionarios, porque los diccionarios trabajan con tablas de hash

456
00:36:00,760 --> 00:36:02,760
y esos sí son súper rapidísimos.

457
00:36:02,760 --> 00:36:06,760
Y dudo que puedan hacer que el match case pudiera llegar a esas velocidades,

458
00:36:06,760 --> 00:36:11,760
salvo que optaran por convertir ese código de alguna manera a diccionarios.

459
00:36:11,760 --> 00:36:19,760
Pero específicamente no conozco si hay benchmarks para compararlo, las velocidades.

460
00:36:19,760 --> 00:36:21,760
¿Alguna otra pregunta?

461
00:36:21,760 --> 00:36:23,760
Sí.

462
00:36:23,760 --> 00:36:27,760
¿Desde la 3.10 es que se puede usar el match case?

463
00:36:27,760 --> 00:36:29,760
Desde la 3.10, sí.

464
00:36:29,760 --> 00:36:31,760
Así es.

465
00:36:31,760 --> 00:36:33,760
Sí, esto sí es muy importante que sepan.

466
00:36:33,760 --> 00:36:37,760
De hecho todavía muchas herramientas no lo soportan muy bien.

467
00:36:37,760 --> 00:36:39,760
De hecho aquí lo pueden ver.

468
00:36:39,760 --> 00:36:42,760
Noten aquí que el match y el case no está coloreado de forma distinta.

469
00:36:42,760 --> 00:36:46,760
O sea, de entrada aquí los Jupyter Notebooks, por lo menos esta versión que estoy usando,

470
00:36:46,760 --> 00:36:50,760
todavía no reconoce esto como palabras.

471
00:36:50,760 --> 00:36:52,760
De hecho no son reservadas.

472
00:36:52,760 --> 00:36:55,760
Les llaman soft keywords, palabras suaves.

473
00:36:55,760 --> 00:37:01,760
Para no romper código, porque es muy probable que mucha gente haya tenido ya variables que se llamaban case o que se llamaban match.

474
00:37:01,760 --> 00:37:07,760
Entonces lo que hace Python 3.10 es ver en qué contexto se están usando.

475
00:37:07,760 --> 00:37:11,760
Y si no se están usando en el contexto match case, son estas palabras reservadas.

476
00:37:11,760 --> 00:37:16,760
Pero si tú la estás usando como nombre de una variable o lo que sea, no entra en conflicto.

477
00:37:16,760 --> 00:37:20,760
Porque digo, si fuera una palabra reservada así dura, te marcaría un error.

478
00:37:20,760 --> 00:37:25,760
Entonces mucho el código que usa esas palabras ya reservadas, ya tronaría.

479
00:37:25,760 --> 00:37:30,760
Entonces sí, todavía ahorita, digo, si hacen la cuenta de octubre a la fecha,

480
00:37:30,760 --> 00:37:35,760
estamos hablando apenas de seis meses que se liberó ya oficialmente la versión 3.10.

481
00:37:35,760 --> 00:37:40,760
Entonces todavía no, muchas herramientas no han alcanzado todavía esto.

482
00:37:40,760 --> 00:37:43,760
En particular, por ejemplo, cuando ya he usado Visual Studio Code,

483
00:37:43,760 --> 00:37:48,760
me parece que PyLance es la herramienta del int que se utiliza por default.

484
00:37:48,760 --> 00:37:51,760
Esta las marca como errores sintácticos todavía ahorita.

485
00:37:51,760 --> 00:37:53,760
Entonces tienes que desactivarlo para...

486
00:37:53,760 --> 00:37:57,760
Digo, si no quieres ver ahí, ahora sí que el delineado ahí está ondulado,

487
00:37:57,760 --> 00:38:00,760
marcándolo como error ahorita.

488
00:38:00,760 --> 00:38:03,760
Pero bueno, yo creo que en el lapso de los próximos meses,

489
00:38:03,760 --> 00:38:07,760
muchas herramientas ya se pondrán al corriente para soportarlo bien.

490
00:38:07,760 --> 00:38:12,760
Pero ahorita por el momento sí tendrían que bajar la última versión de Python para funcionar bien.

491
00:38:12,760 --> 00:38:16,760
Digo, yo uso de repente el Google Collaboratory y esa está, por ejemplo,

492
00:38:16,760 --> 00:38:18,760
todavía a bastantes versiones más atrasada.

493
00:38:18,760 --> 00:38:24,760
Entonces ahí sí tendrán que esperar algunos años antes de que esta versión sea la que tienen ahí disponible.

494
00:38:24,760 --> 00:38:28,760
Por lo menos por experiencia, si se tarda un ratillo en tenerlo.

495
00:38:28,760 --> 00:38:32,760
No he revisado, por ejemplo, si la última versión de Anaconda ya trae la versión 3.10.

496
00:38:32,760 --> 00:38:35,760
Pero igual, si estas herramientas son las que usan normalmente,

497
00:38:35,760 --> 00:38:40,760
puede ser que todavía no esté disponible para usuarios de herramientas

498
00:38:40,760 --> 00:38:43,760
que todavía no se han actualizado.

499
00:38:43,760 --> 00:38:46,760
¿Alguna otra pregunta?

500
00:38:46,760 --> 00:38:48,760
Sí.

501
00:38:48,760 --> 00:38:51,760
Gracias.

502
00:38:51,760 --> 00:39:00,760
¿Tiene alguna regla mágica donde decía más allá de todo un e-mail,

503
00:39:00,760 --> 00:39:05,760
cuáles son las buenas ideas de usar un case o, bueno, obviamente,

504
00:39:05,760 --> 00:39:10,760
no vamos a meter ahí un piso en la red porque sería ya, obviamente, que ganaría por un efecto,

505
00:39:10,760 --> 00:39:13,760
pero es un e-mail sin case en el que hay algún...

506
00:39:13,760 --> 00:39:19,760
Sí, la regla en general, así como que la pauta o lo podríamos llamar la heurística en general,

507
00:39:19,760 --> 00:39:23,760
bueno, primero, para que sea match, tiene que ser sobre un mismo valor,

508
00:39:23,760 --> 00:39:27,760
una misma expresión inicial y todos los case tienen que estar relacionados ahí.

509
00:39:27,760 --> 00:39:31,760
El if, tú puedes tener tus if y el if totalmente independientes.

510
00:39:31,760 --> 00:39:37,760
Tú en el if puedes preguntar sobre la variable X y en el if sobre la variable Y.

511
00:39:37,760 --> 00:39:41,760
O sea, no tienen que tener absolutamente ninguna relación las preguntas.

512
00:39:41,760 --> 00:39:43,760
En el match case sí es.

513
00:39:43,760 --> 00:39:47,760
Entonces, de entrada, si todos son preguntas sobre la misma variable o la misma expresión,

514
00:39:47,760 --> 00:39:49,760
tiene de entrada sentido usar match case.

515
00:39:49,760 --> 00:39:56,760
Pero nuevamente, no hagan lo que hice ahorita con el ejemplo de números romanos.

516
00:39:56,760 --> 00:40:00,760
O sea, definitivamente esa no es la forma correcta de usar el match case.

517
00:40:00,760 --> 00:40:06,760
En general, si son valores así simples, sencillitos,

518
00:40:06,760 --> 00:40:09,760
el match case a lo mejor no tiene mucha ventaja,

519
00:40:09,760 --> 00:40:15,760
pero si ya requieren de lo que estamos viendo aquí de estas coincidencias estructurales,

520
00:40:15,760 --> 00:40:19,760
o sea, donde ya estamos hablando de listas y listas anidadas dentro de listas,

521
00:40:19,760 --> 00:40:23,760
el hacerlo con ifs aunque se puede, empieza realmente a poner muy complicado.

522
00:40:23,760 --> 00:40:27,760
Entonces, el match case definitivamente es la mejor opción en esos casos.

523
00:40:27,760 --> 00:40:35,760
Pero es así muy... como que reglas muy... así como queda el feeling sin ser así muy científicas.

524
00:40:35,760 --> 00:40:39,760
No sé si tengan alguna otra pregunta.

525
00:40:40,760 --> 00:40:43,760
No, pues muchísimas gracias por su atención.

526
00:40:53,760 --> 00:40:55,760
Sí, sí, sí, adelante.

527
00:40:57,760 --> 00:40:59,760
Excelente.

528
00:41:01,760 --> 00:41:04,760
Ok. A ver, creo que ahí salen todos.

529
00:41:04,760 --> 00:41:07,760
Bueno, hagan sí, hagan alguna señal, algo, ¿no?

530
00:41:07,760 --> 00:41:10,760
Para que... por lo menos se vea que no están dormidos, ¿no?

531
00:41:10,760 --> 00:41:11,760
En la plática.

532
00:41:11,760 --> 00:41:14,760
Ok. A ver, dejen de echarme una selfie.

533
00:41:14,760 --> 00:41:17,760
Vamos a ver si... si la logramos.

534
00:41:17,760 --> 00:41:20,760
Donde salgan la gran mayoría.

535
00:41:25,760 --> 00:41:27,760
Perfecto. Muchas gracias.

