1
00:00:00,000 --> 00:00:09,960
So the way we'll do that today is by looking at a number of different tools and best practices

2
00:00:09,960 --> 00:00:14,660
that together build a cohesive end-to-end developer experience where each individual

3
00:00:14,660 --> 00:00:20,000
piece provides value by reducing the overall level of effort needed to maintain an open

4
00:00:20,000 --> 00:00:21,000
source project.

5
00:00:21,000 --> 00:00:24,940
There's a lot to cover and we're going to go fast, but I'll have a GitHub link with

6
00:00:24,940 --> 00:00:28,320
everything that I talk about at the end of the presentation.

7
00:00:28,320 --> 00:00:32,360
So let's jump right in with the foundational pieces that every project needs in order to

8
00:00:32,360 --> 00:00:35,320
function within the greater Python ecosystem.

9
00:00:35,320 --> 00:00:37,080
First up is project metadata.

10
00:00:37,080 --> 00:00:41,160
This is a core requirement to publishing and distributing packages on PyPI and accessible

11
00:00:41,160 --> 00:00:45,340
metadata can also enable developer tooling to better understand our project beyond just

12
00:00:45,340 --> 00:00:47,000
the files on disk.

13
00:00:47,000 --> 00:00:50,960
The best way to do this is with well-structured and standardized metadata.

14
00:00:50,960 --> 00:00:54,320
For anyone who's been around the block in the Python world, starting a new project means

15
00:00:54,320 --> 00:00:56,740
writing a new setup.py.

16
00:00:56,740 --> 00:01:01,180
You import setup tools, you open the readme file, fetch a long description, and maybe

17
00:01:01,180 --> 00:01:04,360
we'll just find another project and copy paste.

18
00:01:04,360 --> 00:01:05,500
We should stop this.

19
00:01:05,500 --> 00:01:06,820
This is not metadata.

20
00:01:06,820 --> 00:01:10,860
It's arbitrary code that needs to be run every time the package is built from source.

21
00:01:10,860 --> 00:01:15,020
Nothing there is standardized beyond whatever setup tools does.

22
00:01:15,020 --> 00:01:19,140
So what we want is a well-defined format that doesn't involve executing someone else's

23
00:01:19,140 --> 00:01:20,140
code.

24
00:01:20,140 --> 00:01:24,500
Thankfully, we've approved standards focused on a single file at the root of Python projects

25
00:01:24,500 --> 00:01:26,420
called PyProject.toml.

26
00:01:26,420 --> 00:01:31,300
This file acts as a central location for project metadata and configuration for developer tools

27
00:01:31,300 --> 00:01:32,300
alike.

28
00:01:32,300 --> 00:01:36,540
The original standards for PyProject.toml were focused around the selection of build

29
00:01:36,540 --> 00:01:41,860
backends, the tools that actually transform your Python sources into installable distributions.

30
00:01:41,860 --> 00:01:47,660
Together, pet 517 and 518 define the build system table, which any package manager can

31
00:01:47,660 --> 00:01:51,900
use to install your preferred build backend and then actually build and install your package.

32
00:01:52,100 --> 00:01:56,700
I'm a fan of Flit, so here we have the Flit core package as the dependency and the associated

33
00:01:56,700 --> 00:01:57,700
build backend.

34
00:01:57,700 --> 00:02:02,620
But these days, our PyProject.toml can also include standardized project metadata thanks

35
00:02:02,620 --> 00:02:04,580
to pep621.

36
00:02:04,580 --> 00:02:09,220
This new format of metadata is in the top-level project table of our file and includes all

37
00:02:09,220 --> 00:02:14,300
of the basic package information that previously lived in setup.py or other backend-specific

38
00:02:14,300 --> 00:02:15,860
configurations.

39
00:02:15,860 --> 00:02:19,980
This unlocks a great potential for developer tooling to understand and use packaged metadata

40
00:02:20,180 --> 00:02:23,220
without the need to support many different formats.

41
00:02:23,220 --> 00:02:27,260
At the top here, we have the basic metadata about the package, as you might expect, including

42
00:02:27,260 --> 00:02:29,820
the minimum Python version requirement.

43
00:02:29,820 --> 00:02:32,260
And here we have our list of package dependencies.

44
00:02:32,260 --> 00:02:36,900
But just listing them isn't often enough and can cause a number of bug reports from users

45
00:02:36,900 --> 00:02:40,900
who want to use your project but have different versions or older versions of those dependencies

46
00:02:40,900 --> 00:02:43,580
or on platforms where they're not supported.

47
00:02:43,580 --> 00:02:47,700
So let's look at how we can better define those dependencies and how that can help guide

48
00:02:47,740 --> 00:02:51,820
users and their package managers towards optimal choices.

49
00:02:51,820 --> 00:02:55,420
So one thing is that things change, especially in software.

50
00:02:55,420 --> 00:02:59,540
Packages will get new features, deprecate functionality, or just outright make breaking

51
00:02:59,540 --> 00:03:01,300
changes that will.

52
00:03:01,300 --> 00:03:04,660
That's why we can set version limits on our dependencies to make sure package managers

53
00:03:04,660 --> 00:03:07,000
install compatible versions.

54
00:03:07,000 --> 00:03:12,100
If we wanted to absolutely guarantee compatibility, we could pin our dependencies to exact versions.

55
00:03:12,100 --> 00:03:15,940
But that's not convenient for users, especially if another package wants to pin to a different

56
00:03:15,940 --> 00:03:17,380
version.

57
00:03:17,380 --> 00:03:22,220
So even if we expand our limits to anything with a major version, we're still potentially

58
00:03:22,220 --> 00:03:26,540
leaving users on old versions open to bugs and security vulnerabilities.

59
00:03:26,540 --> 00:03:33,060
Instead, we can compromise and specify future-friendly version limits on our dependencies.

60
00:03:33,060 --> 00:03:37,100
With this method, we provide only a lower bound on those dependencies, ideally chosen

61
00:03:37,100 --> 00:03:41,860
based on the features we use from them and what versions support those features.

62
00:03:41,860 --> 00:03:44,320
Intermetadata could look something like this.

63
00:03:44,320 --> 00:03:48,640
By skipping the upper version boundary, we're trusting that our dependencies won't suddenly

64
00:03:48,640 --> 00:03:50,240
break compatibility.

65
00:03:50,240 --> 00:03:56,520
That might be a leap of faith, but this trade-off allows our users to upgrade and never potentially

66
00:03:56,520 --> 00:03:58,320
get newer and more secure versions.

67
00:03:58,320 --> 00:04:02,600
It also means we don't need to release a new version of our own project every time one

68
00:04:02,600 --> 00:04:05,480
of our dependencies gets a major feature.

69
00:04:05,480 --> 00:04:10,980
And we can always come back and add an upper limit later if we really need to.

70
00:04:10,980 --> 00:04:14,920
We can also add environment markers to our dependencies for packages that only need to

71
00:04:14,920 --> 00:04:19,620
be installed on specific platforms or backports that aren't needed on newer Python versions.

72
00:04:19,620 --> 00:04:23,220
But once we set them, how do we know our version limits are correct?

73
00:04:23,220 --> 00:04:25,300
The honest answer is we need to validate them.

74
00:04:25,300 --> 00:04:29,420
We need to test this on every version we're allowing.

75
00:04:29,420 --> 00:04:32,740
But if we're being generous on our limits, that's a lot of different versions to test

76
00:04:32,740 --> 00:04:33,740
with.

77
00:04:33,740 --> 00:04:37,780
Well, my coworker Tim wrote a tool to help with exactly that problem.

78
00:04:37,780 --> 00:04:42,780
As the Python packaging ecosystem makes him so happy, he called the tool Pessimist.

79
00:04:42,780 --> 00:04:44,420
What it does is quite simple.

80
00:04:44,420 --> 00:04:48,300
It looks at your project dependencies and runs whatever tests you prefer on all of the

81
00:04:48,300 --> 00:04:52,980
matching versions, then generates a report on whether your limits are valid.

82
00:04:52,980 --> 00:04:57,040
There's also a fast mode, which limits the testing to both the oldest and newest matching

83
00:04:57,040 --> 00:05:03,600
versions specifically for use in local testing or CI when compute time is otherwise limited.

84
00:05:03,600 --> 00:05:07,440
Here we're running it on a project's test suite, and Pessimist validates that it passes

85
00:05:07,440 --> 00:05:09,900
with our limits.

86
00:05:09,900 --> 00:05:14,200
Now that we're confident in our metadata and dependencies, let's focus on building a reproducible

87
00:05:14,200 --> 00:05:16,720
development workflow.

88
00:05:16,720 --> 00:05:21,040
Not only can this simplify the process of developing, testing, and validating our changes,

89
00:05:21,040 --> 00:05:24,420
but it'll also make it that much easier to replicate our development environment on new

90
00:05:24,420 --> 00:05:29,080
machines and VMs, as well as for new developers to pick up our project and immediately make

91
00:05:29,080 --> 00:05:33,120
progress and have confidence that the changes are working.

92
00:05:33,120 --> 00:05:35,920
But just having a list of commands to run isn't really helpful.

93
00:05:35,920 --> 00:05:38,200
You need to have a dedicated command runner.

94
00:05:38,200 --> 00:05:42,120
This will combine all of your build and testing steps into a single command, including any

95
00:05:42,120 --> 00:05:46,920
preparation or setup necessary to get your project running on a new machine.

96
00:05:46,920 --> 00:05:50,440
At a bare minimum, this can be satisfied with make files, and I've personally used them

97
00:05:50,440 --> 00:05:52,960
with many of my projects for the last decade.

98
00:05:52,960 --> 00:05:56,920
But it knows nothing about how Python projects work, and it requires you to re-engineer every

99
00:05:56,920 --> 00:05:58,400
piece of the puzzle.

100
00:05:58,400 --> 00:06:02,920
Ideally, we want something that can do more of that work for us, especially around setting

101
00:06:02,920 --> 00:06:06,040
up virtual environments and installing dependencies.

102
00:06:06,040 --> 00:06:09,640
And we would like to do that on multiple Python versions with a single command.

103
00:06:09,640 --> 00:06:14,200
Tox is one of the most widely used projects for testing, while Knox provides an alternative

104
00:06:14,200 --> 00:06:18,280
system that lets you define your workflow with actual Python code.

105
00:06:18,280 --> 00:06:22,800
But today, I'd like to introduce a new tool I created, a rapid development assistant that

106
00:06:22,800 --> 00:06:25,000
I called THX, or T-H-X.

107
00:06:25,000 --> 00:06:30,040
It uses many of the same basic concepts, but focuses on optimizing the development workflow

108
00:06:30,040 --> 00:06:32,600
for Python projects.

109
00:06:32,600 --> 00:06:38,000
This is configured entirely in your PyProject.toml, and defining simple jobs is straightforward,

110
00:06:38,000 --> 00:06:40,860
with a list of job names and associated commands.

111
00:06:40,860 --> 00:06:45,160
We can then define a subset of those jobs that should be run by default.

112
00:06:45,160 --> 00:06:50,160
Now when we run THX, it executes the default jobs in virtual environments and outputs results

113
00:06:50,160 --> 00:06:51,340
to the terminal.

114
00:06:51,340 --> 00:06:55,560
If everything is successful, we see a bunch of green OK messages.

115
00:06:55,560 --> 00:06:59,720
But if one of those jobs fails, we get clear error output, along with the exact command

116
00:06:59,720 --> 00:07:00,920
that was run.

117
00:07:00,920 --> 00:07:05,200
By default, THX will just run jobs using the same Python version that THX is installed

118
00:07:05,200 --> 00:07:06,200
with.

119
00:07:06,200 --> 00:07:09,600
But if we're trying to support our projects on multiple Python versions, we want our tools

120
00:07:09,600 --> 00:07:12,600
to run our development workflow on each of those supported versions.

121
00:07:12,600 --> 00:07:16,040
Well, THX can do this, and it can do it fast.

122
00:07:16,040 --> 00:07:20,360
We can simply give THX a list of the Python versions that we care about, and THX will

123
00:07:20,360 --> 00:07:23,240
look for these runtimes when executing jobs.

124
00:07:23,240 --> 00:07:27,760
Each of the requested jobs will run on each of the Python versions in parallel, with separate

125
00:07:28,360 --> 00:07:31,300
environments for each version.

126
00:07:31,300 --> 00:07:35,880
In some cases, though, like formatting, we might only need to run a job on a single version.

127
00:07:35,880 --> 00:07:40,000
There's no need to format our code base four times, so we just mark the job with once equals

128
00:07:40,000 --> 00:07:41,160
true.

129
00:07:41,160 --> 00:07:44,000
For more complex jobs, we might want to run multiple steps.

130
00:07:44,000 --> 00:07:48,200
Here, we define the job as a list of steps, each with its own command to run.

131
00:07:48,200 --> 00:07:52,560
THX will run each of these steps in order, stopping early if a step fails.

132
00:07:52,560 --> 00:07:56,520
But in this case, none of these commands depend on the results of the previous one.

133
00:07:56,520 --> 00:07:58,960
They could all run parallel just fine.

134
00:07:58,960 --> 00:08:03,880
So we just mark the job with parallel, and THX will run all of them at the same time,

135
00:08:03,880 --> 00:08:07,640
and again, it will run all of these in parallel with each and every Python version that we're

136
00:08:07,640 --> 00:08:12,640
testing against, taking full advantage of modern multi-core systems and making our iteration

137
00:08:12,640 --> 00:08:14,320
that much faster.

138
00:08:14,320 --> 00:08:19,200
But THX has one more trick up its sleeve, a watch mode, where it can wait for modifications

139
00:08:19,200 --> 00:08:24,520
to our project and automatically rerun its jobs every time our files change on disk.

140
00:08:24,520 --> 00:08:29,000
It's perfect for running in an IDE or terminal alongside your code and gives us immediate

141
00:08:29,000 --> 00:08:33,880
feedback when something has broken our test suite or failed coverage thresholds.

142
00:08:33,880 --> 00:08:38,320
And its parallel performance provides tremendous leverage for validating our project throughout

143
00:08:38,320 --> 00:08:39,320
development.

144
00:08:39,320 --> 00:08:48,080
If you'd like to know more about THX, please check it out at thx.omnilib.dev.

145
00:08:48,080 --> 00:08:51,800
There's more documentation and configuration options that you can find there, along with

146
00:08:52,800 --> 00:08:58,560
common use cases like code coverage and CI, and how THX can help.

147
00:08:58,560 --> 00:09:01,840
So now that we have the tools to build out our workflow, we can begin looking at how

148
00:09:01,840 --> 00:09:04,160
to improve our development experience.

149
00:09:04,160 --> 00:09:07,640
One of the best areas to focus on is code quality, where the side effects of better

150
00:09:07,640 --> 00:09:10,960
code are often as important as the code itself.

151
00:09:10,960 --> 00:09:15,280
Better code doesn't just mean that our project's faster or more reliable, but also that it's

152
00:09:15,280 --> 00:09:18,920
easier to read, easier to understand, and easier to debug.

153
00:09:19,080 --> 00:09:23,160
Together, this means you'll spend less time maintaining and more time building.

154
00:09:23,160 --> 00:09:24,160
So where do we start?

155
00:09:24,160 --> 00:09:29,000
Well, let's pick the lowest hanging fruit first, code style, and let's get the flame

156
00:09:29,000 --> 00:09:30,680
wars out of the way.

157
00:09:30,680 --> 00:09:34,280
I don't care what your code looks like, as long as it all looks the same.

158
00:09:34,280 --> 00:09:38,840
Consistency and predictability are the primary factors to making code easy to read.

159
00:09:38,840 --> 00:09:43,540
And the easier code is to read, the easier it is to understand what it's actually doing.

160
00:09:43,540 --> 00:09:45,280
Just don't make it my problem.

161
00:09:45,280 --> 00:09:50,460
Nobody wants to spend an hour fixing a bug, only to get nitpicky feedback about code style.

162
00:09:50,460 --> 00:09:54,400
Choose a code formatter that enforces your preferred style, and make it an integral part

163
00:09:54,400 --> 00:09:58,560
of the development workflow, so that nobody, including you, has to ever think about code

164
00:09:58,560 --> 00:09:59,960
style again.

165
00:09:59,960 --> 00:10:02,540
The more automated and extensive, the better.

166
00:10:02,540 --> 00:10:06,960
We want to dump code from our brain, and let the computer worry about making it look right

167
00:10:06,960 --> 00:10:08,920
after the fact.

168
00:10:08,920 --> 00:10:10,920
But really, you should just use Black.

169
00:10:10,920 --> 00:10:14,400
It's an excellent tool with strong safety guarantees, so you can run it on your whole

170
00:10:14,400 --> 00:10:17,400
code base without worrying about breaking anything.

171
00:10:17,400 --> 00:10:20,840
And for anyone who cares, it makes your code look like this.

172
00:10:20,840 --> 00:10:24,440
But more importantly, its configuration looks like this.

173
00:10:24,440 --> 00:10:27,860
When you decide to use Black, all the opinions come baked in.

174
00:10:27,860 --> 00:10:29,120
There's no more debate.

175
00:10:29,120 --> 00:10:32,000
There's only one color you can paint the bike shed.

176
00:10:32,000 --> 00:10:35,500
That's the easiest tool you'll ever configure in your life, and everyone will either thank

177
00:10:35,500 --> 00:10:40,660
you for it, or be really angry that they have nothing to argue about anymore.

178
00:10:40,660 --> 00:10:44,340
So Black will make your code look consistent, but it won't move your imports.

179
00:10:44,340 --> 00:10:48,820
I know a lot of folks really like their artisanal, handcrafted imports broken down by color,

180
00:10:48,820 --> 00:10:53,200
size, and favorite musician, but that's a lot of work, and I'm lazy.

181
00:10:53,200 --> 00:10:57,900
So like code style, it's an awful lot easier to just let the computer do it for you.

182
00:10:57,900 --> 00:11:01,300
This is where I get to shamelessly self-promote some more, and say we should all be using

183
00:11:01,300 --> 00:11:02,300
U-Sort.

184
00:11:02,300 --> 00:11:06,640
It was built from the ground up by Tim and myself to understand and manipulate the syntax

185
00:11:07,640 --> 00:11:12,040
so that it can recognize and make intelligent choices about when and where it's safe to

186
00:11:12,040 --> 00:11:14,080
move imports.

187
00:11:14,080 --> 00:11:18,000
So in the best case, U-Sort will follow the most common patterns and sort something that

188
00:11:18,000 --> 00:11:21,160
looks like this into this.

189
00:11:21,160 --> 00:11:24,800
Groups for the standard library, third party, and first party imports.

190
00:11:24,800 --> 00:11:27,200
This is the easy part.

191
00:11:27,200 --> 00:11:31,420
Now suppose we want to import a module and change our runtime configuration before importing

192
00:11:31,420 --> 00:11:32,920
something else.

193
00:11:32,920 --> 00:11:38,640
Unlike other import sorters, U-Sort focuses on making safe changes, and it treats intervening

194
00:11:38,640 --> 00:11:42,040
statements as barriers when sorting blocks of imports.

195
00:11:42,040 --> 00:11:46,360
So the async IO import would never move above the simple filter call, and the warnings import

196
00:11:46,360 --> 00:11:51,840
would never move below it, maintaining functionality without the need for ugly or error-prone comment

197
00:11:51,840 --> 00:11:53,980
directives.

198
00:11:53,980 --> 00:11:58,380
This level of safety is what allows us to run U-Sort at scale inside Meta.

199
00:11:58,380 --> 00:12:02,940
Every Python file covered by our formatter gets sorted by U-Sort without exception, and

200
00:12:02,940 --> 00:12:08,020
we automatically apply catch-up formatting for all covered files every morning.

201
00:12:08,020 --> 00:12:11,820
Now it's great to have these tools, but running multiple formatters separately is a recipe

202
00:12:11,820 --> 00:12:17,940
for minor conflicts, which can cause annoying failures in CI or pre-commit hooks.

203
00:12:17,940 --> 00:12:21,100
What you really need is something that can perform both formatting and import sorting

204
00:12:21,100 --> 00:12:23,740
in a single atomic step.

205
00:12:23,740 --> 00:12:25,360
And that's where U-Format comes in.

206
00:12:25,480 --> 00:12:31,140
U-Format is a combined code formatter and sorter, built on top of Black and U-Sort.

207
00:12:31,140 --> 00:12:35,960
Each file is sorted and then formatted in memory as a single atomic step, guaranteeing

208
00:12:35,960 --> 00:12:39,760
consistent results in CI and pre-commit hooks.

209
00:12:39,760 --> 00:12:42,880
If any of that sounds interesting, please check out the project's documentation for

210
00:12:42,880 --> 00:12:49,620
more details on how they work and how you can integrate them in your developer workflow.

211
00:12:49,620 --> 00:12:53,260
So now that we have formatting taken care of, let's look at how we can apply tooling

212
00:12:53,340 --> 00:12:57,340
to actually make the code more reliable by finding and pointing out bad practices, subtle

213
00:12:57,340 --> 00:13:02,780
bugs or edge cases that aren't obvious, no matter how pretty the code looks.

214
00:13:02,780 --> 00:13:05,020
The easiest place to start is with a linter.

215
00:13:05,020 --> 00:13:08,660
They can help you find potential bugs in your code or even help prevent you from introducing

216
00:13:08,660 --> 00:13:14,140
bugs in the future by steering you away from problematic patterns.

217
00:13:14,140 --> 00:13:17,580
There are a number of good options in the space, including PyLint and PyFlakes, but

218
00:13:17,580 --> 00:13:21,700
my personal favorite and the one we use at Meta is Flake8.

219
00:13:22,580 --> 00:13:28,020
It provides a nice wrapper around PyFlakes, has sensible defaults, easy configuration,

220
00:13:28,020 --> 00:13:31,820
and most importantly, has a number of excellent plugins available that increase the scope

221
00:13:31,820 --> 00:13:34,940
of problems that Flake8 can help us find.

222
00:13:34,940 --> 00:13:38,540
By default, we'll get warnings that range from pointing out bad practices, like star

223
00:13:38,540 --> 00:13:43,980
imports, to bugs waiting to happen, like shadowed imports or asserts with parentheses, or even

224
00:13:43,980 --> 00:13:48,600
runtime errors, like undefined variables or invalid grammar.

225
00:13:48,600 --> 00:13:52,660
With some extra plugins, we can also get notified when we accidentally leave debugging breakpoints

226
00:13:52,660 --> 00:13:57,680
in our code or when we use mutable default values for function parameters or help guide

227
00:13:57,680 --> 00:14:02,320
us to better usage of list comprehensions or generator expressions in our code.

228
00:14:02,320 --> 00:14:05,880
Preventing bugs before they happen will save future you an uncountable number of headaches

229
00:14:05,880 --> 00:14:08,560
and hours wasted debugging your projects.

230
00:14:08,560 --> 00:14:12,580
But what you don't want your linter fighting with is your formatter.

231
00:14:12,580 --> 00:14:17,140
We recommend turning off most, if not all, lint errors related to code style and just

232
00:14:17,180 --> 00:14:18,980
let the formatters do their job.

233
00:14:18,980 --> 00:14:22,980
If it's good enough for the formatter, it should be good enough for your linter.

234
00:14:22,980 --> 00:14:27,600
While linters can look for patterns in individual pieces of your code, the real meat is in static

235
00:14:27,600 --> 00:14:32,740
analysis tools, especially type checkers, which look at your code base as a whole and

236
00:14:32,740 --> 00:14:35,300
make sure everything is correctly passing and using values.

237
00:14:35,300 --> 00:14:39,500
And it can do this based on what it knows about not just your code, but other code as

238
00:14:39,500 --> 00:14:44,260
well, including the standard library and any other type annotated libraries used by your

239
00:14:44,260 --> 00:14:45,820
project.

240
00:14:45,820 --> 00:14:49,220
So let's look at an example of how types can help us find real world bugs that a human

241
00:14:49,220 --> 00:14:50,760
may never notice.

242
00:14:50,760 --> 00:14:55,100
Let's assume get path is a foreign API we don't really know, shouldn't really need to

243
00:14:55,100 --> 00:14:56,840
care about how it works.

244
00:14:56,840 --> 00:14:57,840
Do you see the bug?

245
00:14:57,840 --> 00:15:00,440
Do you have an idea of what it could be?

246
00:15:00,440 --> 00:15:02,500
What if we add some type annotations?

247
00:15:02,500 --> 00:15:05,820
We're adding new information here that previously we might have needed to read a doc string

248
00:15:05,820 --> 00:15:06,820
for.

249
00:15:06,820 --> 00:15:10,340
Well, maybe some extra inline annotations help.

250
00:15:10,340 --> 00:15:13,620
What if I told you that open raises an exception when passed none?

251
00:15:14,220 --> 00:15:18,140
Well, there's some input that can cause get path to return none, and then we're just passing

252
00:15:18,140 --> 00:15:21,740
that straight to open, and you end up with an angry bug report because someone crashed

253
00:15:21,740 --> 00:15:23,020
the production service.

254
00:15:23,020 --> 00:15:27,740
But our type checker can find and report that before we ever release the code, let alone

255
00:15:27,740 --> 00:15:30,340
run it in production.

256
00:15:30,340 --> 00:15:34,220
But beyond finding errors, there are benefits just to adding type annotations to your own

257
00:15:34,220 --> 00:15:35,220
modules.

258
00:15:35,220 --> 00:15:38,700
Consider it as a form of validated documentation for you and everyone else looking at your

259
00:15:38,700 --> 00:15:40,540
code.

260
00:15:40,540 --> 00:15:44,980
Using these two definitions for the same functions, which one do you find more useful?

261
00:15:44,980 --> 00:15:48,540
Which one could you evaluate faster when looking at a foreign API?

262
00:15:48,540 --> 00:15:52,020
We don't even need to see a doc string or look at the body of the code in order to have

263
00:15:52,020 --> 00:15:54,880
a good idea of the contract being described.

264
00:15:54,880 --> 00:15:59,540
This is valuable documentation for developers, and unlike a doc string, a good type checker

265
00:15:59,540 --> 00:16:04,120
will force you and everyone else to keep this information up to date.

266
00:16:04,120 --> 00:16:07,460
So again, there are multiple good choices here for type checkers, but I recommend the

267
00:16:07,460 --> 00:16:09,880
use of MyPy for open source projects.

268
00:16:09,880 --> 00:16:13,600
It's by far the most popular type checker available and works really well with minimal

269
00:16:13,600 --> 00:16:15,980
setup or configuration needed.

270
00:16:15,980 --> 00:16:19,540
For many projects, this is the only option you need just because there are still a large

271
00:16:19,540 --> 00:16:23,580
number of libraries out there that don't have type stubs or aren't appropriately marked

272
00:16:23,580 --> 00:16:26,880
as annotated, and there's not much we can do about that.

273
00:16:26,880 --> 00:16:31,820
You don't even need all of your code to be type annotated to start seeing an impact.

274
00:16:31,820 --> 00:16:35,560
But if you're willing to type annotate everything, including your test cases, I highly recommend

275
00:16:35,560 --> 00:16:37,300
enabling strict mode.

276
00:16:37,300 --> 00:16:41,780
This will let MyPy get more pedantic, find more bugs, and also point out any time you

277
00:16:41,780 --> 00:16:46,300
fail to document, I mean annotate, your code.

278
00:16:46,300 --> 00:16:50,240
So speaking of documentation, while looking at the code directly is important for working

279
00:16:50,240 --> 00:16:54,260
on your own project, the last thing you want to look at is someone else's code, especially

280
00:16:54,260 --> 00:16:58,540
when you just need to know what a function is called or what various arguments do.

281
00:16:58,540 --> 00:17:02,740
Most importantly, there will come a day when your own code looks foreign to you and you've

282
00:17:02,740 --> 00:17:05,640
forgotten what all your own APIs look like.

283
00:17:05,640 --> 00:17:09,600
When that happens, you can turn to your own documentation for help.

284
00:17:09,600 --> 00:17:13,900
But we don't just want to brain dump info into a text file, tucked away and forgotten,

285
00:17:13,900 --> 00:17:16,040
cursed to never be accurate again.

286
00:17:16,040 --> 00:17:19,720
What we need is tooling specifically designed to extract as much information as possible

287
00:17:19,720 --> 00:17:24,200
from our code base, including doc strings and type information, and automatically compile

288
00:17:24,200 --> 00:17:26,240
that documentation into useful formats.

289
00:17:26,240 --> 00:17:30,080
Now, there are many different tools that can do this, but Sphinx is designed specifically

290
00:17:30,080 --> 00:17:33,800
for Python and is used by hundreds of open source projects.

291
00:17:33,960 --> 00:17:38,620
Sphinx will compile and transform a set of source documents into a full website, including

292
00:17:38,620 --> 00:17:40,600
navigation and text search.

293
00:17:40,600 --> 00:17:44,920
You can add arbitrary pages as well, allowing you to build a combined project and documentation

294
00:17:44,920 --> 00:17:50,280
site all in one with relatively little time effort required to maintain it.

295
00:17:50,280 --> 00:17:55,780
Sphinx uses restructured text format, similar to Markdown, but focused on technical documentation.

296
00:17:55,780 --> 00:18:00,340
When compiled, Sphinx generates well-formatted HTML, and we can include code blocks with

297
00:18:00,340 --> 00:18:04,700
syntax highlighting, links to other sections of the documentation, and much more that isn't

298
00:18:04,700 --> 00:18:06,620
possible in plain Markdown.

299
00:18:06,620 --> 00:18:09,660
And we don't need to sacrifice the ability to read and understand the source text in

300
00:18:09,660 --> 00:18:11,760
an editor.

301
00:18:11,760 --> 00:18:14,940
But the real magic of Sphinx comes from the autodoc extension.

302
00:18:14,940 --> 00:18:18,980
This gives Sphinx the power to look at your project's source code and automatically extract

303
00:18:18,980 --> 00:18:24,020
module, class, and function APIs, including type annotations, doc string, contents, and

304
00:18:24,020 --> 00:18:25,100
more.

305
00:18:25,100 --> 00:18:28,820
With this in mind, we can actually write our doc strings with the Sphinx results in mind

306
00:18:28,900 --> 00:18:30,940
using inline restructured text.

307
00:18:30,940 --> 00:18:34,740
We can include references to other functions, inline code blocks, and anything else we could

308
00:18:34,740 --> 00:18:37,580
put in a normal documentation page.

309
00:18:37,580 --> 00:18:42,380
Then we just add the appropriate autodoc directives to our documentation and regenerate our site.

310
00:18:42,380 --> 00:18:46,020
And now our compiled documentation includes our function prototype, formatted contents

311
00:18:46,020 --> 00:18:48,020
of our doc string, as well as type information.

312
00:18:48,020 --> 00:18:51,780
Now, you might be asking, what can you do with this once you have it?

313
00:18:51,780 --> 00:18:54,420
Well, maybe you've heard of a little site called Read the Docs.

314
00:18:54,900 --> 00:18:59,700
This is an excellent free service for building and hosting your project documentation sites.

315
00:18:59,700 --> 00:19:02,660
It's specifically designed to work with Sphinx.

316
00:19:02,660 --> 00:19:07,180
It also has excellent integrations with GitHub, including the ability to automatically build

317
00:19:07,180 --> 00:19:11,420
every time code is pushed, as well as building preview sites for each pull request.

318
00:19:11,420 --> 00:19:16,580
So you can easily evaluate any documentation changes for PRs.

319
00:19:16,580 --> 00:19:20,620
So now that we have an end developer and documentation workflow, let's take a look at how we can

320
00:19:20,620 --> 00:19:27,020
streamline the process of community contributions without putting undue burden on your own time.

321
00:19:27,020 --> 00:19:30,420
One of the most important pieces of having positive community interaction starts with

322
00:19:30,420 --> 00:19:34,380
setting clear boundaries on expectations in both directions.

323
00:19:34,380 --> 00:19:36,380
You really should have a code of conduct.

324
00:19:36,380 --> 00:19:40,220
If and when your project gains more attention, clowns will inevitably show up.

325
00:19:40,220 --> 00:19:43,260
And the easiest way to deal with them is by having a code of conduct with clear set of

326
00:19:43,260 --> 00:19:45,620
rules and consequences that you can follow.

327
00:19:45,780 --> 00:19:50,940
I use the contributor covenant at the Omnimo project and recommend it both for the standards

328
00:19:50,940 --> 00:19:54,700
it includes as well as their guidance on how to enforce it.

329
00:19:54,700 --> 00:19:58,620
Beyond that, make sure you set clear expectations for what contributions you're willing to

330
00:19:58,620 --> 00:20:00,180
accept from the community.

331
00:20:00,180 --> 00:20:02,520
If you only care about bug fixes, say that.

332
00:20:02,520 --> 00:20:04,620
If you're happy to take feature requests, say that.

333
00:20:04,620 --> 00:20:09,020
But let folks know ahead of time if they should open an issue or discuss new features before

334
00:20:09,020 --> 00:20:13,460
they take up their own time and yours with pull requests that you would never accept.

335
00:20:13,500 --> 00:20:16,900
If you can, document the level of support you'll give for each project, but don't

336
00:20:16,900 --> 00:20:17,900
overcommit yourself.

337
00:20:17,900 --> 00:20:22,300
Unless there's a paid support contract, you do not owe anyone your time, you don't owe

338
00:20:22,300 --> 00:20:25,460
them your energy, and you certainly do not owe them your sanity.

339
00:20:25,460 --> 00:20:30,100
If someone's being too needy and is taking up your limited time, then just dump them.

340
00:20:30,100 --> 00:20:33,780
If they're being nice, apologize and just tell them you can't help them, maybe point

341
00:20:33,780 --> 00:20:35,340
them to a different project.

342
00:20:35,340 --> 00:20:39,320
But if they're being less than nice, just don't engage and remove them from the community.

343
00:20:39,320 --> 00:20:42,660
Don't waste your time on unproductive community members.

344
00:20:42,660 --> 00:20:46,520
On a happier note, let's look at how we can simplify and automate as much of their contributor

345
00:20:46,520 --> 00:20:48,220
workflow as possible.

346
00:20:48,220 --> 00:20:51,620
We want to remove barriers between the community members and their ability to ramp up on your

347
00:20:51,620 --> 00:20:58,360
project because the less friction, the more likely you are to receive high-quality contributions.

348
00:20:58,360 --> 00:21:00,740
This starts with, you guessed it, more documentation.

349
00:21:00,740 --> 00:21:04,540
A basic contributor's guide starts with the steps to set up and build your project from

350
00:21:04,540 --> 00:21:07,940
source as well as how to run the project and test suite.

351
00:21:07,940 --> 00:21:12,500
A better guide also includes extra validation steps needed like linters or formatters, as

352
00:21:12,500 --> 00:21:16,660
well as general guidance on what to include with changes like documentation, test cases,

353
00:21:16,660 --> 00:21:18,620
or change log entries.

354
00:21:18,620 --> 00:21:21,740
This is where a reproducible workflow from earlier can really help.

355
00:21:21,740 --> 00:21:26,580
The closer contributors get to the workflow you use, the more trust you'll have in their

356
00:21:26,580 --> 00:21:30,940
contributions and the more trust they will have in their own changes that they're making

357
00:21:30,940 --> 00:21:33,040
during development.

358
00:21:33,040 --> 00:21:37,060
You can further help guide contributors in the right path by adding detailed issue templates

359
00:21:37,060 --> 00:21:41,380
and pull request templates to your project that will pre-populate the text boxes with

360
00:21:41,420 --> 00:21:42,580
whatever you want.

361
00:21:42,580 --> 00:21:46,380
You can have multiple different templates for specific types of issues or requests,

362
00:21:46,380 --> 00:21:50,500
but be sure to include any spots for specific information that you want to see like steps

363
00:21:50,500 --> 00:21:55,540
to reproduce, the user's environment, or whatever makes sense for the project.

364
00:21:55,540 --> 00:21:59,300
Once your community members have submitted a pull request, you want to make sure that

365
00:21:59,300 --> 00:22:03,020
you automate the testing and validation process in a way that not only reduces the time you

366
00:22:03,020 --> 00:22:07,420
spend reviewing their contributions, but also gives immediate actual feedback to the contributor

367
00:22:07,420 --> 00:22:09,220
themselves.

368
00:22:09,220 --> 00:22:12,300
Re-release integration systems are one of the easiest and most common ways to make this

369
00:22:12,300 --> 00:22:13,300
happen.

370
00:22:13,300 --> 00:22:16,780
If your project's on GitHub, then GitHub Actions is the easy choice and runs for free

371
00:22:16,780 --> 00:22:19,260
on public repos.

372
00:22:19,260 --> 00:22:23,500
The biggest benefit here is the ability to configure CI to test your project on a variety

373
00:22:23,500 --> 00:22:28,380
of operating systems and Python runtime versions and get direct feedback in a pull request

374
00:22:28,380 --> 00:22:32,780
on which of those pass so you can easily see if it's OS or version dependent or if it's

375
00:22:32,780 --> 00:22:34,180
a more basic issue.

376
00:22:34,180 --> 00:22:37,580
Again, we'll beat the drum for reproducible workflows.

377
00:22:37,580 --> 00:22:41,700
Whatever CI platform or system you choose, it should be configured to use the same build,

378
00:22:41,700 --> 00:22:44,540
test, and validation workflow that you use locally.

379
00:22:44,540 --> 00:22:49,020
This will help minimize surprises and make it that much easier for you to review a pull

380
00:22:49,020 --> 00:22:52,420
request and understand the results of the CI.

381
00:22:52,420 --> 00:22:57,380
Lastly, be aware that GitHub Actions, as well as integrations to other services, are available

382
00:22:57,380 --> 00:23:03,440
and can also improve the amount of time that it takes you to actually review a pull request.

383
00:23:03,440 --> 00:23:06,060
The last piece of the puzzle is releasing your project.

384
00:23:06,060 --> 00:23:09,180
The easier it is to prepare and release a new version, the faster we can publish our

385
00:23:09,180 --> 00:23:10,420
bug fixes.

386
00:23:10,420 --> 00:23:15,020
The more boring each individual releases with targeted fixes or improvements, the more reliable

387
00:23:15,020 --> 00:23:16,940
and trustworthy your project will be perceived.

388
00:23:16,940 --> 00:23:20,900
Let's start with the most important part of releasing new versions, picking the right

389
00:23:20,900 --> 00:23:21,900
version numbers.

390
00:23:21,900 --> 00:23:26,460
Ultimately, we want version numbers that convey some amount of meaningful information, like

391
00:23:26,460 --> 00:23:30,160
how big or how important or how dangerous your change is.

392
00:23:30,160 --> 00:23:33,740
One of the most well-known schemes is semver, semantic versioning, and I'm here to say

393
00:23:33,740 --> 00:23:35,420
semver is impossible.

394
00:23:35,420 --> 00:23:39,020
The major version number is supposed to tell us when breaking changes occur, but how do

395
00:23:39,020 --> 00:23:40,420
we define breaking changes?

396
00:23:40,420 --> 00:23:42,540
Is a change to a feature breaking?

397
00:23:42,540 --> 00:23:43,980
Is an API change breaking?

398
00:23:43,980 --> 00:23:46,100
Is a bug fix breaking?

399
00:23:46,100 --> 00:23:49,100
On the other end of the scale, we can simply base our versions on the year and date of

400
00:23:49,100 --> 00:23:53,460
each release, but beware because once your major version is based on the calendar year,

401
00:23:53,460 --> 00:23:55,460
you've just burned more versions than Chrome.

402
00:23:55,460 --> 00:23:59,340
Yes, technically you can increment a version epic and start over from zero, but literally

403
00:23:59,340 --> 00:24:03,360
nobody wants that and you'd be surprised how many tools will break.

404
00:24:03,360 --> 00:24:07,520
So really, just pick something, be consistent with your versioning, and communicate your

405
00:24:07,520 --> 00:24:11,520
plan clearly.

406
00:24:11,520 --> 00:24:14,080
But picking a version number is only the first step.

407
00:24:14,080 --> 00:24:17,320
There's a lot more that can go into release than you might expect, so we want to automate

408
00:24:17,320 --> 00:24:19,680
as much of that process as we can as well.

409
00:24:19,680 --> 00:24:23,780
Like our development processes earlier, we want to have reproducible workflows.

410
00:24:23,780 --> 00:24:26,520
You shouldn't have to figure out and piece this all together every time you get a new

411
00:24:26,520 --> 00:24:27,520
laptop.

412
00:24:27,520 --> 00:24:31,280
At the very least, document the necessary tools and steps to publish a release so that

413
00:24:31,280 --> 00:24:34,920
the future you can just refer to your documentation, but we can do more.

414
00:24:34,920 --> 00:24:39,480
The key to reproducible releases is basing them off of published tag revisions in your

415
00:24:39,480 --> 00:24:40,800
source control.

416
00:24:40,800 --> 00:24:46,080
Those tags should already include any changes to documentation, version numbers, et cetera.

417
00:24:46,080 --> 00:24:49,360
Now once it actually gets to getting that, tools can help.

418
00:24:49,360 --> 00:24:53,440
I specifically wrote a tool called Attribution, which automates the process of generating

419
00:24:53,440 --> 00:24:55,440
a change log.

420
00:24:55,440 --> 00:24:58,720
As for building your actual release, you want artifacts, but we're running out of time,

421
00:24:58,720 --> 00:25:01,160
so I'm going to power through this.

422
00:25:01,240 --> 00:25:02,400
Wheels are binary wheels.

423
00:25:02,400 --> 00:25:05,000
They're only on specific platforms and versions.

424
00:25:05,000 --> 00:25:11,240
Source distributions are what you can actually rebuild on anything.

425
00:25:11,240 --> 00:25:12,240
That is key.

426
00:25:12,240 --> 00:25:16,520
You want your S-disk because anybody who's on an OS or version where you don't have a

427
00:25:16,520 --> 00:25:21,480
wheel can actually build your project, but you want the combination because it's faster

428
00:25:21,480 --> 00:25:23,640
for most users.

429
00:25:23,640 --> 00:25:28,080
If you want help in building all of those, the CI build wheel project can help automate

430
00:25:28,080 --> 00:25:31,080
a lot of that in your CI steps.

431
00:25:31,200 --> 00:25:35,320
It helps you support that whole matrix of version compatibility.

432
00:25:35,320 --> 00:25:36,320
We made it.

433
00:25:36,320 --> 00:25:37,320
We've reproduced our workflows.

434
00:25:37,320 --> 00:25:38,800
We've improved our code quality.

435
00:25:38,800 --> 00:25:40,120
We've fostered our community.

436
00:25:40,120 --> 00:25:42,680
We've published our distributions.

437
00:25:42,680 --> 00:25:44,720
Now we take time for ourselves.

438
00:25:44,720 --> 00:25:46,320
Don't forget the golden rule.

439
00:25:46,320 --> 00:25:49,760
It's your life, your project, and ultimately, you're the only one who can choose how to

440
00:25:49,760 --> 00:25:50,760
spend your time.

441
00:25:50,760 --> 00:25:53,880
I appreciate you spending this time here with me.

442
00:25:53,880 --> 00:25:57,840
You can find links to all the projects and resources on my GitHub repo.

443
00:25:57,840 --> 00:25:59,000
Thank you so much.

444
00:25:59,000 --> 00:26:00,000
Have a good PyCon.

445
00:26:00,000 --> 00:26:01,000
Thank you.

446
00:26:01,000 --> 00:26:04,760
Thank you, John.

