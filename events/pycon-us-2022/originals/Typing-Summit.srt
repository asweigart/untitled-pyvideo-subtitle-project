1
00:00:00,000 --> 00:00:16,240
Hi, I'm David Foster, and yeah, welcome to the typing summit.

2
00:00:16,240 --> 00:00:22,700
So I thought it might be useful to present a roundup of some new typing features that

3
00:00:22,700 --> 00:00:28,320
are in the current version of Python that we have right now, Python 3.10, and the new

4
00:00:28,320 --> 00:00:32,880
version of Python that's coming up later this year, Python 3.11.

5
00:00:32,880 --> 00:00:37,480
So I'm just going to go through them somewhat quickly.

6
00:00:37,480 --> 00:00:41,240
First, I guess I should introduce myself a little bit further.

7
00:00:41,240 --> 00:00:47,160
David Foster, contributor to MyPy and especially typed dict.

8
00:00:47,160 --> 00:00:51,960
When I'm not doing open source, I am chief technology officer at TechSmartt where we

9
00:00:51,960 --> 00:00:58,280
are bringing world-class computer science education to the next generation of K-12 students

10
00:00:58,320 --> 00:00:59,440
and teachers.

11
00:00:59,440 --> 00:01:03,040
So getting kids excited about coding.

12
00:01:03,040 --> 00:01:06,520
And you can find me online at these places.

13
00:01:06,520 --> 00:01:15,860
So a couple of years ago, just last year actually, just in early 2021, I wrote an article that

14
00:01:15,860 --> 00:01:22,120
was proclaiming that Python was in the middle of a type checking renaissance because we've

15
00:01:22,120 --> 00:01:28,200
had so many peps recently that are introducing new typing related features.

16
00:01:28,200 --> 00:01:33,360
And this year, 2022, no exception to that.

17
00:01:33,360 --> 00:01:39,880
So as mentioned, I am hoping to in this talk to go through some of the specific features

18
00:01:39,880 --> 00:01:44,840
that are in both the current version of Python and the new version of Python 3.11 that will

19
00:01:44,840 --> 00:01:47,720
be released later this year.

20
00:01:47,800 --> 00:01:52,760
So let's talk about where we are right now with Python 3.10.

21
00:01:52,760 --> 00:01:57,440
We've got four typing related peps here.

22
00:01:57,440 --> 00:02:00,680
A couple that are introducing new kinds of types.

23
00:02:00,680 --> 00:02:03,360
So param, spec and type guard.

24
00:02:03,360 --> 00:02:06,440
There's other types of notation that's been added.

25
00:02:06,440 --> 00:02:13,480
And one theme that I think is recurring is eliminating imports required from the typing

26
00:02:13,480 --> 00:02:18,680
module itself, which makes typing annotations more easy to use.

27
00:02:18,680 --> 00:02:25,760
So just to go through some of these briefly, I'll show an example of code before the introduction

28
00:02:25,760 --> 00:02:29,840
of the feature and what you can do after the feature.

29
00:02:29,840 --> 00:02:35,360
In 3.10, the first thing I have up is param spec, which is particularly useful for annotating

30
00:02:35,360 --> 00:02:37,960
decorators.

31
00:02:37,960 --> 00:02:44,680
Before it was difficult to annotate, annotate the types of parameters that you put into

32
00:02:44,680 --> 00:02:46,800
a callable in particular.

33
00:02:46,800 --> 00:02:49,960
The dot dot dot that I have here is actually what you write.

34
00:02:49,960 --> 00:02:50,960
Dot dot dot.

35
00:02:50,960 --> 00:02:52,520
It's not a placeholder.

36
00:02:52,520 --> 00:02:58,200
The type checker isn't able to understand in this case that there's an association between

37
00:02:58,200 --> 00:03:03,200
the input callables parameters and the output callables parameters.

38
00:03:03,760 --> 00:03:11,240
But if you introduce a param spec, you can use that as a placeholder for any set of parameters.

39
00:03:11,240 --> 00:03:17,120
And so then it becomes possible to have this decorator nicely typed, which has been a problem

40
00:03:17,120 --> 00:03:18,120
for some time.

41
00:03:18,120 --> 00:03:21,400
So you can do that now.

42
00:03:21,400 --> 00:03:22,480
Moving on.

43
00:03:22,480 --> 00:03:23,480
Type guard.

44
00:03:23,480 --> 00:03:29,040
So this is particularly common in JavaScript, but it also happens in Python where you have

45
00:03:29,080 --> 00:03:35,560
a function that is used to check whether something is of a particular property that a type checker

46
00:03:35,560 --> 00:03:36,560
can't figure out.

47
00:03:36,560 --> 00:03:41,640
So in this case, we have an example of a function that checks whether something is a list of

48
00:03:41,640 --> 00:03:42,640
strings.

49
00:03:42,640 --> 00:03:49,880
So we have a function that just returns a bool here, which is okay, but it would be

50
00:03:49,880 --> 00:03:55,000
nice that if you called this function and it returned true, that a type checker could

51
00:03:55,040 --> 00:04:01,040
narrow the type of the thing that you pass to this function to be a str of list.

52
00:04:01,040 --> 00:04:03,680
And with type guard, you can do that.

53
00:04:03,680 --> 00:04:09,040
If you set the return type to type guard list of str, you return true.

54
00:04:09,040 --> 00:04:11,040
Narrowing happens.

55
00:04:11,040 --> 00:04:13,240
Beautiful.

56
00:04:13,240 --> 00:04:14,240
Moving on.

57
00:04:14,240 --> 00:04:15,240
Type alias.

58
00:04:15,240 --> 00:04:21,880
So in Python, we've had the ability to define type aliases for a long time implicitly by

59
00:04:21,880 --> 00:04:29,240
assigning effectively a type expression to a variable.

60
00:04:29,240 --> 00:04:33,800
And then that is interpreted by type checkers as a type alias.

61
00:04:33,800 --> 00:04:38,120
However, there are cases where you want to be explicit that that's actually what you're

62
00:04:38,120 --> 00:04:39,120
doing.

63
00:04:39,120 --> 00:04:45,840
And at the moment, if you do something very similar, which is you assign a stringified

64
00:04:45,840 --> 00:04:51,560
type expression to a variable, a type checker will not be able to figure out that you actually

65
00:04:51,560 --> 00:04:54,880
wanted to make a type alias there.

66
00:04:54,880 --> 00:05:04,200
So now with type alias, you can make the otherwise implicit aliases explicit, and you can now

67
00:05:04,200 --> 00:05:09,720
use forward references for stringified references, which is useful.

68
00:05:09,720 --> 00:05:13,320
So that's kind of cool.

69
00:05:13,320 --> 00:05:23,120
Next up, one of my favorites, is the ability to write union types and optional types, which

70
00:05:23,120 --> 00:05:30,340
is a variable or the constant none using the pipe operator.

71
00:05:30,340 --> 00:05:34,820
So this eliminates a few imports from the typing module.

72
00:05:34,820 --> 00:05:39,920
So no more import from typing module, and you don't have to type as much either because

73
00:05:40,120 --> 00:05:42,600
Instead of writing union, you can use a pipe.

74
00:05:42,600 --> 00:05:46,680
Instead of writing optional, you can just say pipe none.

75
00:05:46,680 --> 00:05:51,800
Works great, is explicit.

76
00:05:51,800 --> 00:05:54,280
So that's Python 3.10.

77
00:05:54,280 --> 00:05:58,560
That's what we have access to today in the final release.

78
00:05:58,560 --> 00:06:04,480
There is also Python 3.11, which is just about to enter its first beta, I believe, either

79
00:06:04,480 --> 00:06:06,800
today or tomorrow.

80
00:06:06,800 --> 00:06:11,000
I heard a clarification.

81
00:06:11,000 --> 00:06:14,840
Next week, okay, 3.10 beta one next week.

82
00:06:14,840 --> 00:06:19,600
So these types of types are now available.

83
00:06:19,600 --> 00:06:26,480
So we have, let's see, one, two, three, four, five, peps here, so I'll just briefly go through

84
00:06:26,480 --> 00:06:29,160
those as well.

85
00:06:29,160 --> 00:06:30,960
So let's talk about literal string.

86
00:06:30,960 --> 00:06:37,880
So there are a number of APIs that expect some kind of fixed format string, a command

87
00:06:37,880 --> 00:06:39,920
string of some kind.

88
00:06:39,920 --> 00:06:47,080
And in the documentation for such APIs, they may say that you really should just use a

89
00:06:47,080 --> 00:06:51,840
string literal, but there's no way for it to actually enforce that because that's just

90
00:06:51,840 --> 00:06:53,120
in the documentation.

91
00:06:53,120 --> 00:06:58,480
So common cases, you have something that's running like a SQL command, or as a second

92
00:06:58,520 --> 00:07:06,680
example I'll show you in a moment, if you're writing a format string to a logging function.

93
00:07:06,680 --> 00:07:11,880
So right now there's no way to tell a type checker that this string that you're passing

94
00:07:11,880 --> 00:07:15,320
in should be a literal.

95
00:07:15,320 --> 00:07:21,800
But with a literal string, you can actually annotate it that there should be specifically

96
00:07:21,800 --> 00:07:23,680
a literal passed in.

97
00:07:23,840 --> 00:07:29,200
And if you don't do that, a type checker will tell you that that's no good.

98
00:07:29,200 --> 00:07:30,200
So that's pretty cool.

99
00:07:30,200 --> 00:07:38,200
So you can avoid command injection for people who use APIs with literal string who also

100
00:07:38,200 --> 00:07:41,320
are running type checkers on their code base.

101
00:07:41,320 --> 00:07:45,600
And for many large code bases, this is already done.

102
00:07:45,600 --> 00:07:50,840
So as mentioned, there's a second example here of formatting strings, which is another

103
00:07:50,840 --> 00:07:53,240
type of command string.

104
00:07:53,280 --> 00:08:01,480
And in particular, we had an issue recently with log4j, where you had some unexpected

105
00:08:01,480 --> 00:08:04,640
use of things in command strings.

106
00:08:04,640 --> 00:08:12,760
And that would be harder to exploit if you had something like this used to type annotate

107
00:08:12,760 --> 00:08:16,520
a function expecting a format string.

108
00:08:16,520 --> 00:08:18,040
So that's literal string.

109
00:08:18,040 --> 00:08:20,380
Type guard double.

110
00:08:20,380 --> 00:08:21,740
So this is interesting.

111
00:08:21,740 --> 00:08:27,380
So there are a couple of libraries that define array-like classes.

112
00:08:27,380 --> 00:08:33,540
So NumPy's ndArray class, TensorFlow's tensor class.

113
00:08:33,540 --> 00:08:42,340
In there are many cases where the data inside these has either a particular set of expected

114
00:08:42,340 --> 00:08:45,540
data types or dimensions.

115
00:08:45,540 --> 00:08:47,740
And right now, the only way that you can...

116
00:08:48,740 --> 00:08:53,440
Right now, you can only put that information in comments and documentation.

117
00:08:53,440 --> 00:08:56,200
It's not enforceable automatically in any way.

118
00:08:56,200 --> 00:09:00,880
So here, I've just got a comment here that's saying, like, this is a image, and it happens

119
00:09:00,880 --> 00:09:05,500
to have a height and width as its dimensions here.

120
00:09:05,500 --> 00:09:14,760
But with type guard double, you can define array types that you can just give generic

121
00:09:14,780 --> 00:09:19,380
properties for each of either the dimensions or the data types or whatever property that

122
00:09:19,380 --> 00:09:23,900
you think is useful to be enforced as consistent.

123
00:09:23,900 --> 00:09:25,860
So here, we're doing...

124
00:09:25,860 --> 00:09:28,660
You can actually just say height and width explicitly.

125
00:09:28,660 --> 00:09:32,660
And because they're new types, it won't allow you to, like, mix them up.

126
00:09:32,660 --> 00:09:36,140
Like, instead of height width, maybe you put width height.

127
00:09:36,140 --> 00:09:42,500
Easy to get it mixed up if you have column-based ordering versus row-based ordering.

128
00:09:42,500 --> 00:09:45,200
So that's type guard double.

129
00:09:45,200 --> 00:09:46,200
Self.

130
00:09:46,200 --> 00:09:51,560
So there are a number of APIs that are written in a so-called fluent style, where you have

131
00:09:51,560 --> 00:09:53,840
methods that...

132
00:09:53,840 --> 00:09:58,880
On a class that return the same instance of that class after they finish.

133
00:09:58,880 --> 00:10:01,440
So they return self at the end.

134
00:10:01,440 --> 00:10:07,840
Before it was possible, although rather cumbersome and verbose, to annotate the return type of

135
00:10:07,840 --> 00:10:13,580
such methods to describe to the type checker that it's actually still returning self.

136
00:10:13,580 --> 00:10:16,580
You can do that with this fancy thing with a type bar.

137
00:10:16,580 --> 00:10:19,780
Well, now you can just do it directly.

138
00:10:19,780 --> 00:10:27,380
So if a function returns the value self, you can also say that in its signature that returns

139
00:10:27,380 --> 00:10:35,140
the type of self, and it will do all of that magic for you, which is great.

140
00:10:35,140 --> 00:10:37,420
Data class transform.

141
00:10:37,420 --> 00:10:38,620
So this one's interesting.

142
00:10:38,620 --> 00:10:48,340
So there are a number of libraries that define things like data class, model classes of various

143
00:10:48,340 --> 00:10:49,460
kinds.

144
00:10:49,460 --> 00:10:57,640
So you have adders, there's an old one, pydantic is a newer one, but there are many of these

145
00:10:57,640 --> 00:11:03,120
libraries that define classes that act like the built-in data class.

146
00:11:03,120 --> 00:11:08,800
And right now, in order for a type checker to support these various libraries, there

147
00:11:08,800 --> 00:11:16,740
has to be a special plugin that is written for each library and each type checker.

148
00:11:16,740 --> 00:11:20,160
So a lot of times these plugins simply don't get written.

149
00:11:20,160 --> 00:11:28,640
Well, now there's a way for library authors who are making something like a pydantic model

150
00:11:28,960 --> 00:11:38,120
or an adders-based model to specify on those sort of meta models effectively, they can

151
00:11:38,120 --> 00:11:44,180
add this data class transform decorator, which tells type checkers that it acts like a data

152
00:11:44,180 --> 00:11:46,000
class.

153
00:11:46,000 --> 00:11:53,200
And so then you don't need the definer of the meta model, doesn't need to start writing

154
00:11:53,200 --> 00:11:56,600
a series of plugins for all the type checkers.

155
00:11:56,600 --> 00:11:59,760
So that's great.

156
00:11:59,760 --> 00:12:07,240
And last but not least, there is an extension to the existing typed dict, typed dictionaries

157
00:12:07,240 --> 00:12:09,160
data type.

158
00:12:09,160 --> 00:12:16,480
Previously, it was possible to define a typed dict, which is a dictionary with a set of

159
00:12:16,480 --> 00:12:22,320
a particular expected keys that have expected values, very common in JSON.

160
00:12:22,320 --> 00:12:29,560
It was possible to define a typed dict where some of the keys are either required and

161
00:12:29,560 --> 00:12:31,440
some of them where they are not required.

162
00:12:31,440 --> 00:12:37,080
You had to do this weird hack where you had one typed dict inheriting from another typed

163
00:12:37,080 --> 00:12:41,120
dict in order to mark some keys as required or as not required.

164
00:12:41,120 --> 00:12:43,600
Well, now you can just mark it directly.

165
00:12:43,600 --> 00:12:48,120
So very common is you have a lot of keys that are required and a few that are not required.

166
00:12:48,120 --> 00:12:53,400
So much, much simpler to write.

167
00:12:53,400 --> 00:12:57,320
So that is what I've got.

168
00:12:57,320 --> 00:13:02,520
If you're looking for more information for, for example, a list of typing related peps,

169
00:13:02,520 --> 00:13:09,960
I've assembled an updated list in that blog post, Python's Type Checking Renaissance.

170
00:13:09,960 --> 00:13:14,840
If you search for that, you will find that list of typing related peps and you can get

171
00:13:14,840 --> 00:13:19,200
the pet links there as well.

172
00:13:19,200 --> 00:13:24,200
Thanks for listening, folks.

173
00:13:24,200 --> 00:13:29,560
So I've got like, I think, two, three minutes?

174
00:13:29,560 --> 00:13:30,560
Three minutes for questions.

175
00:13:30,560 --> 00:13:31,560
Hit me.

176
00:13:31,560 --> 00:13:50,880
So the question was, are the features that I mentioned available in typing extensions

177
00:13:50,880 --> 00:13:53,560
or will they be available in typing extensions?

178
00:13:53,560 --> 00:13:58,760
In general, all new typing features are added to typing extensions first and they will work

179
00:13:58,760 --> 00:14:01,960
in any version of Python.

180
00:14:01,960 --> 00:14:07,840
So yeah, you can use these today, even if you're using a older version of Python in

181
00:14:07,840 --> 00:14:20,840
most cases.

182
00:14:21,840 --> 00:14:24,840
So pep604, could you tell me what that maps to?

183
00:14:24,840 --> 00:14:25,840
Type unions.

184
00:14:25,840 --> 00:14:26,840
Type unions.

185
00:14:26,840 --> 00:14:27,840
Sorry.

186
00:14:27,840 --> 00:14:28,840
What was the runtime of the older version of Python?

187
00:14:28,840 --> 00:14:29,840
The old version for unions.

188
00:14:29,840 --> 00:14:30,840
I heard many different things.

189
00:14:30,840 --> 00:14:31,840
Sorry.

190
00:14:31,840 --> 00:14:32,840
X, pipe, Y.

191
00:14:32,840 --> 00:14:33,840
X, pipe, Y?

192
00:14:33,840 --> 00:14:34,840
Okay, repeat the question.

193
00:14:34,840 --> 00:14:39,840
It was my question, the clarification that that will work at runtime, so you have to

194
00:14:39,840 --> 00:14:40,840
have a front-future Python.

195
00:14:40,840 --> 00:14:41,840
So I'm going to go ahead and ask you to repeat the question.

196
00:14:41,840 --> 00:14:42,840
So I'm going to go ahead and ask you to repeat the question.

197
00:14:42,840 --> 00:14:43,840
So I'm going to go ahead and ask you to repeat the question.

198
00:14:43,840 --> 00:14:44,840
So I'm going to go ahead and ask you to repeat the question.

199
00:14:44,840 --> 00:14:45,840
So I'm going to go ahead and ask you to repeat the question.

200
00:14:45,840 --> 00:14:46,840
So I'm going to go ahead and ask you to repeat the question.

201
00:14:46,840 --> 00:14:47,840
So I'm going to go ahead and ask you to repeat the question.

202
00:14:47,840 --> 00:14:48,840
So I'm going to go ahead and ask you to repeat the question.

203
00:14:48,840 --> 00:14:49,840
So I'm going to go ahead and ask you to repeat the question.

204
00:14:49,840 --> 00:14:50,840
So I'm going to go ahead and ask you to repeat the question.

205
00:14:50,840 --> 00:14:51,840
So I'm going to go ahead and ask you to repeat the question.

206
00:14:51,840 --> 00:14:52,840
So I'm going to go ahead and ask you to repeat the question.

207
00:14:52,840 --> 00:14:53,840
So I'm going to go ahead and ask you to repeat the question.

208
00:14:53,840 --> 00:14:54,840
So I'm going to go ahead and ask you to repeat the question.

209
00:14:54,840 --> 00:14:55,840
So I'm going to go ahead and ask you to repeat the question.

210
00:14:55,840 --> 00:14:56,840
So I'm going to go ahead and ask you to repeat the question.

211
00:14:56,840 --> 00:14:57,840
So I'm going to go ahead and ask you to repeat the question.

212
00:14:57,840 --> 00:14:58,840
So I'm going to go ahead and ask you to repeat the question.

213
00:14:58,840 --> 00:14:59,840
So I'm going to go ahead and ask you to repeat the question.

214
00:14:59,840 --> 00:15:00,840
So I'm going to go ahead and ask you to repeat the question.

215
00:15:00,840 --> 00:15:01,840
So I'm going to go ahead and ask you to repeat the question.

216
00:15:01,840 --> 00:15:02,840
So I'm going to go ahead and ask you to repeat the question.

217
00:15:02,840 --> 00:15:03,840
So I'm going to go ahead and ask you to repeat the question.

218
00:15:03,840 --> 00:15:04,840
So I'm going to go ahead and ask you to repeat the question.

219
00:15:04,840 --> 00:15:05,840
So I'm going to go ahead and ask you to repeat the question.

220
00:15:05,840 --> 00:15:06,840
So I'm going to go ahead and ask you to repeat the question.

221
00:15:06,840 --> 00:15:07,840
So I'm going to go ahead and ask you to repeat the question.

222
00:15:07,840 --> 00:15:08,840
So I'm going to go ahead and ask you to repeat the question.

223
00:15:08,840 --> 00:15:09,840
So I'm going to go ahead and ask you to repeat the question.

224
00:15:09,840 --> 00:15:10,840
So I'm going to go ahead and ask you to repeat the question.

225
00:15:10,840 --> 00:15:11,840
So I'm going to go ahead and ask you to repeat the question.

226
00:15:11,840 --> 00:15:12,840
So I'm going to go ahead and ask you to repeat the question.

227
00:15:12,840 --> 00:15:37,840
So I'm going to go ahead and ask you to repeat the question.

228
00:15:38,840 --> 00:15:43,840
None Pipex?

229
00:15:43,840 --> 00:15:45,840
I do not know if that works or not.

230
00:15:45,840 --> 00:15:57,840
I learned something.

231
00:15:57,840 --> 00:15:58,840
Okay.

232
00:15:58,840 --> 00:16:04,840
So yeah, the question was does we have x Pipe none, but maybe not none Pipex?

233
00:16:04,840 --> 00:16:07,840
Apparently from research here, both work.

234
00:16:07,840 --> 00:16:09,840
Got a question here.

235
00:16:09,840 --> 00:16:11,840
What are we going to get in 312?

236
00:16:11,840 --> 00:16:12,840
312.

237
00:16:12,840 --> 00:16:13,840
Let's see.

238
00:16:13,840 --> 00:16:16,840
So there are two things that I know about.

239
00:16:16,840 --> 00:16:21,840
One, which is tentatively called either type form or annotation type.

240
00:16:21,840 --> 00:16:32,840
That's something that I'm working on, which will allow you to label the type of a type annotation object, which is very close to type of T.

241
00:16:32,840 --> 00:16:35,840
The type of T doesn't accept certain things like unions and a few other things.

242
00:16:35,840 --> 00:16:37,840
That's something I'm planning on adding.

243
00:16:37,840 --> 00:16:44,840
And there is a second one from that article, which I do not remember offhand.

244
00:16:44,840 --> 00:16:47,840
You'll have to go look it up for me.

245
00:16:47,840 --> 00:16:49,840
Do we have any more time?

246
00:16:49,840 --> 00:16:51,840
Yes, please.

247
00:16:51,840 --> 00:16:52,840
Can I ask a question?

248
00:16:52,840 --> 00:17:00,840
In the spirit of being controversial from yesterday, optional is one of the most confusing words I have ever come across in my life.

249
00:17:00,840 --> 00:17:07,840
Because optional x is not in data classes, for example, optional.

250
00:17:07,840 --> 00:17:10,840
Could we call it not required?

251
00:17:10,840 --> 00:17:14,840
Could we replace it with required and not required?

252
00:17:14,840 --> 00:17:17,840
We're counting it in favor of 5 and a half.

253
00:17:18,840 --> 00:17:28,840
So the discussion that was made that was related to that, the thought was that optional was basically too, that it was too deprecating.

254
00:17:28,840 --> 00:17:34,840
So probably we're going to be with it for a long time at the very least.

255
00:17:34,840 --> 00:17:42,840
Rather than either reclassifying the use of the word optional or going completely eliminating it.

256
00:17:42,840 --> 00:17:46,840
That was more or less the consensus that seemed to be the case.

257
00:17:47,840 --> 00:17:56,840
So, yeah, for those of you who don't know me, my name is Aras Ponsu.

258
00:17:56,840 --> 00:18:03,840
And today I will be talking about basically the work that has been going on around tensor typing in the past.

259
00:18:03,840 --> 00:18:10,840
What is going on now? What is the next step today? And overall, what is going on in the ecosystem?

260
00:18:10,840 --> 00:18:16,840
So first of all, like, tensor typing is a very nervous topic.

261
00:18:16,840 --> 00:18:23,840
Because it really works a lot of things and you don't have anything that appears in numerical numbers.

262
00:18:23,840 --> 00:18:31,840
So on the one hand, we have very clear aspects like creating a tensor or getting a simple tensor.

263
00:18:31,840 --> 00:18:35,840
Or doing some basic matrix multiplication or concatenation.

264
00:18:35,840 --> 00:18:39,840
And this is something that comes to everyone's mind when you think of tensor typing.

265
00:18:39,840 --> 00:18:45,840
But by extension, when we think about machine learning, we have neural networks and layers.

266
00:18:45,840 --> 00:18:50,840
And because at the end of the day, the layers are just performing tensor multiplications.

267
00:18:50,840 --> 00:18:54,840
If we are capable of typing tensor, we can also type like neural networks.

268
00:18:54,840 --> 00:19:03,840
And do things like verifying that the inputs and the outputs of the layers in the neural network, they are correct at type checking time.

269
00:19:03,840 --> 00:19:10,840
And then we also have a wider range of operations that are a bit more sophisticated.

270
00:19:10,840 --> 00:19:13,840
That appear nonetheless very often in numerical entries.

271
00:19:13,840 --> 00:19:20,840
For example, we are getting things like tensor, we are flattening tensors, we are doing forecasting.

272
00:19:20,840 --> 00:19:27,840
Or some very popular operations like armix, armax, anion, transpose, etc.

273
00:19:27,840 --> 00:19:33,840
So unfortunately, there isn't one perfect solution for solving everything.

274
00:19:33,840 --> 00:19:37,840
Instead, we aim to solve this problem with a combination of tools.

275
00:19:37,840 --> 00:19:41,840
And these tools, we can put them into three main categories.

276
00:19:41,840 --> 00:19:45,840
One, variadix, another table arithmetic, another custom operator.

277
00:19:45,840 --> 00:19:49,840
And each of these tools contributes in a different way to solve this problem.

278
00:19:49,840 --> 00:19:52,840
So variadix allows us to solve some fundamental problems.

279
00:19:52,840 --> 00:19:56,840
For example, it's aligning itself with the concept of tensor.

280
00:19:56,840 --> 00:20:01,840
Like as a graph with a variable number of parameters, which is in the dimension sizes.

281
00:20:01,840 --> 00:20:09,840
It also allows us to say that we are moving to a dimension, or for example, in the matrix multiplication.

282
00:20:09,840 --> 00:20:15,840
And then table arithmetic is key every time that there is an arithmetic operation in the dimensions.

283
00:20:15,840 --> 00:20:19,840
For example, concatenation and slash operation on convolution.

284
00:20:19,840 --> 00:20:27,840
And then custom operators are needed for those operators that cannot be expressed any other way, but are very common.

285
00:20:27,840 --> 00:20:32,840
For example, broadcasting. Broadcasting is all over the place in numerical areas.

286
00:20:32,840 --> 00:20:36,840
And it cannot be expressed with arithmetic or with other methods.

287
00:20:36,840 --> 00:20:44,840
So as of now, I think something to be very proud of is the huge milestone that we achieved with respect to last year.

288
00:20:44,840 --> 00:20:49,840
That is the instance of F646 that now is available from Python 3.

289
00:20:49,840 --> 00:20:55,840
I think we have talked much about this in the past years.

290
00:20:55,840 --> 00:20:59,840
It's one of the reasons why many people started working together in tensor diving.

291
00:20:59,840 --> 00:21:04,840
So that this is already done, it's quite an achievement.

292
00:21:04,840 --> 00:21:06,840
And I think they are very winners.

293
00:21:06,840 --> 00:21:13,840
Then on the departmental side, I'm working with Kravitz on having an app that is ready for BOSO.

294
00:21:13,840 --> 00:21:18,840
Although for the ones who tried, you know that this is available in Python.

295
00:21:18,840 --> 00:21:20,840
Python is from the very beginning.

296
00:21:20,840 --> 00:21:30,840
And it's also nice to have it to show that it's technically possible to implement it and to get insights about what are the implications of an implementation.

297
00:21:30,840 --> 00:21:34,840
And then custom operators is a more amused topic.

298
00:21:34,840 --> 00:21:39,840
They're having a lot of discussion about what other operators are important for timing.

299
00:21:39,840 --> 00:21:43,840
Some of them, as I mentioned, are forecasting.

300
00:21:43,840 --> 00:21:46,840
It's very, very common.

301
00:21:46,840 --> 00:21:52,840
All the products that this is already available in Python, they are available in Python.

302
00:21:52,840 --> 00:21:55,840
So what are the effects?

303
00:21:55,840 --> 00:21:58,840
Let's take a look at what we used to have and what we have now.

304
00:21:58,840 --> 00:22:04,840
So basically before, we couldn't express that we have a tensor of any number of dimensions.

305
00:22:04,840 --> 00:22:13,840
Instead of working with a dimension in tensor, we need to have at least define a class for every number of dimensions.

306
00:22:13,840 --> 00:22:16,840
Tensors of one dimension, two dimensions, three dimensions.

307
00:22:16,840 --> 00:22:18,840
And this applies also to methods.

308
00:22:18,840 --> 00:22:20,840
So you need to work those for any number of dimensions.

309
00:22:20,840 --> 00:22:22,840
And here there's only one parameter.

310
00:22:22,840 --> 00:22:24,840
There are two or three parameters and you need to work those.

311
00:22:24,840 --> 00:22:28,840
This gets to a combinatorial conclusion that is crazy actually.

312
00:22:28,840 --> 00:22:34,840
So we actually, if I remember correctly, must have created a library that was trying to use this idea.

313
00:22:34,840 --> 00:22:39,840
And at the end, that was the problem, that there were so many combinations that people didn't understand.

314
00:22:39,840 --> 00:22:41,840
But now we have exactly what we wanted.

315
00:22:41,840 --> 00:22:47,840
At least we were able to express that we have a tensor, not a one-dimensional, not a two-dimensional, of any number of dimensions.

316
00:22:47,840 --> 00:22:51,840
And I think this is a very nice thing to have.

317
00:22:51,840 --> 00:22:55,840
And it makes it also very easy to work with dimensions later on.

318
00:22:55,840 --> 00:23:02,840
For example, you see that now we don't need to be overloading, but as well that I was to express something that are not necessarily tensor-specific.

319
00:23:02,840 --> 00:23:06,840
For example, when you define the A method, you don't pass a tensor.

320
00:23:06,840 --> 00:23:14,840
You pass a variable number of numbers that will be converted into a set of the tensor and by servers that you can force it.

321
00:23:14,840 --> 00:23:18,840
And you can extract the dimensions and put them in the top.

322
00:23:18,840 --> 00:23:24,840
So yeah, having this makes a big difference on what can be modeled and open the doors to a lot of things.

323
00:23:24,840 --> 00:23:28,840
So once again, having this is really great news.

324
00:23:28,840 --> 00:23:30,840
Then, type arithmetic.

325
00:23:30,840 --> 00:23:43,840
Well, now that we have very early type arithmetic, it's kind of one of the most clear things that would open the door to support in many other use cases, especially in the mathematical machine learning.

326
00:23:43,840 --> 00:23:50,840
So type arithmetic basically appears anywhere where you need to do some arithmetic operations on the dimension.

327
00:23:50,840 --> 00:23:54,840
For example, if you want to multiply into the tensor, you will need to add some of the tensor.

328
00:23:54,840 --> 00:23:59,840
You want to get any slice into the tensor, you will need to do the subtraction.

329
00:23:59,840 --> 00:24:11,840
If you need to generate tensor with values in some range, you will need to do subtraction and division or something like social classification again with the quantum multiplication.

330
00:24:11,840 --> 00:24:18,840
Perhaps the main exponent of what type arithmetic can be is a convolution.

331
00:24:18,840 --> 00:24:28,840
Convolutions have a pretty intimidating formula when you look at it, but then you think more carefully and you realize that at the end it's plain arithmetic.

332
00:24:28,840 --> 00:24:34,840
It's true that the formula is very convoluted by definition, but it's pretty simple.

333
00:24:34,840 --> 00:24:38,840
There is subtraction, multiplication, division.

334
00:24:38,840 --> 00:24:53,840
So basically if we are able to support arithmetic, we will be able to support something so complicated as this, no matter how we combine it, how many layers there are, we should be able to verify that what is happening here is correct.

335
00:24:53,840 --> 00:25:00,840
And this is a challenge for humans, for programmers, because these formulas are so complex that you can easily get lost on them.

336
00:25:00,840 --> 00:25:03,840
So to have it verify that on bad timing is great.

337
00:25:03,840 --> 00:25:20,840
And then by extension, by supporting this, we are also supporting symbolic arithmetic in the sense that we are also capable of giving to variables that represent dimensions, we are able to represent their expressions.

338
00:25:20,840 --> 00:25:34,840
Because this way we, for example, can verify that the input that you're providing to an error in what is correct and you are not passing something that would fail at content.

339
00:25:34,840 --> 00:25:41,840
So how do these operators work? Well, at the end, the semantics of the operators are quite straightforward.

340
00:25:41,840 --> 00:25:48,840
First of all, we assume that we are going to be using iterative integers for defining the values of the sets of the dimensions.

341
00:25:48,840 --> 00:25:59,840
And then basically the arithmetic operators are behaving like they would if they had frontends. So literal 2 plus iterative 3 would be 5 and so on and so forth.

342
00:25:59,840 --> 00:26:06,840
There will be x cases that we consider as how are we handling any, how are we handling them and what.

343
00:26:06,840 --> 00:26:13,840
This requires some more discussion, but this is one of the last things that we are covering.

344
00:26:13,840 --> 00:26:17,840
But that's a simple summary.

345
00:26:17,840 --> 00:26:22,840
And then the other key part of supporting the arithmetic is equality.

346
00:26:22,840 --> 00:26:27,840
Because so far, like what they have been commenting doesn't look like that surprising.

347
00:26:27,840 --> 00:26:31,840
Okay, you have a system where you have to press 3 and you're supposed to press 5.

348
00:26:31,840 --> 00:26:34,840
But it's not enough. So it's not enough.

349
00:26:34,840 --> 00:26:44,840
Because at the end, you are going to be doing all the time expressions in tensors that they are going to get equivalent, but with different expressions.

350
00:26:44,840 --> 00:26:54,840
And the problem is that you will get an error from the type checker telling you, hey, for example, here you have a tensor of size a plus a and this one is of size a plus a.

351
00:26:54,840 --> 00:26:59,840
So they are not the same when you're operation is invalid. But for us, like, this is obvious that they are the same, right?

352
00:26:59,840 --> 00:27:03,840
Because it's not as common to me. But for the type checker, this is far from obvious.

353
00:27:03,840 --> 00:27:12,840
And this applies to a very wide range of expressions that they will appear in absolutely normal circumstances.

354
00:27:12,840 --> 00:27:17,840
So supporting them is a must to make this feature useful.

355
00:27:17,840 --> 00:27:23,840
But at the same time, we want to make sure that this is not going to make the language way more complicated.

356
00:27:23,840 --> 00:27:34,840
Because nowadays, we have the language that can do such a thing are dependent typing languages where basically they need to provide a proof that there is an equality between expressions.

357
00:27:34,840 --> 00:27:39,840
And that's definitely far from the vision that we have for Python as an engine.

358
00:27:39,840 --> 00:27:46,840
So basically the idea is that we need to ensure that whatever we add is going to add zero overhead for the program.

359
00:27:47,840 --> 00:27:54,840
And the only kind of advantage that we have is that we are limiting ourselves to a few number of operators.

360
00:27:54,840 --> 00:27:59,840
We don't want to express absolutely anything in the tensor.

361
00:27:59,840 --> 00:28:04,840
We only want to express a few number of operators. So can we optimize for them?

362
00:28:04,840 --> 00:28:08,840
Well, we can. And that's basically the idea behind the proposal.

363
00:28:08,840 --> 00:28:12,840
That is to create a canonical representation.

364
00:28:12,840 --> 00:28:16,840
Basically, the idea is that we have two expressions which are equivalent.

365
00:28:16,840 --> 00:28:22,840
They should be internally represented the same way. And if we achieve this, then equality comparisons are free.

366
00:28:22,840 --> 00:28:31,840
So how does this work? Well, for the case of addition, subtraction, multiplication, we can think about this as polynomials.

367
00:28:31,840 --> 00:28:35,840
So the problem becomes just how can we compare polynomials to the problem.

368
00:28:35,840 --> 00:28:45,840
For this, we go through a series of steps that goes through expanding the polynomial into monomials, grouping them, raising zeros, setting up that order.

369
00:28:45,840 --> 00:28:49,840
And we can guarantee that if they are equivalent, they will be represented in the same way.

370
00:28:49,840 --> 00:28:56,840
It's not that much that we know exactly how to do this since there are libraries that can automatically check this properties.

371
00:28:56,840 --> 00:29:01,840
But I think in this case it's quite clear how can we achieve it.

372
00:29:01,840 --> 00:29:08,840
In the case of division, it's a bit tricky because this is not just division. This is integer division or floor division.

373
00:29:08,840 --> 00:29:15,840
So this is not such a common mathematical function. And there is not that many rules about it that are popular.

374
00:29:15,840 --> 00:29:20,840
But basically, some rules that are applied for integer or normal division don't apply to integer division.

375
00:29:20,840 --> 00:29:26,840
Perhaps the most obvious is n divided by 2 plus n divided by 2 is not even...

376
00:29:26,840 --> 00:29:31,840
We have an example, right? 1 divided by 2 plus 1 divided by 2 is actually 0.

377
00:29:31,840 --> 00:29:41,840
So all these things will be kept in mind to make sure that the rules of type arithmetic are consistent with the runtime behavior of the corresponding Python functions.

378
00:29:41,840 --> 00:29:46,840
So that's an overview of the rules of equality.

379
00:29:46,840 --> 00:29:55,840
Here is just a brief comment about some experience that I have had myself implementing differently with type arithmetic in Pyre.

380
00:29:55,840 --> 00:30:01,840
So I was typing some code on ResNet, this neural network, with Pyre.

381
00:30:01,840 --> 00:30:07,840
There are many challenges that I'm not going to answer until I tell you what makes it hard to type it.

382
00:30:07,840 --> 00:30:16,840
The fact is that at some point I could type this part of the neural network where there is a long series of convolutional layers.

383
00:30:16,840 --> 00:30:22,840
If you remember well, the formula for convolutions is quite sophisticated.

384
00:30:22,840 --> 00:30:30,840
So just imagine doing this five times, one side of your color, the formula gets pretty complicated.

385
00:30:30,840 --> 00:30:41,840
But the interesting bit here is that if you look at the return value of the function, you see that the actual dimension of the tensor that is returning is really simple.

386
00:30:41,840 --> 00:30:52,840
And this is because the quality, the automatic equality system is capable of realizing that despite making a lot of sequences of this complicated transformation,

387
00:30:52,840 --> 00:30:58,840
a lot of things can get simplified and overall get simplified very simple.

388
00:30:58,840 --> 00:31:05,840
So I think that's a good way of solving that problem.

389
00:31:05,840 --> 00:31:09,840
Finally, let me tell you something about custom operators.

390
00:31:09,840 --> 00:31:16,840
Again, this is like a broad category to put together many different ideas that would contribute to potential typing.

391
00:31:16,840 --> 00:31:28,840
But clearly one of the most valuable is broadcasting because so far we have claimed that we could support many operators in the support for variarities neural network.

392
00:31:28,840 --> 00:31:35,840
But the fact is that in most libraries, almost all operators have a variant for their broadcasting case.

393
00:31:35,840 --> 00:31:38,840
Basically, if the tensor doesn't match, then they do broadcasting.

394
00:31:38,840 --> 00:31:45,840
So to fully support all these libraries that do broadcasting, we need to be able to express it.

395
00:31:45,840 --> 00:31:51,840
And the thing is that broadcasting appears in all the cube operators, like addition, subtraction, multiplication, division, comparison.

396
00:31:51,840 --> 00:31:54,840
They're all over the place. They all have a broadcasting variant.

397
00:31:54,840 --> 00:31:58,840
And being able to express this is super important.

398
00:31:58,840 --> 00:32:01,840
Fortunately, broadcasting is very standardized with semantics.

399
00:32:01,840 --> 00:32:07,840
And it behaves really much the same in non-bi-bio-tensor flow.

400
00:32:07,840 --> 00:32:10,840
So that's, I would think, well.

401
00:32:10,840 --> 00:32:19,840
Nonetheless, again, we have been broadcasting the challenge of making sure that even different broadcasting expressions, we can verify that they're the same.

402
00:32:19,840 --> 00:32:26,840
We don't want to be in a situation where we don't realize that broadcasting is the same as BMI broadcasting is commonly.

403
00:32:26,840 --> 00:32:28,840
Or it's also a striptease.

404
00:32:28,840 --> 00:32:34,840
And overall, there are multiple situations where we need to guarantee that they are equal.

405
00:32:34,840 --> 00:32:43,840
About other operators that we have talked about in the past, for example, I mentioned many times the product.

406
00:32:43,840 --> 00:32:49,840
Basically, often you need to make the product of all the dimensions of a sensor.

407
00:32:49,840 --> 00:32:54,840
For example, when you want to do a resave or a WDT sensor, you are going to do this.

408
00:32:54,840 --> 00:32:57,840
It's true that you would overload a bunch of multiplications.

409
00:32:57,840 --> 00:33:04,840
Nonetheless, this is not something you're going to do, especially when you have multiple parameters and you can start having too many combinations.

410
00:33:04,840 --> 00:33:12,840
And then a pattern that appears very often is when you are removing a dimension from a sensor, when you are replacing a dimension from a sensor.

411
00:33:12,840 --> 00:33:19,840
These operators were mentioned by Pradeep not so long time ago.

412
00:33:19,840 --> 00:33:30,840
I remember with some checks, there were like 40 or 50 or more different operators in Python that would need these to extract themselves.

413
00:33:30,840 --> 00:33:33,840
So this shows how common this pattern is.

414
00:33:33,840 --> 00:33:40,840
For example, in Armax or Armint, that is something very commonly used.

415
00:33:40,840 --> 00:33:46,840
You are exerping this, removing one of the dimensions of the sensor in one of the positions.

416
00:33:46,840 --> 00:33:52,840
Or, for example, when you are doing a transpose by definition, you are transposing two dimensions of the sensor.

417
00:33:52,840 --> 00:33:54,840
So you will be doing exactly this.

418
00:33:54,840 --> 00:33:57,840
So having support for this certainly will help a lot.

419
00:33:58,840 --> 00:34:07,840
That's basically a summary of all the key elements for achieving sensor typing.

420
00:34:07,840 --> 00:34:11,840
I think, again, it's important to realize the future step forward.

421
00:34:11,840 --> 00:34:19,840
There has been C4.6 and how happy we should be about the work that has been done there.

422
00:34:19,840 --> 00:34:24,840
And also to be excited about what we can be achieved for the month.

423
00:34:24,840 --> 00:34:27,840
So, yes, that was everything from my side.

424
00:34:27,840 --> 00:34:29,840
Thank you very much for your attention.

425
00:34:29,840 --> 00:34:34,840
And Pradeep has kindly offered to my discussion.

426
00:34:34,840 --> 00:34:36,840
And Pradeep, you can invite me.

427
00:34:36,840 --> 00:34:41,840
I'm going to challenge you and I'm going to try to get you from here.

428
00:34:41,840 --> 00:34:43,840
So, yes, thank you very much.

429
00:34:55,840 --> 00:34:56,840
Hello.

430
00:35:01,840 --> 00:35:02,840
I have questions.

431
00:35:02,840 --> 00:35:03,840
Oh, thanks.

432
00:35:03,840 --> 00:35:04,840
Okay.

433
00:35:07,840 --> 00:35:08,840
Is it on?

434
00:35:08,840 --> 00:35:09,840
No.

435
00:35:11,840 --> 00:35:12,840
Okay.

436
00:35:12,840 --> 00:35:15,840
Let me know if anybody has questions.

437
00:35:15,840 --> 00:35:18,840
So I just have a question about broadcasting.

438
00:35:18,840 --> 00:35:22,840
Do you think what broadcasting is and why it's complicated?

439
00:35:22,840 --> 00:35:29,840
So broadcasting means that you can add tensors that are not identical in their dimensions,

440
00:35:29,840 --> 00:35:32,840
but are aligned along across certain dimensions.

441
00:35:32,840 --> 00:35:40,840
For example, if you have one tensor of dimensions 5, 1, and the other one of 1, 4,

442
00:35:40,840 --> 00:35:43,840
so they're not identical, so you might think they can't add them.

443
00:35:43,840 --> 00:35:49,840
But in reality, it allows you to add them and get a tensor of type of shape 5, 4,

444
00:35:49,840 --> 00:35:53,840
or 5, all the ones that ignore basically and collapse into it.

445
00:35:53,840 --> 00:35:57,840
So that's the idea from a shape point of view.

446
00:35:57,840 --> 00:36:00,840
So we need that because without that, we will be really in shape.

447
00:36:00,840 --> 00:36:07,840
So we need broadcasting to be able to support usual thoughts and tensor operations.

448
00:36:07,840 --> 00:36:12,840
The easy example is if you take a matrix and add a scalar,

449
00:36:12,840 --> 00:36:16,840
it doesn't just matter if they work even though the scalar is not a matrix.

450
00:36:20,840 --> 00:36:24,840
Any other questions?

451
00:36:24,840 --> 00:36:32,840
Yeah, for your custom functions, so is your idea in the long term that there's that concept of custom operators for specific functions?

452
00:36:32,840 --> 00:36:34,840
Yeah, so that was the fear that we had.

453
00:36:34,840 --> 00:36:37,840
We need kind of custom operators for each one.

454
00:36:37,840 --> 00:36:41,840
So I went to all the tensor functions that we have right now

455
00:36:41,840 --> 00:36:46,840
and I'm sort of classifying them what operators we need for each one.

456
00:36:46,840 --> 00:36:50,840
So I found that remove add in the case of the main things that we need.

457
00:36:50,840 --> 00:36:54,840
And that would cover basically almost all the tensor operations we have.

458
00:36:54,840 --> 00:37:00,840
There are a couple niche ones, which I don't think it's okay to ignore them.

459
00:37:00,840 --> 00:37:02,840
And say that we can't type them.

460
00:37:02,840 --> 00:37:04,840
So it's not really going to help.

461
00:37:10,840 --> 00:37:12,840
Any other thoughts, questions?

462
00:37:12,840 --> 00:37:19,840
Yes, so I didn't understand one part of the slides where I think you said we didn't need a zero-prover to make this work.

463
00:37:19,840 --> 00:37:23,840
But it sounds like you're lifting the whole context for system into typing.

464
00:37:23,840 --> 00:37:28,840
And typically, from what I know from like the post-process, I know we look at it sometimes,

465
00:37:28,840 --> 00:37:31,840
but you need a zero-prover for that.

466
00:37:31,840 --> 00:37:37,840
So I think it's like ordered monomial, is that problem?

467
00:37:37,840 --> 00:37:41,840
So if I understand your question, you're using how we avoid having a TM for this?

468
00:37:41,840 --> 00:37:48,840
Yeah, so the thing is for addition and multiplication, you're able to get a canonical representation for that.

469
00:37:48,840 --> 00:37:52,840
So you don't need to prove that these two types are equal.

470
00:37:52,840 --> 00:37:57,840
But for division, right now we sort of have a best effort in simplification.

471
00:37:57,840 --> 00:38:01,840
And if you have, so it's like if you divide, because it's integer division,

472
00:38:01,840 --> 00:38:06,840
and as Alphonse mentioned, you have n by 2 plus n by 2.

473
00:38:06,840 --> 00:38:08,840
They're not equal to n, right?

474
00:38:08,840 --> 00:38:15,840
So we do have equivalent expressions that the type checking will not always work.

475
00:38:15,840 --> 00:38:18,840
So it's important and very contributory.

476
00:38:18,840 --> 00:38:19,840
So it's a subset.

477
00:38:19,840 --> 00:38:23,840
Yeah, I would like to add that since the last year,

478
00:38:23,840 --> 00:38:27,840
I was actually surprised by the power of SimPy.

479
00:38:27,840 --> 00:38:29,840
I think SimPy is the right library.

480
00:38:29,840 --> 00:38:35,840
And they have some specific functions for doing pretty much the same, but in the context of parametric.

481
00:38:35,840 --> 00:38:40,840
And like change variables to variables in the Cypher.

482
00:38:40,840 --> 00:38:47,840
And I think that they do guarantee that the integer division and quantity checking is totally covering all these cases.

483
00:38:47,840 --> 00:38:53,840
So I think that from a implementation point of view, this could be leveraged and unaltered.

484
00:38:59,840 --> 00:39:02,840
Any other thoughts? I can pass it on to Sharon.

485
00:39:03,840 --> 00:39:06,840
Yeah, yeah, you're up next.

486
00:39:06,840 --> 00:39:08,840
Thank you. Thank you.

487
00:39:08,840 --> 00:39:09,840
Thank you.

488
00:39:19,840 --> 00:39:22,840
David already told us about all the new tests that you're getting in.

489
00:39:22,840 --> 00:39:24,840
He saved the larger group direction.

490
00:39:24,840 --> 00:39:27,840
Yes. Thank you.

491
00:39:27,840 --> 00:39:29,840
Now you guys can hear me.

492
00:39:29,840 --> 00:39:33,840
Yeah, David already told us about all the new paths in back-up quick with the lab.

493
00:39:33,840 --> 00:39:38,840
There's actually a bunch more smaller features that we're also getting and going to introduce those.

494
00:39:41,840 --> 00:39:42,840
Like we have all these paths.

495
00:39:42,840 --> 00:39:44,840
I'm not going to talk about them.

496
00:39:44,840 --> 00:39:50,840
Instead, what we have is reveal type, never, assert never, assert type, get overdose,

497
00:39:51,840 --> 00:39:54,840
changes to final, and any as a base class.

498
00:39:55,840 --> 00:39:56,840
It's time to reveal type.

499
00:39:56,840 --> 00:40:02,840
When we started talking about this, everybody thought reveal type was already implemented in platform 4 and specified.

500
00:40:02,840 --> 00:40:03,840
It wasn't.

501
00:40:03,840 --> 00:40:05,840
It just doesn't matter.

502
00:40:05,840 --> 00:40:08,840
We all decided it's so useful, we're all going to use it.

503
00:40:09,840 --> 00:40:11,840
So the other thing to typing in 3.11,

504
00:40:11,840 --> 00:40:19,840
the advantage of I think the thing about runtime includes that you can run your test suite at the same time as you're debugging your types.

505
00:40:19,840 --> 00:40:24,840
And if you're using it in education, you can run your examples,

506
00:40:24,840 --> 00:40:27,840
which reveal type in them and they will actually work at runtime.

507
00:40:32,840 --> 00:40:33,840
We have never.

508
00:40:33,840 --> 00:40:37,840
No return has been in the type system since pretty much the beginning.

509
00:40:38,840 --> 00:40:42,840
But it was meant to be only used for functions that never return.

510
00:40:43,840 --> 00:40:49,840
But every type checker basically decided we want to bottom type and we're going to use never for that.

511
00:40:50,840 --> 00:40:55,840
To make that clearer, 3.11, you're adding never as basically an equivalent of no return.

512
00:40:56,840 --> 00:41:02,840
I recommend that type checkers treat them as the same in their internal representations.

513
00:41:03,840 --> 00:41:09,840
But in error message, I would recommend you output never when you're on 3.11 or in New York.

514
00:41:13,840 --> 00:41:16,840
Relate to never, we add the assert never function.

515
00:41:16,840 --> 00:41:18,840
This isn't actually a type system feature.

516
00:41:18,840 --> 00:41:21,840
You could implement this in user codes just as easily.

517
00:41:22,840 --> 00:41:28,840
But it's kind of hard to discover and a lot of people have to discover it independently.

518
00:41:29,840 --> 00:41:33,840
So we're adding it to typing to make it easy for our quality to find out how to use it.

519
00:41:34,840 --> 00:41:40,840
So the use case is that you want to assert that some code is unreachable and the type checker can prove that it's unreachable.

520
00:41:40,840 --> 00:41:44,840
In this example, we know there's only two booleans.

521
00:41:44,840 --> 00:41:47,840
So if it's not true or false, then it's obviously impossible.

522
00:41:48,840 --> 00:41:53,840
And with this explicit assert never call, the type checker will tell you if there's a third boolean,

523
00:41:54,840 --> 00:41:58,840
we expect it to switch to ternary logic, and you didn't update your code.

524
00:41:58,840 --> 00:42:02,840
The next thing to add is helpful for asserting that if you put type annotations in the type checker,

525
00:42:02,840 --> 00:42:05,840
it actually understands them the way you intended them.

526
00:42:08,840 --> 00:42:12,840
In this simple case, you put int in the type function annotations.

527
00:42:12,840 --> 00:42:15,840
So obviously the type checker will think that x is an int.

528
00:42:16,840 --> 00:42:18,840
In this case, it's of course trivial.

529
00:42:19,840 --> 00:42:22,840
We majorly discuss this in the next class.

530
00:42:22,840 --> 00:42:24,840
In this case, it's of course trivial.

531
00:42:25,840 --> 00:42:34,840
We majorly discuss this in type chat, where we want to test that the stuff we provide actually result in the types that we think they result in.

532
00:42:35,840 --> 00:42:41,840
Because sometimes we do pretty complicated things with overloads and generic self types and protocols and what not.

533
00:42:42,840 --> 00:42:47,840
We want to make sure that type checks actually understand what they're doing in the way we intended it.

534
00:42:47,840 --> 00:42:52,840
And actually, so, yeah, go ahead.

535
00:42:52,840 --> 00:42:56,840
So I was going to ask whether, is it null of the runtime?

536
00:42:56,840 --> 00:42:58,840
It does nothing as runtime.

537
00:42:59,840 --> 00:43:02,840
I think in this case we're going to do literally nothing.

538
00:43:03,840 --> 00:43:07,840
It's purely for checking that the static type is what you think it is.

539
00:43:09,840 --> 00:43:11,840
It returns the values.

540
00:43:11,840 --> 00:43:16,840
Oh, right, yes, it returns the values. So then you can put it in an expression and keep using it.

541
00:43:17,840 --> 00:43:20,840
Does this do the exact type check or is it something like type check?

542
00:43:20,840 --> 00:43:22,840
So, not how like, what's the question?

543
00:43:23,840 --> 00:43:25,840
It's exact type check.

544
00:43:26,840 --> 00:43:28,840
It's possible if you have to think more about details.

545
00:43:28,840 --> 00:43:37,840
One thing that I actually got into recently was if you have two protocols that have the same methods, should that assert type thing do the same thing?

546
00:43:38,840 --> 00:43:42,840
And the way you can get the night time, it doesn't think they're the same thing, but then you shoot.

547
00:43:43,840 --> 00:43:49,840
What does a reveal type do at runtime? Does it print it out or just something?

548
00:43:49,840 --> 00:43:51,840
It prints the type of the value.

549
00:43:52,840 --> 00:43:54,840
It returns the value also.

550
00:43:54,840 --> 00:43:56,840
Yes, it also returns the value.

551
00:43:56,840 --> 00:44:04,840
Yeah, that's one of the things we found out while trying to standardize is it's effortlessly implemented, but not effortlessly implemented exactly the same.

552
00:44:05,840 --> 00:44:08,840
The returning the value thing is not night time, I guess.

553
00:44:08,840 --> 00:44:15,840
It's useful because then you can just put reveal type anywhere in the expression and night time tells you what type is a different point.

554
00:44:17,840 --> 00:44:19,840
So that's the way to standardize it.

555
00:44:19,840 --> 00:44:22,840
I think I like that to change the information a little bit.

556
00:44:22,840 --> 00:44:38,840
The basic plain devil's advocate is that that code is going to surely enormously confuse new users who see that and they assume that they're going to hard check it at runtime.

557
00:44:38,840 --> 00:44:39,840
It's possible, yes.

558
00:44:39,840 --> 00:44:46,840
We went over a lot of possible names for this function and ultimately you could say that the development was better than assert type.

559
00:44:46,840 --> 00:44:52,840
We tried to make clear the information in the documentation when it does.

560
00:44:52,840 --> 00:44:57,840
If you have suggestions for how to make it even more clear, we can still change the information.

561
00:44:57,840 --> 00:45:04,840
One fun trick here is that the SOAP never does have a runtime SOAP, but it's so that it's not a runtime SOAP.

562
00:45:04,840 --> 00:45:06,840
This is true.

563
00:45:06,840 --> 00:45:08,840
So it's shaggy type?

564
00:45:09,840 --> 00:45:11,840
Yeah, it's possible.

565
00:45:11,840 --> 00:45:16,840
I guess I didn't want anything too long either, but shaggy type.

566
00:45:16,840 --> 00:45:20,840
Shaggy type can be something even more likely to get in your runtime.

567
00:45:20,840 --> 00:45:28,840
Yeah, I think we went over many of these and couldn't come up with anything that's really better.

568
00:45:30,840 --> 00:45:37,840
I guess the last thing I want to say if you are already using this in TypeShed right now, Alex Weigut added it for PyRat.

569
00:45:37,840 --> 00:45:39,840
Last week I think.

570
00:45:39,840 --> 00:45:41,840
And MyPy added to MyPy.

571
00:45:41,840 --> 00:45:47,840
We just released support, so we're going to have MyPy assert type checks in TypeShed also very soon.

572
00:45:47,840 --> 00:45:53,840
If the PyR people want PyR to do the same thing, please contribute and save for PyType.

573
00:45:56,840 --> 00:46:06,840
I think one thing that's worth saying about that, the naming is just, the use cases for this are mostly for implementers and type checkers are a very complicated type library.

574
00:46:06,840 --> 00:46:10,840
So it's not the kind of thing that's likely to show up in the beginning of the season.

575
00:46:10,840 --> 00:46:16,840
Yeah, I guess the main risk there is you see it in either the typing notification, you see it in either the download form.

576
00:46:16,840 --> 00:46:19,840
That's your grant that most people want to see it very much.

577
00:46:20,840 --> 00:46:23,840
This is a feature of PyPons right now?

578
00:46:26,840 --> 00:46:29,840
Yeah, so it's in typing.py at runtime.

579
00:46:29,840 --> 00:46:31,840
It's in 3.11, it's in typing extensions.

580
00:46:31,840 --> 00:46:36,840
But obviously the runtime just, I guess we established it just returns the value.

581
00:46:36,840 --> 00:46:38,840
The interesting implementation is in type checkers.

582
00:46:38,840 --> 00:46:41,840
And MyPy and PyRy support it.

583
00:46:41,840 --> 00:46:44,840
I believe PyType already supported it on the disk name.

584
00:46:44,840 --> 00:46:45,840
Is that correct?

585
00:46:45,840 --> 00:46:46,840
Yeah.

586
00:46:46,840 --> 00:46:49,840
We support a PyType extension that assert type.

587
00:46:49,840 --> 00:46:52,840
I think we need to just like alias it to something in typing.

588
00:46:52,840 --> 00:46:53,840
Okay, yeah.

589
00:46:53,840 --> 00:46:55,840
All right, that's a certain type.

590
00:46:55,840 --> 00:46:57,840
I'm going to say more questions.

591
00:46:57,840 --> 00:47:02,840
Then the next thing we have is around support for runtime use of typing.

592
00:47:02,840 --> 00:47:12,840
The way that Overload was implemented, it would just completely throw away the overloads after the actual function is defined.

593
00:47:12,840 --> 00:47:20,840
So in this example, before PyPy with 11, the overload is for a function that is not in the type.

594
00:47:20,840 --> 00:47:25,840
And then after PyPy with 11, the overload is for a function for f.

595
00:47:25,840 --> 00:47:31,840
You just never reopen it again because it's lost in the module namespace and there's no more reference to it.

596
00:47:31,840 --> 00:47:40,840
And this means it's impossible for type checkers that look at their runtime types to ever find an overload back.

597
00:47:40,840 --> 00:47:48,840
So we added something that gathers the overload in basically a dictionary in the typing module at runtime.

598
00:47:48,840 --> 00:47:55,840
So that you can then call the get overloads function to retrieve the overloads again and see what they are.

599
00:47:57,840 --> 00:48:02,840
I was motivated to add this because in the type checker network only I need this to get an overdose.

600
00:48:02,840 --> 00:48:16,840
Another use case is that in health outputs and other documentation, we will now be able to show overloads because again, they are completely accessible to runtime and you couldn't even find them.

601
00:48:17,840 --> 00:48:22,840
How does that work at runtime? Does the decorative fashion have some secret name somewhere?

602
00:48:22,840 --> 00:48:33,840
There's just a dictionary in typing that's I think the way they end up doing this for module to function name to the list of overloads.

603
00:48:33,840 --> 00:48:48,840
The downside is that the dash offices are never used because they keep these things around and they add overloads a little bit slower than runtime because it has to do a little bit more work.

604
00:48:48,840 --> 00:49:07,840
Similarly for final, also it was impossible for a runtime type checker to support not subtesting a final class because final is returned to class unchanged.

605
00:49:07,840 --> 00:49:10,840
There's no way to know that this class was decorated as final.

606
00:49:10,840 --> 00:49:18,840
So now we add this number of final attributes on the defined class or methods when you apply it.

607
00:49:19,840 --> 00:49:24,840
I think this now means that all typing decorators are in respect to the runtime if you need them.

608
00:49:24,840 --> 00:49:29,840
Last but not least, a recommendation from Shansu.

609
00:49:29,840 --> 00:49:40,840
Be ready in staff supported subclassing any for cases where you have something that you can basically do anything with that's also wants some custom behavior.

610
00:49:40,840 --> 00:49:49,840
The most common example is mark objects which you can use to pass anywhere, but they also have some methods that are just a panel from box.

611
00:49:50,840 --> 00:49:54,840
So this will also be allowed in runtime.

612
00:49:59,840 --> 00:50:04,840
Yeah, and some takeaways from this include that there's still room for improvements.

613
00:50:04,840 --> 00:50:15,840
There's more things we can have at if there's new ideas that you think are useful, we can consider them for people 12 or if you're really ambitious for three with the left and for future trees.

614
00:50:15,840 --> 00:50:20,840
Eventually, two days of spring that conference.

615
00:50:20,840 --> 00:50:25,840
So if you have some idea of how likely and then you can get it.

616
00:50:27,840 --> 00:50:31,840
Yeah, so maybe you can make people 12 and better if there's more new ideas.

617
00:50:34,840 --> 00:50:37,840
And last, there is, as I mentioned, the bonus slides.

618
00:50:39,840 --> 00:50:43,840
This is something that's service to check out, which is very active core developer.

619
00:50:43,840 --> 00:50:44,840
There's the PR for today.

620
00:50:46,840 --> 00:50:51,840
Currently, at runtime, it's impossible to make a generic name to pull just because of some cost.

621
00:50:51,840 --> 00:50:52,840
Thanks to the implementation.

622
00:50:53,840 --> 00:50:56,840
Even though to be at least this seems pretty natural.

623
00:50:56,840 --> 00:51:02,840
Like in this example, he has a name to pull one field is the other field is the 10 depends on the generic.

624
00:51:04,840 --> 00:51:10,840
So anything plans to allow these three with the left and worst PR and make this work that runtime.

625
00:51:10,840 --> 00:51:18,840
My only hesitation is that maybe there's some reason in the static type system that this opens a giant hole and there's some reason not to do it.

626
00:51:19,840 --> 00:51:22,840
So if you as a tech checker maintainer things, this is a bad idea.

627
00:51:23,840 --> 00:51:24,840
Please let me know and we can.

628
00:51:25,840 --> 00:51:26,840
We consider it.

629
00:51:27,840 --> 00:51:30,840
That's what it work with my pie out of the box.

630
00:51:30,840 --> 00:51:34,840
No, my eyes actually the main reason I think it doesn't work.

631
00:51:34,840 --> 00:51:35,840
Doesn't work.

632
00:51:36,840 --> 00:51:41,840
Yeah, I think my my internal support doesn't go to the next level.

633
00:51:41,840 --> 00:51:44,840
So generic things are not going to work.

634
00:51:44,840 --> 00:51:50,840
And as I think that shouldn't stop us.

635
00:51:50,840 --> 00:51:55,840
Like I think it's to be it seems like a natural way to extend the time system.

636
00:51:56,840 --> 00:52:01,840
I said that doesn't support it, but we don't have to wait for that.

637
00:52:01,840 --> 00:52:05,840
There's nothing uses for runtime things like.

638
00:52:08,840 --> 00:52:12,840
Maybe I mean maybe you can use generics anywhere.

639
00:52:12,840 --> 00:52:14,840
We have generic version of the model.

640
00:52:14,840 --> 00:52:18,840
Yes, yeah, it's getting because I know it's happening, but thank you.

641
00:52:18,840 --> 00:52:19,840
People seem to use them.

642
00:52:19,840 --> 00:52:21,840
I have never used one of the options.

643
00:52:21,840 --> 00:52:22,840
I don't understand.

644
00:52:22,840 --> 00:52:25,840
But I suppose your classes are just classes.

645
00:52:25,840 --> 00:52:28,840
So that's that's what already work.

646
00:52:28,840 --> 00:52:29,840
It doesn't need this.

647
00:52:30,840 --> 00:52:31,840
So you are.

648
00:52:32,840 --> 00:52:33,840
Generical variables.

649
00:52:33,840 --> 00:52:34,840
Like.

650
00:52:37,840 --> 00:52:38,840
I think so.

651
00:52:38,840 --> 00:52:40,840
Yeah, I guess I.

652
00:52:40,840 --> 00:52:41,840
The art of this morning.

653
00:52:41,840 --> 00:52:45,840
I haven't read that much of this out of the slides ready for presentation.

654
00:52:45,840 --> 00:52:48,840
But I think it should just be general generics.

655
00:52:48,840 --> 00:52:51,840
You can make a generic of her type of people probably.

656
00:52:51,840 --> 00:52:54,840
One thing I was concerned about is the variance.

657
00:52:54,840 --> 00:52:58,840
Should it be unlikely covariance because two goals are.

658
00:52:58,840 --> 00:53:00,840
What happens if he is contravariant?

659
00:53:01,840 --> 00:53:04,840
Yeah, I guess that's something for type.

660
00:53:04,840 --> 00:53:07,840
That's probably something that's the runtime doesn't need to care about.

661
00:53:07,840 --> 00:53:09,840
I guess the fields.

662
00:53:09,840 --> 00:53:11,840
Yeah, I mean, both areas.

663
00:53:11,840 --> 00:53:13,840
But you also have methods on the two.

664
00:53:13,840 --> 00:53:15,840
So then you might want a different experience.

665
00:53:15,840 --> 00:53:19,840
If you have a method arguments that's generic, you probably want it to be.

666
00:53:19,840 --> 00:53:20,840
Contravariance.

667
00:53:20,840 --> 00:53:21,840
Yeah.

668
00:53:24,840 --> 00:53:27,840
Well, also, I think that's going to happen for type.

669
00:53:27,840 --> 00:53:30,840
I know the type of people can't be there right now.

670
00:53:30,840 --> 00:53:33,840
Yeah, it actually is better to do the same thing for tactics.

671
00:53:35,840 --> 00:53:38,840
I think I should be sitting near you who will.

672
00:53:38,840 --> 00:53:40,840
I think I should be sitting near you who will.

673
00:53:40,840 --> 00:53:42,840
I think I should be sitting near you who will.

674
00:53:42,840 --> 00:53:45,840
I think I should be sitting near you who will.

675
00:53:45,840 --> 00:53:48,840
That's a quick thing.

676
00:53:48,840 --> 00:53:49,840
That's granted.

677
00:53:49,840 --> 00:53:50,840
It doesn't work.

678
00:53:50,840 --> 00:53:52,840
We have to ask support for that.

679
00:53:52,840 --> 00:53:55,840
And I think there's possibly work with respect to you.

680
00:53:55,840 --> 00:53:57,840
That's any day.

681
00:53:57,840 --> 00:54:00,840
This is one of the four things.

682
00:54:00,840 --> 00:54:04,840
So I'm looking at getting an eventually generic type.

683
00:54:04,840 --> 00:54:06,840
It's looking at that as a feature.

684
00:54:10,840 --> 00:54:15,840
So you can stand in inspection that this has a square record.

685
00:54:15,840 --> 00:54:16,840
Intercept.

686
00:54:16,840 --> 00:54:17,840
Right.

687
00:54:17,840 --> 00:54:20,840
I guess that's after tech checkers.

688
00:54:20,840 --> 00:54:24,840
Julie, you've incurred from the from the aspect of tech.

689
00:54:24,840 --> 00:54:29,840
So if you do and see one to the tech checker, we've heard that.

690
00:54:29,840 --> 00:54:32,840
I think it should just work like any generic class.

691
00:54:32,840 --> 00:54:37,840
I will say I tried to use this and was surprised that it didn't work.

692
00:54:37,840 --> 00:54:42,840
I just did something else because it wasn't essential, but it was surprising that you couldn't get it.

693
00:54:42,840 --> 00:54:43,840
Yeah, I feel the same way.

694
00:54:43,840 --> 00:54:46,840
Like it feels like it should work, but it doesn't.

695
00:54:46,840 --> 00:54:48,840
Yeah.

696
00:54:48,840 --> 00:54:52,840
Yeah, there's also like, my type also doesn't support generic normal people.

697
00:54:52,840 --> 00:54:56,840
Like not many people because generic people aren't supposed to wear my type.

698
00:54:56,840 --> 00:54:59,840
Yeah.

699
00:54:59,840 --> 00:55:04,840
There's just an artifact that's the way these types are represented in AIPy.

700
00:55:04,840 --> 00:55:09,840
The paths for generic and paths for tuple just don't have to work with each other.

701
00:55:09,840 --> 00:55:12,840
Are you saying that my type doesn't support generic tuples?

702
00:55:12,840 --> 00:55:13,840
Yep.

703
00:55:18,840 --> 00:55:20,840
Yeah, so much than any type.

704
00:55:20,840 --> 00:55:21,840
Yeah.

705
00:55:21,840 --> 00:55:25,840
Are there any more questions?

706
00:55:25,840 --> 00:55:26,840
Yeah.

707
00:55:26,840 --> 00:55:28,840
Question about the previous slide.

708
00:55:28,840 --> 00:55:32,840
For the final one, so like, sorry about runtime usage.

709
00:55:32,840 --> 00:55:39,840
Like if you mark class as final and you try to inherit from it and like run your code, does that result in a runtime error?

710
00:55:39,840 --> 00:55:40,840
No, it doesn't.

711
00:55:40,840 --> 00:55:42,840
It doesn't get checked by anything at runtime.

712
00:55:42,840 --> 00:55:47,840
It's just that this attribute is there so that if you want to check it, it's there.

713
00:55:47,840 --> 00:55:52,840
Is it feasible now to add runtime usage because of this final field?

714
00:55:52,840 --> 00:55:53,840
And you could do it.

715
00:55:53,840 --> 00:56:03,840
I think it's, maybe it should be a different decorator because final as of existing now already means,

716
00:56:03,840 --> 00:56:08,840
like it's established that it doesn't get necessarily checked at runtime.

717
00:56:08,840 --> 00:56:13,840
So there might be people depending on that and not there anyway.

718
00:56:13,840 --> 00:56:20,840
That's if you want to be good at the decorator in the somewhere that actually makes the class not so passable.

719
00:56:20,840 --> 00:56:24,840
You could have it as an argument, final, or here in course.

720
00:56:24,840 --> 00:56:25,840
Yeah.

721
00:56:25,840 --> 00:56:28,840
I guess if there's an interesting that then you could add that.

722
00:56:28,840 --> 00:56:32,840
I personally don't feel like a very strong need, but you could do it.

723
00:56:33,840 --> 00:56:36,840
Have you also considered individual methods?

724
00:56:36,840 --> 00:56:37,840
I mean, just a little bit from the beginning.

725
00:56:37,840 --> 00:56:39,840
Yeah, it's also done from methods.

726
00:56:39,840 --> 00:56:46,840
So it's not an exclusive class on the example, but basically the main final works that are done at runtime is it tries to set up attributes.

727
00:56:46,840 --> 00:56:51,840
It infills it, ignores the error, and it just recurs whatever it wants to do.

728
00:56:54,840 --> 00:56:57,840
I have a question about get overloads.

729
00:56:57,840 --> 00:57:05,840
If it sees a function that is a single dispatch function, would it be able to read that registry of overloads?

730
00:57:05,840 --> 00:57:08,840
Or does it only look at the ones that are?

731
00:57:08,840 --> 00:57:09,840
Overloads, yes.

732
00:57:11,840 --> 00:57:17,840
I think that this is a generalizing to single dispatch, but we decided it's two different.

733
00:57:17,840 --> 00:57:20,840
It's better to just keep it to just over that.

734
00:57:20,840 --> 00:57:22,840
I might implement something else.

735
00:57:28,840 --> 00:57:37,840
The last thing I want to provide with named tuples is that there's also the R-concretory that makes it possible to inherit anything and make it named tuple.

736
00:57:38,840 --> 00:57:49,840
Actually, if I could not do that, I feel like it would make it too harsh to region-guard named tuples in the text system if they can inherit from arbitrary non-named tuple classes,

737
00:57:49,840 --> 00:57:52,840
because named tuples are pretty different things.

738
00:57:52,840 --> 00:57:55,840
But I'd also be happy to hear more opinions about that.

739
00:57:58,840 --> 00:58:00,840
I have a question about get overloads.

740
00:58:00,840 --> 00:58:04,840
You said it's like a mapping of multiple function names to overloads.

741
00:58:04,840 --> 00:58:05,840
Yes.

742
00:58:05,840 --> 00:58:07,840
What happens if you have overloads?

743
00:58:07,840 --> 00:58:09,840
Not that I've ever used this.

744
00:58:09,840 --> 00:58:11,840
I'm just curious.

745
00:58:11,840 --> 00:58:13,840
You mean you define the overloads inside a function?

746
00:58:13,840 --> 00:58:14,840
Yes.

747
00:58:14,840 --> 00:58:16,840
Yes, they will get overwritten.

748
00:58:16,840 --> 00:58:22,840
So every time you do it, I guess it will create new overloads and put them in the same place.

749
00:58:22,840 --> 00:58:26,840
Actually, this was something we thought about a lot while implementing this.

750
00:58:26,840 --> 00:58:29,840
It was a concern that if you keep doing this, you just get unloaded memory.

751
00:58:29,840 --> 00:58:32,840
You used to do it every time you do it, you'd get more overloads.

752
00:58:32,840 --> 00:58:37,840
So the way it results, actually, is that the line number of the overloads part of the key.

753
00:58:37,840 --> 00:58:41,840
So if you define a new overload with the same line number, it gets overwritten.

754
00:58:43,840 --> 00:58:47,840
This can have slightly unexpected effects if you generate invested functions.

755
00:58:47,840 --> 00:58:50,840
But we didn't think there was a penalty on it.

756
00:58:50,840 --> 00:58:53,840
So I'm guessing that's your thing of like in a for loop.

757
00:58:53,840 --> 00:59:00,840
I was actually thinking of like, yeah, two functions that both define the same code inside of that with the same name.

758
00:59:00,840 --> 00:59:03,840
But if the line number is part of it, then I guess that solves that.

759
00:59:04,840 --> 00:59:05,840
Yeah.

760
00:59:05,840 --> 00:59:08,840
I guess I have to say, name it in the same module.

761
00:59:08,840 --> 00:59:12,840
I'm sure both of them can actually make the keys be nice and confident.

762
00:59:20,840 --> 00:59:21,840
I am ready.

763
00:59:21,840 --> 00:59:23,840
If there are more questions, I can answer them.

764
00:59:23,840 --> 00:59:25,840
If there's no more time, then we can move on to the next.

765
00:59:26,840 --> 00:59:27,840
Yeah.

766
00:59:27,840 --> 00:59:32,840
In regards to name-cubable thing, I feel like there's been many times where I wanted not necessarily a name-cubable,

767
00:59:32,840 --> 00:59:38,840
but just an immutable, no boilerplate, struct essentially.

768
00:59:38,840 --> 00:59:39,840
Data class-cruiser.

769
00:59:39,840 --> 00:59:40,840
Data class-cruiser.

770
00:59:40,840 --> 00:59:41,840
Yeah.

771
00:59:41,840 --> 00:59:45,840
But then you have, well, I mean, it's still data class.

772
00:59:45,840 --> 00:59:48,840
It's doing runtime stuff.

773
00:59:48,840 --> 00:59:49,840
Check that.

774
00:59:49,840 --> 00:59:50,840
I don't know.

775
00:59:50,840 --> 00:59:51,840
I always, I go for name-cubable.

776
00:59:51,840 --> 00:59:52,840
It's internal.

777
00:59:52,840 --> 00:59:54,840
I don't care that it's a name-cubable.

778
00:59:54,840 --> 00:59:55,840
Yeah.

779
00:59:55,840 --> 00:59:57,840
I guess that's kind of a style question.

780
00:59:57,840 --> 01:00:05,840
I think we don't want to add too many more things to name-cubable because data class is generally a better solution.

781
01:00:05,840 --> 01:00:10,840
It doesn't make you generally into a tuple and make you iterable, which is usually not what it was.

782
01:00:10,840 --> 01:00:11,840
Yeah.

783
01:00:11,840 --> 01:00:13,840
Depending on who you are, of course.

784
01:00:13,840 --> 01:00:17,840
Can you get back to the reveal time thing?

785
01:00:17,840 --> 01:00:18,840
Quick interruption.

786
01:00:18,840 --> 01:00:21,840
Just because we're running late, let's do a 10-minute break.

787
01:00:21,840 --> 01:00:28,840
So a 10-minute break, if you still have questions, we can say if you could, unless you're on your break.

788
01:00:28,840 --> 01:00:34,840
But yeah, I think we'll start the next talk at 1, sorry, 2.35.

789
01:00:34,840 --> 01:00:37,840
So yeah, just at FYI.

790
01:00:37,840 --> 01:00:40,840
I don't want to cut this off, but I also want to give people a chance to look at it.

791
01:00:46,840 --> 01:00:48,840
Hi, everyone.

792
01:00:48,840 --> 01:00:49,840
This is B.I.

793
01:00:49,840 --> 01:00:50,840
My name is Rebecca.

794
01:00:50,840 --> 01:00:54,840
I work at Google on the PyType Checker.

795
01:00:54,840 --> 01:00:58,840
Today I am not talking about PyType for once.

796
01:00:58,840 --> 01:01:05,840
I'm talking about a possible extension to PEP647, which is the user-defined type guard.

797
01:01:05,840 --> 01:01:11,840
These slides were made in collaboration with Eric Trout, who is the author of PEP647.

798
01:01:11,840 --> 01:01:18,840
He was not able to make it to PyCon, but he was a huge help in putting together this presentation.

799
01:01:18,840 --> 01:01:23,840
So I'm going to start with a brief refresher on PEP647.

800
01:01:23,840 --> 01:01:29,840
We wanted some criticisms of the PEP, then look at extension proposals to cover these criticisms,

801
01:01:29,840 --> 01:01:33,840
and then we should have some time for discussion at the end.

802
01:01:33,840 --> 01:01:36,840
So first off, what is a type guard?

803
01:01:36,840 --> 01:01:41,840
It's an expression used in a conditional to narrow the type of another expression.

804
01:01:41,840 --> 01:01:48,840
So if we look at this example, val is not none is a type guard that narrows the type of val.

805
01:01:48,840 --> 01:01:54,840
In the positive case, when the type guard returns true, val is narrowed to the non-none type option,

806
01:01:54,840 --> 01:01:58,840
and in the negative case, the type is narrowed to none.

807
01:01:58,840 --> 01:02:06,840
So what PEP647 does is that it allows users to define their own type guards.

808
01:02:06,840 --> 01:02:10,840
So this case is stir list, is a type guard.

809
01:02:10,840 --> 01:02:15,840
In the positive case, it narrows the type of its input to list of stirs,

810
01:02:15,840 --> 01:02:19,840
and in the negative case, it leaves the type unchanged.

811
01:02:19,840 --> 01:02:26,840
So for some background on this PEP, it was inspired by type guards in TypeScript.

812
01:02:26,840 --> 01:02:34,840
Eric talked with the TypeScript team a bit about what would they have done differently if they could go back in time,

813
01:02:34,840 --> 01:02:40,840
and based on those conversations, he made type guard in Python as flexible as possible.

814
01:02:40,840 --> 01:02:44,840
There are no restrictions on the type guard type.

815
01:02:44,840 --> 01:02:48,840
So that's why examples like the previous one worked.

816
01:02:48,840 --> 01:02:54,840
It narrowed list of objects to list of stirs, even though there's no subtyping relationship there.

817
01:02:54,840 --> 01:03:01,840
So this flexibility does lead to some trade-offs, which is what I want to talk about next.

818
01:03:02,840 --> 01:03:06,840
To motivate this, I start with an example.

819
01:03:06,840 --> 01:03:11,840
So NumPy is a popular numerical computing library.

820
01:03:11,840 --> 01:03:16,840
It has this function called isScaler, which, approximately speaking,

821
01:03:16,840 --> 01:03:20,840
what it does is it takes in a value that can be of any type,

822
01:03:20,840 --> 01:03:26,840
and it will return true if the type is string or supports float.

823
01:03:26,840 --> 01:03:33,840
So if you pass isScaler a value that is either supports float or a NumPy nd array,

824
01:03:33,840 --> 01:03:38,840
then with isScaler that was true, you know that it supports float.

825
01:03:38,840 --> 01:03:41,840
Otherwise, you know it's an nd array.

826
01:03:41,840 --> 01:03:46,840
So this is pretty obviously a type guard in the cool old rule sense,

827
01:03:46,840 --> 01:03:51,840
but if we annotate isScaler using PEP647 type guards,

828
01:03:51,840 --> 01:03:56,840
you'll see that a type checker would actually infer the wrong types.

829
01:03:56,840 --> 01:04:00,840
You remember we wanted supports float in the positive case,

830
01:04:00,840 --> 01:04:06,840
an nd array in the negative case, and we would get these both wrong.

831
01:04:06,840 --> 01:04:09,840
So why is that?

832
01:04:09,840 --> 01:04:17,840
So in the negative case, the problem is that type guard does not do any type narrowing,

833
01:04:17,840 --> 01:04:21,840
so we aren't able to get rid of that supports float.

834
01:04:21,840 --> 01:04:28,840
And in the positive case, the problem is that the type guard type is actually a union

835
01:04:28,840 --> 01:04:37,840
that contains this stir element that we should be able to tell is impossible based on the input type,

836
01:04:37,840 --> 01:04:44,840
but type guard does not do this elimination of impossible union elements.

837
01:04:44,840 --> 01:04:52,840
So quick question, why doesn't these type guards do these operations to refine the type?

838
01:04:52,840 --> 01:04:56,840
And the answer to that is that they're not always safe,

839
01:04:56,840 --> 01:05:02,840
because a type guard can do checks that aren't encoded in the type information.

840
01:05:02,840 --> 01:05:11,840
So if you have a type guard that checks whether something is a list of single character strings,

841
01:05:11,840 --> 01:05:17,840
then when the type guard evaluates to false, the input can still be a list of stir.

842
01:05:17,840 --> 01:05:20,840
You can't actually eliminate that type.

843
01:05:20,840 --> 01:05:29,840
And Python type guards especially, there's no guarantee about the relationship between the type guard type and the input type,

844
01:05:29,840 --> 01:05:36,840
so it's even more unsafe to try to do these sorts of operations.

845
01:05:36,840 --> 01:05:42,840
So even though these operations are unsafe, we saw that there's an obvious use case for them.

846
01:05:42,840 --> 01:05:49,840
So the next thing I'm going to talk about is a few proposals made to extend type guard to do these things.

847
01:05:49,840 --> 01:05:54,840
I'm going to cover the proposals basically in chronological order.

848
01:05:54,840 --> 01:06:00,840
First show a couple of the earlier ones that were determined to not really be sufficient,

849
01:06:00,840 --> 01:06:06,840
and hopefully that will show why the final proposal is what it is.

850
01:06:06,840 --> 01:06:14,840
The first and most obvious proposal was to add a to argument form of type guard.

851
01:06:14,840 --> 01:06:19,840
In this case, the first argument was specified in the positive case,

852
01:06:19,840 --> 01:06:24,840
and the second argument, the type generatum in the negative case.

853
01:06:24,840 --> 01:06:32,840
And one sort of nice thing about this proposal is that it would actually give a way to express type asserts,

854
01:06:32,840 --> 01:06:40,840
which are functions that raise an exception if the type isn't, sorry, if its input isn't of a specified type.

855
01:06:40,840 --> 01:06:47,840
We just put no return as the type in the negative case to show that it raises an exception.

856
01:06:47,840 --> 01:06:56,840
But as appealing as this proposal looks, it has a couple of disadvantages that were considered to be deal breakers.

857
01:06:56,840 --> 01:07:04,840
So the first one is that it doesn't address that issue of not eliminating impossible union elements in the positive case,

858
01:07:04,840 --> 01:07:10,840
and that's just because that was a requirement that came up somewhat later in the discussion.

859
01:07:10,840 --> 01:07:19,840
And another problem is that for this to be useful, you really want to be able to say sometimes that the type in the negative case

860
01:07:19,840 --> 01:07:27,840
is anything but the type in the positive case, and this proposal does not give a way to express that.

861
01:07:27,840 --> 01:07:36,840
There's a last sort of minor thing, which is that it would also be of an unusual definition for type guard,

862
01:07:36,840 --> 01:07:41,840
different from other generic types, although that's not as big of a deal.

863
01:07:41,840 --> 01:07:51,840
So that brings us to the second proposal, which is just to modify the semantics of the existing type guard type.

864
01:07:51,840 --> 01:08:00,840
So say if you pass in a union type to a type guard, and the type guard type is on the types in the union,

865
01:08:00,840 --> 01:08:04,840
then just go ahead and apply type narrowing in the negative case.

866
01:08:05,840 --> 01:08:10,840
This seems like a pretty straightforward change. Again, there are a few disadvantages.

867
01:08:10,840 --> 01:08:17,840
It doesn't address that issue of impossible union elements in the positive case,

868
01:08:17,840 --> 01:08:23,840
and also this would change existing behavior in an unsafe way.

869
01:08:23,840 --> 01:08:29,840
If you have user code that's already using type guard, you make this change and somebody doing the wrong thing.

870
01:08:29,840 --> 01:08:35,840
And the last concern is that you start adding all these rules for what type narrowing does and doesn't occur.

871
01:08:35,840 --> 01:08:38,840
It starts to get pretty complicated.

872
01:08:39,840 --> 01:08:46,840
So that brings us to the last proposal, which is to forget about modifying the existing type guard construct

873
01:08:46,840 --> 01:08:54,840
and instead add a new construct called strict type guard that does all these things that we wanted for its scalar.

874
01:08:54,840 --> 01:09:00,840
Apply type narrowing in the negative case, eliminate impossible union elements in the positive case.

875
01:09:00,840 --> 01:09:09,840
In order to make these operations a little safer, strict type guard would also enforce that the type guard type is a subtype of the input type.

876
01:09:11,840 --> 01:09:17,840
So this would be the complete solution. It's also pretty complex.

877
01:09:17,840 --> 01:09:26,840
And strict type guard is already prototyped in Plight Ride today. You can try it out if you want.

878
01:09:26,840 --> 01:09:35,840
But what Eric told me is that he hasn't gotten much feedback on strict type guard, good or bad.

879
01:09:35,840 --> 01:09:44,840
So the question at this point is sort of, is there much interest or appetite in this, like, in having to do forward with the path or no.

880
01:09:44,840 --> 01:09:50,840
And that's about all I have. So I'd love to hear your thoughts on this.

881
01:10:02,840 --> 01:10:07,840
Is there a thread specifically around strict type guard, either on type C or in another location?

882
01:10:08,840 --> 01:10:16,840
There are several. I did not think to link them in the slides.

883
01:10:16,840 --> 01:10:25,840
I did not know that there was a question that this would even be considered as a yes or no thing. So yeah, I'd like to sign the support.

884
01:10:25,840 --> 01:10:27,840
This is a comment.

885
01:10:27,840 --> 01:10:32,840
So the last one I think is going to be very hard.

886
01:10:36,840 --> 01:10:44,840
For the strict type guard scenario unions, would that make how the work depends on...

887
01:10:44,840 --> 01:10:53,840
Yeah, for the strict type guard, if the input type is a union, then we use special narrowing.

888
01:10:53,840 --> 01:11:00,840
Wouldn't that mean that the way you think work depends on whether the type checker happens to incur a union in your case?

889
01:11:00,840 --> 01:11:06,840
So if the type checker infers some different type than a union, it's going to be very different.

890
01:11:06,840 --> 01:11:11,840
So, talking about this case here?

891
01:11:11,840 --> 01:11:17,840
Yeah, so in this case it's obvious that the problem is a union because it's in a function rotation.

892
01:11:17,840 --> 01:11:21,840
But in the general case, it might be some local variable.

893
01:11:21,840 --> 01:11:28,840
And whether or not it's a purposeful union depends on basically how the type checker does its type inference.

894
01:11:28,840 --> 01:11:33,840
Yeah, I think that is...

895
01:11:33,840 --> 01:11:38,840
I mean, if you have a variable that's assigned to different line shapes, different types...

896
01:11:38,840 --> 01:11:49,840
Yeah, so like if it's defined as either a valid or something else, you might refer to your temporal literal types or the common type of both of them, depending on what type of type checker uses to the type that it is.

897
01:11:49,840 --> 01:11:59,840
So just to mention here, the type checker type includes a union, but the only way you know whether it includes a union is based on some specific decisions in the type checker on how it does inference.

898
01:11:59,840 --> 01:12:10,840
So I guess if I provide the type guard type here, I mean the type that's specified between the values of the type checker and the type that's specified between the values of the type checker.

899
01:12:10,840 --> 01:12:21,840
So I guess if I provide the type guard type here, I mean that the type that's specified between the brackets after the type guard.

900
01:12:21,840 --> 01:12:33,840
So whether that's a union should be pretty obvious, but it's definitely true that whether it can play as a union should depend on the type checker.

901
01:12:33,840 --> 01:12:43,840
So the union cases and eliminating some possibility, do you ever consider overloads? I know overloads would be perfect on these issues.

902
01:12:43,840 --> 01:12:56,840
Like having an overload in the type guard, in the type function. As far as I know, that is not something that has been considered.

903
01:12:56,840 --> 01:13:04,840
So I can grab that slide that is an A-Lar case and you have an overload on it. Oh, if a string is passed in, then it like, makes sense.

904
01:13:04,840 --> 01:13:08,840
If a string is passed in, then it like, makes sense.

905
01:13:08,840 --> 01:13:15,840
Okay, that was quite slow.

906
01:13:15,840 --> 01:13:20,840
Yeah, that's definitely a good idea. You have to think about that some more.

907
01:13:20,840 --> 01:13:30,840
When you're calling it, it's only an object. So you don't know the exact type. Overloads help when you already know the type.

908
01:13:30,840 --> 01:13:37,840
So if you go to the next slide, with this one, you can have two different implementations of this table.

909
01:13:37,840 --> 01:13:47,840
So it's conveniently supports load or any other type. So in case where you have just object to bring the overload on there.

910
01:13:47,840 --> 01:13:53,840
I think we should be overloading the scalar. If a string is passed in, is scalar a support?

911
01:13:53,840 --> 01:14:00,840
Well, yeah, you can't pick the right one. So you wind up hitting, catch all the children with this.

912
01:14:00,840 --> 01:14:07,840
Okay, that's what you're saying.

913
01:14:07,840 --> 01:14:20,840
I'm not really understanding the proposal, but was there any consideration of going with the two parameter type card approach, but also introducing an operator to handle the narrow zoom in that case?

914
01:14:20,840 --> 01:14:25,840
I actually like that.

915
01:14:25,840 --> 01:14:34,840
So basically go with your proposal one, but also introduce something like narratives to a like,

916
01:14:34,840 --> 01:14:47,840
or basically the proposal would be instead of having a new string type card, you should have a new string type operator that's like narrow zoom,

917
01:14:47,840 --> 01:14:56,840
that would let you selectively make type card perspective.

918
01:14:56,840 --> 01:15:03,840
I'm just not understanding. So this example of saying the narrow's tube would be like in that first part?

919
01:15:03,840 --> 01:15:14,840
Yeah, it would be type card that narrows to the third and then narrows to the last five.

920
01:15:14,840 --> 01:15:24,840
And you would push the responsible depending on the size of the narrows.

921
01:15:24,840 --> 01:15:45,840
I'm not sure if this is already mentioned as an alternative, but could you make the typing of val in this third, for example, a type card and basically like put it on the types of the valomys,

922
01:15:45,840 --> 01:16:01,840
so then later on you have a vector that takes in that type card and also the union of supports flow and string and kind of intersects so that now you get a narrowed union type that's returned from the ceiling.

923
01:16:01,840 --> 01:16:19,840
That way like when you have the positive phase, it would only have supports flow because you kind of intersected the type of union supports flow in the array with the union type of supports flow and string, which only gives you a union type of supports flow.

924
01:16:19,840 --> 01:16:30,840
So this question is you could use a type bar to capture the type that you don't want. Is that right?

925
01:16:30,840 --> 01:16:44,840
Yeah, so like this scalar in this case when you pass in val, it's a type bar and the tracker knows that it is a type supports flow and the array.

926
01:16:44,840 --> 01:16:59,840
And then the output, the type bar type, is an intersection of the union string supports flow and supports flow and the array with the input.

927
01:16:59,840 --> 01:17:04,840
So like it would be an intersection of all the things that are inside of type bar.

928
01:17:11,840 --> 01:17:14,840
Do you need an intersection operator for that?

929
01:17:14,840 --> 01:17:15,840
Yes.

930
01:17:15,840 --> 01:17:16,840
That's fine.

931
01:17:16,840 --> 01:17:20,840
Right, but I feel like that's a great and useful thing to do in a first place.

932
01:17:21,840 --> 01:17:29,840
There isn't an intersection operator. I guess this would be the potential use for it.

933
01:17:29,840 --> 01:17:44,840
I want to get back up a little bit. I tried this before.

934
01:17:44,840 --> 01:17:56,840
The main thing I have these cases for is not just one, but something very similar of the function that takes in a type variable and then it returns that same type variable.

935
01:17:56,840 --> 01:18:03,840
If you use a type bar, then right now with the non-strict type bar, it loses information that is stored in the type variable.

936
01:18:03,840 --> 01:18:06,840
If you use a type error, it tries to return afterwards.

937
01:18:06,840 --> 01:18:13,840
With the strict type bar, you keep the input type and the type variable in the path.

938
01:18:15,840 --> 01:18:22,840
Oh, saying right now with the type bar, if you take the input and the type bar type, that's like the same type variable and it loses that function.

939
01:18:22,840 --> 01:18:37,840
Yeah, so I'll give a function that's the EIM function that if type bar function X, return X, right now if you use the normal type bar, it will give you a type error of X is no longer related to the type variable.

940
01:18:37,840 --> 01:18:40,840
With strict type bar, it reserves it.

941
01:18:40,840 --> 01:18:50,840
I'm just saying like try out strict type bar and it gives you that behavior.

942
01:18:50,840 --> 01:18:52,840
That's it.

943
01:18:52,840 --> 01:18:57,840
Congratulations.

944
01:18:57,840 --> 01:18:59,840
Thank you.

945
01:18:59,840 --> 01:19:04,840
Applause

946
01:19:09,840 --> 01:19:12,840
I've actually got two talks here back to back.

947
01:19:12,840 --> 01:19:18,840
First one I have here is all about the future of typed dict.

948
01:19:18,840 --> 01:19:24,840
So just briefly in case anyone came in a little bit late, I'm David Foster.

949
01:19:24,840 --> 01:19:32,840
I did the initial implementation of typed dict and I'm generally shepherding related features to it at this point.

950
01:19:32,840 --> 01:19:44,840
And when I'm not in doing open source things, I am the CTO at TechSmartt and we are inspiring kids to code in the K through 12 space.

951
01:19:44,840 --> 01:19:56,840
So I thought it might be worth briefly reviewing the history of various features that are related to typed dict.

952
01:19:56,840 --> 01:20:09,840
It was originally introduced with just a functional syntax and then later on a class based syntax was added, which I think is the kind that most people are using at this point.

953
01:20:09,840 --> 01:20:22,840
At the same time, we got the ability to declare typed dicts with total equals false, which means that all the keys for it are not required.

954
01:20:22,840 --> 01:20:35,840
And just recently with new PEP 655, we have the ability to declare individual keys as either required or not required.

955
01:20:35,840 --> 01:20:38,840
So that's where we are right now.

956
01:20:38,840 --> 01:20:45,840
So there are a couple ideas for things to add to typed dict in the future.

957
01:20:45,840 --> 01:20:54,840
These have been proposed on a typing SIG mailing list and in some cases other places such as issue trackers and similar.

958
01:20:54,840 --> 01:21:04,840
I thought that it would be interesting to just give a review of what these types of extensions might look like.

959
01:21:04,840 --> 01:21:07,840
And yeah, so let's get started.

960
01:21:07,840 --> 01:21:21,840
So one thing that is a bit of a pain point with typed dicts is at least with MyPy you can't have a recursive definition of typed dicts.

961
01:21:21,840 --> 01:21:32,840
So common case is if I'm trying to, in this example, make a structure that's like a file system, I can't have a directory that contains other directories.

962
01:21:32,840 --> 01:21:40,840
But if we were to add support for recursive typed dicts, then this would be okay.

963
01:21:40,840 --> 01:21:46,840
At this point, currently, this does not work as far as I understand.

964
01:21:46,840 --> 01:21:48,840
So recursive typed dicts.

965
01:21:48,840 --> 01:21:54,840
You'd think it would work, but oh, I see a question.

966
01:21:54,840 --> 01:21:58,840
Typed JSON.

967
01:21:58,840 --> 01:22:06,840
Yes, it would make a typed JSON type more feasible than it is right now.

968
01:22:06,840 --> 01:22:14,840
There may be some other challenges with that, but it's probably a prerequisite for a better type on that.

969
01:22:16,840 --> 01:22:28,840
I do not know if other type checkers support it or not.

970
01:22:28,840 --> 01:22:32,840
I'm hearing from the audience that PyWrite does support recursive typed dicts already.

971
01:22:32,840 --> 01:22:37,840
So cool.

972
01:22:37,840 --> 01:22:39,840
More things that we could do.

973
01:22:39,840 --> 01:22:57,840
So another idea is, so right now, if you declare a typed dict with a particular set of keys, because the standardized form of typed dict in, I forget the pep number, the standardized form allows subclassing of typed dicts.

974
01:22:57,840 --> 01:23:06,840
It will actually allow you to add keys at runtime to a typed dict value that aren't in the original definition.

975
01:23:06,840 --> 01:23:10,840
So typed dicts are open by default.

976
01:23:10,840 --> 01:23:26,840
But there may be some cases where you have, you want a more strict usage of typed dicts such that, for example, in this example, we have a point 2D that declares only an X and Y key.

977
01:23:26,840 --> 01:23:35,840
But at the moment, if you were today to try to set an additional key Z on it at runtime, that would actually work.

978
01:23:35,840 --> 01:23:37,840
But you might not want it to work.

979
01:23:37,840 --> 01:23:42,840
So an idea is there might be some way to declare a typed dict as being closed.

980
01:23:42,840 --> 01:23:55,840
Here, just a provisional syntax idea is maybe use the final key word or the decorator on a typed dict definition, which would then mark it as being closed.

981
01:23:55,840 --> 01:24:02,840
So I thought this was an interesting idea.

982
01:24:02,840 --> 01:24:05,840
Next one I have up is something that's a little bit similar.

983
01:24:05,840 --> 01:24:08,840
Read-only typed dicts.

984
01:24:08,840 --> 01:24:11,840
So right now a typed dict is a dict.

985
01:24:11,840 --> 01:24:17,840
And because dicts are mutable, you can change them after construction.

986
01:24:17,840 --> 01:24:26,840
But sometimes it might be useful to have a read-only type of typed dict.

987
01:24:26,840 --> 01:24:34,840
So right now the read-only version of a regular dict is called a mapping.

988
01:24:34,840 --> 01:24:40,840
So I was like, well, maybe we would call it something like typed mapping if we wanted this type of support.

989
01:24:40,840 --> 01:24:43,840
So I think this is kind of interesting.

990
01:24:43,840 --> 01:24:48,840
And another sort of, see, I'd have to review my type theory.

991
01:24:48,840 --> 01:24:57,840
But because this is a immutable type, there may be something that can be invariant here that wouldn't be possible in other cases.

992
01:24:57,840 --> 01:25:02,840
So there might be some interesting uses for that.

993
01:25:02,840 --> 01:25:06,840
So that's read-only typed dicts.

994
01:25:06,840 --> 01:25:16,840
And the fourth idea, which was actually mentioned earlier during the summit, was adding support for generics in typed dicts.

995
01:25:16,840 --> 01:25:24,840
So this is, for example, a point 2D where you could instantiate it with an int parameter.

996
01:25:24,840 --> 01:25:27,840
So it's an x, y integer coordinates.

997
01:25:27,840 --> 01:25:30,840
Or you could instantiate it with float.

998
01:25:30,840 --> 01:25:33,840
So it's an x, y of float float.

999
01:25:33,840 --> 01:25:37,840
And so, again, I guess this is actually provisional syntax as well.

1000
01:25:37,840 --> 01:25:42,840
But it seems like this would be sort of the obvious syntax.

1001
01:25:42,840 --> 01:25:52,840
And in some cases, you may even want to have, say, like a type alias that is using these integer or these generic parameters.

1002
01:25:52,840 --> 01:25:56,840
And then you could instantiate the alias, which would be kind of interesting.

1003
01:25:56,840 --> 01:26:02,840
That's not something that would be a straightforward thing to support, at least in MyPy.

1004
01:26:02,840 --> 01:26:04,840
So I'd have to.

1005
01:26:04,840 --> 01:26:09,840
So that would definitely require some thought on the specific syntax and then implementation difficulty and similar.

1006
01:26:10,840 --> 01:26:15,840
But this does seem like something that may be desired.

1007
01:26:15,840 --> 01:26:18,840
And it was even mentioned, as I said earlier.

1008
01:26:18,840 --> 01:26:24,840
So, yeah, that is just a couple ideas.

1009
01:26:24,840 --> 01:26:29,840
So I think a number of people in this room are probably already subscribed to Typing SIG.

1010
01:26:29,840 --> 01:26:31,840
And these are just ideas.

1011
01:26:31,840 --> 01:26:35,840
Like, I'm not saying that I'm personally going to implement all of them myself.

1012
01:26:35,840 --> 01:26:37,840
But I'll definitely provide some support.

1013
01:26:37,840 --> 01:26:49,840
But anyone who's here and who's interested or who's watching at some later point, yeah, love some help on making Type Dict better.

1014
01:26:49,840 --> 01:26:54,840
Put some designs together, put some peps together, write some code.

1015
01:26:54,840 --> 01:26:56,840
You'll be great.

1016
01:26:56,840 --> 01:27:02,840
So, yeah, I think I've got a couple minutes for questions.

1017
01:27:02,840 --> 01:27:07,840
All right.

1018
01:27:07,840 --> 01:27:08,840
Oh.

1019
01:27:08,840 --> 01:27:14,840
Some types, let me think.

1020
01:27:14,840 --> 01:27:17,840
I think so.

1021
01:27:17,840 --> 01:27:21,840
The question was, are type dicts the canonical way to do some types in Python?

1022
01:27:21,840 --> 01:27:26,840
And I think that would be a union type is what you're looking for.

1023
01:27:27,840 --> 01:27:31,840
Or union is one idea.

1024
01:27:31,840 --> 01:27:36,840
But sometimes I want to have a subtype that includes multiple things.

1025
01:27:36,840 --> 01:27:38,840
Subtype includes multiple things.

1026
01:27:38,840 --> 01:27:42,840
Product types.

1027
01:27:42,840 --> 01:27:47,840
So let's see.

1028
01:27:48,840 --> 01:27:49,840
So let's see.

1029
01:27:49,840 --> 01:27:57,840
So a product type could be done with a typed name tuple, which is the capital form of named tuple.

1030
01:27:57,840 --> 01:28:01,840
So that might be what you're looking for there.

1031
01:28:01,840 --> 01:28:02,840
That's immutable, right?

1032
01:28:02,840 --> 01:28:03,840
Correct.

1033
01:28:03,840 --> 01:28:05,840
It is immutable in that situation.

1034
01:28:05,840 --> 01:28:07,840
You could also use a given class.

1035
01:28:07,840 --> 01:28:12,840
I think it's immutable.

1036
01:28:12,840 --> 01:28:13,840
Let's see.

1037
01:28:13,840 --> 01:28:15,840
I think I've got another minute for questions.

1038
01:28:15,840 --> 01:28:16,840
One in the front.

1039
01:28:16,840 --> 01:28:21,840
Excuse me if this is a dumb question, but is there a way to declare the type of everything else you have?

1040
01:28:21,840 --> 01:28:26,840
So like you said that z in your example, everything else, is that possible?

1041
01:28:26,840 --> 01:28:28,840
And if not, is it a consideration?

1042
01:28:28,840 --> 01:28:38,840
So I believe the question was, if you have just a regular type dict, can you add z onto the end of it just in today's syntax?

1043
01:28:38,840 --> 01:28:40,840
Can you restrict the type of z?

1044
01:28:40,840 --> 01:28:43,840
Can you say, elate like tuple, you can type dot dot dot?

1045
01:28:43,840 --> 01:28:44,840
Yes, you can do this.

1046
01:28:44,840 --> 01:28:55,840
So if you know in advance that there could be a z key added, and you knew that, for example, that it needed to be of typed int, you could use the not required key to declare.

1047
01:28:55,840 --> 01:28:57,840
What do you mean by using z?

1048
01:28:57,840 --> 01:29:07,840
So you're saying, okay, so is there a way to declare that for any unknown key added to a typed dict, that it must be of a particular fixed type?

1049
01:29:07,840 --> 01:29:12,840
There is no current way to do that that I know of.

1050
01:29:12,840 --> 01:29:20,840
And I don't believe, I believe there was something proposed on a typing stick thread that was like along the lines of this.

1051
01:29:20,840 --> 01:29:23,840
There was a thread about this.

1052
01:29:23,840 --> 01:29:32,840
It's possible to do if we have, you'd have to make it final to avoid a collision with subclassing rules.

1053
01:29:32,840 --> 01:29:41,840
We would need a pet for it, and we need to figure out what's the best way to specify the type, which could interact with the rules for scoping on generics.

1054
01:29:41,840 --> 01:29:46,840
But it should be possible if we have a use case that needs it.

1055
01:29:46,840 --> 01:29:54,840
Okay. Sounds like this capability could be added, but it might also be a little bit tricky, so probably a pet person would be required.

1056
01:29:54,840 --> 01:30:04,840
If you're on control of the data, the thing that works really well today is just nesting all the unknown stuff, and it takes their...

1057
01:30:04,840 --> 01:30:06,840
Cool.

1058
01:30:06,840 --> 01:30:12,840
Well, that's all I've got for this little, little talk right here.

1059
01:30:12,840 --> 01:30:17,840
So thanks for listening for that first bit.

1060
01:30:17,840 --> 01:30:23,840
Applause.

1061
01:30:23,840 --> 01:30:32,840
So now I've got a different thing to talk about.

1062
01:30:32,840 --> 01:30:45,840
So I wanted to give an overview of a number of tools that are in the Python typing ecosystem right now, which manipulate type annotation objects at runtime.

1063
01:30:45,840 --> 01:30:57,840
There's a lot of interesting things that's being done here, so I just did a survey of all the ones that all of the libraries that are doing this type of thing that I could get my hands on.

1064
01:30:57,840 --> 01:31:09,840
So it's probably worth saying as some background that type annotations were originally designed only for use by type checkers to use statically.

1065
01:31:09,840 --> 01:31:32,840
And while the syntax for declaring type annotations has been a subset of the expression syntax in Python, and therefore you can actually get a hold of these objects at runtime, I think that originally perhaps runtime usages were not necessarily focused on.

1066
01:31:32,840 --> 01:31:47,840
But because you can actually get expressions with types, there are many libraries that have found alternate uses for actually using these type annotation variables.

1067
01:31:47,840 --> 01:31:59,840
So the things I want to go through are several different libraries, several different tools that are using type annotations at runtime, sort of categorized by the type of usage.

1068
01:31:59,840 --> 01:32:21,840
And I thought it would also be worth highlighting four of those tools that are using type annotations at runtime, showing where they run into problems or challenges that are especially unique to the runtime usage of annotations that don't come up in the static case.

1069
01:32:21,840 --> 01:32:44,840
So here are more or less four patterns that all the libraries I've looked at are using. One is just straight up doing type checking at runtime, like adding a decorator to a function to verify that its inputs and outputs are what they are expected.

1070
01:32:44,840 --> 01:33:02,840
There are beefed up versions of built-in type introspection functions that exist, which can look at not just runtime class-based types, but can look at things like unions, can look at things like typed DICs.

1071
01:33:02,840 --> 01:33:12,840
So sort of written it as like the enhanced version of is instance or is subclass or the type functions.

1072
01:33:12,840 --> 01:33:21,840
Another thing that comes up a lot is related to the stringification or unstringification of type objects.

1073
01:33:21,840 --> 01:33:30,840
In the case of the PEP5 something something where type annotations would become strings by default.

1074
01:33:30,840 --> 01:33:46,840
This becomes PEP563. This becomes something that would have to be dealt with on a more regular basis. You would have types as strings everywhere, not just as a forward reference exception or similar.

1075
01:33:46,840 --> 01:33:56,840
So there are libraries where usually as part of their utility functions they are either stringifying or unstringifying types.

1076
01:33:56,840 --> 01:34:05,840
And the last area that I want to go over is using types when they're parsing and formatting typed structures.

1077
01:34:05,840 --> 01:34:15,840
So let's get into runtime type checking. So there's a couple libraries. I'm going to go over Typecard, PyTypes, and BearType.

1078
01:34:15,840 --> 01:34:23,840
Typecard is specifically advertised for doing runtime type checking for functions.

1079
01:34:23,840 --> 01:34:32,840
PyTypes provides a generic type checking toolbox and one of its tools happens to be runtime type checking.

1080
01:34:32,840 --> 01:34:39,840
And BearType is interesting. It also does runtime type checking.

1081
01:34:39,840 --> 01:34:51,840
So all three of these libraries give some kind of type checked decorator that you can put on a function.

1082
01:34:51,840 --> 01:35:05,840
And then when you at runtime call the function the decorator inserts some code to check the parameter types coming in and the return value that is going out.

1083
01:35:05,840 --> 01:35:25,840
So all three functions do this. The Typecard library in particular has something pretty fun where you can install an import hook where it will just add this decorator to everything within a particular module at runtime as it is imported.

1084
01:35:25,840 --> 01:35:37,840
So that allows you to just put these checks everywhere in a particular module very, very quickly without a lot of invasive code modifications.

1085
01:35:37,840 --> 01:35:41,840
So I think that's interesting. That's unique to Typecard at this time.

1086
01:35:41,840 --> 01:36:01,840
I'll also mention that the last library I mentioned, BearType, also allows you to add new types that are custom that you can have logic written in Python to see whether something is of a particular type.

1087
01:36:01,840 --> 01:36:07,840
This is similar to the type guarded functions as well, but it's just expressed in a different manner.

1088
01:36:07,840 --> 01:36:17,840
So this is kind of interesting. So this is an example of a type that a NumPy array is float.

1089
01:36:17,840 --> 01:36:33,840
It's worth mentioning that one big difference between these two, between these three libraries is that in general we have libraries that are just exhaustively checking the type.

1090
01:36:33,840 --> 01:36:46,840
So if you have something that's annotated as like list of str, it will actually look at the list and then go through every element in the list no matter how long it is and check that all of the items are str.

1091
01:36:46,840 --> 01:37:01,840
So that is a very correct way to check it, but it's also kind of slow. BearType is interesting in that it advertises that everywhere its type checking operations are amortized constant time.

1092
01:37:01,840 --> 01:37:09,840
Now the way that they do that is that, for example, in the case of list str, it uses a probabilistic algorithm.

1093
01:37:09,840 --> 01:37:15,840
It just picks a random element of the list and checks that random element rather than checking all of them.

1094
01:37:15,840 --> 01:37:34,840
So that's something to take into consideration depending on where you would be using these types of decorators, whether it's a best effort type of checking or whether you are depending on it, for example, for a security property.

1095
01:37:34,840 --> 01:37:44,840
Like you probably wouldn't want to use best effort checking on a parsing function that's getting something from untrusted network input or similar.

1096
01:37:44,840 --> 01:37:51,840
So that is runtime type checking uses.

1097
01:37:51,840 --> 01:38:16,840
I had mentioned that several of these libraries provide either directly or as part of their infrastructure type introspection functions that are enhanced versions of similar functions in the standard library, except that they are aware of a large subset, if not all, of the PEP 484 typing hints annotations.

1098
01:38:16,840 --> 01:38:28,840
The libraries that apply here, some familiar faces, we have PyTypes, which is that type checking toolbox, so it's sort of specializing in lower level things.

1099
01:38:28,840 --> 01:38:31,840
RunType, which is a newer entrant.

1100
01:38:31,840 --> 01:38:36,840
TriCast, which is dealing with is instance specifically.

1101
01:38:36,840 --> 01:38:40,840
TypeGuard and baretype again.

1102
01:38:41,840 --> 01:39:02,840
The top three libraries listed here specialize in one or more type introspection functions, whereas the bottom two libraries specialize in other things, but they export their internal type introspection functions of this kind.

1103
01:39:02,840 --> 01:39:06,840
So for example, is instance.

1104
01:39:06,840 --> 01:39:11,840
All five of these libraries have some variant of is instance.

1105
01:39:11,840 --> 01:39:22,840
For example, TriCast, which specializes in is assignable, which is a version of is instance and a cast function.

1106
01:39:22,840 --> 01:39:24,840
Yeah, so that specializes in it.

1107
01:39:24,840 --> 01:39:38,840
And let's see, TypeGuard has a check type, but you have to, but it uses, it generates an error message with if it fails, so you have to give it some thing to put in that error message.

1108
01:39:38,840 --> 01:39:42,840
Everything else uses pretty much the same signature.

1109
01:39:42,840 --> 01:39:50,840
They do vary in whether they support, say, capitalist versus lowercase list for generic lists.

1110
01:39:50,840 --> 01:39:54,840
They do vary and they support typed DICs versus not.

1111
01:39:54,840 --> 01:39:57,840
They do vary in whether they support other types of things.

1112
01:39:57,840 --> 01:40:03,840
So these libraries are not all created equal in terms of like all of the things that they support.

1113
01:40:03,840 --> 01:40:12,840
And as mentioned, bare type is a probabilistic check as well, so you have to be a little careful with that under certain circumstances.

1114
01:40:12,840 --> 01:40:14,840
So that's is instance.

1115
01:40:14,840 --> 01:40:17,840
Is subclass is a type.

1116
01:40:17,840 --> 01:40:24,840
Given a potential subtype and a potential supertype, is this relationship actually true?

1117
01:40:24,840 --> 01:40:29,840
So we've got two libraries that expose a version of this.

1118
01:40:29,840 --> 01:40:34,840
RunType and PyTypes expose this.

1119
01:40:34,840 --> 01:40:38,840
Sometimes with some caveats.

1120
01:40:38,840 --> 01:40:41,840
And the last one is type.

1121
01:40:41,840 --> 01:40:51,840
So the type function, normally you give it a value and then it will give you what is the type annotation object that describes it.

1122
01:40:51,840 --> 01:40:59,840
And PyTypes has a version that does its best to guess, especially for collection types.

1123
01:40:59,840 --> 01:41:08,840
If you give it a list of all string objects, it will try to infer a list of str or a list of all integer objects.

1124
01:41:08,840 --> 01:41:11,840
It will try to infer a list of int.

1125
01:41:11,840 --> 01:41:14,840
This is, naturally speaking, a little bit hard to do.

1126
01:41:14,840 --> 01:41:29,840
Like if you gave it a list of integers that are all of value 1, technically you could, one type that could be used to write that would be list of literal of 1, which would be pretty strange.

1127
01:41:29,840 --> 01:41:35,840
But I guess my point is that this is always going to be a bit of a lossy operation.

1128
01:41:35,840 --> 01:41:43,840
A best effort guess because type information is not preserved at runtime for a particular type.

1129
01:41:43,840 --> 01:41:48,840
A value that is encountered at runtime.

1130
01:41:48,840 --> 01:41:52,840
So this is always a best effort case.

1131
01:41:52,840 --> 01:41:57,840
So those are all like type utility functions.

1132
01:41:57,840 --> 01:42:08,840
Now I have libraries that are dealing with the problem of stringifying and unstringifying type annotation objects.

1133
01:42:08,840 --> 01:42:23,840
So in this case, what I think about it is you have type annotation objects that you are either formatting as a string or parsing from a string to be a type annotation object again.

1134
01:42:23,840 --> 01:42:30,840
So in the case of formatting, the only library I could find that attempts to do this is actually PyTypes.

1135
01:42:30,840 --> 01:42:37,840
Again, that sort of collection of generic type operators that's just the toolbox.

1136
01:42:37,840 --> 01:42:42,840
So it will do that for you.

1137
01:42:42,840 --> 01:42:46,840
Parsing is a little bit more interesting.

1138
01:42:46,840 --> 01:42:51,840
I believe the only library that does this is TriCast.

1139
01:42:51,840 --> 01:43:00,840
TriCast when you pass it in its function that accepts both type objects, it will also accept a top level string type.

1140
01:43:00,840 --> 01:43:09,840
So if you give it a top level string reference to a type, then it needs to be able to resolve that to an actual type annotation object.

1141
01:43:09,840 --> 01:43:14,840
So it has a library that it exports for that purpose.

1142
01:43:14,840 --> 01:43:23,840
So get type hints works if you already have...

1143
01:43:23,840 --> 01:43:27,840
get type hints will deal with string types in the middle.

1144
01:43:27,840 --> 01:43:33,840
So if you have a list of string int, it can deal with that.

1145
01:43:33,840 --> 01:43:48,840
But if you have a top level thing that is just a string, it can't deal with that without additional information about an assumed set of locals or an assumed set of globals.

1146
01:43:48,840 --> 01:44:01,840
This... it can't get all strings to figure it out, but it will automatically resolve things that are in built-ins like lowercase list.

1147
01:44:01,840 --> 01:44:06,840
I think it only will do things that are available in built-ins.

1148
01:44:06,840 --> 01:44:16,840
So if you want to use capitalist, you have to say typing.capitalist, and it will look for a module name and import that.

1149
01:44:16,840 --> 01:44:20,840
And then it may not be able to figure out in some cases still.

1150
01:44:20,840 --> 01:44:22,840
So best effort here.

1151
01:44:22,840 --> 01:44:31,840
So it's saying the difference is exactly when the string is trying to talk the app to the string in case the form is not located at the end of the string.

1152
01:44:31,840 --> 01:44:39,840
Correct. So it parses the string to find the module first and then get that out of the module.

1153
01:44:39,840 --> 01:44:50,840
And then once it's actually gotten it out of the module, it actually does delegate internally to get typing hints to resolve it the rest of the way insofar as possible.

1154
01:44:51,840 --> 01:44:58,840
Yeah, so I guess that's it for stringifying and unstringifying types. There are just a couple things that do that.

1155
01:44:58,840 --> 01:45:08,840
And the last topic I have here is related to dealing with parsing and formatting typed structures of some kind.

1156
01:45:08,840 --> 01:45:18,840
So an example here is you get some data off the wire. You're a web app. You get a dictionary off the wire which is describing a movie.

1157
01:45:18,840 --> 01:45:24,840
Matrix is one of my favorites. So you get a string off the wire.

1158
01:45:24,840 --> 01:45:32,840
Typically, so this is a JSON string. So you use JSON loads to get you an actual dictionary object with the stuff inside of it.

1159
01:45:32,840 --> 01:45:40,840
And so then the question is, what next? So then you just have a plain dictionary object.

1160
01:45:40,840 --> 01:45:42,840
There are a couple things that you could do.

1161
01:45:42,840 --> 01:46:00,840
You could use a typed dict. So then you still have the same dict object, but then the type checker will tell you whenever you're using it improperly.

1162
01:46:00,840 --> 01:46:07,840
Or you could use a specialized model class of some type, such as, for example, data classes.

1163
01:46:07,840 --> 01:46:27,840
Or you could use a Pydantic model. And so the general goal is that you're taking something that is just a plain dictionary and then putting it into some kind of type structure that is either enforced at statically or enforced at runtime.

1164
01:46:27,840 --> 01:46:39,840
And it's worth noting that all of these typed classes, let's see, I've got, it's like I have three minutes left here.

1165
01:46:39,840 --> 01:46:54,840
So yeah, so all of these, all of these model like classes use type annotations to declare what the expected types of the fields are.

1166
01:46:54,840 --> 01:47:15,840
So because the types of fields are available at runtime, you can have libraries like Pydantic that will read those field annotations and use it to do enforcement of those types at runtime.

1167
01:47:15,840 --> 01:47:30,840
Let's see. So I mentioned that in general there's, so there is a pattern where there is some kind of parse function and some kind of model class. If you have Pydantic, you have Pydantic models.

1168
01:47:30,840 --> 01:47:43,840
If you're using data classes, data classes the model, then there's a separate package called data classes JSON, which will actually enforce that information at runtime.

1169
01:47:43,840 --> 01:47:55,840
There's the older adders package, which is similar to data classes that declares a model type. And then there is a separate package called c adders, which actually enforces it at runtime.

1170
01:47:55,840 --> 01:48:08,840
And then if last but not least, we have typed dict, which already exists. And if you're using typed dict, that's interesting because that's actually the type of the dictionary itself.

1171
01:48:08,840 --> 01:48:15,840
So you can just use an is instance effectively. You can use an is instance function to see whether it parses correctly or not.

1172
01:48:15,840 --> 01:48:27,840
So since I'm running low on time, I will just show that this is how you do it in Pydantic. You declare a base model.

1173
01:48:27,840 --> 01:48:36,840
And if you pass in something that doesn't conform to the declared annotations, it will fail at runtime.

1174
01:48:36,840 --> 01:48:57,840
If you're using the strategy of using typed dict, you can use either in this particular instance, it's easier to use a smart cast function, which actually checks to see whether something is assignable to the movie type in this case at runtime and then returns it if it is.

1175
01:48:57,840 --> 01:48:59,840
Turns not if it's not.

1176
01:48:59,840 --> 01:49:09,840
So this is one way to do it. Or you can just use an is instance function. And there's many different modules providing an is instance function.

1177
01:49:09,840 --> 01:49:18,840
This is the one that's from TriCast. But as mentioned earlier in the presentation, there are several others as well.

1178
01:49:18,840 --> 01:49:28,840
So I'm pretty much out of time. So I will just briefly put this slide up as some challenges that are there.

1179
01:49:28,840 --> 01:49:38,840
Libraries don't support all of the typing stuff that's done everywhere. Sometimes there are speed issues with checking things like list of stir.

1180
01:49:38,840 --> 01:49:46,840
Some types of annotations are erased entirely at runtime, such as new type and typed dict. So that's tricky.

1181
01:49:46,840 --> 01:49:58,840
If you're dealing with pidantic, it will treat things that are actually strings, like it will treat the string of one as an int, so it's looser than you might expect.

1182
01:49:58,840 --> 01:50:11,840
There's also the interesting case that is instance at runtime and the equivalent is instance from pep-it-484 disagree on a couple things, especially like booleans and ints, which is kind of interesting.

1183
01:50:11,840 --> 01:50:21,840
And then there's ever the problem of string being also a sequence of itself, which is kind of bizarre. So that's all I've got.

1184
01:50:21,840 --> 01:50:34,840
Thanks for listening, folks.

1185
01:50:34,840 --> 01:50:41,840
Yeah, so apparently this was a topic that a lot of you wanted to hear about. So Shannon asked if I would talk about it, and I foolishly agreed to do so.

1186
01:50:41,840 --> 01:50:49,840
So that's why I'm standing here now. I'm going to start with a brief history of how we got to where we are.

1187
01:50:49,840 --> 01:50:56,840
The OG typing pep was at 44, actually 43, but 44 was the one that specified how it all works.

1188
01:50:56,840 --> 01:51:03,840
And it said that at runtime annotations are eagerly evaluated. So we have this propagate function.

1189
01:51:03,840 --> 01:51:14,840
The names sum of and none are evaluated as the module is executed as this function is being constructed immediately to whatever they refer to.

1190
01:51:14,840 --> 01:51:26,840
And that works great in simple cases. But if we have, say, circular references like this case, we will get to this child annotation and not yet have a child class.

1191
01:51:26,840 --> 01:51:37,840
So that name will refer to nothing and we'll get a name error, which is unpleasant. So pep-44 recommends that we should put that in quotes to avoid that problem.

1192
01:51:37,840 --> 01:51:47,840
A similar case is the self-referential case because the body of the class is executed when the class name has not yet been bound in the namespace.

1193
01:51:47,840 --> 01:51:53,840
We also have to manually quote that type of annotation.

1194
01:51:53,840 --> 01:52:09,840
Another case is if you have circular references between modules that only involve annotations, sometimes you'll hide some of those imports using type checking to avoid a runtime import cycle.

1195
01:52:09,840 --> 01:52:15,840
And again, that name is not going to exist in the namespace at runtime, so we have to quote that annotation.

1196
01:52:15,840 --> 01:52:25,840
So this all works. All the type checkers support resolving these. And at runtime, you can use typing.getTypeNits to introspect some function or class and get its annotations.

1197
01:52:25,840 --> 01:52:39,840
And getTypeNits will look up the stringified names in the namespace, the global namespace of the module and resolve the real objects when you ask for them and give you back the dictionary of the annotations resolved to real objects.

1198
01:52:39,840 --> 01:52:47,840
But as people began using type annotations more broadly, this was just unpleasant.

1199
01:52:47,840 --> 01:52:59,840
It also explained to people why in writing you have to put quotes around annotations. It looks strange. It makes it look like types are kind of a hold-on feature of a language.

1200
01:52:59,840 --> 01:53:19,840
So people wanted to avoid this. And there was another problem, which is that eager evaluation meant that in a large code base, you could spend a significant amount of CPU time and memory compiling and evaluating all of these annotations, even if you may never use them at runtime because it looked like it really interested in the static type checking.

1201
01:53:19,840 --> 01:53:35,840
So given all of those issues, a smart fellow named Uka Shuana came along and said, we have the support for annotations to be strings, so why don't we just make them all these strings all the time and resolve some of these problems?

1202
01:53:35,840 --> 01:53:51,840
So under PEP563, you can say from, to, triple annotations. And now, even though we don't manually quote anything, these annotations become strings and we just get strings back. They're never evaluated.

1203
01:53:51,840 --> 01:54:10,840
Unless we again call typing.getTypeHints, which as we already saw, is able to resolve those to the real objects once the namespace is complete. This approach solves the circular reference problem. We don't call getTypeHints until the model is done executing. All the names will exist and everything is happy.

1204
01:54:10,840 --> 01:54:26,840
It solves the performance problem because strings are very cheap. So we can load those strings up really quickly. It doesn't have an extensive runtime cost. Another nice benefit that it has is that once value that annotations provide is documentation.

1205
01:54:26,840 --> 01:54:48,840
People want to know what does this function take, what does it return. The ideal documentation uses the annotations as they are typed in the source code. An example of runtime documentation is the built-in help function. If you say help some function, it will tell you about the signature of that function.

1206
01:54:48,840 --> 01:55:12,840
Ideally, if you have a type alias referring to some massive union, you would prefer the help function to tell you that the parameter takes this nice semantic type alias name, not some massive unreadable union. It happens that annotations as strings serves this use case very well because all of the strings, exactly as they were typed in the source code, represent your runtime.

1207
01:55:12,840 --> 01:55:34,840
Can I ask a quick question on that? Yes. Presumably the annotations still have to be valid syntax, right? Yes, that is a very good point. So with pet.py63, the annotation must be valid syntax, it must parse. It does not have to compile, which is an important distinction that we'll review later. So you can say it's a type or module you haven't imported.

1208
01:55:35,840 --> 01:55:50,840
You can say it's anything that's valid syntax and the runtime won't care unless you call it get type and then all of a sudden it will care and you can't find it. Static checkers also care. It's true, static checkers care doesn't exist at all.

1209
01:55:50,840 --> 01:56:09,840
Okay, so at first it seemed that pet.py63 solved all the problems and made everyone very happy, but as it turned out later, we know now that not everyone knows that. Because people, as we just saw in the last talk, people do use type annotations for things that are not static type checking, it turns out.

1210
01:56:09,840 --> 01:56:23,840
We saw many libraries in David's talk, I just have a few of them mentioned here, typecar and pygantic. And people even do things like writing code in nested scopes in Python, it turns out. And sometimes they reference names from nested scopes in annotations.

1211
01:56:23,840 --> 01:56:36,840
And get type-nets is not that smart when it is resolving a string. All it knows how to do is look things up in the global namespace of the module. In this particular case, it will try to look up these two names, they aren't in the global namespace and it will fail.

1212
01:56:36,840 --> 01:56:55,840
So that makes pygantic users unhappy. So last year when pet.py63 was scheduled to become the default behavior in Python 3.10, users of pygantic and other libraries said, oh no, you're going to break our code.

1213
01:56:55,840 --> 01:57:12,840
And around that same time, another smart person named Larry J. Steens came up with an idea called pet.py649. Larry said, it turns out that in Python, when we have some code and we want to delay its evaluation, we have this neat trick for doing that, it's called a function.

1214
01:57:12,840 --> 01:57:29,840
And functions already know how to look up names in various nested scopes and keep track of those as a closure or as a global associated with the function and all that already works in Python. We don't typically preserve code for later use as a string.

1215
01:57:29,840 --> 01:57:33,840
So Larry said, why don't we do the same thing with annotations?

1216
01:57:33,840 --> 01:57:54,840
So under pet.py649, every annotated function or class has a DUNDERCOAnnotations attribute, which is a Hillary function. And when you call it, then you will get a result dictionary of all your annotations with the values as the fully resolved objects.

1217
01:57:54,840 --> 01:58:04,840
Or if you just access the DUNDERCOAnnotations attribute, it will behind the scenes call COAnnotations for you and cache the result and give you that same dictionary.

1218
01:58:04,840 --> 01:58:13,840
So now this example works because the annotations are stored in the function, the function is a closure, it goes about the nested scope, with the names in it, everything just works.

1219
01:58:13,840 --> 01:58:14,840
So I can ask another question?

1220
01:58:14,840 --> 01:58:15,840
Yes, of course.

1221
01:58:15,840 --> 01:58:25,840
Before pet.py649, so we wrote pet.py563, what was preventing you from just using getTypen to look up the actual frames?

1222
01:58:25,840 --> 01:58:28,840
In an example like this nested one?

1223
01:58:28,840 --> 01:58:31,840
Or just in general, I guess the nested one is still a problem.

1224
01:58:31,840 --> 01:58:40,840
So in general, with simple cases of only referring to global module level names and annotations, getTypens works just fine.

1225
01:58:40,840 --> 01:58:48,840
The problem is that people do do more complicated things and then what you resolve over on time was more complicated, nested things don't work.

1226
01:58:48,840 --> 01:58:58,840
There was also a debate about getTypens calls eval, so it's slower, but there's a tradeoff because Typens you're not using getIgnored, but the material could be slower.

1227
01:58:58,840 --> 01:59:07,840
Yes, okay, so pet.py649 does seem to solve that nested scoping problem.

1228
01:59:07,840 --> 01:59:12,840
However, it did introduce a few new problems that pet.py563 didn't have.

1229
01:59:12,840 --> 01:59:23,840
If we look at the data classes feature in the standard library, it is one case where the standard library cares about annotations and wants to resolve them in a class decorator.

1230
01:59:23,840 --> 01:59:27,840
Now the fun thing about class decorators is they run immediately from the classes defined.

1231
01:59:27,840 --> 01:59:35,840
So in this example with the circular reference among data classes, the data class decorator runs on parent and once again child is not yet defined.

1232
01:59:35,840 --> 01:59:43,840
So all of this work we've done to delay the evaluation of annotations is not very useful if we then go ahead and try to resolve them eagerly without waiting.

1233
01:59:43,840 --> 01:59:47,840
So this is an issue that pet.py649 introduces.

1234
01:59:47,840 --> 01:59:56,840
Now the interesting thing about data classes is that data classes doesn't really care all that much about what is in the annotation.

1235
01:59:56,840 --> 02:00:02,840
All it really cares about is whether the annotation is wrapped in a class var or in a midvar.

1236
02:00:02,840 --> 02:00:04,840
The rest of the annotation it doesn't care about.

1237
02:00:04,840 --> 02:00:11,840
And we'll come back to that point later, but for now we'll just say this is an issue we need to resolve with pet.py649.

1238
02:00:12,840 --> 02:00:22,840
Another potential issue with pet.py649 is that it is less friendly to the documentation case or the wide help case that we discussed earlier.

1239
02:00:22,840 --> 02:00:28,840
Because you're only going to get whatever the fully expanded runtime representation of your annotation is.

1240
02:00:28,840 --> 02:00:32,840
You won't get the nice semantic name that was originally typed in source code.

1241
02:00:32,840 --> 02:00:35,840
So we'll need to look at how we can resolve that.

1242
02:00:35,840 --> 02:00:38,840
So that brings us up to today where the future remains unclear.

1243
02:00:38,840 --> 02:00:40,840
So we have a little bit of a delay here.

1244
02:00:40,840 --> 02:00:44,840
Pet.py63 was accepted in Python 3.7, which is now on hold.

1245
02:00:44,840 --> 02:00:50,840
The steering council decided not to make it the default behavior in 3.10 because of these issues that come up.

1246
02:00:50,840 --> 02:00:52,840
And so it's kind of in limbo.

1247
02:00:52,840 --> 02:00:55,840
And pet.py649 is still in traffic.

1248
02:00:55,840 --> 02:01:05,840
So in order to hopefully move this forward a little bit, I'm going to try to present a high level comparison of those two pets along three axes.

1249
02:01:05,840 --> 02:01:08,840
So that's the migration path to the final state.

1250
02:01:10,840 --> 02:01:11,840
Starting with usability.

1251
02:01:11,840 --> 02:01:13,840
We kind of already started this discussion, right?

1252
02:01:13,840 --> 02:01:14,840
And looking at history.

1253
02:01:14,840 --> 02:01:18,840
We saw what some of the usability problems with each of the pets are for different use cases.

1254
02:01:18,840 --> 02:01:27,840
So now I'm going to talk about some things that have been proposed that could resolve or patch up some of those usability rules and what that would look like.

1255
02:01:27,840 --> 02:01:32,840
So for pet.py63, we saw that it can't handle names and nested scopes.

1256
02:01:32,840 --> 02:01:48,840
Lukas, the author of the pet, has proposed that we could expand this implementation so that it does track reference names from local scopes and keep around on the object some kind of closure of those names that will be needed to resolve the annotations.

1257
02:01:48,840 --> 02:01:54,840
And then get type names could be made smart enough to use these to help resolve the names.

1258
02:01:54,840 --> 02:02:01,840
So if we implemented that, pet.py63 would be able to handle this type of case.

1259
02:02:02,840 --> 02:02:11,840
Now even with that kind of improvement, there are still many cases where pet.py63 is going to surprise people at runtime.

1260
02:02:11,840 --> 02:02:25,840
It still ultimately is preserving code as a string, which has no useful metadata around it, and then making a best effort later on to stitch that string back together with some names because then hopefully it will come up with something that works.

1261
02:02:25,840 --> 02:02:35,840
For instance, don't copy the annotation strings anywhere else to any other object and then later try to resolve them because they'll lose their names and they won't resolve them.

1262
02:02:35,840 --> 02:02:44,840
This might seem a bit theoretical, but in fact the only two things in the standard library that really care about annotations, type dict and data class, both have this exact bug.

1263
02:02:46,840 --> 02:02:49,840
And it's been fixed in type dict, but not yet in data classes.

1264
02:02:49,840 --> 02:02:57,840
So both type dict and data classes in one way or another need to take annotations from a base class and copy it over onto a subclass.

1265
02:02:57,840 --> 02:03:09,840
And so they both do that. And on the pet.py63, that breaks if you have a data class in one module and then a subclass of it in another module and you try to resolve some type dicts on subclass.

1266
02:03:09,840 --> 02:03:16,840
It's going to be trying to resolve annotations from the base in the wrong namespace and it just breaks.

1267
02:03:16,840 --> 02:03:22,840
So this has been worked around in type dict. It could also be worked around with some special case code for data classes.

1268
02:03:22,840 --> 02:03:30,840
But I think it kind of illustrates that with pet.py63, it's a bit working against the grain of one-time resolution annotations.

1269
02:03:30,840 --> 02:03:40,840
And it's likely that this kind of issue is going to continue to bite people at one time indefinitely as they try to do creative things with the annotations.

1270
02:03:40,840 --> 02:03:50,840
Okay, moving on to pep649 and how we could address some of the issues with it.

1271
02:03:50,840 --> 02:03:56,840
We saw this case of the cyclic reference in data classes.

1272
02:03:56,840 --> 02:04:02,840
And as we saw, the data classes actually has very limited introspection needs.

1273
02:04:02,840 --> 02:04:12,840
So if there is only some way we could reliably figure out if an annotation is a class bar or an emit bar without needing to worry about whether the other names in the annotation resolve, that would be nice.

1274
02:04:12,840 --> 02:04:20,840
If you're observing, you may have already been asking yourself, why doesn't this break on the pet.py63?

1275
02:04:20,840 --> 02:04:28,840
Because even on the pet.py63, if data class tried to resolve the annotations using get type hints, it would break in exactly the same way.

1276
02:04:28,840 --> 02:04:40,840
And the answer is that data class avoids the issue entirely with a fairly unpleasant hack, which is that it just looks at the string annotation and looks for literally the text class bar or emit bar.

1277
02:04:40,840 --> 02:04:44,840
And if it's there, it's probably a class bar or emit bar.

1278
02:04:44,840 --> 02:04:46,840
And so it never resolves it.

1279
02:04:46,840 --> 02:04:56,840
And of course that could break trivially if you alias or shadow those names in strange ways, but it was decided that was a better tradeoff to avoid causing this problem.

1280
02:04:56,840 --> 02:05:04,840
With pet.py649, we can't use that workaround because we don't have a string to regex match against.

1281
02:05:04,840 --> 02:05:06,840
You just have a function.

1282
02:05:06,840 --> 02:05:08,840
But there is something we can do.

1283
02:05:08,840 --> 02:05:18,840
Turns out we can eval a code object, which is not as expensive as evalving a string because we're not parsing and defining the code.

1284
02:05:18,840 --> 02:05:22,840
It's a code object. We're just calling it in a fun way.

1285
02:05:22,840 --> 02:05:26,840
We can call it with our own global dictionary.

1286
02:05:26,840 --> 02:05:31,840
And we can make the global dictionary a special dictionary that finds that we're missing.

1287
02:05:31,840 --> 02:05:35,840
If there's any missing name, we'll just return some kind of miss and wrap object.

1288
02:05:35,840 --> 02:05:40,840
And this is fine for data classes because, as I said, it doesn't care about all the other stuff in the annotation.

1289
02:05:40,840 --> 02:05:43,840
It just wants to look for that class bar or emit bar.

1290
02:05:43,840 --> 02:05:45,840
So if we do this, all the names that are there will resolve.

1291
02:05:45,840 --> 02:05:48,840
Names that aren't there will give us back an object.

1292
02:05:48,840 --> 02:05:50,840
We won't get a name error.

1293
02:05:50,840 --> 02:05:52,840
And that is how this case works.

1294
02:05:52,840 --> 02:05:55,840
So this behavior could be in an agility function.

1295
02:05:55,840 --> 02:05:57,840
It could be in a type-ins.

1296
02:05:57,840 --> 02:05:59,840
It could be built in data classes.

1297
02:05:59,840 --> 02:06:02,840
It's not something that looks a little ugly.

1298
02:06:02,840 --> 02:06:04,840
It's not something that end users would have to do.

1299
02:06:04,840 --> 02:06:06,840
We built it into the right tooling.

1300
02:06:06,840 --> 02:06:11,840
But most importantly, it solves the data class case.

1301
02:06:11,840 --> 02:06:13,840
We can use a similar technique.

1302
02:06:13,840 --> 02:06:16,840
I might skip through this pretty quickly because it's a little iffy.

1303
02:06:16,840 --> 02:06:19,840
We can get annotations, the original annotations of strings.

1304
02:06:19,840 --> 02:06:26,840
We can do that in a similar way where we define some kind of stringifier class that takes a name.

1305
02:06:26,840 --> 02:06:31,840
And then if you get item it, it puts together a longer string with the brackets of the dot.

1306
02:06:31,840 --> 02:06:39,840
It kind of reproduces the original code that would have been written there.

1307
02:06:39,840 --> 02:06:41,840
And it turns out this works.

1308
02:06:41,840 --> 02:06:44,840
And we can do a similar thing where everything just becomes one of these stringifier objects.

1309
02:06:44,840 --> 02:06:49,840
And if we do that, we can get back the original annotation, my areas in this case.

1310
02:06:49,840 --> 02:06:54,840
So that's one way we could satisfy this use case on our PEP 649.

1311
02:06:54,840 --> 02:06:57,840
Another way we could...

1312
02:06:57,840 --> 02:07:00,840
Oh, I inserted this slide at the wrong point.

1313
02:07:00,840 --> 02:07:01,840
Okay.

1314
02:07:01,840 --> 02:07:07,840
Another way we could is just say if you want the original text in the source code,

1315
02:07:07,840 --> 02:07:09,840
just go look at the original source code.

1316
02:07:09,840 --> 02:07:11,840
Maybe a simpler approach.

1317
02:07:11,840 --> 02:07:14,840
You can use inspect.getSource to get the source of the function.

1318
02:07:14,840 --> 02:07:16,840
You can parse the AST.

1319
02:07:16,840 --> 02:07:18,840
You can use AST.onParsed.

1320
02:07:18,840 --> 02:07:23,840
Essentially, you can produce what PEP 563 does and get back the original text of those annotations.

1321
02:07:23,840 --> 02:07:27,840
Again, this could be built into a utility function that these documentation tools could use.

1322
02:07:27,840 --> 02:07:30,840
So that's another option.

1323
02:07:30,840 --> 02:07:35,840
Another important limitation of PEP 649 that we touched on earlier and we should consider

1324
02:07:35,840 --> 02:07:40,840
is that under PEP 563, tagged annotations must only be valid syntax.

1325
02:07:40,840 --> 02:07:43,840
Under PEP 649, they must compile.

1326
02:07:43,840 --> 02:07:49,840
And that's important because some people like to use new type syntax that's only been introduced

1327
02:07:49,840 --> 02:07:53,840
in, say, 310 and use it on the 38 code base.

1328
02:07:53,840 --> 02:07:57,840
And if they're using PEP 563, they can do that because it's valid syntax.

1329
02:07:57,840 --> 02:07:59,840
But it won't compile.

1330
02:07:59,840 --> 02:08:04,840
So in a case like this where we're on Python 3.7, we're trying to use in pipe string.

1331
02:08:04,840 --> 02:08:06,840
Under PEP 563, this would work fine.

1332
02:08:06,840 --> 02:08:08,840
Under PEP 649, it would not.

1333
02:08:08,840 --> 02:08:11,840
Sorry, wouldn't that still work?

1334
02:08:11,840 --> 02:08:14,840
It works as long as you don't inspect the annotations, right?

1335
02:08:14,840 --> 02:08:15,840
Oh, sorry.

1336
02:08:15,840 --> 02:08:18,840
This would work as long as you don't inspect the annotations you're writing.

1337
02:08:18,840 --> 02:08:19,840
Yes.

1338
02:08:19,840 --> 02:08:20,840
Sorry.

1339
02:08:20,840 --> 02:08:21,840
It compiles.

1340
02:08:21,840 --> 02:08:22,840
It doesn't run.

1341
02:08:22,840 --> 02:08:23,840
Yes.

1342
02:08:23,840 --> 02:08:24,840
I'm sorry.

1343
02:08:24,840 --> 02:08:25,840
I got that wrong on the slide.

1344
02:08:25,840 --> 02:08:26,840
This does compile.

1345
02:08:26,840 --> 02:08:27,840
It doesn't run.

1346
02:08:27,840 --> 02:08:30,840
So if you inspect the annotations, this wouldn't break.

1347
02:08:30,840 --> 02:08:31,840
Okay.

1348
02:08:31,840 --> 02:08:32,840
Moving on.

1349
02:08:32,840 --> 02:08:33,840
Performance.

1350
02:08:34,840 --> 02:08:37,840
I added that slide at the last minute and clearly it's a mistake.

1351
02:08:37,840 --> 02:08:38,840
Okay.

1352
02:08:38,840 --> 02:08:39,840
Okay.

1353
02:08:39,840 --> 02:08:41,840
So I wanted to look at performance.

1354
02:08:41,840 --> 02:08:45,840
Now Larry has said that we shouldn't consider performance as the primary factor in making

1355
02:08:45,840 --> 02:08:49,840
this decision because the important thing is to get the right semantics for the language

1356
02:08:49,840 --> 02:08:50,840
and then we can optimize them.

1357
02:08:50,840 --> 02:08:51,840
Generally, I agree.

1358
02:08:51,840 --> 02:08:52,840
I think that's right.

1359
02:08:52,840 --> 02:08:56,840
It also doesn't hurt to look at the current state of the performance comparison and see

1360
02:08:56,840 --> 02:09:00,840
what the starting point is for whatever optimization we're doing.

1361
02:09:00,840 --> 02:09:05,840
So I wanted to benchmark a real production codebase with a lot of tech annotations like

1362
02:09:05,840 --> 02:09:11,840
Instagram server codebase, but the PEP649 reference implementation is based on a 3.10

1363
02:09:11,840 --> 02:09:17,840
alpha and getting any real codebase to run on a alpha.tyton is impossible.

1364
02:09:17,840 --> 02:09:21,840
So I didn't have time to actually forward port the implementation.

1365
02:09:21,840 --> 02:09:28,840
So instead I did a synthetic benchmark where I generated a module with 10,000 classes and

1366
02:09:28,840 --> 02:09:29,840
functions.

1367
02:09:29,840 --> 02:09:32,840
Person zero, person one, and person nine, nine, nine, nine.

1368
02:09:32,840 --> 02:09:35,840
They all look identical, but they're all separate classes.

1369
02:09:35,840 --> 02:09:37,840
Let's build that for 666.

1370
02:09:37,840 --> 02:09:38,840
Oh.

1371
02:09:38,840 --> 02:09:43,840
And yeah, I'm using this typing in a fairly simple, typical way that you might see type

1372
02:09:43,840 --> 02:09:44,840
annotations used.

1373
02:09:44,840 --> 02:09:48,840
So I think it's not a ridiculous benchmark, hopefully.

1374
02:09:48,840 --> 02:09:51,840
I timed it like this using user bin time.

1375
02:09:51,840 --> 02:09:53,840
Just importing the module.

1376
02:09:53,840 --> 02:09:58,840
Obviously, we did a warmup run to do the very slow initial compilation of that massive module,

1377
02:09:58,840 --> 02:10:03,840
but what I'm actually timing is the subsequent runs where we have a PYC and we're just importing

1378
02:10:03,840 --> 02:10:04,840
it.

1379
02:10:04,840 --> 02:10:06,840
I did a bunch of runs and averaged them.

1380
02:10:06,840 --> 02:10:08,840
Didn't do any fancy statistics.

1381
02:10:08,840 --> 02:10:13,840
The numbers did not vary a lot, so I didn't feel they were pretty consistent.

1382
02:10:13,840 --> 02:10:15,840
This is where it came out.

1383
02:10:15,840 --> 02:10:21,840
As we probably expected, we see that PEP563 has a bit of an advantage both in time and

1384
02:10:21,840 --> 02:10:25,840
in the max memory usage, but the difference is not huge.

1385
02:10:25,840 --> 02:10:29,840
You might expect particularly the memory usage difference to be more than that when you're

1386
02:10:29,840 --> 02:10:33,840
talking about strings versus code objects, but actually it's not a lot.

1387
02:10:33,840 --> 02:10:40,840
And another thing that's worth pointing out here is it has been proposed that we could put the

1388
02:10:40,840 --> 02:10:47,840
annotations into a separate section of the Marshall data in the PYC file and only load that

1389
02:10:47,840 --> 02:10:50,840
section lazily if the annotations are actually requested.

1390
02:10:50,840 --> 02:10:55,840
If we could implement that, that would essentially reduce the overhead for both of these approaches

1391
02:10:55,840 --> 02:10:58,840
to zero, so it would erase any difference between them.

1392
02:10:58,840 --> 02:11:00,840
In the case we're not expecting.

1393
02:11:00,840 --> 02:11:06,840
Do you know how these compare to the Eager Evaluation PEP44?

1394
02:11:06,840 --> 02:11:08,840
Are they both faster than that?

1395
02:11:08,840 --> 02:11:12,840
They are both significantly faster than PEP44.

1396
02:11:12,840 --> 02:11:17,840
I could revise the slide and put PEP44 numbers on, but I don't think I'll do that here.

1397
02:11:17,840 --> 02:11:22,840
I didn't really include 44 in the comparison, but I think for a number of reasons nobody is

1398
02:11:22,840 --> 02:11:29,840
seriously proposing that we stick with Eager Evaluation forever, so I just considered these two options.

1399
02:11:29,840 --> 02:11:31,840
Okay.

1400
02:11:31,840 --> 02:11:33,840
All right.

1401
02:11:33,840 --> 02:11:39,840
Going on to the last question, which is the question of migration to reach one of these end states.

1402
02:11:39,840 --> 02:11:45,840
So a couple possibly debatable assumptions that I'm making in this section.

1403
02:11:45,840 --> 02:11:54,840
It is a bit subtle, but although PEP649 and PEP44 both resolve annotations to real one-time objects in a way

1404
02:11:54,840 --> 02:12:02,840
that should look very similar, in practice if you rebind a name to a different value in a module, you could

1405
02:12:02,840 --> 02:12:06,840
get different results from PEP649 than you would have gotten from 44.

1406
02:12:06,840 --> 02:12:12,840
Now, you can argue how likely that is, how common it is, how much of a problem it is, but it has the potential

1407
02:12:12,840 --> 02:12:18,840
to create code, which I think means that we would need a future import for PEP649 and a transition period,

1408
02:12:18,840 --> 02:12:23,840
not just a flip-and-switch in one version and suddenly we have new semantics.

1409
02:12:23,840 --> 02:12:30,840
Second assumption, which in my opinion is less debatable, someone could debate it, which is that libraries,

1410
02:12:30,840 --> 02:12:36,840
particularly libraries that use a lot of annotations and have already started to adopt PEP63, I think those

1411
02:12:36,840 --> 02:12:43,840
libraries need to be able to write multi-version code, code that supports all the supported Python versions

1412
02:12:43,840 --> 02:12:47,840
without being forced back to PEP44 semantics to do that.

1413
02:12:47,840 --> 02:12:55,840
And what that means is that if we choose to move to 649, the existing PEP563 future import has to stay in Python

1414
02:12:55,840 --> 02:13:00,840
and keep working until the oldest supported Python has 649 available.

1415
02:13:00,840 --> 02:13:07,840
Since the earliest version at this point 649 could go into reasonably is 3.12, that means that 563 would need to

1416
02:13:07,840 --> 02:13:13,840
stick around until 3.12's end of life, which is many years down the road at this point.

1417
02:13:13,840 --> 02:13:18,840
So we'd be going for quite a while with two side-by-side implementations available.

1418
02:13:21,840 --> 02:13:27,840
So, yes, given those assumptions, what does the churn look like with this migration intent, for whom?

1419
02:13:28,840 --> 02:13:32,840
So there's a very clear split here between different communities of users.

1420
02:13:32,840 --> 02:13:41,840
For PyNantic style users who've never adopted PEP563 in the first place, migrating from 484 to 649 will certainly be

1421
02:13:41,840 --> 02:13:49,840
a less disruptive transition than 44 to 563. As we discussed, the way that 44 and 649 look at runtime is very,

1422
02:13:49,840 --> 02:13:56,840
very similar, whereas 44 to 563 is almost certain to be some issues, even if we do the improvement for nested

1423
02:13:56,840 --> 02:14:03,840
scopes. So that community of users would definitely have a less disruptive transition if we go to 649.

1424
02:14:03,840 --> 02:14:10,840
On the other hand, for users of static typing who have started adopting 563, obviously the less disruptive

1425
02:14:10,840 --> 02:14:15,840
transition would be to not do anything, to keep using 563.

1426
02:14:15,840 --> 02:14:24,840
I do think that even for this community, if and only if we can do the lax globals thing so that existing data class

1427
02:14:24,840 --> 02:14:32,840
circular references don't start breaking suddenly, if we do that, I think that the migration from 563 to 649

1428
02:14:32,840 --> 02:14:39,840
for those users should not be too bad. In most cases, apart from things like data class, which do it, which introspect the

1429
02:14:39,840 --> 02:14:44,840
annotations without you wanting to, most of these users aren't even introspecting annotations anyway, so they aren't

1430
02:14:44,840 --> 02:14:48,840
really going to care.

1431
02:14:48,840 --> 02:14:57,840
This brings us to the overall winner and the part where I cop out. So obviously how you evaluate all of this, it really

1432
02:14:57,840 --> 02:15:02,840
depends on what you value and how you weigh the different use cases and factors and communities of users.

1433
02:15:02,840 --> 02:15:10,840
I will give you my opinion, which is if we assume that, and these are things that I do believe, that annotations are

1434
02:15:10,840 --> 02:15:17,840
certainly at this point not only for static typing and for documentation, but that I think all of those other

1435
02:15:17,840 --> 02:15:25,840
run-time use cases we saw are equally valid and equally supported use cases for annotations, if we believe that,

1436
02:15:25,840 --> 02:15:33,840
and if we also believe that it's worth some medium-term turn, like two competing future annotations for future

1437
02:15:33,840 --> 02:15:39,840
future annotations available for a number of releases, if it's worth some medium-term turn to reach a preferable

1438
02:15:39,840 --> 02:15:48,840
long-term state, if both of those things are true, then I do think that 649 semantics are a more natural fit that

1439
02:15:48,840 --> 02:15:54,840
integrates annotations better into the entire language, which is something Steering Council has said that they want,

1440
02:15:54,840 --> 02:16:01,840
and will generally lead to less surprising behavior and bugs at runtime when people try to use annotations at runtime,

1441
02:16:01,840 --> 02:16:08,840
and probably should be preferred. If we want to negate one of those two assumptions, either of them, I think,

1442
02:16:08,840 --> 02:16:16,840
that would tend to point towards Pet563 as maybe a preferable option, and I feel compelled to observe that even if many

1443
02:16:16,840 --> 02:16:24,840
people in this room would like to say that annotations are for static typing, that doesn't mean the Steering Council will agree with us.

1444
02:16:24,840 --> 02:16:31,840
So, that's my conclusion, and I'm interested, very interested, in hearing your thoughts.

1445
02:16:41,840 --> 02:16:49,840
What do you think of Larry's forward-class definitions? Larry's here?

1446
02:16:49,840 --> 02:16:51,840
Larry is here, hi Larry.

1447
02:16:51,840 --> 02:16:53,840
Larry is also here, hi Larry.

1448
02:16:53,840 --> 02:17:01,840
A lot of time getting deep into this, I think that they aren't necessary.

1449
02:17:01,840 --> 02:17:11,840
I think that one thing that I think is important for making the transition from Pet563 to 649 doable for existing

1450
02:17:11,840 --> 02:17:20,840
large-scale users of 649 is that this data class case, I don't know, I can't find any more.

1451
02:17:20,840 --> 02:17:29,840
The self-referential data class, that this case needs to keep working in existing code bases when they move from

1452
02:17:29,840 --> 02:17:35,840
563 to 649 without changing the code, without doing a viewport declaration thing or anything.

1453
02:17:35,840 --> 02:17:43,840
It just needs to keep working, which I think means we need the lax global solution in data classes either way.

1454
02:17:43,840 --> 02:17:49,840
Even if we wanted to do forward-class declarations, we would still need to do the lax global solution.

1455
02:17:49,840 --> 02:17:56,840
I think that's all that needs to be said about that. Right now I'm debating merits of forward-class declarations on my own merits

1456
02:17:56,840 --> 02:18:01,840
probably at another time, but that's where I think it's relevant for this question.

1457
02:18:05,840 --> 02:18:11,840
How do other languages solve this problem?

1458
02:18:11,840 --> 02:18:15,840
That's a good question and one I have not looked into at all.

1459
02:18:15,840 --> 02:18:19,840
Compiler!

1460
02:18:19,840 --> 02:18:24,840
I'm not aware of other languages that impact on type annotations relating to language evolution.

1461
02:18:24,840 --> 02:18:31,840
Type script doesn't preserve annotations of properties.

1462
02:18:31,840 --> 02:18:37,840
How many languages have that much support for front-end annotations of personalities?

1463
02:18:37,840 --> 02:18:43,840
I don't know.

1464
02:18:43,840 --> 02:18:49,840
Anyone know what Googy does?

1465
02:18:49,840 --> 02:18:55,840
No annotations.

1466
02:18:55,840 --> 02:19:01,840
I don't know what those annotations are.

1467
02:19:01,840 --> 02:19:07,840
There's a whole bunch of tables full of data people.

1468
02:19:07,840 --> 02:19:13,840
I'm not sure if we need to bring that up.

1469
02:19:13,840 --> 02:19:19,840
We erase that on time, but there's a concept of read by generics where you can compile and generate specializing for the word.

1470
02:19:19,840 --> 02:19:27,840
You can do the parsing without implementing those specializations instead of providing general access to annotations.

1471
02:19:27,840 --> 02:19:35,840
In Rust you can use a macro as your ultimate escape hatch to get access to the code.

1472
02:19:35,840 --> 02:19:43,840
I was going to say that I work in opening API generators in space and no language has as good support as Python does.

1473
02:19:43,840 --> 02:19:49,840
In Python you can introspect everything and generate primers and Rust every library is a bunch of macros.

1474
02:19:49,840 --> 02:19:53,840
It doesn't support anywhere near as much as you can get in Python.

1475
02:19:53,840 --> 02:19:59,840
Anyone know what Julia is doing?

1476
02:19:59,840 --> 02:20:05,840
The next version of this talk will have a survey of the language.

1477
02:20:05,840 --> 02:20:11,840
Yes?

1478
02:20:11,840 --> 02:20:19,840
I think Julia suggested that with PEP 649 using new syntax from later versions could be a problem.

1479
02:20:19,840 --> 02:20:25,840
It seemed unclear whether it actually was.

1480
02:20:25,840 --> 02:20:29,840
I just wanted clarification.

1481
02:20:29,840 --> 02:20:35,840
That was the slide I added late this afternoon.

1482
02:20:35,840 --> 02:20:41,840
The new versions must compile, but in general when people want to use...

1483
02:20:41,840 --> 02:20:49,840
When we introduce new things like the type operator working on built-in types, that compiles fine on older versions.

1484
02:20:49,840 --> 02:20:55,840
It just doesn't run because those types in older versions don't have the render or method on them.

1485
02:20:55,840 --> 02:21:01,840
This would actually work fine as long as you don't introspect annotations.

1486
02:21:01,840 --> 02:21:09,840
Thank you.

1487
02:21:09,840 --> 02:21:13,840
I'm Kevin and I work at DeepMind.

1488
02:21:13,840 --> 02:21:19,840
We've implemented another type generator.

1489
02:21:19,840 --> 02:21:25,840
I want to talk a little bit about Python subtyping.

1490
02:21:25,840 --> 02:21:29,840
Subtyping is really important. Why is subtyping important?

1491
02:21:29,840 --> 02:21:35,840
There's a PEP 483 which gives some of the theory behind the original type in PEP.

1492
02:21:35,840 --> 02:21:39,840
It defines a relation called is consistent with.

1493
02:21:39,840 --> 02:21:45,840
This is basically what some of them would call something like signability.

1494
02:21:45,840 --> 02:21:51,840
It tells us when we have an expression with a static type 2.1

1495
02:21:51,840 --> 02:21:57,840
and we pass that or assign that to a variable with an annotation of static type 2.2.

1496
02:21:57,840 --> 02:22:03,840
That includes parameters, passing arguments for parameters.

1497
02:22:03,840 --> 02:22:07,840
It includes returning values from functions of a return type annotation.

1498
02:22:07,840 --> 02:22:13,840
The first clause of the rules for consistency is that a type is consistent with another type if it's a subtype.

1499
02:22:13,840 --> 02:22:19,840
If we want to implement this signability check, we have to implement subtyping inside of a type checker.

1500
02:22:19,840 --> 02:22:23,840
That's why subtyping is important.

1501
02:22:23,840 --> 02:22:27,840
The PEP 483 also covers subtyping a little bit.

1502
02:22:27,840 --> 02:22:31,840
It's not entirely complete. It doesn't try to be.

1503
02:22:31,840 --> 02:22:35,840
It says that it's a start point to a speckle. It's not intended to be a speckle.

1504
02:22:35,840 --> 02:22:41,840
As such, it's not always clear what the intended behavior is on subtyping.

1505
02:22:41,840 --> 02:22:49,840
Another drawback of using this PEP as a speckle is that it's never been updated in the presence of new typing features which are constantly being introduced.

1506
02:22:49,840 --> 02:22:55,840
I list a bunch of things there. That all depend on subtyping or impact in some way.

1507
02:22:55,840 --> 02:23:03,840
Obviously, the PEPs are going to constantly be updated to do those things.

1508
02:23:03,840 --> 02:23:13,840
What we frequently do is we'll black box test some type checker implementations to figure out what the intended behavior is when we implement a checker.

1509
02:23:13,840 --> 02:23:27,840
As a jumping off point to talk about subtyping, I found a couple of conversations on Slack channels or chat forms that I've done.

1510
02:23:27,840 --> 02:23:37,840
Where people who are experienced Python developers or who understand Python types quite well were talking about typing.

1511
02:23:37,840 --> 02:23:45,840
I said, I think that union of any and foo is equal to any. Wolf, who is actually an implementer of a Python type checker, says that too.

1512
02:23:45,840 --> 02:23:55,840
In a different conversation, Frog said you should use any as a type connotation which is the same as optional.

1513
02:23:55,840 --> 02:24:01,840
I wanted to use that as a jumping off point.

1514
02:24:01,840 --> 02:24:09,840
Obviously, first of all, these people speaking don't mean double equal or same as in any sort of formal sense.

1515
02:24:09,840 --> 02:24:15,840
They're speaking informally. I did want to ask what it means formally in terms of subtyping.

1516
02:24:15,840 --> 02:24:19,840
I'll focus on the second one. Is any the same as optional?

1517
02:24:19,840 --> 02:24:25,840
From the standpoint of subtyping, it would be the same if they were subtypes of each other.

1518
02:24:25,840 --> 02:24:29,840
Here's a little quiz. There is some money in this situation.

1519
02:24:29,840 --> 02:24:33,840
What is the subtype relation between any and optional any?

1520
02:24:33,840 --> 02:24:37,840
If you think that any is a subtype of optional any, raise your hand.

1521
02:24:43,840 --> 02:24:49,840
Excellent. If you think that optional any is a subtype of any, raise your hand.

1522
02:24:51,840 --> 02:24:57,840
Got some? So there are some bulbs there. If you think that neither of these is true, raise your hand.

1523
02:24:57,840 --> 02:25:01,840
Nobody is going to go for neither.

1524
02:25:01,840 --> 02:25:09,840
If you think it's unspecified or rather should be unspecified, check your sheet of paper. Raise your hand.

1525
02:25:09,840 --> 02:25:13,840
We have a few takers for that as well.

1526
02:25:13,840 --> 02:25:19,840
PEP 483 does have some rules for subtyping of unions. I put them on the slide to see that it's dense.

1527
02:25:19,840 --> 02:25:23,840
I'm going to give an alternative definition of subtyping for unions.

1528
02:25:23,840 --> 02:25:27,840
This is pretty standard. There are two rules.

1529
02:25:27,840 --> 02:25:31,840
The first one tells us what it means for something to be a subtype of a union.

1530
02:25:31,840 --> 02:25:37,840
A type is a subtype of a union if it is a subtype of at least one of the components of the union.

1531
02:25:37,840 --> 02:25:43,840
The second rule, so-called union on the left, tells us what it means for a union to be a subtype of a type.

1532
02:25:43,840 --> 02:25:47,840
That is if all of the components of the union are subtyped for that type.

1533
02:25:47,840 --> 02:25:55,840
In the PEP 483 definition of subtyping for unions, a lot of those points were consequences of this more simple definition.

1534
02:25:55,840 --> 02:25:59,840
Which I claim is the one.

1535
02:25:59,840 --> 02:26:01,840
We'll use this one.

1536
02:26:01,840 --> 02:26:05,840
Now we can ask part of that question. Is any subtype of a polyoptional union?

1537
02:26:05,840 --> 02:26:07,840
Yes?

1538
02:26:07,840 --> 02:26:13,840
Is X a subtype of that union? When we say subtype, are we always including itself as one?

1539
02:26:13,840 --> 02:26:17,840
I believe so, yes. I believe we want that property of subtyping, yes.

1540
02:26:17,840 --> 02:26:23,840
Is any a subtype of optional any?

1541
02:26:23,840 --> 02:26:31,840
The answer is maybe. We need any to be a subtype of any or else any to be a subtype of none.

1542
02:26:31,840 --> 02:26:35,840
According to the rules that I gave.

1543
02:26:35,840 --> 02:26:39,840
I think it's intended that this is true because any is a subtype of any.

1544
02:26:39,840 --> 02:26:43,840
I believe it's intended that any is not a subtype of none.

1545
02:26:43,840 --> 02:26:47,840
PEP 483 is actually not crystal clear about this.

1546
02:26:47,840 --> 02:26:51,840
Because it's using just plain English instead of formal English.

1547
02:26:51,840 --> 02:26:55,840
It just says that any is not a subtype of every type.

1548
02:26:55,840 --> 02:26:59,840
Which could be read to mean that there exists some type T that any is not a subtype of.

1549
02:26:59,840 --> 02:27:03,840
I don't think this is exactly what it's intended.

1550
02:27:03,840 --> 02:27:07,840
But that's a sort of perversity to that.

1551
02:27:07,840 --> 02:27:11,840
It also says that every type is not a subtype of any.

1552
02:27:11,840 --> 02:27:15,840
Which could be interpreted to mean that there is no type T that is a subtype of any.

1553
02:27:15,840 --> 02:27:19,840
Including any itself. I do believe that we intend that any is a subtype of any.

1554
02:27:19,840 --> 02:27:25,840
That subtyping is requested. Even for any which is kind of a wild card special case.

1555
02:27:25,840 --> 02:27:29,840
So can we observe subtyping? Is there any place where we can observe subtyping?

1556
02:27:29,840 --> 02:27:33,840
There is one convenient place where we can observe subtyping.

1557
02:27:33,840 --> 02:27:37,840
If we have two components of the union that have a subtype relation.

1558
02:27:37,840 --> 02:27:41,840
We eliminate the subtype from the union. So the example is that manager is a subtype of employee.

1559
02:27:41,840 --> 02:27:45,840
And we eliminate manager from the union.

1560
02:27:45,840 --> 02:27:49,840
So I wrote a function. It's a generic function.

1561
02:27:49,840 --> 02:27:53,840
Generic and two type variables T and U. And it takes a T and a U.

1562
02:27:53,840 --> 02:27:57,840
And returns the union of T and U. And I gave it an implementation.

1563
02:27:57,840 --> 02:28:01,840
Because Pyright was a really clever, all kind of inline specialized function.

1564
02:28:01,840 --> 02:28:05,840
And all science and type checkup. So I gave it an implementation that would defeat Pyright.

1565
02:28:05,840 --> 02:28:09,840
And then I used reveal type.

1566
02:28:09,840 --> 02:28:13,840
To show what the type of that is. And I used CAS.

1567
02:28:13,840 --> 02:28:17,840
Which allows me to ascribe a static type to an expression.

1568
02:28:17,840 --> 02:28:21,840
To ask what is the union of any and optional any.

1569
02:28:21,840 --> 02:28:25,840
If any is a subtype of optional any. We would expect that

1570
02:28:25,840 --> 02:28:29,840
What would survive in a union is optional any.

1571
02:28:31,840 --> 02:28:35,840
MyPy says yeah. That's fine.

1572
02:28:35,840 --> 02:28:39,840
And Pyright says yeah that's fine. So that is what I expected.

1573
02:28:39,840 --> 02:28:43,840
I tested Pytype and it just says any.

1574
02:28:43,840 --> 02:28:47,840
Which seems to indicate that perhaps optional any is a subtype of any.

1575
02:28:47,840 --> 02:28:51,840
And there was some takers for that when I asked the question.

1576
02:28:51,840 --> 02:28:55,840
And Pyright says the same.

1577
02:28:55,840 --> 02:28:59,840
So is Pytype wrong? Is that a plug against Pytype?

1578
02:28:59,840 --> 02:29:03,840
I say maybe not. So I say reveal type is not standard.

1579
02:29:03,840 --> 02:29:07,840
It will become standard. So that's good.

1580
02:29:07,840 --> 02:29:11,840
But maybe. But still a little bit unspecified what is happening with reveal type.

1581
02:29:11,840 --> 02:29:15,840
So perhaps Pytype is implementing the union internally.

1582
02:29:15,840 --> 02:29:19,840
And when it renders that type it's only showing it as any.

1583
02:29:19,840 --> 02:29:23,840
So it really has internally optional any.

1584
02:29:23,840 --> 02:29:27,840
We saw that some expert QGN programs thought that was the case. Those were the same.

1585
02:29:27,840 --> 02:29:31,840
So I asked a more graphic question. What is the type of optional any?

1586
02:29:31,840 --> 02:29:35,840
And it did show me optional any. So it's not the case that it's doing something different.

1587
02:29:35,840 --> 02:29:39,840
It's rendering the type.

1588
02:29:39,840 --> 02:29:43,840
So what is really going on is I pulled a fast one when I gave this function union.

1589
02:29:43,840 --> 02:29:47,840
That was a generic function that took two arguments.

1590
02:29:47,840 --> 02:29:51,840
And claimed that it would return the union. It doesn't necessarily actually return the union.

1591
02:29:51,840 --> 02:29:55,840
So the way that generic functions work is that at a call site they're implicitly

1592
02:29:55,840 --> 02:29:59,840
instantiated. We choose types or the type variables T and U based on the static types of the arguments.

1593
02:29:59,840 --> 02:30:03,840
So the static types of the arguments will generate constraints on T and U.

1594
02:30:03,840 --> 02:30:07,840
We'll do some sort of constraint solving to find out what the solution to these constraints are.

1595
02:30:07,840 --> 02:30:11,840
And that will be the answer.

1596
02:30:11,840 --> 02:30:15,840
Parameter passing was based on consistency.

1597
02:30:15,840 --> 02:30:19,840
I claimed.

1598
02:30:19,840 --> 02:30:23,840
And so the constraints that we generate must be consistency constraints.

1599
02:30:23,840 --> 02:30:27,840
So what we really need is that any is consistent with T.

1600
02:30:27,840 --> 02:30:31,840
And optional any is consistent with U.

1601
02:30:31,840 --> 02:30:35,840
I'm saying these are not subject constraints because

1602
02:30:35,840 --> 02:30:39,840
assignability is based on this consistency relation.

1603
02:30:39,840 --> 02:30:43,840
So one solution, the one I acted as was the expected one, is that

1604
02:30:43,840 --> 02:30:47,840
T is actually equal to any and U is actually equal to optional any.

1605
02:30:47,840 --> 02:30:51,840
But another solution is that those are both any.

1606
02:30:51,840 --> 02:30:55,840
Because any is consistent with any type.

1607
02:30:55,840 --> 02:30:59,840
And so a valid solution to this system concerning this would be any.

1608
02:30:59,840 --> 02:31:03,840
And I feel like that's what PyTex is actually choosing. It's choosing a different solution.

1609
02:31:03,840 --> 02:31:07,840
Another solution would be that T is tuple of int and int.

1610
02:31:07,840 --> 02:31:11,840
And that U is optional string.

1611
02:31:11,840 --> 02:31:15,840
And there's lots more. So because I put any in there and any is consistent with anything we can do a lot of weird things.

1612
02:31:15,840 --> 02:31:19,840
So the punchline is we'd like to talk about

1613
02:31:19,840 --> 02:31:23,840
what is the best solution to these systems of constraints.

1614
02:31:23,840 --> 02:31:27,840
And we don't quite have the machine we need for that.

1615
02:31:27,840 --> 02:31:31,840
So given that there's some weirdness going on with this generic function, let's just directly ask

1616
02:31:31,840 --> 02:31:35,840
what happens if I ask for the union of any and optional any.

1617
02:31:35,840 --> 02:31:39,840
So we would expect that this is optional any.

1618
02:31:39,840 --> 02:31:43,840
That was my line. And PyWrite and PyTex would agree.

1619
02:31:43,840 --> 02:31:47,840
So PyTex is finding a different solution to the constraints of the generic function.

1620
02:31:47,840 --> 02:31:51,840
But they both agree. PyRest still says any.

1621
02:31:51,840 --> 02:31:55,840
So PyRest seems to really agree that those two types are actually the same.

1622
02:31:55,840 --> 02:31:59,840
And MyPy did a really weird thing.

1623
02:31:59,840 --> 02:32:03,840
It showed me that the union of any and optional any was any and any and none.

1624
02:32:07,840 --> 02:32:11,840
So that's interesting.

1625
02:32:11,840 --> 02:32:15,840
So maybe that is a bug in MyPy.

1626
02:32:15,840 --> 02:32:19,840
I don't think I would actually believe that any is a sub-individu.

1627
02:32:19,840 --> 02:32:23,840
So by black-boxing, I can't tell.

1628
02:32:23,840 --> 02:32:27,840
Another way to task would be with a conditional expression.

1629
02:32:27,840 --> 02:32:31,840
So we have conditional expressions and two su-expressions.

1630
02:32:31,840 --> 02:32:35,840
We would expect the type of this to be the so-called least upper bound

1631
02:32:35,840 --> 02:32:39,840
of the static types of the two su-expressions.

1632
02:32:39,840 --> 02:32:43,840
So the least upper bound is a common supertype.

1633
02:32:43,840 --> 02:32:47,840
So we want it to be an upper bound because that's safe.

1634
02:32:47,840 --> 02:32:51,840
We want it to be the least upper bound because that will avoid

1635
02:32:51,840 --> 02:32:55,840
spurious type errors if we try to use this somewhere else.

1636
02:32:55,840 --> 02:32:59,840
And the least upper bound always exists in Python because we have unions.

1637
02:32:59,840 --> 02:33:03,840
It's always the union. So there's always a least upper bound with respect to subtyping.

1638
02:33:03,840 --> 02:33:07,840
So we should be able to ask this question of our four type checkers.

1639
02:33:07,840 --> 02:33:11,840
And find out what they think about that.

1640
02:33:11,840 --> 02:33:15,840
And Pyright and Pytype gave me the answer expected.

1641
02:33:15,840 --> 02:33:19,840
Mypy gave me something different. Pyre gave me something. Pyre is consistent with

1642
02:33:19,840 --> 02:33:23,840
what Pyre showed me before, which is that things those are the same. And Mypy again

1643
02:33:23,840 --> 02:33:27,840
surprised me because it's not finding the least upper bound. It's doing something

1644
02:33:27,840 --> 02:33:31,840
more like solving some constraints on some

1645
02:33:31,840 --> 02:33:35,840
implicit type variables.

1646
02:33:35,840 --> 02:33:39,840
So the join with the two types instead of the union.

1647
02:33:39,840 --> 02:33:43,840
So the join with the two types. My py doesn't believe in the terms.

1648
02:33:43,840 --> 02:33:47,840
My py doesn't believe in the terms.

1649
02:33:47,840 --> 02:33:51,840
So Pyre said that

1650
02:33:51,840 --> 02:33:55,840
Pyre didn't believe in those two types were the same. So as Pyright

1651
02:33:55,840 --> 02:33:59,840
should optional any be a subject of any? And again maybe

1652
02:33:59,840 --> 02:34:03,840
the product thought it was. At conjecture there's no program where you can put

1653
02:34:03,840 --> 02:34:07,840
any instead of optional any or optional instead of any

1654
02:34:07,840 --> 02:34:11,840
and detect a difference in terms of static checking behavior.

1655
02:34:11,840 --> 02:34:15,840
Other than the string representation of error messages for instance.

1656
02:34:15,840 --> 02:34:19,840
I've spent a lot of time talking about this one.

1657
02:34:19,840 --> 02:34:23,840
About that union of any. One more interesting question is what about the

1658
02:34:23,840 --> 02:34:27,840
union of any an object?

1659
02:34:27,840 --> 02:34:31,840
So Mypy says that this is union of any an object.

1660
02:34:31,840 --> 02:34:35,840
Py type says the same. Pyre says this is any.

1661
02:34:35,840 --> 02:34:39,840
So it's treating any as kind of a top type in the

1662
02:34:39,840 --> 02:34:43,840
subtype hierarchy. The object is somehow a subtype of any.

1663
02:34:43,840 --> 02:34:47,840
The PEP 483 actually has a line that's interesting. It says that

1664
02:34:47,840 --> 02:34:51,840
there's a corollary that union of anything that includes object returns object.

1665
02:34:51,840 --> 02:34:55,840
I think that might just be a bug in PEP. But that implies

1666
02:34:55,840 --> 02:34:59,840
that any is a subtype of object. Because by the rule

1667
02:34:59,840 --> 02:35:03,840
you would need that to eliminate any from that union.

1668
02:35:03,840 --> 02:35:07,840
But that's actually not ridiculous. It does have some nice consequences.

1669
02:35:07,840 --> 02:35:11,840
So if we said that any was a subtype of object, then

1670
02:35:11,840 --> 02:35:15,840
any would have the methods that are on the type step for an object

1671
02:35:15,840 --> 02:35:19,840
in a type check. And we could specifically say that if we invoke something like

1672
02:35:19,840 --> 02:35:23,840
for instance hash on any, we would get the

1673
02:35:23,840 --> 02:35:27,840
return type int instead of any. Which is not

1674
02:35:27,840 --> 02:35:31,840
a good thing. We have a little stir so it can't just have the castor

1675
02:35:31,840 --> 02:35:35,840
strength. So that actually might be something we want.

1676
02:35:35,840 --> 02:35:39,840
So that was all

1677
02:35:39,840 --> 02:35:43,840
about any. And any is a really weird kind of wild card.

1678
02:35:43,840 --> 02:35:47,840
So maybe you think that there's something weird going on with any.

1679
02:35:47,840 --> 02:35:51,840
And so there's a couple other cases that don't involve any that I found interesting.

1680
02:35:51,840 --> 02:35:55,840
So what about tuples?

1681
02:35:55,840 --> 02:35:59,840
So we have rules for subtyping of tuples. Basically a tuple

1682
02:35:59,840 --> 02:36:03,840
type is a subtype of another tuple type if they have the same length.

1683
02:36:03,840 --> 02:36:07,840
And the components are component-wise subtypes. That makes sense.

1684
02:36:07,840 --> 02:36:11,840
We also have variadic homogeneous tuples.

1685
02:36:11,840 --> 02:36:15,840
And I think that you could obviously extend the subtyping rule to say that

1686
02:36:15,840 --> 02:36:19,840
two variadic tuples have the same length as each other because they both have no length.

1687
02:36:19,840 --> 02:36:23,840
And that no fixed size tuple has the same length as a variadic tuple.

1688
02:36:23,840 --> 02:36:27,840
So I think it's an obvious way to extend this rule to include

1689
02:36:27,840 --> 02:36:31,840
subtyping of variadic tuples. The question I wanted to ask

1690
02:36:31,840 --> 02:36:35,840
is what is the subtype relation between a fixed size tuple

1691
02:36:35,840 --> 02:36:39,840
and a variadic tuple? So another little quiz.

1692
02:36:39,840 --> 02:36:43,840
What should the subtype relation be between a variadic

1693
02:36:43,840 --> 02:36:47,840
tuple against and a pair of these?

1694
02:36:47,840 --> 02:36:51,840
So if you think that the variadic tuple is a subtype of a pair,

1695
02:36:51,840 --> 02:36:55,840
raise your hand.

1696
02:36:55,840 --> 02:36:59,840
No takers for that.

1697
02:36:59,840 --> 02:37:03,840
What if you think that the pair is a subtype of a variadic tuple?

1698
02:37:03,840 --> 02:37:07,840
Yeah, lots of people make that. So there's no way to decide.

1699
02:37:07,840 --> 02:37:11,840
What about neither?

1700
02:37:11,840 --> 02:37:15,840
Okay, we have one person who says neither. Who thinks that this should be unspecified?

1701
02:37:15,840 --> 02:37:19,840
We shouldn't know.

1702
02:37:19,840 --> 02:37:23,840
I tried to test this and it seems like all the checkers agree that there is no subtype relation.

1703
02:37:23,840 --> 02:37:27,840
You put those in the union together, it doesn't eliminate either one of those.

1704
02:37:27,840 --> 02:37:31,840
And that surprised me a little bit. Because I actually did, I

1705
02:37:31,840 --> 02:37:35,840
agreed with most of the people there and thought that there should be a subtype relation. It's safe to pass

1706
02:37:35,840 --> 02:37:39,840
the pair where I expect a variadic tuple.

1707
02:37:39,840 --> 02:37:43,840
So maybe what's really, but I do know that the checkers actually allow me to do that.

1708
02:37:43,840 --> 02:37:47,840
So what might be going on is that it's a kind of a consistent, it's not a subtype relation

1709
02:37:47,840 --> 02:37:51,840
exactly, but it's a kind of consistency relation where it says that the

1710
02:37:51,840 --> 02:37:55,840
pair is consistent with the variadic tuple.

1711
02:37:55,840 --> 02:37:59,840
So I wrote another function to try to test that out. It's a generic function

1712
02:37:59,840 --> 02:38:03,840
that tries to force me to find a type that is consistent with two types.

1713
02:38:03,840 --> 02:38:07,840
So X and Y have the same type, T.

1714
02:38:07,840 --> 02:38:11,840
So I'm trying to generate constraints to find a type that's consistent.

1715
02:38:11,840 --> 02:38:15,840
And what I found is that my pypyreg and pyre

1716
02:38:15,840 --> 02:38:19,840
all pick the variadic tuple, which is very nice

1717
02:38:19,840 --> 02:38:23,840
and that's a good behavior for type checking. So I do seem to think that they're

1718
02:38:23,840 --> 02:38:27,840
consistent. Py type kept the meaning.

1719
02:38:27,840 --> 02:38:31,840
So py type found the solution. So that means that maybe py type does believe that they're consistent, but

1720
02:38:31,840 --> 02:38:35,840
they found a different solution to, again, there's some system of constraints, we don't have any meaning

1721
02:38:35,840 --> 02:38:39,840
solution necessarily. So do we all

1722
02:38:39,840 --> 02:38:43,840
agree they're consistent? So I wrote another function that would allow me to upcast from a

1723
02:38:43,840 --> 02:38:47,840
pair of ints to a tuple of ints. This should be okay

1724
02:38:47,840 --> 02:38:51,840
if I can cast implicitly up from a pair to a

1725
02:38:51,840 --> 02:38:55,840
variadic tuple of ints. And everybody agreed that was okay.

1726
02:38:55,840 --> 02:38:59,840
Can I downcast from the pair of ints

1727
02:38:59,840 --> 02:39:03,840
to the variadic tuple? And my py and pyre said it's an error.

1728
02:39:03,840 --> 02:39:07,840
Which is probably good, but they don't agree that there's a

1729
02:39:07,840 --> 02:39:11,840
subtype relation, which is interesting. Py type and pyre both actually said that was okay.

1730
02:39:11,840 --> 02:39:15,840
So my interpretation is that py type and pyre are

1731
02:39:15,840 --> 02:39:19,840
treating this as a kind of consistency relationship. It's not subtyping.

1732
02:39:19,840 --> 02:39:23,840
And just like any, it allows implicitly upcasting and downcasting.

1733
02:39:23,840 --> 02:39:27,840
Though one of those is not safe. And then my py and pyre

1734
02:39:27,840 --> 02:39:31,840
was treating it also as a kind of consistency, but it's not allowing downcasting.

1735
02:39:31,840 --> 02:39:35,840
And finally, what about

1736
02:39:35,840 --> 02:39:39,840
function signature subtyping? So we can subtype for functions, not just palpable.

1737
02:39:39,840 --> 02:39:43,840
And this is pretty confusing because we have

1738
02:39:43,840 --> 02:39:47,840
positional only, named only, optional parameters. It makes it pretty complicated.

1739
02:39:47,840 --> 02:39:51,840
You can write out all the cases. You can decide

1740
02:39:51,840 --> 02:39:55,840
them. Writing a single rule that determines

1741
02:39:55,840 --> 02:39:59,840
if a pair of functions signatures are subtypes is not that easy.

1742
02:39:59,840 --> 02:40:03,840
So another little quiz is

1743
02:40:03,840 --> 02:40:07,840
what is the relationship between a signature

1744
02:40:07,840 --> 02:40:11,840
that has a pair of

1745
02:40:11,840 --> 02:40:15,840
arguments in str and another signature that has

1746
02:40:15,840 --> 02:40:19,840
a required argument and an optional str argument?

1747
02:40:19,840 --> 02:40:23,840
So if you think that the signature with two required arguments

1748
02:40:23,840 --> 02:40:27,840
is a subtype along with an optional argument, there's your hand.

1749
02:40:27,840 --> 02:40:31,840
It takes a while to think about that.

1750
02:40:31,840 --> 02:40:35,840
Nobody does. The other way around.

1751
02:40:35,840 --> 02:40:39,840
Okay. So how many things both?

1752
02:40:39,840 --> 02:40:43,840
Does anyone think that there's neither?

1753
02:40:43,840 --> 02:40:47,840
And I think we should leave this unspecified.

1754
02:40:47,840 --> 02:40:51,840
So it actually should be. I think it shouldn't be. And this is actually important here

1755
02:40:51,840 --> 02:40:55,840
because if we do compatible override checking for subclassing

1756
02:40:55,840 --> 02:40:59,840
we need to actually allow this kind of relationship to be ferment.

1757
02:40:59,840 --> 02:41:03,840
So I asked

1758
02:41:03,840 --> 02:41:07,840
all these type checkers this question. And so my pi and pi type

1759
02:41:07,840 --> 02:41:11,840
said yes, which is what I expected. And again

1760
02:41:11,840 --> 02:41:15,840
I put it in a new mean and see if one gets eliminated. Both with caveats.

1761
02:41:15,840 --> 02:41:19,840
So in corner cases they're doing good things. I have a pretty

1762
02:41:19,840 --> 02:41:23,840
exhaustive test suite. So there's cases where maybe the implementers

1763
02:41:23,840 --> 02:41:27,840
of those tools think those are bugs. Pyright Pyroball said no,

1764
02:41:27,840 --> 02:41:31,840
but again with caveats. It's too bad that not Pyright people are here

1765
02:41:31,840 --> 02:41:35,840
because one interesting thing with Pyright is that it depends on which

1766
02:41:35,840 --> 02:41:39,840
order you put things. When you're solving constraints to a generic function

1767
02:41:39,840 --> 02:41:43,840
which solution it will choose. Which I think is a very undesirable behavior.

1768
02:41:43,840 --> 02:41:47,840
And then the last thing about function subtyping is

1769
02:41:47,840 --> 02:41:51,840
what about generic function signature subtyping? So we have

1770
02:41:51,840 --> 02:41:55,840
generic functions. I would expect that a generic signature

1771
02:41:55,840 --> 02:41:59,840
was a subtype of all of its instantiations. So in other words

1772
02:41:59,840 --> 02:42:03,840
I have a function that needs a callable that takes a mass of string to a string

1773
02:42:03,840 --> 02:42:07,840
and I have a generic function that takes

1774
02:42:07,840 --> 02:42:11,840
a mass of t to t. I would expect that

1775
02:42:11,840 --> 02:42:15,840
the generic function is a subtitle of that instantiation

1776
02:42:15,840 --> 02:42:19,840
so that it's safe for me to pass the generic function

1777
02:42:19,840 --> 02:42:23,840
to a decorative function.

1778
02:42:23,840 --> 02:42:27,840
So I asked that question. So we don't have syntax for

1779
02:42:27,840 --> 02:42:31,840
unfortunately we don't have syntax for a generic callable.

1780
02:42:31,840 --> 02:42:35,840
I suggested on the typing stick that we use lambda and then I put a smiley

1781
02:42:35,840 --> 02:42:39,840
so I thought it was joking, but I was actually dead serious.

1782
02:42:39,840 --> 02:42:43,840
So it's exactly what it is. So we say that there's a generic callable

1783
02:42:43,840 --> 02:42:47,840
and is that a subtype of the instantiation? And my Pyright says yes.

1784
02:42:47,840 --> 02:42:51,840
Which is what I want. And all the other tools say that.

1785
02:42:51,840 --> 02:42:55,840
So what we really need

1786
02:42:55,840 --> 02:42:59,840
is something that we don't actually have spelled out, which is something like

1787
02:42:59,840 --> 02:43:03,840
consistent subtyping. So we need a notion of consistency

1788
02:43:03,840 --> 02:43:07,840
and we need a notion of subtyping and we need to combine them in a way that makes sense for the Python

1789
02:43:07,840 --> 02:43:11,840
subtyping system to come up with something like

1790
02:43:11,840 --> 02:43:15,840
consistent subtyping. So if we go back to the PEP again, we have a rule that says

1791
02:43:15,840 --> 02:43:19,840
that a type can be a subtype of another and another rule that says that any is consistent with

1792
02:43:19,840 --> 02:43:23,840
everything and that everything is consistent with any.

1793
02:43:23,840 --> 02:43:27,840
And this is pretty standard from what's known as gradual typing.

1794
02:43:27,840 --> 02:43:31,840
But these rules aren't complete. It doesn't allow us to conclude that

1795
02:43:31,840 --> 02:43:35,840
list of int is consistent with list, for instance.

1796
02:43:35,840 --> 02:43:39,840
Because there's no rule that lets us do that. So we have to allow

1797
02:43:39,840 --> 02:43:43,840
that the type argument has some relation. We also want to

1798
02:43:43,840 --> 02:43:47,840
conclude that, and we have to be careful there because list is invariant, so we don't want to

1799
02:43:47,840 --> 02:43:51,840
have a rule that allows us to conclude that list of int is consistent with list of flow.

1800
02:43:51,840 --> 02:43:55,840
We don't want that. We also want list of int to be consistent with

1801
02:43:55,840 --> 02:43:59,840
sequence. We would like,

1802
02:43:59,840 --> 02:44:03,840
I claim, to be able to characterize what is the best solution

1803
02:44:03,840 --> 02:44:07,840
to system constraints.

1804
02:44:07,840 --> 02:44:11,840
So we need something more than just

1805
02:44:11,840 --> 02:44:15,840
subtyping. So the conclusion of the call for action

1806
02:44:15,840 --> 02:44:19,840
is that we should actually respect for what we intend

1807
02:44:19,840 --> 02:44:23,840
to implement. Because perhaps we're building on this already.

1808
02:44:23,840 --> 02:44:27,840
Like, for instance, the variadic generic path assumes that there's some kind

1809
02:44:27,840 --> 02:44:31,840
of subtyping relation between variadic tuples. And not only variadic tuples,

1810
02:44:31,840 --> 02:44:35,840
variadic tuples can have a variadic bit in the middle somehow.

1811
02:44:35,840 --> 02:44:39,840
And we don't know what that is for sure. Of course checkers are always free to implement

1812
02:44:39,840 --> 02:44:43,840
anything they want, but they should be able to intentionally

1813
02:44:43,840 --> 02:44:47,840
implement a difference of intended behavior. And they should be able to

1814
02:44:47,840 --> 02:44:51,840
characterize what that is. And then we should be able to recognize bugs in the implementation.

1815
02:44:51,840 --> 02:44:55,840
So we should be able to eventually produce some kind of performance testing.

1816
02:44:55,840 --> 02:44:59,840
That's it. Thank you.

1817
02:44:59,840 --> 02:45:03,840
Applause

1818
02:45:07,840 --> 02:45:11,840
Questions?

1819
02:45:11,840 --> 02:45:15,840
Question?

1820
02:45:15,840 --> 02:45:19,840
Question?

1821
02:45:19,840 --> 02:45:23,840
Question?

1822
02:45:23,840 --> 02:45:27,840
Question?

1823
02:45:27,840 --> 02:45:31,840
Question?

1824
02:45:31,840 --> 02:45:35,840
Question?

1825
02:45:35,840 --> 02:45:39,840
Question?

1826
02:45:39,840 --> 02:45:43,840
Question?

1827
02:45:43,840 --> 02:45:47,840
Question?

1828
02:45:47,840 --> 02:45:51,840
Question?

1829
02:45:51,840 --> 02:45:55,840
Question?

1830
02:45:55,840 --> 02:45:59,840
Question?

1831
02:45:59,840 --> 02:46:03,840
definition of what should happen if you access the attribute of a union.

1832
02:46:03,840 --> 02:46:06,840
I don't think we have that specification.

1833
02:46:06,840 --> 02:46:09,840
I think that's a good point. I think you might be right.

1834
02:46:09,840 --> 02:46:12,840
And then I think we should write that down so we know that's what we should implement.

1835
02:46:12,840 --> 02:46:15,840
It's also not just a matter of what we should implement,

1836
02:46:15,840 --> 02:46:19,840
but it's also a matter of how we explain this to developers.

1837
02:46:19,840 --> 02:46:23,840
Because listening to developers talk, they actually do believe that they're the same.

1838
02:46:23,840 --> 02:46:26,840
So I think you might be right that they're different.

1839
02:46:26,840 --> 02:46:28,840
I think that interjection should be wrong.

1840
02:46:28,840 --> 02:46:31,840
This was again the slide that I put in at the last minute.

1841
02:46:31,840 --> 02:46:34,840
But I think you could be right.

1842
02:46:34,840 --> 02:46:37,840
I think we should decide that that's what it is. We should write it down.

1843
02:46:37,840 --> 02:46:41,840
I'm curious what the use case of any is.

1844
02:46:41,840 --> 02:46:43,840
Do we actually want it to be part of the type system?

1845
02:46:43,840 --> 02:46:46,840
Because I think right now Pyre paints it as an escape hatch,

1846
02:46:46,840 --> 02:46:49,840
where it's like, I don't want you to type check things against this.

1847
02:46:49,840 --> 02:46:53,840
This should just be excluded, essentially. It should be consistent with everything.

1848
02:46:53,840 --> 02:46:57,840
In that sense, if you join something to it, we basically say,

1849
02:46:57,840 --> 02:47:01,840
since it can sometimes be any, you still don't want type errors against it.

1850
02:47:01,840 --> 02:47:06,840
So in that sense, it's a different application than just an object, I guess.

1851
02:47:06,840 --> 02:47:11,840
So Shannon was saying that what is the status of any?

1852
02:47:11,840 --> 02:47:13,840
I think there's different answers to that.

1853
02:47:13,840 --> 02:47:17,840
So the system that Python has seems to be based on gradual typing.

1854
02:47:17,840 --> 02:47:23,840
And the gradual typing view of any, or dynamic, or whatever you call that type,

1855
02:47:23,840 --> 02:47:25,840
is that it's an arbitrary static type.

1856
02:47:25,840 --> 02:47:29,840
So at some point, there's some static type that you could eventually write in there

1857
02:47:29,840 --> 02:47:32,840
that would be the static type.

1858
02:47:32,840 --> 02:47:36,840
And so from that standpoint, so that's one view of any.

1859
02:47:36,840 --> 02:47:41,840
Another view of any is that you just take a very naive, stat theoretic idea of what types are,

1860
02:47:41,840 --> 02:47:45,840
their sets of values, and then any describes a set of all Python values.

1861
02:47:45,840 --> 02:47:47,840
So it's a kind of top type.

1862
02:47:47,840 --> 02:47:49,840
That's what we did.

1863
02:47:49,840 --> 02:47:51,840
Yeah, that's what we did in Dart.

1864
02:47:51,840 --> 02:47:53,840
Object is a top type, and any was a top type.

1865
02:47:53,840 --> 02:47:57,840
But any had a special property that you can then reverse that type error.

1866
02:47:57,840 --> 02:48:01,840
I think Python has intentionally chosen something which is a little more subtle than that, though,

1867
02:48:01,840 --> 02:48:05,840
that it's not explicitly a top type with respect to subtyping.

1868
02:48:05,840 --> 02:48:08,840
Kind of both a top type and a bottom type.

1869
02:48:08,840 --> 02:48:11,840
Well, it's why we have this separate consistency.

1870
02:48:11,840 --> 02:48:16,840
So the comment was that it's both a top type and a bottom type.

1871
02:48:16,840 --> 02:48:20,840
I would say that I think it's a top type with respect to consistent subtyping,

1872
02:48:20,840 --> 02:48:24,840
and a bottom type with respect to consistent subtyping.

1873
02:48:24,840 --> 02:48:26,840
But not with respect to subtyping.

1874
02:48:26,840 --> 02:48:30,840
That's the way out of that maze that we're in.

1875
02:48:30,840 --> 02:48:34,840
Please write a new version of that for a free version.

1876
02:48:34,840 --> 02:48:36,840
Anybody?

1877
02:48:36,840 --> 02:48:41,840
Yeah, I think that's a possible way forward.

1878
02:48:41,840 --> 02:48:43,840
Another pat.

1879
02:48:47,840 --> 02:48:51,840
I know this hearing council requested one type of piece of this stuff.

1880
02:48:51,840 --> 02:48:53,840
I think you've got those specifications.

1881
02:48:53,840 --> 02:48:59,840
It would be potentially really great to have this shed as sweet as possible.

1882
02:48:59,840 --> 02:49:01,840
Do you have a subtype, Tom?

1883
02:49:01,840 --> 02:49:04,840
Yeah, I agree absolutely with that.

1884
02:49:04,840 --> 02:49:09,840
Those are the other...

1885
02:49:09,840 --> 02:49:10,840
Over here.

1886
02:49:10,840 --> 02:49:15,840
You have made a claim that we need this notion of the best solution of constraints.

1887
02:49:15,840 --> 02:49:20,840
I was wondering what the envision usefulness other than the new type.

1888
02:49:20,840 --> 02:49:23,840
What is it useful to have the best solution?

1889
02:49:23,840 --> 02:49:29,840
Well, since we want sub-order on types and we want to choose the least solution...

1890
02:49:29,840 --> 02:49:31,840
When are you forced to choose the solution?

1891
02:49:31,840 --> 02:49:33,840
That's the question.

1892
02:49:33,840 --> 02:49:36,840
When are you forced to choose the solution?

1893
02:49:36,840 --> 02:49:39,840
When are you forced to solve, choose a solution?

1894
02:49:39,840 --> 02:49:40,840
Yes.

1895
02:49:40,840 --> 02:49:44,840
The way that generic functions usually work is that when you apply the function,

1896
02:49:44,840 --> 02:49:47,840
you choose instantiation of the function based on the types of the arguments.

1897
02:49:47,840 --> 02:49:51,840
At that point you have to generate constraints and then choose a solution.

1898
02:49:51,840 --> 02:49:57,840
If you choose a solution that's too big, then you can have spurious...

1899
02:50:03,840 --> 02:50:05,840
Another question.

1900
02:50:05,840 --> 02:50:11,840
I think one other similar place where type checkers vary on overloads.

1901
02:50:11,840 --> 02:50:13,840
What overload do you take?

1902
02:50:13,840 --> 02:50:17,840
Whenever there's some having really different type checkers will kind of take their own overload.

1903
02:50:17,840 --> 02:50:22,840
You need to see what their own...

1904
02:50:22,840 --> 02:50:24,840
So the comment was about overloads.

1905
02:50:24,840 --> 02:50:28,840
So yeah, type checkers should somehow statically resolve overloads.

1906
02:50:28,840 --> 02:50:30,840
And that's completely unspecified.

1907
02:50:30,840 --> 02:50:35,840
Okay.

1908
02:50:35,840 --> 02:50:37,840
Excellent. Thank you.

1909
02:50:37,840 --> 02:50:43,840
Applause.

1910
02:50:49,840 --> 02:50:52,840
I do have slides, but they're just talking points.

1911
02:50:52,840 --> 02:50:56,840
And yes, panelists might want to...

1912
02:50:56,840 --> 02:51:01,840
I'll try to read them. They're not very much.

1913
02:51:01,840 --> 02:51:12,840
I went over my inbox and looked for a few juicy quotes from people who don't seem to completely have bought into the typing overloads.

1914
02:51:12,840 --> 02:51:19,840
Here's a really long time Python core that he was in the Python community since 1994.

1915
02:51:19,840 --> 02:51:27,840
I'm going to come out as a strong minus one for sneaking anything typing related into even any built-in.

1916
02:51:27,840 --> 02:51:33,840
I don't know why I'm doing this. Maybe I...

1917
02:51:33,840 --> 02:51:36,840
Okay.

1918
02:51:36,840 --> 02:51:38,840
And this was...

1919
02:51:38,840 --> 02:51:47,840
The discussion was normally about should we add any as a built-in, but he read a whole lot into it and sort of clearly vented it.

1920
02:51:47,840 --> 02:51:50,840
Some of you may recognize who this is.

1921
02:51:50,840 --> 02:51:56,840
Python looks more and more like a language with typed declarations as a built-in particle language.

1922
02:51:56,840 --> 02:52:01,840
Its beauty has always been its simplicity, such is not the case anymore.

1923
02:52:01,840 --> 02:52:08,840
And then Fredrik Lund or someone else have both collaborate, set one, two, three, four, five, whatever.

1924
02:52:08,840 --> 02:52:11,840
I think they both said it.

1925
02:52:11,840 --> 02:52:13,840
But who said it first?

1926
02:52:13,840 --> 02:52:16,840
So here's another core dev.

1927
02:52:16,840 --> 02:52:25,840
Not quite as ancient, but someone who says, I do actually like typed annotations in straightforward situations.

1928
02:52:25,840 --> 02:52:29,840
They even found blogs for me and tool tips and PSPode are nice.

1929
02:52:29,840 --> 02:52:35,840
What I don't like is not being able to stick to simple stuff and not bother in annotating complicated bits.

1930
02:52:35,840 --> 02:52:44,840
Or being pushed into over strict annotations because it's too hard or too proposed to express dynamic type constraints.

1931
02:52:44,840 --> 02:52:55,840
This sounds like someone who would like to sprinkle generous amounts of any throughout their code or just leaving things unannotated.

1932
02:52:55,840 --> 02:53:01,840
And I know that VS Code in particular, or Instrict Mode, is really annoying about that.

1933
02:53:01,840 --> 02:53:11,840
Here is someone who's not a core dev, but I thought there was a general understanding that when typing was added to Python,

1934
02:53:11,840 --> 02:53:24,840
I presume he refers to Python 4.4, there would be no impact or at least minimal impact on people who didn't use it.

1935
02:53:24,840 --> 02:53:27,840
Oh, I remember who this is.

1936
02:53:27,840 --> 02:53:31,840
Now we see another instance of the attention creep.

1937
02:53:31,840 --> 02:53:37,840
This person has a really good view of where Python is going.

1938
02:53:37,840 --> 02:53:44,840
And then there was a core dev who just said, my grasp on the details of typing is tenuous and mixed.

1939
02:53:44,840 --> 02:53:51,840
Ah, okay, well I'll unplug because clearly my USB ports are not what they used to be.

1940
02:53:54,840 --> 02:53:55,840
Thank you, thank you.

1941
02:53:55,840 --> 02:53:56,840
It's okay.

1942
02:53:56,840 --> 02:54:03,840
I would also interject that the most recent talk you just saw, sorry, my own fancy statement, Kevin.

1943
02:54:03,840 --> 02:54:16,840
Almost everyone who's a core dev who's not in this room and several core devs who are in this room would feel that went straight over their head.

1944
02:54:16,840 --> 02:54:21,840
And also too esoteric, too bothered to learn more about Python.

1945
02:54:21,840 --> 02:54:36,840
So this sort of gets into the sort of accusation that the typing folks, the folks who either implemented type checkers or are heavy users of type checkers,

1946
02:54:36,840 --> 02:54:51,840
and want all their code to type correctly have lost sort of touch with the vast majority of Python core devs and possibly Python users.

1947
02:54:55,840 --> 02:54:57,840
I have no questions prepared.

1948
02:54:57,840 --> 02:55:14,840
I think that we had sort of an email thread where we all vetted about what kind of things went wrong between some typing folks and the core dev team and the steering council.

1949
02:55:14,840 --> 02:55:19,840
I think Matthew, I'd like to hear your experience a bit.

1950
02:55:19,840 --> 02:55:24,840
Can you say a bit more about your experience with getting a big typing company accepted?

1951
02:55:24,840 --> 02:55:35,840
Yeah. So with PEP 646, variadic generics, we initially thought, oh, this is just going to be the small things, like necessary prerequisite for other types of typing.

1952
02:55:35,840 --> 02:55:40,840
I mean, no problem at all. Maybe a few weeks. Two years later it's finally been accepted.

1953
02:55:40,840 --> 02:55:45,840
It's been accepted twice, by the way. It's been accepted twice. Wow.

1954
02:55:45,840 --> 02:55:57,840
I think the takeaway I actually realized while all the other folks were typing on this thread was just the importance of really aiming for keeping the practices as small as possible.

1955
02:55:57,840 --> 02:56:11,840
I think we both just weren't strict enough. We weren't strict enough about this in the first place, but I think also PEP 4.8.4 is a precedent of, hey, you're introducing a new feature.

1956
02:56:11,840 --> 02:56:19,840
Implement all the things. Whereas I think in retrospect we should have literally just been like, hey, what's the smallest chunk of this we can implement first?

1957
02:56:19,840 --> 02:56:24,840
And then go from there. I'd say other than that, though, my experience was very positive.

1958
02:56:24,840 --> 02:56:32,840
I thought the steering council was very understanding of the fact that, oh yeah, we had this last minute realization that there was a bug we needed to fix.

1959
02:56:32,840 --> 02:56:40,840
And the steering council did charge us a little bit, but we were very appreciative of the implementation process and accepted the second time.

1960
02:56:40,840 --> 02:56:45,840
My advice on that one is really we should have a policy of trying to keep PEPs as small as possible.

1961
02:56:45,840 --> 02:56:55,840
So encouraging people who are writing PEPs to do that. But yeah, some members of the court have, like, yeah, they have to have that confidence.

1962
02:56:55,840 --> 02:57:04,840
I'd like to say, the chiding bit, you had the bad luck of being the second one PEP that came with changes after we started considering it.

1963
02:57:04,840 --> 02:57:11,840
So we felt we needed, not for you as such, but for everyone, to remind everyone, don't waste our time.

1964
02:57:11,840 --> 02:57:17,840
And I mean, it's not that big a deal, but if everyone does it, it does become a big deal.

1965
02:57:17,840 --> 02:57:25,840
It's also important to understand that to you, especially when you modify it, it's a lot of time.

1966
02:57:25,840 --> 02:57:31,840
Because it doesn't work in a way that we go into the room and say, what do you think, what do you think, plus what have I done.

1967
02:57:31,840 --> 02:57:34,840
And that's not the way because our job is not to decide ourselves.

1968
02:57:34,840 --> 02:57:38,840
Mainly, that's the last resort is to reflect what the Python community thinks.

1969
02:57:38,840 --> 02:57:48,840
So it's literally going to all those mailings and like all be mailed by email, making sure that we understand all positions, what are the different gaps if they are,

1970
02:57:48,840 --> 02:57:53,840
and to make sure that every possible complaint that people have or things like that is reflected.

1971
02:57:53,840 --> 02:58:00,840
And if there is a last minute addition or change, it's just we need to go back and check everything against the new version.

1972
02:58:00,840 --> 02:58:04,840
So it's not about like, you know, we are very important people with, you know, our time is ready.

1973
02:58:04,840 --> 02:58:08,840
It's also like, it just doubles the time and we have like a huge queue.

1974
02:58:08,840 --> 02:58:14,840
Well, not anymore. We have a huge queue. We have to work through it.

1975
02:58:14,840 --> 02:58:16,840
Yeah, for now.

1976
02:58:16,840 --> 02:58:26,840
I'd like to invite Pradeep to say a few things about your experience with a PEP that didn't get accepted after,

1977
02:58:26,840 --> 02:58:31,840
I would say a lot of the dates in this group.

1978
02:58:31,840 --> 02:58:34,840
Yeah, so that is the callable syntax.

1979
02:58:34,840 --> 02:58:39,840
I think most of the typing sync community wants nice syntax for callable.

1980
02:58:39,840 --> 02:58:41,840
It's the most complicated type we have.

1981
02:58:41,840 --> 02:58:45,840
So beginning of the middle of last year, we all started discussing it.

1982
02:58:45,840 --> 02:58:48,840
Huge debates, lots of possible approaches.

1983
02:58:48,840 --> 02:58:52,840
We sort of narrowed it down, read on stuff.

1984
02:58:52,840 --> 02:59:08,840
But then when we went to Python there, we got a lot of strong pushback in one thread towards the end saying that it's troubling to see Python becoming more complicated for the sake of typing and making the language syntax more complicated.

1985
02:59:08,840 --> 02:59:12,840
So I think from that point onward, it's like a pretty hard set.

1986
02:59:12,840 --> 02:59:14,840
Several of those people.

1987
02:59:14,840 --> 02:59:16,840
Yeah.

1988
02:59:16,840 --> 02:59:23,840
Yeah, I think one question I had was what recommendation do you have for somebody who is ready to type a syntax book?

1989
02:59:23,840 --> 02:59:30,840
Should we try to open more non-typing code for folks early in the process?

1990
02:59:30,840 --> 02:59:43,840
It's hard to say because I understand the need for a lot of those changes is from the typing theory, which is fairly esoteric, if that's fair to say.

1991
02:59:43,840 --> 03:00:00,840
So for someone who doesn't care about static typing at all, or type announce at all, or dynamic typing at all, for them to be pulling and saying, hey, what do you think of the syntax for this use case, if they don't understand the use case and why it's important to be able to express those things, that's not going to end well.

1992
03:00:00,840 --> 03:00:02,840
That's just...

1993
03:00:02,840 --> 03:00:07,840
Well, I mean, they have to put in the effort to understand it, right?

1994
03:00:07,840 --> 03:00:13,840
So if there are core developers who are interested, then absolutely, if they want to.

1995
03:00:13,840 --> 03:00:16,840
But if it's not, you know, if you don't find something...

1996
03:00:16,840 --> 03:00:23,840
The core developers who are interested are probably already on the typing side.

1997
03:00:23,840 --> 03:00:26,840
Well, yeah, it's always me.

1998
03:00:26,840 --> 03:00:32,840
I think there is two sides of this story, because what happens for...

1999
03:00:32,840 --> 03:00:37,840
I mean, this is true for typing, but it's also true for other very specialized.

2000
03:00:37,840 --> 03:00:40,840
When you discuss, you say, okay, we have this problem, right?

2001
03:00:40,840 --> 03:00:45,840
And then you go to the specialized group and you say, can we find the best solution for this problem once we all think it's a problem?

2002
03:00:45,840 --> 03:00:51,840
And then you spend all this time and you iterate that it's hard work and, you know, like, I understand how hard it is.

2003
03:00:51,840 --> 03:00:58,840
But then you go to the general community and they may actually have questions about the problem at the end of your stack, right?

2004
03:00:58,840 --> 03:01:06,840
They say, okay, maybe it's a problem, but it's not worth solving, or at least with new syntax or the cost is not big.

2005
03:01:06,840 --> 03:01:11,840
So, you know, maybe you are spending all this time trying to find the resolution for the problem,

2006
03:01:11,840 --> 03:01:15,840
while maybe the bigger community doesn't think it's a problem worth solving with the cost that you're adding.

2007
03:01:15,840 --> 03:01:20,840
And trying to find, like, a solution or if that is the case, it's actually very challenging,

2008
03:01:20,840 --> 03:01:26,840
because as Thomas said, if you go to Python there, you now need to filter all the people that don't understand the problem.

2009
03:01:26,840 --> 03:01:31,840
And it's very hard for us as well, because we need to balance both things.

2010
03:01:31,840 --> 03:01:38,840
And many people don't understand that, you know, sometimes they come with a problem and they say, okay, but this is a problem, right?

2011
03:01:38,840 --> 03:01:40,840
And this is the solution and this is the best solution.

2012
03:01:40,840 --> 03:01:43,840
And then we say, no. And they say, why?

2013
03:01:43,840 --> 03:01:48,840
It's the resolution, because, you know, yes, it's a problem, but maybe it's not worth solving with more syntax, right?

2014
03:01:48,840 --> 03:01:51,840
Or whatever it is. There doesn't need to be syntax versus non-syntax.

2015
03:01:51,840 --> 03:01:55,840
So, I understand this quite hard. I don't think we have a magical solution.

2016
03:01:55,840 --> 03:02:02,840
We are quite approachable in the sense that you want to contact the string class before some kind of early recommendation,

2017
03:02:02,840 --> 03:02:09,840
or like maybe we say, for instance, a paper like the Collabor syntax that involves a lot of, you know, big changes.

2018
03:02:09,840 --> 03:02:14,840
You could contact the string class and say, okay, so what do you think is the best strategy here?

2019
03:02:14,840 --> 03:02:17,840
So, I can contact Python and I'm like, what do you think may happen?

2020
03:02:17,840 --> 03:02:23,840
So, you may be, you will have as much information as possible so you can have better decisions.

2021
03:02:23,840 --> 03:02:30,840
I know this is going to take a lot of time, but it's a tough problem, because it's a human problem at the end of the day.

2022
03:02:30,840 --> 03:02:35,840
And I think the thing is, there's a problem that needs to be solved.

2023
03:02:35,840 --> 03:02:44,840
The problem has a cost, like the fact that a problem exists causes all kinds of extra work that needs to be done, unreadable code, etc.

2024
03:02:44,840 --> 03:02:49,840
The solution also has problems. It also has a cost.

2025
03:02:49,840 --> 03:02:55,840
And those costs will be different, because if you don't use static typing, then the cost of not having all those syntax is zero.

2026
03:02:55,840 --> 03:03:01,840
So, any solution that's going to cost you anything is going to be a negative.

2027
03:03:01,840 --> 03:03:14,840
So, we need to make sure that we make clear how big of a problem it really is and how costly the solution is for others.

2028
03:03:14,840 --> 03:03:19,840
So that we can convince people that, yes, this is worth the cost.

2029
03:03:19,840 --> 03:03:28,840
Now, for the callable syntax, the Serial Council would announce on our own, like not even, ignore, not ignoring,

2030
03:03:28,840 --> 03:03:38,840
but not even considering the rest of Python Dev, that the syntax, the cost of the syntax was just too big for the problem.

2031
03:03:38,840 --> 03:03:45,840
And, I mean, it's an art thing to say, it's like, yeah, that problem isn't important enough to solve.

2032
03:03:45,840 --> 03:03:51,840
It is important, and we wish it could solve it, but not form the cost of that particular syntax,

2033
03:03:51,840 --> 03:03:58,840
because it had all kinds of small issues and larger issues, and it made complicated rules about precedence.

2034
03:03:58,840 --> 03:04:03,840
And, yeah, that's why we decided that particular pet is not worth it.

2035
03:04:03,840 --> 03:04:08,840
But that doesn't mean the problem isn't worth solving. We just don't have a good way of solving it.

