1
00:00:00,000 --> 00:00:08,400
Hello, welcome to the second session.

2
00:00:08,400 --> 00:00:09,400
My name is Jonas.

3
00:00:09,400 --> 00:00:14,200
I'll be the session chair for the next three talks and introduce the speakers.

4
00:00:14,200 --> 00:00:18,200
Make sure you come to the front if you're comfortable so you can see the slides.

5
00:00:18,200 --> 00:00:23,280
Our first speaker in the session is Reuven Lerner, who will be talking about understanding

6
00:00:23,280 --> 00:00:24,280
attributes.

7
00:00:24,280 --> 00:00:28,600
Allegedly, they are not nearly as boring as you might think.

8
00:00:28,600 --> 00:00:29,600
Hi, everyone.

9
00:00:29,600 --> 00:00:30,600
Wow.

10
00:00:30,600 --> 00:00:37,600
It is so nice to see people in three dimensions.

11
00:00:37,600 --> 00:00:39,600
You have no idea.

12
00:00:39,600 --> 00:00:40,600
Maybe you do.

13
00:00:40,600 --> 00:00:43,400
Maybe you've been experiencing, you might have heard there's a bit of a pandemic going

14
00:00:43,400 --> 00:00:44,400
around.

15
00:00:44,400 --> 00:00:48,680
In any event, my name is Reuven, and I teach Python for a living.

16
00:00:48,680 --> 00:00:52,000
I've been doing this since, I've been in business since 1995.

17
00:00:52,000 --> 00:00:53,360
I do corporate training.

18
00:00:53,360 --> 00:00:55,000
I do video training, hybrid training.

19
00:00:55,000 --> 00:00:57,480
I have this thing called weekly Python exercise.

20
00:00:57,480 --> 00:00:58,480
I have books.

21
00:00:58,480 --> 00:01:01,840
Panda's workout, Python workout.

22
00:01:01,840 --> 00:01:07,480
You're welcome to come to my booth, ask questions afterwards, and even get swag and a raffle

23
00:01:07,480 --> 00:01:08,880
on my books.

24
00:01:08,880 --> 00:01:11,280
But let's get into the topic at hand.

25
00:01:11,280 --> 00:01:13,080
Let's assign to a variable.

26
00:01:13,080 --> 00:01:14,280
Exciting, right?

27
00:01:14,280 --> 00:01:18,520
So here I say x equals 100.

28
00:01:18,520 --> 00:01:19,520
What's going on here?

29
00:01:19,520 --> 00:01:21,080
I'll tell you what it does not mean.

30
00:01:21,080 --> 00:01:26,640
So many people who come from the C world, and we have to sort of be nice to them, pity

31
00:01:27,280 --> 00:01:30,920
them, but basically people from the C world sort of believe that when you say x equals

32
00:01:30,920 --> 00:01:35,400
five, what you're doing is you're taking a variable, which is basically an alias to

33
00:01:35,400 --> 00:01:41,120
a memory location, and you're saying I want to stick that value into that memory location.

34
00:01:41,120 --> 00:01:42,960
That's not how it works in Python.

35
00:01:42,960 --> 00:01:46,920
This does not mean put the value of 100 in the memory location called x.

36
00:01:46,920 --> 00:01:53,200
What it does mean is the name x should now refer to the integer object 100.

37
00:01:53,200 --> 00:01:55,400
A totally different kind of thing.

38
00:01:55,400 --> 00:01:57,000
And we can see this really nicely.

39
00:01:57,000 --> 00:02:01,400
For those of you who aren't familiar with it, the Python tutor site, Python tutor.com

40
00:02:01,400 --> 00:02:04,040
for Philip Gwell, amazing, amazing stuff.

41
00:02:04,040 --> 00:02:07,680
And we can see here on the left we have the variable x, the global variable x, and it's

42
00:02:07,680 --> 00:02:10,720
referring to an integer object 100.

43
00:02:10,720 --> 00:02:11,720
So far so good.

44
00:02:11,720 --> 00:02:14,080
Let's get a little fancier.

45
00:02:14,080 --> 00:02:16,760
Let's create a class, a do nothing class.

46
00:02:16,760 --> 00:02:19,240
Class my class, pass.

47
00:02:19,240 --> 00:02:23,120
And then I say x equals an instance of my class.

48
00:02:23,120 --> 00:02:27,920
Now what I'm going to do is I'm going to say x.y equals 100.

49
00:02:27,920 --> 00:02:29,400
What am I doing here?

50
00:02:29,400 --> 00:02:32,160
I am not assigning to x.

51
00:02:32,160 --> 00:02:34,040
I am assigning to x.y.

52
00:02:34,040 --> 00:02:37,760
I am creating an attribute on x.

53
00:02:37,760 --> 00:02:40,360
Y is not a variable.

54
00:02:40,360 --> 00:02:42,840
And it's very important to keep track of that and to understand that.

55
00:02:42,840 --> 00:02:46,960
We have two totally separate storage systems in Python.

56
00:02:46,960 --> 00:02:51,040
And here we see then that x refers to an instance of my class.

57
00:02:51,040 --> 00:02:56,680
And in that class we have the attribute y with a value of 100.

58
00:02:56,680 --> 00:03:00,860
Now every single object in Python has attributes, every single one.

59
00:03:00,860 --> 00:03:04,920
And you can think of them as a private dictionary on the object.

60
00:03:04,920 --> 00:03:09,900
But instead of using square brackets you're using a dot to either set or retrieve them.

61
00:03:09,900 --> 00:03:12,340
And the attribute does not exist in the variable.

62
00:03:12,340 --> 00:03:18,200
So while we colloquially could say yes, x has an attribute y, realistically x is the

63
00:03:18,560 --> 00:03:24,440
variable referring to that object, and the object has the attribute y.

64
00:03:24,440 --> 00:03:28,120
So we can retrieve from attributes really easily.

65
00:03:28,120 --> 00:03:31,600
I can say, for example, sys.version.

66
00:03:31,600 --> 00:03:32,600
I do import sys.

67
00:03:32,600 --> 00:03:36,680
I've created the global variable sys which refers to a module object.

68
00:03:36,680 --> 00:03:41,400
So sys is a variable and version is an attribute on that variable.

69
00:03:41,400 --> 00:03:43,720
And it gets me back the version of Python I'm running.

70
00:03:43,720 --> 00:03:47,000
I can say str.upper of abc.

71
00:03:47,000 --> 00:03:49,560
Upper is a global variable, actually it's a built in, right?

72
00:03:49,560 --> 00:03:52,400
It's a variable that refers to the string class.

73
00:03:52,400 --> 00:03:54,800
Upper is a method on that.

74
00:03:54,800 --> 00:03:58,960
And then I can, once I retrieve that method object, actually a function object, then I

75
00:03:58,960 --> 00:04:03,240
can use parentheses to invoke it and get back a result.

76
00:04:03,240 --> 00:04:06,660
And similarly I can say random.randint of 0 to 100.

77
00:04:06,660 --> 00:04:08,120
Random is a module.

78
00:04:08,120 --> 00:04:09,120
Randint is a method.

79
00:04:09,120 --> 00:04:12,520
I get that method object back and I invoke it.

80
00:04:12,520 --> 00:04:15,600
So far so good.

81
00:04:15,600 --> 00:04:20,560
Just like variables, attributes can contain any Python object at all.

82
00:04:20,560 --> 00:04:21,560
It can be data.

83
00:04:21,560 --> 00:04:23,280
It can be a function.

84
00:04:23,280 --> 00:04:28,880
Absolutely anything can be in an attribute just as absolutely anything can be in a variable.

85
00:04:28,880 --> 00:04:31,000
What if I want to set attributes?

86
00:04:31,000 --> 00:04:35,440
Well with pretty rare exceptions, typically having to do with built ins that are written

87
00:04:35,440 --> 00:04:39,780
in C, you can set any attribute on any object you want in Python.

88
00:04:39,780 --> 00:04:43,720
So here, assuming I have an object that's not one of the built in types, I can say x.y

89
00:04:43,760 --> 00:04:49,840
equals 100 and I will have added that attribute to the object.

90
00:04:49,840 --> 00:04:54,240
Or if the attribute already exists, then I replace the previous version with the new

91
00:04:54,240 --> 00:04:55,240
version.

92
00:04:55,240 --> 00:04:58,440
And if that sounds a lot like a dictionary, guess what?

93
00:04:58,440 --> 00:05:00,480
It's a lot like a dictionary.

94
00:05:00,480 --> 00:05:07,000
So some of you might remember the difficulty and pain that we had in upgrading Python 2

95
00:05:07,000 --> 00:05:08,000
to Python 3.

96
00:05:08,000 --> 00:05:11,120
Well, I have an easier solution.

97
00:05:11,520 --> 00:05:18,960
I've now upgraded Python 4 with no pain whatsoever.

98
00:05:18,960 --> 00:05:24,720
You see then I can set absolutely positively any value I want, on absolutely positively

99
00:05:24,720 --> 00:05:29,160
any attribute I want, on absolutely positively any object I want.

100
00:05:29,160 --> 00:05:36,820
But you know, why would I set version to be 4 when if I set it to 4.20, Elon Musk comes

101
00:05:36,820 --> 00:05:38,960
and buys Python.

102
00:05:39,800 --> 00:05:44,360
Okay, we actually set attributes all the time.

103
00:05:44,360 --> 00:05:45,360
All the time.

104
00:05:45,360 --> 00:05:46,640
We don't think about it very much.

105
00:05:46,640 --> 00:05:50,680
If I create a new class, class person, I'm going to have depthDunderInit.

106
00:05:50,680 --> 00:05:51,680
What is DunderInit?

107
00:05:51,680 --> 00:05:53,560
I'll tell you what it isn't.

108
00:05:53,560 --> 00:05:55,560
It isn't the constructor method.

109
00:05:55,560 --> 00:05:58,160
It's not creating a new object.

110
00:05:58,160 --> 00:06:02,840
After the new object has already been created, DunderInit is invoked to add attributes to

111
00:06:02,840 --> 00:06:03,840
the object.

112
00:06:03,840 --> 00:06:06,440
That is the role of DunderInit.

113
00:06:06,440 --> 00:06:09,440
If you don't have attributes on your object, don't have DunderInit.

114
00:06:09,440 --> 00:06:12,320
If you don't have attributes on your object, then you've got other issues.

115
00:06:12,320 --> 00:06:14,440
But let's not talk about that right now.

116
00:06:14,440 --> 00:06:16,100
And then I get self and name.

117
00:06:16,100 --> 00:06:18,040
So self is the instance.

118
00:06:18,040 --> 00:06:20,120
It's the new instance that was just created.

119
00:06:20,120 --> 00:06:24,160
And name is the parameter, the local variable that contains the value.

120
00:06:24,160 --> 00:06:28,520
And then what I do is I take that value name and assign to self.name.

121
00:06:28,520 --> 00:06:30,120
And self, of course, is that new instance.

122
00:06:30,120 --> 00:06:33,100
So I'm adding an attribute to that instance.

123
00:06:33,100 --> 00:06:34,560
And now the object has it.

124
00:06:34,560 --> 00:06:36,760
Now it's referred to here by self.

125
00:06:36,760 --> 00:06:41,280
But of course, outside of the method, outside of DunderInit, that object is going to have

126
00:06:41,280 --> 00:06:44,360
a different name, a different reference, a different variable.

127
00:06:44,360 --> 00:06:47,000
For example, P1 and P2.

128
00:06:47,000 --> 00:06:50,040
Now while DunderInit is running, we can see what's going on.

129
00:06:50,040 --> 00:06:54,360
We have the global variable, person, which refers to the person class.

130
00:06:54,360 --> 00:06:58,560
And then inside of DunderInit, we have two local variables, self, which refers to the

131
00:06:58,560 --> 00:06:59,720
person instance.

132
00:06:59,720 --> 00:07:05,240
And we can see then that self has an attribute called name, and its value is name1, which

133
00:07:05,240 --> 00:07:09,140
we got assigned to from that variable name1.

134
00:07:09,140 --> 00:07:13,220
Then when we return it, well here we go, we've got name and name1, fine.

135
00:07:13,220 --> 00:07:19,960
When we return it, P1 is referring to that instance, which still has the attribute name,

136
00:07:19,960 --> 00:07:22,040
and we have the value name1.

137
00:07:22,040 --> 00:07:25,320
OK, not too bad, not too shabby.

138
00:07:25,320 --> 00:07:27,740
Let's make this a little more interesting.

139
00:07:27,740 --> 00:07:29,280
What's missing from this program?

140
00:07:30,080 --> 00:07:36,760
Let's assume that this is our startup's crown jewels.

141
00:07:36,760 --> 00:07:41,160
It's such a great program, to be able to create a person like this, clearly we're

142
00:07:41,160 --> 00:07:43,040
going to go public pretty soon.

143
00:07:43,040 --> 00:07:49,320
But my manager has come in and said, I've spoken to our customers, and they demand new

144
00:07:49,320 --> 00:07:52,180
functionality, customers.

145
00:07:52,180 --> 00:07:57,480
They want us to keep track of how many people we're creating in our virtual world, our

146
00:07:57,480 --> 00:08:03,080
virtual universe, our metaverse, if you will, to coin a phrase.

147
00:08:03,080 --> 00:08:06,240
So let's keep track of the population as we add people there.

148
00:08:06,240 --> 00:08:09,720
OK, well how am I going to do that?

149
00:08:09,720 --> 00:08:12,880
Well here's one idea, I could use a global variable for that, right?

150
00:08:12,880 --> 00:08:13,880
That's a fantastic idea.

151
00:08:13,880 --> 00:08:16,600
It's not a fantastic idea.

152
00:08:16,600 --> 00:08:20,120
So I'm going to say here, population equals zero, I'm going to create that global variable,

153
00:08:20,120 --> 00:08:23,100
then I'm going to create the class, and here's what I'm going to do.

154
00:08:23,100 --> 00:08:26,280
Every single time I create a new instance, we're going to go through Dunder init.

155
00:08:26,280 --> 00:08:29,800
And so every single time, I can add one to the population.

156
00:08:29,800 --> 00:08:34,880
And so before I create my instances, I'm going to say before population equals that, and

157
00:08:34,880 --> 00:08:37,280
afterwards I'm going to say population equals that, it's going to start at zero, it's going

158
00:08:37,280 --> 00:08:41,600
to end at two, it's going to be fantastic until it's not.

159
00:08:41,600 --> 00:08:43,040
Unbound local error.

160
00:08:43,040 --> 00:08:48,800
I hope each of you has a favorite Python error, because this is my favorite one.

161
00:08:48,800 --> 00:08:51,080
Because it confuses the heck out of all sorts of people.

162
00:08:51,080 --> 00:08:53,400
Unbound local error, what does that mean?

163
00:08:53,400 --> 00:08:56,640
Well, binding is a way of saying assignment.

164
00:08:56,640 --> 00:09:03,340
It basically means, hey, dummy, you have a local variable that doesn't have a value,

165
00:09:03,340 --> 00:09:05,360
but you're trying to retrieve that value anyway.

166
00:09:05,360 --> 00:09:07,400
Well, wait, how can that be?

167
00:09:07,400 --> 00:09:12,480
Because normally in Python, I mean, look, in other languages, you can declare a variable

168
00:09:12,480 --> 00:09:14,920
and then not give it a value, and you can end up with this sort of thing.

169
00:09:14,920 --> 00:09:16,560
But in Python, we don't have declarations.

170
00:09:16,560 --> 00:09:19,920
Well, other than, whoa, what an amazing language.

171
00:09:19,920 --> 00:09:24,400
So basically, how can I have a variable that doesn't have a value?

172
00:09:24,400 --> 00:09:26,180
And the answer is because it's local.

173
00:09:26,180 --> 00:09:29,800
Because when I'm inside of dunder init there, I'm inside of a function.

174
00:09:29,800 --> 00:09:36,480
And inside of a function, if I assign to a variable, that variable is local by definition.

175
00:09:36,480 --> 00:09:41,160
Python keeps track of this and says, aha, you assigned a population, population is local.

176
00:09:41,160 --> 00:09:43,380
But that's a compilation time.

177
00:09:43,380 --> 00:09:48,560
Then I run the function and it says, okay, I need one plus the current value of, oh my

178
00:09:48,560 --> 00:09:51,920
God, unbound local error.

179
00:09:51,920 --> 00:09:53,400
So what am I going to do?

180
00:09:53,400 --> 00:09:56,920
Well, one possibility is to use global.

181
00:09:56,920 --> 00:09:58,540
Not a good solution.

182
00:09:58,540 --> 00:09:59,540
One possibility is to use global.

183
00:09:59,540 --> 00:10:04,680
And the global statement says, hey, Python, when you compile this function, don't record

184
00:10:04,680 --> 00:10:07,480
population as a local variable.

185
00:10:07,480 --> 00:10:09,040
Pay no attention to that.

186
00:10:09,040 --> 00:10:10,920
Instead, assign to the global variable.

187
00:10:10,920 --> 00:10:12,480
And indeed, that works.

188
00:10:12,480 --> 00:10:16,960
I can say here population equals zero, here we'll get zero, here we'll get two.

189
00:10:16,960 --> 00:10:18,880
All is good.

190
00:10:18,880 --> 00:10:20,200
But it's not.

191
00:10:20,200 --> 00:10:23,200
Because you really shouldn't be using global variables unless you absolutely positively

192
00:10:23,200 --> 00:10:24,200
have to.

193
00:10:24,200 --> 00:10:25,200
And this is not so good.

194
00:10:25,200 --> 00:10:27,800
But we have a better solution.

195
00:10:27,800 --> 00:10:32,820
Remember, everything in Python is an object, including classes.

196
00:10:32,820 --> 00:10:35,200
Every object has attributes.

197
00:10:35,200 --> 00:10:37,440
We can set and retrieve attributes on every object.

198
00:10:37,440 --> 00:10:42,560
So how about, how about it, we set an attribute on the person class.

199
00:10:42,560 --> 00:10:43,640
So here's what I'm going to do.

200
00:10:43,640 --> 00:10:48,880
I'm going to take my class, person, and after I define it, then I'm going to add population

201
00:10:48,880 --> 00:10:49,880
to it.

202
00:10:49,880 --> 00:10:50,880
Can I do that?

203
00:10:50,880 --> 00:10:52,120
Absolutely I can do that.

204
00:10:52,120 --> 00:10:53,600
Don't do this.

205
00:10:53,600 --> 00:10:56,460
But you can absolutely positively do it and it will work.

206
00:10:56,460 --> 00:10:59,920
As I like to say, unfortunately this works.

207
00:10:59,920 --> 00:11:00,920
Right?

208
00:11:00,920 --> 00:11:02,240
Like it will give you the right solution.

209
00:11:02,240 --> 00:11:07,560
And here what we see is we can't talk about population anymore as a global variable.

210
00:11:07,560 --> 00:11:08,640
Because it's not.

211
00:11:08,640 --> 00:11:10,720
It's not a variable at all.

212
00:11:10,720 --> 00:11:11,720
It's an attribute.

213
00:11:11,720 --> 00:11:14,880
We can't attribute on person.

214
00:11:14,880 --> 00:11:17,800
But I think we can all agree this is pretty ugly.

215
00:11:17,800 --> 00:11:21,640
Or as we call it in the consulting industry, an opportunity.

216
00:11:21,640 --> 00:11:25,520
So first we're creating the person class and then after we're done we add the population

217
00:11:25,520 --> 00:11:26,600
attribute to it.

218
00:11:26,600 --> 00:11:30,080
This cannot possibly be the best way.

219
00:11:30,080 --> 00:11:31,080
Well I have a solution.

220
00:11:31,080 --> 00:11:34,480
The solution is quiz time.

221
00:11:34,480 --> 00:11:37,160
What will this code print?

222
00:11:37,160 --> 00:11:41,160
So I took basically what I had here with the person class and I got rid of the population

223
00:11:41,160 --> 00:11:43,320
stuff and I added a few print statements.

224
00:11:43,320 --> 00:11:46,880
So the question is what will be printed in what order?

225
00:11:46,880 --> 00:11:49,480
And I am such a nice guy I will give you a hint.

226
00:11:49,480 --> 00:11:53,200
A will be printed first.

227
00:11:53,200 --> 00:11:55,920
After that you're kind of on your own.

228
00:11:55,920 --> 00:11:58,080
All right fine I'll reveal the answer.

229
00:11:58,080 --> 00:12:05,920
The answer is A, B, D, E, C, C. Okay well what's going on here?

230
00:12:05,920 --> 00:12:09,720
Because that is not obvious to an awful lot of people I show this to.

231
00:12:09,720 --> 00:12:12,680
And I really enjoy showing this to people because it forces you to really think through

232
00:12:12,680 --> 00:12:16,200
a lot of these issues having to do with classes.

233
00:12:16,200 --> 00:12:19,040
So print A, done.

234
00:12:19,040 --> 00:12:23,360
But many people especially those coming from statically compiled languages say well okay

235
00:12:23,360 --> 00:12:27,160
this print B here that's not going to run at all.

236
00:12:27,160 --> 00:12:31,640
Or maybe it's going to run and then like they start trying to figure it out and it just

237
00:12:31,640 --> 00:12:33,160
sort of doesn't work.

238
00:12:33,160 --> 00:12:35,080
But actually it's printed right away.

239
00:12:35,080 --> 00:12:36,400
And then they say oh I get it.

240
00:12:36,400 --> 00:12:39,120
A then B. Obviously then we're going to print C next.

241
00:12:39,120 --> 00:12:40,240
But no we print D next.

242
00:12:40,240 --> 00:12:44,760
We skip over C. So something is going something is very weird there.

243
00:12:44,760 --> 00:12:48,720
And it's not just if you're overseas.

244
00:12:48,720 --> 00:12:54,760
So then we have D. Then we have E. And then finally we print C and we print it twice.

245
00:12:54,760 --> 00:12:56,120
So what's going on?

246
00:12:56,120 --> 00:13:02,300
And part of the reason why people get confused by this is that functions and classes look

247
00:13:02,300 --> 00:13:03,600
almost exactly the same.

248
00:13:04,200 --> 00:13:10,800
So before this can happen, before we can have person invoked and before we can then call

249
00:13:10,800 --> 00:13:14,760
DunderInit, DunderInit needs to be there.

250
00:13:14,760 --> 00:13:19,120
Functions and classes look the same but function bodies are not executed when we define the

251
00:13:19,120 --> 00:13:20,120
functions.

252
00:13:20,120 --> 00:13:23,400
But class bodies need to execute when we define the class.

253
00:13:23,400 --> 00:13:29,220
Otherwise there's no DunderInit for us to call on our brand new object.

254
00:13:29,220 --> 00:13:36,860
So what that means is that when I define a class it is executed line by line by line.

255
00:13:36,860 --> 00:13:38,900
But wait a second.

256
00:13:38,900 --> 00:13:41,300
In my class I had DunderInit.

257
00:13:41,300 --> 00:13:43,460
Shouldn't the body of DunderInit run?

258
00:13:43,460 --> 00:13:47,540
No because a function body does not run when you define it.

259
00:13:47,540 --> 00:13:51,980
The function body only runs when you actually run it.

260
00:13:51,980 --> 00:13:53,580
But there's something kind of weird going on here.

261
00:13:53,580 --> 00:13:55,220
What about def?

262
00:13:55,220 --> 00:13:56,620
Def does two things.

263
00:13:56,620 --> 00:14:01,020
It creates a new function object and it assigns that object to a variable, that function's

264
00:14:01,020 --> 00:14:02,020
name.

265
00:14:02,020 --> 00:14:08,020
But here def is defining DunderInit which is what?

266
00:14:08,020 --> 00:14:09,980
It's an attribute.

267
00:14:09,980 --> 00:14:11,140
It's an attribute.

268
00:14:11,140 --> 00:14:13,240
Methods are attributes.

269
00:14:13,240 --> 00:14:19,100
And so DunderInit is an attribute on the class just like the attribute we set before population.

270
00:14:19,100 --> 00:14:21,260
This happens to be a function attribute.

271
00:14:21,260 --> 00:14:22,400
Population was an integer.

272
00:14:22,400 --> 00:14:24,540
In both cases attributes on the class.

273
00:14:24,540 --> 00:14:26,100
We define them in different ways.

274
00:14:26,100 --> 00:14:27,460
We use def to define it.

275
00:14:27,460 --> 00:14:29,380
But something still doesn't make sense here.

276
00:14:29,380 --> 00:14:31,500
I've got init as a class attribute.

277
00:14:31,500 --> 00:14:37,440
How can it be that def is now defining an attribute when it usually defines a variable?

278
00:14:37,440 --> 00:14:42,340
The reason is you can think of classes as file list modules.

279
00:14:42,340 --> 00:14:45,400
Modules without a file.

280
00:14:45,400 --> 00:14:49,300
Functions in a class body are class attributes.

281
00:14:49,300 --> 00:14:51,660
Inside of the class they look like variables.

282
00:14:51,660 --> 00:14:54,860
But outside the class they look like attributes.

283
00:14:54,860 --> 00:14:56,500
It's just like modules.

284
00:14:56,500 --> 00:15:01,060
When you define a function or a variable in a module file, inside of the file that's

285
00:15:01,060 --> 00:15:02,060
a global.

286
00:15:02,060 --> 00:15:06,760
But outside the file I have it as an attribute on the module object that I have defined,

287
00:15:06,760 --> 00:15:08,340
that I've imported.

288
00:15:08,340 --> 00:15:12,980
So any functions we define inside of a class aren't variables.

289
00:15:12,980 --> 00:15:14,340
They're attributes.

290
00:15:14,340 --> 00:15:15,580
Attributes on our class.

291
00:15:15,580 --> 00:15:19,760
And any assignments we thus make in a class don't create variables.

292
00:15:19,760 --> 00:15:22,380
They create attributes also.

293
00:15:22,380 --> 00:15:27,860
Which means I can go back to my person class from before and I can say population equals

294
00:15:27,860 --> 00:15:28,860
zero just like that.

295
00:15:28,860 --> 00:15:32,020
I am not at all creating a variable.

296
00:15:32,020 --> 00:15:33,420
It's not a global variable.

297
00:15:33,420 --> 00:15:34,760
It's not a variable at all.

298
00:15:34,760 --> 00:15:35,980
It is an attribute.

299
00:15:35,980 --> 00:15:36,980
Person dot population.

300
00:15:36,980 --> 00:15:41,460
By the way, sometimes people say, well, why don't we then call it person dot population

301
00:15:41,460 --> 00:15:42,940
side of the class?

302
00:15:42,940 --> 00:15:46,700
And the reason is that the name person is only defined after the class body has been

303
00:15:46,700 --> 00:15:47,700
run.

304
00:15:47,700 --> 00:15:51,300
So you can't do that.

305
00:15:51,300 --> 00:15:54,180
Some people look at this and they're like, oh, I've seen these before.

306
00:15:54,180 --> 00:15:56,700
I come from a background in C++.

307
00:15:56,700 --> 00:15:59,740
And we call these static variables.

308
00:15:59,740 --> 00:16:04,600
And I say, please don't use obscene language in my classes.

309
00:16:04,600 --> 00:16:09,060
But the thing is you shouldn't talk this way because it mixes things up.

310
00:16:09,060 --> 00:16:10,380
Static variables are shared.

311
00:16:10,380 --> 00:16:13,300
They're shared among the class and the instances.

312
00:16:13,300 --> 00:16:15,020
But attributes are not shared.

313
00:16:15,020 --> 00:16:16,020
The names are not shared.

314
00:16:16,020 --> 00:16:17,020
They can all reference.

315
00:16:17,020 --> 00:16:19,420
They can all point to the same object.

316
00:16:19,420 --> 00:16:23,300
But an attribute exists, a class attribute only exists in the class.

317
00:16:23,300 --> 00:16:25,860
Python does not have the idea of a shared attribute.

318
00:16:25,860 --> 00:16:29,140
It just doesn't exist in the language.

319
00:16:29,140 --> 00:16:30,140
Well let's see that.

320
00:16:30,140 --> 00:16:31,140
Let's see that they're different.

321
00:16:31,140 --> 00:16:32,540
So I'm going to add a little code here.

322
00:16:32,540 --> 00:16:37,820
I'm going to say after we've created our two person objects, person dot population,

323
00:16:37,820 --> 00:16:39,140
and I'm going to show you.

324
00:16:39,140 --> 00:16:42,300
We're not going to get anything from P1 and P2 populations.

325
00:16:42,300 --> 00:16:44,140
See, person population I get two.

326
00:16:44,140 --> 00:16:46,500
P1 population I get two.

327
00:16:46,500 --> 00:16:48,900
P2 population I get two.

328
00:16:48,900 --> 00:16:51,260
Uh oh.

329
00:16:51,260 --> 00:16:52,820
It worked and we got the same values.

330
00:16:52,820 --> 00:16:55,420
So maybe they are really shared.

331
00:16:55,420 --> 00:16:57,180
Nope.

332
00:16:57,180 --> 00:17:01,160
This is where I introduce what I call ICPO.

333
00:17:01,160 --> 00:17:04,980
The Attribute Lookup Path in Python.

334
00:17:04,980 --> 00:17:08,980
Instance, class, parent, object.

335
00:17:08,980 --> 00:17:14,220
This is how Python looks for attributes all the time, all of the time.

336
00:17:14,260 --> 00:17:18,700
And once you understand this, a whole lot of other things in Python start to make more

337
00:17:18,700 --> 00:17:19,780
sense.

338
00:17:19,780 --> 00:17:21,300
So what is this ICPO rule?

339
00:17:21,300 --> 00:17:25,420
First of all, Python looks on the object you actually talked about, the instance itself,

340
00:17:25,420 --> 00:17:28,420
and says does this attribute exist here?

341
00:17:28,420 --> 00:17:29,420
If so, great.

342
00:17:29,420 --> 00:17:30,420
We stop.

343
00:17:30,420 --> 00:17:31,420
We have the value.

344
00:17:31,420 --> 00:17:32,940
If not, we're not going to give up right away.

345
00:17:32,940 --> 00:17:34,700
We go to the class.

346
00:17:34,700 --> 00:17:37,220
Does the instance's class have this attribute?

347
00:17:37,220 --> 00:17:38,580
If so, great.

348
00:17:38,580 --> 00:17:40,380
If not, we keep going to the parent.

349
00:17:40,380 --> 00:17:42,620
We'll talk about that later, but we look it up in the parent.

350
00:17:42,620 --> 00:17:47,140
And if not there, then on object, the top of the class hierarchy.

351
00:17:47,140 --> 00:17:49,220
So let's walk through this.

352
00:17:49,220 --> 00:17:52,340
I say person.population.

353
00:17:52,340 --> 00:17:56,060
Python turns to, I know it doesn't feel like an instance, but classes are objects unless

354
00:17:56,060 --> 00:17:57,300
they are instances.

355
00:17:57,300 --> 00:17:58,980
Does person have the attribute population?

356
00:17:58,980 --> 00:17:59,980
The answer is yes.

357
00:17:59,980 --> 00:18:00,980
We get the value two.

358
00:18:00,980 --> 00:18:02,220
End of story.

359
00:18:02,220 --> 00:18:06,780
And then Python says, hey, P1, do you have the attribute population?

360
00:18:06,780 --> 00:18:09,380
And the answer is no.

361
00:18:09,380 --> 00:18:10,380
But Python doesn't give up.

362
00:18:10,380 --> 00:18:11,380
It says, oh, I see.

363
00:18:12,060 --> 00:18:13,300
Oh, I'll check on the class.

364
00:18:13,300 --> 00:18:16,220
Does person, P1's class, have the attribute population?

365
00:18:16,220 --> 00:18:17,220
It does.

366
00:18:17,220 --> 00:18:20,140
And we get the value back, too.

367
00:18:20,140 --> 00:18:21,140
I can also say P2.

368
00:18:21,140 --> 00:18:22,660
Does P2 have it?

369
00:18:22,660 --> 00:18:23,660
No.

370
00:18:23,660 --> 00:18:24,660
Does person have it?

371
00:18:24,660 --> 00:18:25,660
Yes.

372
00:18:25,660 --> 00:18:26,660
And we get it back.

373
00:18:26,660 --> 00:18:31,140
Now, I should note, this assumes we have not assigned an attribute population to P1 or

374
00:18:31,140 --> 00:18:32,140
P2.

375
00:18:32,140 --> 00:18:33,980
If you do that, all bets are off.

376
00:18:33,980 --> 00:18:37,340
Because then it will find the attribute on the instance.

377
00:18:37,340 --> 00:18:38,720
And it won't continue to the class.

378
00:18:38,720 --> 00:18:41,360
And you'll end up with a terrible, terrible situation.

379
00:18:41,360 --> 00:18:43,800
Don't do that.

380
00:18:43,800 --> 00:18:46,120
ICPO explains method lookup.

381
00:18:46,120 --> 00:18:47,780
It really does.

382
00:18:47,780 --> 00:18:52,560
Because if now I have a new version of person, and this version of person has a new method,

383
00:18:52,560 --> 00:18:54,640
it has the greet method.

384
00:18:54,640 --> 00:18:56,640
And so I can say P1 equals person name one.

385
00:18:56,640 --> 00:18:57,640
P2 equals person name two.

386
00:18:57,640 --> 00:18:58,880
Now I have my two people.

387
00:18:58,880 --> 00:18:59,880
Let's say hello to them.

388
00:18:59,880 --> 00:19:01,160
P1.greet.

389
00:19:01,160 --> 00:19:03,240
What happens here?

390
00:19:03,240 --> 00:19:05,640
Python turns to P1 and says, does it have the attribute greet?

391
00:19:05,640 --> 00:19:07,980
And the answer is no.

392
00:19:07,980 --> 00:19:08,980
So it turns to the class.

393
00:19:08,980 --> 00:19:09,980
Does person have the attribute greet?

394
00:19:09,980 --> 00:19:11,840
And the answer is yes.

395
00:19:11,840 --> 00:19:15,080
We get back that method object and we execute it.

396
00:19:15,080 --> 00:19:16,560
And then we do the same thing here.

397
00:19:16,560 --> 00:19:18,400
P2, does it have attribute greet?

398
00:19:18,400 --> 00:19:19,400
No.

399
00:19:19,400 --> 00:19:20,400
Does person have it?

400
00:19:20,400 --> 00:19:21,400
Yes.

401
00:19:21,400 --> 00:19:22,920
We get back the method object and we execute it.

402
00:19:22,920 --> 00:19:26,320
And it works great.

403
00:19:26,320 --> 00:19:30,440
The method here is defined as a class attribute.

404
00:19:30,440 --> 00:19:34,080
But we access it via the instance.

405
00:19:34,080 --> 00:19:37,280
OK.

406
00:19:37,280 --> 00:19:38,280
Let's try a new class.

407
00:19:38,280 --> 00:19:39,280
Right?

408
00:19:39,280 --> 00:19:44,140
So the method object is such a roaring success, my boss has come back to me and has said,

409
00:19:44,140 --> 00:19:45,900
listen, we need something new.

410
00:19:45,900 --> 00:19:47,420
We need an employee class.

411
00:19:47,420 --> 00:19:50,340
And employees are almost like people.

412
00:19:50,340 --> 00:19:52,020
Sometimes employees even are people.

413
00:19:52,020 --> 00:19:54,660
But that depends on the company you're working for.

414
00:19:54,660 --> 00:19:58,420
So employees, unlike people, are created with two attributes.

415
00:19:58,420 --> 00:20:00,820
Name and ID number.

416
00:20:00,820 --> 00:20:01,820
Otherwise they're the same as people.

417
00:20:01,820 --> 00:20:02,820
Right?

418
00:20:02,820 --> 00:20:03,820
So we have to have some distinction.

419
00:20:03,820 --> 00:20:04,820
So what do I do?

420
00:20:04,820 --> 00:20:07,540
I say to my boss, listen, I know exactly what I'm going to do.

421
00:20:07,540 --> 00:20:08,900
Give me a month.

422
00:20:08,920 --> 00:20:10,240
And my boss says, sounds great.

423
00:20:10,240 --> 00:20:11,240
See you in a month.

424
00:20:11,240 --> 00:20:14,640
And I think, ha, I'm going to do this in five minutes.

425
00:20:14,640 --> 00:20:17,520
And I'll watch TikTok videos the rest of the month.

426
00:20:17,520 --> 00:20:18,520
Perfect.

427
00:20:18,520 --> 00:20:21,520
So here I have my person class.

428
00:20:21,520 --> 00:20:26,360
And I now use the most powerful tool in a programmer's arsenal.

429
00:20:26,360 --> 00:20:27,860
Copy paste.

430
00:20:27,860 --> 00:20:31,560
And I define my employee class making a few slight adjustments.

431
00:20:31,560 --> 00:20:35,440
I add an assignment to self ID number based on ID number.

432
00:20:35,440 --> 00:20:37,320
And then I can create a new employee.

433
00:20:37,320 --> 00:20:38,560
New employee.

434
00:20:38,580 --> 00:20:41,740
I call E1 greet, E2 greet, and it's fantastic.

435
00:20:41,740 --> 00:20:45,740
And I am feeling great about myself because now I have a whole month to improve my ridiculous

436
00:20:45,740 --> 00:20:46,740
dances.

437
00:20:48,140 --> 00:20:50,460
My boss comes back a month later.

438
00:20:50,460 --> 00:20:55,540
And as bosses always do in software companies, wants to inspect my code.

439
00:20:55,540 --> 00:20:59,920
Looks at my code and says, why am I spending so much money on Python training and conferences

440
00:20:59,920 --> 00:21:03,140
for you when all you did was copy and paste.

441
00:21:03,140 --> 00:21:04,140
Why didn't you use inheritance?

442
00:21:04,140 --> 00:21:06,540
And I say, oh, inheritance.

443
00:21:06,540 --> 00:21:07,540
Right.

444
00:21:07,760 --> 00:21:08,760
Give me another month.

445
00:21:08,760 --> 00:21:09,760
I promise it'll be better.

446
00:21:09,760 --> 00:21:10,760
Sounds good.

447
00:21:10,760 --> 00:21:11,760
Boss walks away.

448
00:21:11,760 --> 00:21:12,760
I'll see you in a month.

449
00:21:12,760 --> 00:21:16,160
So let's try this again except with inheritance.

450
00:21:16,160 --> 00:21:17,160
What do I do here?

451
00:21:17,160 --> 00:21:20,140
I put person in parentheses after employee.

452
00:21:20,140 --> 00:21:23,160
This says employee is a person.

453
00:21:23,160 --> 00:21:25,320
Employee inherits from person.

454
00:21:25,320 --> 00:21:26,960
What does that really do?

455
00:21:26,960 --> 00:21:29,840
It inserts person into the ICPO search.

456
00:21:29,840 --> 00:21:34,800
It means now that if we don't find an attribute on the class, we will look for it in the class's

457
00:21:34,800 --> 00:21:35,800
parent.

458
00:21:35,800 --> 00:21:40,940
If we don't find an attribute, a method basically, an employee, we will look for it in person.

459
00:21:40,940 --> 00:21:43,620
And sure enough, now I call E1.greet.

460
00:21:43,620 --> 00:21:44,620
What happens?

461
00:21:44,620 --> 00:21:45,620
Python says does E1 have greet?

462
00:21:45,620 --> 00:21:46,620
The answer is no.

463
00:21:46,620 --> 00:21:48,420
Does its class employee have greet?

464
00:21:48,420 --> 00:21:49,420
The answer is yes.

465
00:21:49,420 --> 00:21:50,420
End of search.

466
00:21:50,420 --> 00:21:54,520
We have accomplished nothing at all through our inheritance.

467
00:21:54,520 --> 00:21:57,480
So yes, we inherit from person, but we're not taking advantage of it.

468
00:21:57,480 --> 00:22:00,220
So let's take advantage of it now.

469
00:22:00,220 --> 00:22:02,420
Let's use inheritance.

470
00:22:03,420 --> 00:22:07,440
The greet method is exactly the same in both person and employee.

471
00:22:07,440 --> 00:22:10,020
So we can get rid of it in employee.

472
00:22:10,020 --> 00:22:14,880
And so I say here class employee, just like before, except I've gotten rid of the greet

473
00:22:14,880 --> 00:22:15,880
method.

474
00:22:15,880 --> 00:22:18,700
And now when I call greet, what happens?

475
00:22:18,700 --> 00:22:20,660
Python asks E1, do you have an attribute greet?

476
00:22:20,660 --> 00:22:21,660
The answer is no.

477
00:22:21,660 --> 00:22:25,460
It asks the class employee, do you have the attribute greet?

478
00:22:25,460 --> 00:22:26,460
The answer is no.

479
00:22:26,460 --> 00:22:27,460
So we go to the parent.

480
00:22:27,460 --> 00:22:28,460
Do you have the attribute greet?

481
00:22:28,460 --> 00:22:29,580
The answer is yes.

482
00:22:29,580 --> 00:22:30,860
We get back the method.

483
00:22:30,860 --> 00:22:31,860
We run it.

484
00:22:31,860 --> 00:22:32,860
It's good.

485
00:22:32,860 --> 00:22:35,460
And the same thing happens with E2.

486
00:22:35,460 --> 00:22:39,860
So a lot of people look at this code and they say, oh, inheritance sounds great.

487
00:22:39,860 --> 00:22:43,260
And then they say, wait, we can improve this code even more.

488
00:22:43,260 --> 00:22:46,020
Because name, I'm setting name in employee.

489
00:22:46,020 --> 00:22:47,900
I can also set name.

490
00:22:47,900 --> 00:22:51,620
Why am I setting name in employee and also setting it in person?

491
00:22:51,620 --> 00:22:56,140
I can just get rid of it in employee and all will be great.

492
00:22:56,140 --> 00:23:01,820
So here I have name being passed in and nothing having to do with name because I am an optimist.

493
00:23:02,780 --> 00:23:06,500
I assume that person will take care of it.

494
00:23:06,500 --> 00:23:10,140
Yeah, except it won't.

495
00:23:10,140 --> 00:23:11,740
Employee has no attribute name.

496
00:23:11,740 --> 00:23:13,540
And I say what?

497
00:23:13,540 --> 00:23:14,740
How can that be?

498
00:23:14,740 --> 00:23:18,260
And I decide to run the vars function on it just to double check.

499
00:23:18,260 --> 00:23:23,860
And I see that E1 has only an ID number and E2 has only an ID number.

500
00:23:23,860 --> 00:23:28,380
And perhaps you feel this way sometimes at work that they don't really believe you have

501
00:23:28,380 --> 00:23:29,900
a name, just a number.

502
00:23:29,900 --> 00:23:33,060
But that's a bug, not a feature.

503
00:23:33,060 --> 00:23:35,900
Or so I'd like to think.

504
00:23:35,900 --> 00:23:37,900
So what's going on here?

505
00:23:37,900 --> 00:23:39,260
Well here's the thing.

506
00:23:39,260 --> 00:23:41,780
The name attribute was never set.

507
00:23:41,780 --> 00:23:47,740
We never got to person.thunder in it in which name was set.

508
00:23:47,740 --> 00:23:50,580
And the problem is basically this.

509
00:23:50,580 --> 00:23:52,980
We created a new instance of employee.

510
00:23:52,980 --> 00:23:55,060
We asked the new instance, do you have in it?

511
00:23:55,060 --> 00:23:56,060
No.

512
00:23:56,060 --> 00:23:57,060
We asked employee, do you have in it?

513
00:23:57,060 --> 00:23:58,060
Yes.

514
00:23:58,060 --> 00:23:59,060
That ran.

515
00:23:59,100 --> 00:24:03,660
We asked a person in it, because it never ran, name was not added.

516
00:24:03,660 --> 00:24:07,860
People coming from statically compiled languages are often surprised by this because they see

517
00:24:07,860 --> 00:24:09,820
classes as a set of declarations.

518
00:24:09,820 --> 00:24:14,460
And they say, oh, the subclasses declarations and the superclasses declarations will be

519
00:24:14,460 --> 00:24:15,620
merged together.

520
00:24:15,620 --> 00:24:17,500
So I get all of these different fields.

521
00:24:17,500 --> 00:24:19,260
I get all these different attributes set.

522
00:24:19,260 --> 00:24:21,680
But that's not how it works in Python.

523
00:24:21,680 --> 00:24:25,200
We set these attributes explicitly in Python and thunder in it.

524
00:24:25,200 --> 00:24:28,580
You don't run thunder in it, the attribute's not set.

525
00:24:28,660 --> 00:24:30,220
So what can we do about this?

526
00:24:30,220 --> 00:24:34,060
Well, we have a few different possibilities.

527
00:24:34,060 --> 00:24:36,460
One is to explicitly call person thunder in it.

528
00:24:36,460 --> 00:24:40,460
Right there inside of employee in it, I can say, yeah, I can run it.

529
00:24:40,460 --> 00:24:43,220
There's nothing technically wrong with this.

530
00:24:43,220 --> 00:24:46,740
But this is where, right, and gives me the right answer.

531
00:24:46,740 --> 00:24:48,420
But it's better to use super here.

532
00:24:48,420 --> 00:24:50,340
Super basically says it's a proxy.

533
00:24:50,340 --> 00:24:55,360
And it says, I will figure out who we can run thunder in it on.

534
00:24:55,360 --> 00:24:56,360
And it goes up the chain.

535
00:24:56,360 --> 00:24:59,840
And it says, oh, person has thunder in it, I'll run that.

536
00:24:59,840 --> 00:25:00,360
Fantastic.

537
00:25:00,360 --> 00:25:01,760
And then we get M1.

538
00:25:01,760 --> 00:25:03,080
We get hello, M2.

539
00:25:03,080 --> 00:25:03,840
All is good.

540
00:25:05,120 --> 00:25:10,880
So this is how we see attributes in use on the instance, on the class, and on the parent.

541
00:25:10,880 --> 00:25:14,400
And I should add, if we have multiple parents, right, if we have something that

542
00:25:14,400 --> 00:25:16,560
inherits from something that inherits from something that inherits from something,

543
00:25:16,560 --> 00:25:20,760
it will just go up that whole chain until it gets to object.

544
00:25:20,760 --> 00:25:25,280
Object is the top object, top class in our object hierarchy.

545
00:25:26,240 --> 00:25:27,760
And let's talk about that a bit.

546
00:25:27,760 --> 00:25:31,720
What happens when I print P1 or print E1?

547
00:25:31,720 --> 00:25:33,920
First of all, I get back something that's just horribly ugly.

548
00:25:33,920 --> 00:25:39,520
I will never understand why this is considered the default, but fine, it is.

549
00:25:39,520 --> 00:25:41,120
Anyway, why?

550
00:25:41,120 --> 00:25:45,840
Because when I call print, why can we print anything in Python?

551
00:25:45,840 --> 00:25:48,640
Because print turns its argument into a string.

552
00:25:48,640 --> 00:25:49,800
How do we turn something into a string?

553
00:25:49,800 --> 00:25:51,240
We call str on it.

554
00:25:51,240 --> 00:25:52,360
What happens when we call str on it?

555
00:25:52,360 --> 00:25:54,240
It looks for a dunder str.

556
00:25:54,320 --> 00:25:57,200
And the dunder str method with P1, does P1 have dunder str?

557
00:25:57,200 --> 00:25:57,800
No.

558
00:25:57,800 --> 00:25:59,360
Does P1's class person have dunder str?

559
00:25:59,360 --> 00:25:59,960
No.

560
00:25:59,960 --> 00:26:01,440
Does object have str?

561
00:26:01,440 --> 00:26:02,280
Yes.

562
00:26:02,280 --> 00:26:05,080
So we get the default implementation of dunder str.

563
00:26:05,080 --> 00:26:08,640
And that's what we get, the default ugly result that we saw.

564
00:26:08,640 --> 00:26:11,840
And with E1, it's basically the same thing, just with an added step.

565
00:26:11,840 --> 00:26:13,480
Does E1 have dunder str?

566
00:26:13,480 --> 00:26:14,360
No.

567
00:26:14,360 --> 00:26:16,040
Does E1's class employee have dunder str?

568
00:26:16,040 --> 00:26:16,760
No.

569
00:26:16,760 --> 00:26:18,760
Does E1's class's parent person have dunder str?

570
00:26:18,760 --> 00:26:19,080
No.

571
00:26:19,080 --> 00:26:19,720
Does object have it?

572
00:26:19,720 --> 00:26:20,120
Yes.

573
00:26:20,120 --> 00:26:22,440
We get it all good.

574
00:26:22,440 --> 00:26:26,480
This is how we can do operator overloading, attribute lookup.

575
00:26:26,480 --> 00:26:31,160
If you define dunder str in your class, you're basically stopping the search

576
00:26:31,160 --> 00:26:35,520
at an earlier stage, and thus you never get to dunder str in object.

577
00:26:38,520 --> 00:26:42,760
But something is still missing.

578
00:26:42,760 --> 00:26:45,640
Python loves to be explicit.

579
00:26:45,640 --> 00:26:47,600
And Python loves to work without matter.

580
00:26:47,600 --> 00:26:47,840
Right?

581
00:26:47,840 --> 00:26:51,400
We in the Python world like to laugh at those other languages that have matter.

582
00:26:51,400 --> 00:26:53,360
Explicit is better than implicit.

583
00:26:53,360 --> 00:26:57,920
But there's a big piece of magic here that we all know about

584
00:26:57,920 --> 00:26:59,720
and that we don't complain about too much.

585
00:26:59,720 --> 00:27:01,960
And that is method rewriting.

586
00:27:01,960 --> 00:27:03,560
So you might know this, and you might not.

587
00:27:03,560 --> 00:27:09,440
But basically, if I have s equals abcd, and then I call s.upper,

588
00:27:09,440 --> 00:27:10,480
I get back abcd.

589
00:27:10,480 --> 00:27:10,960
Great.

590
00:27:10,960 --> 00:27:13,560
That's the normal way we would invoke a method.

591
00:27:13,560 --> 00:27:16,960
But I can also say str.upper of s.

592
00:27:16,960 --> 00:27:17,840
And that works also.

593
00:27:17,840 --> 00:27:20,120
It's exactly the same thing.

594
00:27:20,160 --> 00:27:21,840
But something's wrong here.

595
00:27:21,840 --> 00:27:23,680
Something's a little weird.

596
00:27:23,680 --> 00:27:26,800
We know that methods are stored in class attributes.

597
00:27:26,800 --> 00:27:30,920
And we know that we can retrieve a class attribute via either the class

598
00:27:30,920 --> 00:27:32,480
or the instance.

599
00:27:32,480 --> 00:27:35,480
But somehow, we're getting different behavior,

600
00:27:35,480 --> 00:27:37,440
depending on how we retrieve it.

601
00:27:37,440 --> 00:27:39,320
Let's just look at that again for a moment.

602
00:27:39,320 --> 00:27:40,600
Let's go back here.

603
00:27:40,600 --> 00:27:41,840
Here we go.

604
00:27:41,840 --> 00:27:42,960
Right?

605
00:27:42,960 --> 00:27:45,880
I'm asking for the dot upper.

606
00:27:45,880 --> 00:27:47,960
I'm asking for the upper attribute.

607
00:27:47,960 --> 00:27:49,280
I can ask for it on the instance.

608
00:27:49,280 --> 00:27:50,520
I can ask for it in the class.

609
00:27:50,520 --> 00:27:53,960
In one case, it expects to get, in this class case,

610
00:27:53,960 --> 00:27:56,160
it expects to get the instance as an argument.

611
00:27:56,160 --> 00:27:58,240
But in the instance case, it does not.

612
00:27:58,240 --> 00:27:59,840
So what's going on here?

613
00:27:59,840 --> 00:28:00,920
Well, let's ask.

614
00:28:00,920 --> 00:28:02,320
Person.greet.

615
00:28:02,320 --> 00:28:03,760
What do we get back?

616
00:28:03,760 --> 00:28:06,680
We get back a function, a plain old Python function.

617
00:28:06,680 --> 00:28:11,200
p1.greet, I get a bound method.

618
00:28:11,200 --> 00:28:12,680
Huh.

619
00:28:12,680 --> 00:28:14,920
That's kind of weird.

620
00:28:14,920 --> 00:28:15,760
What's going on?

621
00:28:15,760 --> 00:28:18,480
And the answer is descriptors.

622
00:28:18,480 --> 00:28:20,600
Normally, when I retrieve a class attribute,

623
00:28:20,600 --> 00:28:23,200
I get the object stored in that attribute.

624
00:28:23,200 --> 00:28:25,680
That's the normal behavior that we've seen so far,

625
00:28:25,680 --> 00:28:27,240
and you've probably seen day to day,

626
00:28:27,240 --> 00:28:30,120
and you don't think much more about it than that.

627
00:28:30,120 --> 00:28:33,200
But if the attribute has a DunderGet method,

628
00:28:33,200 --> 00:28:36,640
that is to say, if the attribute is of a type,

629
00:28:36,640 --> 00:28:39,520
and that type has DunderGet installed,

630
00:28:39,520 --> 00:28:43,720
then the result of DunderGet is returned instead.

631
00:28:43,720 --> 00:28:44,680
Let's try this.

632
00:28:44,680 --> 00:28:48,400
I'm going to say here, class loud number.

633
00:28:49,320 --> 00:28:50,520
And basically, this is just going

634
00:28:50,520 --> 00:28:52,760
to store an integer for us, nothing too exciting.

635
00:28:52,760 --> 00:28:54,440
And I should add, by the way, descriptors

636
00:28:54,440 --> 00:28:56,960
can be very, very complex.

637
00:28:56,960 --> 00:28:58,800
I'm not going to all of descriptors here.

638
00:28:58,800 --> 00:29:02,040
I'm just showing it to you at a higher level.

639
00:29:02,040 --> 00:29:05,040
But you'll get the gist here, I think.

640
00:29:05,040 --> 00:29:06,400
So basically, I have my class.

641
00:29:06,400 --> 00:29:07,920
This is a totally reasonable class.

642
00:29:07,920 --> 00:29:09,520
DunderInit, self n.

643
00:29:09,520 --> 00:29:10,880
And then when we run DunderInit, we're

644
00:29:10,880 --> 00:29:12,240
going to print out that we're there,

645
00:29:12,240 --> 00:29:14,040
and we're going to assign self n equals n.

646
00:29:14,040 --> 00:29:16,800
And then DunderGet, this is that special method.

647
00:29:16,800 --> 00:29:18,120
We're going to say self, and I'm just

648
00:29:18,120 --> 00:29:20,080
going to paper over the arguments we get for now.

649
00:29:20,080 --> 00:29:21,920
We're going to get into it in a moment.

650
00:29:21,920 --> 00:29:24,160
Splat args, meaning, oh, whatever positional arguments

651
00:29:24,160 --> 00:29:25,520
you want to pass, that's fine.

652
00:29:25,520 --> 00:29:27,200
And then here, what are we going to do?

653
00:29:27,200 --> 00:29:29,360
We're going to return self dot n.

654
00:29:29,360 --> 00:29:33,080
If I assign an instance of loud number to a variable,

655
00:29:33,080 --> 00:29:36,320
nothing special happens.

656
00:29:36,320 --> 00:29:41,200
But if I assign it to a class attribute, magic happens.

657
00:29:41,200 --> 00:29:42,680
Let's see.

658
00:29:42,680 --> 00:29:48,040
So let's say class person, age equals loud number 30.

659
00:29:48,040 --> 00:29:48,880
What am I doing here?

660
00:29:48,880 --> 00:29:50,360
I'm creating a person class, and the person class

661
00:29:50,360 --> 00:29:51,160
has nothing else in it.

662
00:29:51,160 --> 00:29:53,400
I'm just concentrating right now on this descriptor.

663
00:29:53,400 --> 00:29:57,040
And I say, let's make age equal to an instance, one new instance

664
00:29:57,040 --> 00:29:59,640
of loud number 30.

665
00:29:59,640 --> 00:30:02,480
When I now ask, well, when I run that,

666
00:30:02,480 --> 00:30:04,320
I get in loud number in it n equals 30,

667
00:30:04,320 --> 00:30:06,280
because we ran that code.

668
00:30:06,280 --> 00:30:08,040
It's part of the class definition.

669
00:30:08,040 --> 00:30:12,400
When we define a class, the class definition runs.

670
00:30:12,400 --> 00:30:14,680
When I say p equals person, great.

671
00:30:14,680 --> 00:30:16,200
We've created a new instance of person.

672
00:30:16,200 --> 00:30:17,400
And when I say, whoops.

673
00:30:17,400 --> 00:30:20,320
Ah, no, no, no, no, no, come back.

674
00:30:20,320 --> 00:30:22,600
Well, end of talk, folks.

675
00:30:22,600 --> 00:30:24,320
Hope didn't leave you in suspense.

676
00:30:26,800 --> 00:30:29,120
It was much worse when that happened during my dissertation

677
00:30:29,120 --> 00:30:31,720
defense.

678
00:30:31,720 --> 00:30:34,480
Anyway, what's going on here?

679
00:30:34,480 --> 00:30:38,800
What we have here is p, an instance of person.

680
00:30:38,800 --> 00:30:40,960
It refers to an instance of person.

681
00:30:40,960 --> 00:30:41,280
Great.

682
00:30:41,280 --> 00:30:42,960
That's not the truly interesting thing.

683
00:30:42,960 --> 00:30:44,620
The truly interesting is that above it,

684
00:30:44,700 --> 00:30:48,020
person, which refers to the person class,

685
00:30:48,020 --> 00:30:50,500
it has an attribute, age.

686
00:30:50,500 --> 00:30:52,700
And what is the value of age?

687
00:30:52,700 --> 00:30:55,540
It's an instance of loud number.

688
00:30:55,540 --> 00:30:57,620
OK, I know it's a little confusing to keep track of.

689
00:30:57,620 --> 00:30:59,900
But basically, the class attribute is an object.

690
00:30:59,900 --> 00:31:01,580
But of course, class attributes are always objects,

691
00:31:01,580 --> 00:31:03,260
because everything is an object in Python.

692
00:31:03,260 --> 00:31:04,780
Just here, it's an object of a type

693
00:31:04,780 --> 00:31:08,140
that we created with this wacky Dunder get method.

694
00:31:08,140 --> 00:31:09,260
And watch this now.

695
00:31:09,260 --> 00:31:11,140
I say p.age.

696
00:31:11,140 --> 00:31:16,700
I'm retrieving the class attribute via the instance.

697
00:31:16,700 --> 00:31:18,780
And it invokes the method.

698
00:31:18,780 --> 00:31:21,140
Dunder get is running.

699
00:31:21,140 --> 00:31:22,820
And then I get back 30.

700
00:31:22,820 --> 00:31:25,420
And then I say person.age.

701
00:31:25,420 --> 00:31:26,540
And the method is running.

702
00:31:26,540 --> 00:31:28,700
And I get back 30.

703
00:31:28,700 --> 00:31:30,340
That's kind of weird, right?

704
00:31:30,340 --> 00:31:34,500
I mean, I did get the attribute value back.

705
00:31:34,500 --> 00:31:36,060
But I didn't get the attribute itself.

706
00:31:36,060 --> 00:31:37,980
I got whatever Dunder get in the attribute

707
00:31:37,980 --> 00:31:39,500
wanted to return to me.

708
00:31:39,500 --> 00:31:40,460
Here's the weirder thing.

709
00:31:40,460 --> 00:31:42,780
I did not use parentheses.

710
00:31:42,780 --> 00:31:44,940
In Python, if I don't use parentheses,

711
00:31:44,940 --> 00:31:47,780
I don't invoke a method or a function.

712
00:31:47,780 --> 00:31:49,780
And here, I did not use parentheses.

713
00:31:49,780 --> 00:31:52,380
And yet, it was invoked.

714
00:31:52,380 --> 00:31:55,140
What the heck?

715
00:31:55,140 --> 00:31:56,660
So what are get's parameters?

716
00:31:56,660 --> 00:31:58,000
What is it actually doing there?

717
00:31:58,000 --> 00:31:59,820
Well, before, I said it was just splat args.

718
00:31:59,820 --> 00:32:02,260
But it actually gets two arguments.

719
00:32:02,260 --> 00:32:04,660
And those two arguments are assigned to two parameters.

720
00:32:04,660 --> 00:32:06,020
And there are different names and conventions

721
00:32:06,020 --> 00:32:06,900
for calling these.

722
00:32:06,900 --> 00:32:09,300
I call it obj and obj type.

723
00:32:09,300 --> 00:32:11,380
Choose your own poison here.

724
00:32:11,380 --> 00:32:14,500
So the first argument that we get after self is obj.

725
00:32:14,500 --> 00:32:18,820
From what instance is the attribute being retrieved?

726
00:32:18,820 --> 00:32:23,420
So through whom am I trying to retrieve this?

727
00:32:23,420 --> 00:32:26,340
And the second argument is, in which class

728
00:32:26,340 --> 00:32:29,580
is this attribute stored?

729
00:32:29,580 --> 00:32:30,740
So let's try this again.

730
00:32:30,740 --> 00:32:33,380
I'm going to create my class, age equals loud number 30,

731
00:32:33,380 --> 00:32:34,980
and we see that.

732
00:32:34,980 --> 00:32:38,700
And now, I say p equals person, a new instance.

733
00:32:38,700 --> 00:32:40,100
And I say p.age.

734
00:32:40,100 --> 00:32:43,820
And look at what I get in my printout.

735
00:32:43,820 --> 00:32:46,620
It says obj is an instance of person.

736
00:32:46,620 --> 00:32:47,820
Well, that's true.

737
00:32:47,820 --> 00:32:52,380
I accessed age via the instance of person p.

738
00:32:52,380 --> 00:32:55,420
And the obj type is person, the class person.

739
00:32:55,420 --> 00:32:58,540
So what we know is p.age, it invoked under get.

740
00:32:58,540 --> 00:33:01,980
And under get knows on which instance and from which class.

741
00:33:01,980 --> 00:33:08,420
And if I say person, if I say person.age, obj is none.

742
00:33:09,700 --> 00:33:13,180
And still, obj type is the class person.

743
00:33:13,180 --> 00:33:17,140
In other words, if I retrieve it via the class, obj is none.

744
00:33:17,140 --> 00:33:18,700
But if I retrieve it via the instance,

745
00:33:18,700 --> 00:33:21,460
obj is the instance on which I ran that.

746
00:33:24,060 --> 00:33:26,060
Whoops, come back.

747
00:33:26,060 --> 00:33:27,140
So here's the thing.

748
00:33:27,140 --> 00:33:32,060
You use descriptors every single day,

749
00:33:32,060 --> 00:33:35,020
because methods are descriptors.

750
00:33:35,460 --> 00:33:39,340
When we retrieve a method via the class,

751
00:33:39,340 --> 00:33:41,900
Python returns the original function.

752
00:33:41,900 --> 00:33:46,900
But when we, and it can tell because obj is set to none.

753
00:33:46,900 --> 00:33:49,900
So we need to supply an instance as the first argument.

754
00:33:49,900 --> 00:33:52,140
It knows, oh, I didn't get object here.

755
00:33:52,140 --> 00:33:54,900
So we need to get that argument so that we can call the function

756
00:33:54,900 --> 00:33:55,780
correctly.

757
00:33:55,780 --> 00:33:58,620
But when we retrieve a method via the instance,

758
00:33:58,620 --> 00:34:01,540
Python says, aha, what I want to do

759
00:34:01,540 --> 00:34:05,460
is take that instance, obj, and turn it into the first argument,

760
00:34:05,460 --> 00:34:07,940
move it over there, so that then we

761
00:34:07,940 --> 00:34:10,980
can call the original function with all of its arguments,

762
00:34:10,980 --> 00:34:13,700
but with obj at the front.

763
00:34:13,700 --> 00:34:15,660
Well, how's it going to do that?

764
00:34:15,660 --> 00:34:18,460
And the answer is, partials.

765
00:34:18,460 --> 00:34:20,040
So you might not be familiar with it,

766
00:34:20,040 --> 00:34:22,820
but we have something in func tools in Python called partials.

767
00:34:22,820 --> 00:34:25,660
So I can say, for example, def add of a and b, return a plus b.

768
00:34:25,660 --> 00:34:27,940
Totally normal addition function.

769
00:34:27,940 --> 00:34:32,620
And then I say, add 5 equals partial of add and 5.

770
00:34:32,620 --> 00:34:35,260
Add 5 is a function object, effectively.

771
00:34:35,260 --> 00:34:36,060
It's a callable.

772
00:34:36,060 --> 00:34:38,420
I can invoke it, as you see down at the bottom.

773
00:34:38,420 --> 00:34:42,980
I say, add 5 of 10, and it returns 15.

774
00:34:42,980 --> 00:34:49,420
Because we sort of preloaded the first argument 5 onto add.

775
00:34:49,420 --> 00:34:52,380
That's exactly what's going on here with our methods.

776
00:34:52,380 --> 00:34:56,260
When I invoke a method via the instance,

777
00:34:56,300 --> 00:34:58,780
Python does the rewriting and returns a partial.

778
00:34:58,780 --> 00:35:01,740
It automatically assigns or binds

779
00:35:01,740 --> 00:35:04,820
that instance to the method.

780
00:35:04,820 --> 00:35:06,380
Guess what it says here.

781
00:35:06,380 --> 00:35:08,980
When I retrieve person.greet, it's just the function.

782
00:35:08,980 --> 00:35:14,100
But in return p1.greet, it's the bound method person.greet

783
00:35:14,100 --> 00:35:15,980
to that particular object.

784
00:35:15,980 --> 00:35:18,580
It's telling us what it's doing, but it's

785
00:35:18,580 --> 00:35:20,540
hard to understand without walking through all

786
00:35:20,540 --> 00:35:22,940
this attribute stuff.

787
00:35:22,940 --> 00:35:24,700
Wait a second.

788
00:35:24,700 --> 00:35:27,980
What did it do with our original function?

789
00:35:27,980 --> 00:35:31,140
It's very nice at all to say, oh, I defined my method,

790
00:35:31,140 --> 00:35:34,580
and it was replaced with this descriptor magic.

791
00:35:34,580 --> 00:35:36,940
But where is my original method greet?

792
00:35:36,940 --> 00:35:40,100
And the answer is that it's put on another class attribute.

793
00:35:40,100 --> 00:35:43,300
It's sort of moved around to dunderdict.

794
00:35:43,300 --> 00:35:45,940
And so the method name there is the key,

795
00:35:45,940 --> 00:35:48,460
and the original function is the value.

796
00:35:48,460 --> 00:35:53,060
So if we ask for a method via the class, obj is none,

797
00:35:53,060 --> 00:35:54,780
and we get back the original function.

798
00:35:54,780 --> 00:35:57,100
The method descriptor just returns that function

799
00:35:57,100 --> 00:35:59,060
from dunderdict.

800
00:35:59,060 --> 00:36:03,020
But if there is an object there, then Python basically

801
00:36:03,020 --> 00:36:06,580
creates a partial with our instance,

802
00:36:06,580 --> 00:36:09,460
and that function returns them together,

803
00:36:09,460 --> 00:36:10,540
and that is our method.

804
00:36:14,780 --> 00:36:17,180
So when we ask for a.b in Python,

805
00:36:17,180 --> 00:36:19,860
an awful lot of stuff is going on.

806
00:36:19,860 --> 00:36:23,180
Python looks for our attribute via ICPO.

807
00:36:23,180 --> 00:36:24,860
When we finally find an attribute,

808
00:36:24,860 --> 00:36:26,860
it might be descriptor.

809
00:36:26,860 --> 00:36:28,980
And the descriptor then does some magic there,

810
00:36:28,980 --> 00:36:33,380
depending on if we called it via the instance or via the class.

811
00:36:33,380 --> 00:36:36,060
We use descriptors every single day

812
00:36:36,060 --> 00:36:37,820
without thinking about it very much.

813
00:36:37,820 --> 00:36:39,340
And I should add, there are people

814
00:36:39,340 --> 00:36:42,100
who really want to implement descriptors.

815
00:36:42,100 --> 00:36:43,900
You almost certainly don't have to.

816
00:36:43,900 --> 00:36:46,420
I think knowing the protocol is useful for a deeper

817
00:36:46,420 --> 00:36:49,380
understanding of Python, but the odds of you actually

818
00:36:49,380 --> 00:36:51,980
implementing a descriptor on your own are very, very slim.

819
00:36:51,980 --> 00:36:54,220
Most of the time, if you think about implementing

820
00:36:54,220 --> 00:36:56,580
a descriptor, you can instead use

821
00:36:56,580 --> 00:36:58,420
what's known as a property, which

822
00:36:58,420 --> 00:37:00,780
is a much, much simpler form of descriptors

823
00:37:00,780 --> 00:37:03,420
that papers over a lot of this stuff.

824
00:37:03,420 --> 00:37:06,860
But basically, via these attributes,

825
00:37:06,860 --> 00:37:09,380
we get class attributes.

826
00:37:09,380 --> 00:37:11,100
We get inheritance.

827
00:37:11,100 --> 00:37:13,580
We get almost kind of sharing stuff

828
00:37:13,580 --> 00:37:15,860
between instances and classes, and we

829
00:37:15,860 --> 00:37:20,460
get the magic of methods and their rewriting.

830
00:37:20,460 --> 00:37:21,540
All right.

831
00:37:21,540 --> 00:37:22,460
We're at the end now.

832
00:37:22,460 --> 00:37:23,460
Thank you very much.

833
00:37:23,460 --> 00:37:26,140
Apparently, we're not taking questions and sessions here.

834
00:37:26,140 --> 00:37:28,380
But I will say, if you want to come up,

835
00:37:28,380 --> 00:37:29,660
I have a booth in the expo.

836
00:37:29,660 --> 00:37:31,100
You're welcome to come up and chat with me

837
00:37:31,100 --> 00:37:32,820
and ask me whatever questions you want.

838
00:37:32,820 --> 00:37:34,260
It would be my pleasure.

839
00:37:34,260 --> 00:37:35,460
Thanks so much, everyone.

840
00:37:35,460 --> 00:37:37,020
Thank you.

