1
00:00:00,000 --> 00:00:11,360
And now I want to welcome our C Python developer in residence and our first keynote speaker.

2
00:00:11,360 --> 00:00:14,360
Let's give him a warm welcome.

3
00:00:14,360 --> 00:00:17,360
Hi, there.

4
00:00:17,360 --> 00:00:28,800
This is easily the biggest crowd I've ever spoken to, so I'm a little nervous.

5
00:00:28,800 --> 00:00:29,800
My name is Lukasz.

6
00:00:29,800 --> 00:00:30,800
I'm from the internet.

7
00:00:30,800 --> 00:00:32,400
You can find me in all sorts of places online.

8
00:00:32,400 --> 00:00:37,000
But I've been coming to PyCon for a while now, and I'll be here for the entire event,

9
00:00:37,000 --> 00:00:40,760
so I'm happy to answer any questions you might have about any subject.

10
00:00:40,760 --> 00:00:43,600
I like Python, so we can talk about Python.

11
00:00:43,600 --> 00:00:49,120
I also like Robert Maynard Persig's Zen and the Art of Motorcycle Maintenance.

12
00:00:49,120 --> 00:00:51,520
That's a pictogram from the cover of the book.

13
00:00:51,520 --> 00:00:55,320
First read it some 10 years ago, and it massively influenced me.

14
00:00:55,320 --> 00:01:02,560
It's like some meditation about technology that also is connecting it to how people perceive

15
00:01:02,560 --> 00:01:04,040
art.

16
00:01:04,040 --> 00:01:09,280
It talks a lot about Q-ality, and it never really left me since.

17
00:01:09,280 --> 00:01:14,680
I just reread it this month, and it totally holds up, so I highly recommend you looking

18
00:01:14,680 --> 00:01:17,400
it up if you haven't read it yet.

19
00:01:17,400 --> 00:01:22,600
In fact, we're going to be talking about Q-ality here too, but it's going to be maybe a little

20
00:01:23,280 --> 00:01:30,200
bit of a mundane kind of Q-ality, because we're going to be talking about type annotations.

21
00:01:30,200 --> 00:01:32,400
Type annotations are here to stay.

22
00:01:32,400 --> 00:01:38,280
They've been first added to Python 3.5, and ever since, there's been a number of peps

23
00:01:38,280 --> 00:01:43,160
that made them easier to use and made them more powerful to express more complex and

24
00:01:43,160 --> 00:01:44,160
complex types.

25
00:01:44,160 --> 00:01:52,360
So if you haven't ever annotated any application yet, you're likely to be in for a treat soon.

26
00:01:53,160 --> 00:01:57,000
And if you did, you might have some experiences with it.

27
00:01:57,000 --> 00:02:03,680
Some of us have been annotating Python programs for quite a while now, and with this experience,

28
00:02:03,680 --> 00:02:10,440
we have kind of devised some best practices on how to do this, how to write code so that

29
00:02:10,440 --> 00:02:12,320
it doesn't really fight the type checker.

30
00:02:12,320 --> 00:02:15,720
And this is what we're going to be talking about today.

31
00:02:15,720 --> 00:02:22,320
And also about some what we consider anti-patterns, where what you're trying to do works against

32
00:02:22,680 --> 00:02:25,000
what the type checker will want from you.

33
00:02:25,000 --> 00:02:30,520
And finally, we'll cover some limitations of static typing compared to what the runtime

34
00:02:30,520 --> 00:02:36,520
Python allows you to do, and whether they're a ball and chain or more of something that

35
00:02:36,520 --> 00:02:41,320
you should be really kind of grateful to have.

36
00:02:41,320 --> 00:02:45,520
So why do we even have type annotations in the first place?

37
00:02:45,520 --> 00:02:51,480
Looking at this very simple code example that pretty much reads like English, we can see

38
00:02:51,480 --> 00:02:56,920
that it's a process all function accepting one argument, which is items, and for each

39
00:02:56,920 --> 00:03:02,480
of those items, it will find a children attribute on them and call a process method.

40
00:03:02,480 --> 00:03:03,480
Easy.

41
00:03:03,480 --> 00:03:10,200
But even in such a small example, there might be a lot of complexity and questions hiding.

42
00:03:10,200 --> 00:03:12,400
In this particular case, what is items?

43
00:03:12,400 --> 00:03:13,400
We don't really know.

44
00:03:13,400 --> 00:03:17,840
Like in Python, items, maybe there are pairs in dictionaries, right?

45
00:03:17,840 --> 00:03:19,000
Key value pairs.

46
00:03:19,000 --> 00:03:23,760
But here we know that this is not the case because those don't have a children attribute.

47
00:03:23,760 --> 00:03:25,160
So it's something else.

48
00:03:25,160 --> 00:03:26,520
How do we find out?

49
00:03:26,520 --> 00:03:31,920
If there's no doc string, we need to grab through our code base to find out.

50
00:03:31,920 --> 00:03:35,520
But finding items in a big code base, not very easy.

51
00:03:35,520 --> 00:03:37,680
So how about looking for the children attribute?

52
00:03:37,680 --> 00:03:39,400
Again, not very easy.

53
00:03:39,400 --> 00:03:41,720
How about we grab for a process method?

54
00:03:41,720 --> 00:03:44,140
In all likelihood, you're going to have more than one.

55
00:03:44,140 --> 00:03:46,540
So you need some form of documentation.

56
00:03:46,540 --> 00:03:50,700
And you need it if you're using powerful features of Python like its dynamicism as

57
00:03:50,700 --> 00:03:57,500
well because in this case, we have some proxy that has instances which are callable, just

58
00:03:57,500 --> 00:03:58,940
like functions.

59
00:03:58,940 --> 00:04:05,260
And from the signature here, you see that you can call it with any arguments.

60
00:04:05,260 --> 00:04:06,260
Anything goes.

61
00:04:06,260 --> 00:04:07,260
It's all good.

62
00:04:07,260 --> 00:04:08,660
But is it?

63
00:04:08,660 --> 00:04:16,500
Experience shows that there is only one or a few cases where it makes sense to call a

64
00:04:16,500 --> 00:04:19,580
call this proxy with some set of arguments.

65
00:04:19,580 --> 00:04:20,580
So what are they?

66
00:04:20,580 --> 00:04:25,440
Well, either we need to read the body of the function or we're lucky enough to have some

67
00:04:25,440 --> 00:04:33,460
documentation which is either in a doc string or provided in some sphinx docs on the side.

68
00:04:33,460 --> 00:04:40,720
But I would argue that type annotations are a wonderful form of documentation which works

69
00:04:41,720 --> 00:04:49,280
it will both allow people on board to a new code base to be productive quicker.

70
00:04:49,280 --> 00:04:54,520
But it also will allow you yourself to remember what you thought about the function you were

71
00:04:54,520 --> 00:04:57,800
writing six months or six years back.

72
00:04:57,800 --> 00:04:58,800
It helps with review.

73
00:04:58,800 --> 00:05:02,140
It helps with debugging.

74
00:05:02,140 --> 00:05:04,300
But also, it's machine readable.

75
00:05:04,300 --> 00:05:08,720
Thanks to a type checker, we can validate assumptions about code that you're writing

76
00:05:08,800 --> 00:05:13,520
right now and keep validating those assumptions into the future.

77
00:05:13,520 --> 00:05:19,080
So if you change a function, which is very likely to happen, we modify our software,

78
00:05:19,080 --> 00:05:27,360
we keep maintaining it, the type checker might still be checking whether the API stays sane.

79
00:05:27,360 --> 00:05:33,320
So I could finish right now and we could just go to the coffee break sooner because I hope

80
00:05:33,320 --> 00:05:35,120
I convinced you it's all good.

81
00:05:35,280 --> 00:05:40,240
What if your type annotations look something more like this?

82
00:05:40,240 --> 00:05:46,160
This is a screenshot taken by Ned Batchelder and posted on Twitter last year by him.

83
00:05:46,160 --> 00:05:50,680
He said, you know, I'm looking through this Python documentation and like, what is this?

84
00:05:50,680 --> 00:05:51,680
Is this the future?

85
00:05:51,680 --> 00:05:55,280
Are we supposed to be able to read this?

86
00:05:55,280 --> 00:05:58,560
My response at the time was like, ah, yeah, no.

87
00:05:58,560 --> 00:06:03,160
Obviously even the biggest fan of typing will tell you that this is not optimal.

88
00:06:03,200 --> 00:06:05,080
This is not what we want.

89
00:06:05,080 --> 00:06:10,640
Fortunately, there is plenty of ways in which even without bothering PyTest developers,

90
00:06:10,640 --> 00:06:15,180
we can improve the situation so we can make this more readable.

91
00:06:15,180 --> 00:06:20,680
So I responded on the Twitter thread, but people started piling on with their own favorite

92
00:06:20,680 --> 00:06:21,680
examples.

93
00:06:21,680 --> 00:06:22,880
We're like, how about this example?

94
00:06:22,880 --> 00:06:23,880
How about this example?

95
00:06:23,880 --> 00:06:24,880
How about this?

96
00:06:24,880 --> 00:06:32,880
And I came to the conclusion that sometimes ugly type annotations hint at ugly code.

97
00:06:33,200 --> 00:06:40,760
It's a controversial thing to say, maybe insolent, but if you're not at least a little bit controversial

98
00:06:40,760 --> 00:06:46,080
doing a keynote, then how are you living your life?

99
00:06:46,080 --> 00:06:47,080
Needs to be memorable.

100
00:06:47,080 --> 00:06:48,960
But also, I'm pretty serious.

101
00:06:48,960 --> 00:06:52,440
Type annotations don't create additional complexity.

102
00:06:52,440 --> 00:06:55,640
They expose complexity that was always there.

103
00:06:55,640 --> 00:06:56,640
And hold on, hold on.

104
00:06:56,640 --> 00:06:58,200
I understand that.

105
00:06:58,320 --> 00:07:03,440
Eight-year-olds who first dabble with programming thanks to Python don't necessarily need to

106
00:07:03,440 --> 00:07:04,440
know all this.

107
00:07:04,440 --> 00:07:06,800
And it's wonderful that Python allows that.

108
00:07:06,800 --> 00:07:11,520
I understand we have, even in the audience, plenty of professionals who wouldn't otherwise

109
00:07:11,520 --> 00:07:18,240
call themselves programmers, but they're enabled by Python to be productive in their respective

110
00:07:18,240 --> 00:07:19,240
fields.

111
00:07:19,240 --> 00:07:20,840
So I understand all this.

112
00:07:20,840 --> 00:07:27,320
However, with experience, you're going to be handling increasing amounts of complexity.

113
00:07:27,360 --> 00:07:34,280
Your five-line long snippets will become 50-line long scripts and then 500 lines long.

114
00:07:34,280 --> 00:07:37,360
And soon enough, you're going to be looking at half a million lines of code that you're

115
00:07:37,360 --> 00:07:38,880
maintaining.

116
00:07:38,880 --> 00:07:44,560
And with that increased complexity, your understanding of what's going on has to increase as well.

117
00:07:44,560 --> 00:07:49,200
Otherwise, you're going to end up with a big ball of mud that is not really maintainable

118
00:07:49,200 --> 00:07:53,720
and its behavior cannot be really easily reasoned about.

119
00:07:53,720 --> 00:08:02,200
So let's talk about how we can structure our code such that it actually makes type annotations

120
00:08:02,200 --> 00:08:03,200
less ugly.

121
00:08:03,200 --> 00:08:08,680
First, let's actually solve this case that Ned Batchelder showed us because it's particularly

122
00:08:08,680 --> 00:08:10,000
egregious.

123
00:08:10,000 --> 00:08:14,600
And luckily, we can do this with only a few simple things.

124
00:08:14,600 --> 00:08:20,760
First of all, please use modern typing syntax.

125
00:08:20,760 --> 00:08:22,840
We are working on Python 3.11 right now.

126
00:08:23,000 --> 00:08:29,280
Python 3.10 was released in October and Python 3.9 will see its final bug fix release just

127
00:08:29,280 --> 00:08:30,880
two weeks from now.

128
00:08:30,880 --> 00:08:36,040
What that means is there is little excuse not using Python 3.9 right now.

129
00:08:36,040 --> 00:08:37,440
It's in stable Debian.

130
00:08:37,440 --> 00:08:38,440
Come on.

131
00:08:38,440 --> 00:08:44,400
So using modern typing syntax in Python 3.9 allows you to use built-in types as generic

132
00:08:44,400 --> 00:08:47,120
collections, which is tremendously useful.

133
00:08:47,200 --> 00:08:55,840
Even in Python 3.10, you can use the pipe operator for unions, which combined make for

134
00:08:55,840 --> 00:09:01,640
really terse but readable syntax that expresses even pretty complex types.

135
00:09:01,640 --> 00:09:03,000
Let's see an example.

136
00:09:03,000 --> 00:09:08,280
We have a match argument to some function, which can be either a string or a regular

137
00:09:08,280 --> 00:09:10,760
expression pattern or none.

138
00:09:10,760 --> 00:09:12,040
This is how we express it.

139
00:09:12,040 --> 00:09:16,360
And the only piece of complexity here is that it's a regular expression of string because

140
00:09:16,400 --> 00:09:19,840
it could be a regular expression of bytes.

141
00:09:19,840 --> 00:09:24,960
So I hope that even if this is the first time you're seeing type annotations in this form,

142
00:09:24,960 --> 00:09:28,160
you can kind of see why it's red like this.

143
00:09:28,160 --> 00:09:30,480
But after a while, it becomes second nature.

144
00:09:30,480 --> 00:09:33,080
Just looking at those types, you know what they are.

145
00:09:33,080 --> 00:09:37,840
Let's look at a more complex example where we don't want an object of a type.

146
00:09:37,840 --> 00:09:40,240
We want to be passed a class.

147
00:09:40,240 --> 00:09:44,960
So in this case, we would say we expect some type to be given to us.

148
00:09:45,040 --> 00:09:49,680
We want a type of E, not E itself, not an instance of an object, a class.

149
00:09:49,680 --> 00:09:53,480
Or we want many of those classes in a tuple.

150
00:09:53,480 --> 00:09:58,800
So we either accept a type of E or a tuple of many of those types.

151
00:09:58,800 --> 00:10:05,120
And with those two examples combined, we end up with a much more readable piece of documentation

152
00:10:05,120 --> 00:10:10,440
that is an equivalent of what we've seen before.

153
00:10:10,440 --> 00:10:16,720
We can really read what it does right now, which is a context manager that responds to

154
00:10:16,720 --> 00:10:18,160
a raised exception.

155
00:10:18,160 --> 00:10:21,160
And you need to specify what you expect to be raised.

156
00:10:21,160 --> 00:10:25,840
Either one type of an exception or multiple in a tuple.

157
00:10:25,840 --> 00:10:34,680
And you can optionally say that we should be matching some piece of message in this

158
00:10:34,680 --> 00:10:35,840
context manager.

159
00:10:35,840 --> 00:10:38,560
So it's either a string or a pattern of a string.

160
00:10:38,600 --> 00:10:41,400
If we don't specify anything, the default value is none.

161
00:10:41,400 --> 00:10:42,400
Done.

162
00:10:42,400 --> 00:10:43,400
Okay.

163
00:10:43,400 --> 00:10:44,400
We understand what is going on right now.

164
00:10:44,400 --> 00:10:49,760
The context manager actually returns a raised context that is dependent on the type of the

165
00:10:49,760 --> 00:10:51,960
exception that we gave it.

166
00:10:51,960 --> 00:10:52,960
Okay.

167
00:10:52,960 --> 00:10:53,960
So cool.

168
00:10:53,960 --> 00:11:01,360
But I kind of, you know, helped it be more readable by changing formatting here a bit.

169
00:11:01,360 --> 00:11:06,720
And it's maybe a mundane thing to say right now, but I do believe that standardizing signature

170
00:11:06,760 --> 00:11:12,080
formatting has a lot of impact on how readable annotations later are.

171
00:11:12,080 --> 00:11:17,520
Because some preexisting conventions on how to format them don't really gel well with

172
00:11:17,520 --> 00:11:18,520
annotations.

173
00:11:18,520 --> 00:11:26,280
Especially the ones that try to hang subsequent arguments under the opening parenthesis.

174
00:11:26,280 --> 00:11:28,440
It ends up looking something like this.

175
00:11:28,440 --> 00:11:29,440
It's very small.

176
00:11:29,440 --> 00:11:32,000
I don't expect you to be able to read what is there.

177
00:11:32,040 --> 00:11:38,120
I don't even expect you to be able to say how many arguments this function accepts.

178
00:11:38,120 --> 00:11:42,640
It's not very nice and there's little space for the return annotation as well.

179
00:11:42,640 --> 00:11:44,240
So how do you fix it?

180
00:11:44,240 --> 00:11:47,360
Well, I have one simple suggestion.

181
00:11:47,360 --> 00:11:48,360
Just blacken that shit.

182
00:11:48,360 --> 00:11:49,360
You know?

183
00:11:49,360 --> 00:11:50,360
It will do it for you.

184
00:11:50,360 --> 00:11:55,480
It will do it automatically.

185
00:11:55,480 --> 00:11:59,080
This will allow you to increase the font size over twice.

186
00:11:59,080 --> 00:12:00,600
Now we can actually see what's going on.

187
00:12:00,640 --> 00:12:03,840
Now we can see the name of the function and that it accepts three arguments.

188
00:12:03,840 --> 00:12:04,840
Cool.

189
00:12:04,840 --> 00:12:09,880
And there's plenty of space for the return annotation, which is a dictionary of strings

190
00:12:09,880 --> 00:12:11,480
to a set of strings.

191
00:12:11,480 --> 00:12:17,360
But I'm not particularly happy about this annotation because what are those strings?

192
00:12:17,360 --> 00:12:21,840
Remember, type annotations are human readable documentation.

193
00:12:21,840 --> 00:12:24,040
They're meant for humans first.

194
00:12:24,040 --> 00:12:30,200
So my suggestion to you is to give those types meaningful names.

195
00:12:30,200 --> 00:12:33,840
It doesn't matter to the type checker and it matters even less to runtime Python, which

196
00:12:33,840 --> 00:12:36,360
doesn't do much with type annotations.

197
00:12:36,360 --> 00:12:38,600
But it matters a lot to a human.

198
00:12:38,600 --> 00:12:40,160
Let's see an example.

199
00:12:40,160 --> 00:12:45,680
If we have a show lyrics function that takes some query list of string and takes some lyrics

200
00:12:45,680 --> 00:12:51,000
database which is a dictionary of string to another dictionary of string to string, this

201
00:12:51,000 --> 00:12:54,680
is everything that a type checker needs.

202
00:12:54,680 --> 00:12:56,720
But I don't quite understand what is going on here.

203
00:12:56,760 --> 00:13:01,200
So let us help ourselves by giving names to all those strings.

204
00:13:01,200 --> 00:13:07,960
For example, looking at the inner dictionary, we can say that the keys are song names and

205
00:13:07,960 --> 00:13:10,240
the values are lyrics.

206
00:13:10,240 --> 00:13:15,640
Now the mystery of the inner dictionary is solved so we can even give that entire dictionary

207
00:13:15,640 --> 00:13:21,120
a name, song to lyrics, and the annotation magically becomes less verbose.

208
00:13:21,120 --> 00:13:25,720
And we can do this with the external dictionary too, saying the keys here are actually artist

209
00:13:25,720 --> 00:13:26,720
names.

210
00:13:26,720 --> 00:13:34,920
So now with all of those annotations, we have a much shorter function signature and also

211
00:13:34,920 --> 00:13:39,080
we can reuse those human readable names in other functions.

212
00:13:39,080 --> 00:13:44,880
You can expect that if we are being passed a lyrics database in one function, there must

213
00:13:44,880 --> 00:13:47,720
be some other function that produces it, right?

214
00:13:47,720 --> 00:13:51,840
And there might be others that filter them, mutate them or whatnot.

215
00:13:51,840 --> 00:13:59,400
So reusing the same annotations that communicate to humans what those things are, tremendously

216
00:13:59,400 --> 00:14:01,760
useful, highly recommended.

217
00:14:01,760 --> 00:14:11,120
So now we are moving from visual things, from simple modifications, to more of like code

218
00:14:11,120 --> 00:14:12,800
refactoring area.

219
00:14:12,800 --> 00:14:15,980
So we're going to be making increasing changes to this.

220
00:14:15,980 --> 00:14:20,520
But this is all still about human understanding of the code at hand.

221
00:14:20,560 --> 00:14:26,400
So for example, I would argue that you should be making your functions small and simple

222
00:14:26,400 --> 00:14:28,880
and to dispatch early to specialize.

223
00:14:28,880 --> 00:14:36,120
The tractors of typing love to give you examples where they would use some super dynamic function

224
00:14:36,120 --> 00:14:42,600
that's found in Python, say, the max built in, and they will say, hey, try to type that

225
00:14:42,600 --> 00:14:43,600
and see what happens.

226
00:14:43,600 --> 00:14:48,080
Well, of course, this isn't even a built in that has one signature.

227
00:14:48,080 --> 00:14:49,520
It's got two.

228
00:14:49,520 --> 00:14:52,800
And those are plenty dynamic here as well.

229
00:14:52,800 --> 00:14:59,400
And they allow for some funky stuff like the iterable in the first form doesn't have to

230
00:14:59,400 --> 00:15:02,920
have the same types as the optional default value.

231
00:15:02,920 --> 00:15:07,480
And the arguments given in the second form might be of incompatible types, too.

232
00:15:07,480 --> 00:15:08,480
It's all good.

233
00:15:08,480 --> 00:15:12,240
You can all do this and it will work magically in Python.

234
00:15:12,240 --> 00:15:14,680
And are you using functions like these?

235
00:15:14,680 --> 00:15:15,940
Of course you are.

236
00:15:15,940 --> 00:15:20,860
This is the core of Python, the vocabulary that we have that doesn't matter what kinds

237
00:15:20,860 --> 00:15:24,380
of data you're putting in, the same verbs apply.

238
00:15:24,380 --> 00:15:27,100
So it's wonderful to have this in Python.

239
00:15:27,100 --> 00:15:32,980
But when was the last time you actually constructed a function that was this dynamic?

240
00:15:32,980 --> 00:15:36,420
I would argue that if you're raising your hand right now, which I can't really see,

241
00:15:36,420 --> 00:15:41,740
like you're an author of some library or framework that needs this sort of dynamicism and God

242
00:15:42,300 --> 00:15:48,020
Yes, in this case, static typing will be a little verbose.

243
00:15:48,020 --> 00:15:53,940
But for everybody else, for end user code, it's very unlikely for you to have to deal

244
00:15:53,940 --> 00:15:57,140
with this sort of dynamicism.

245
00:15:57,140 --> 00:15:59,940
So let's just put things in perspective.

246
00:15:59,940 --> 00:16:05,540
Well, if you do, then you will look inside the implementation of a function like this

247
00:16:05,540 --> 00:16:09,900
because the documentation doesn't tell you that if you're implementing something that

248
00:16:09,940 --> 00:16:11,660
is tremendously dynamic.

249
00:16:11,660 --> 00:16:14,820
The implementation tends to look sort of like this.

250
00:16:14,820 --> 00:16:16,060
There's some dispatch there.

251
00:16:16,060 --> 00:16:21,280
There's 20 lines here dealing with one form and 10 lines there dealing with another form.

252
00:16:21,280 --> 00:16:24,580
It's not the kind of function that you love to read.

253
00:16:24,580 --> 00:16:27,460
It's hard to test it thoroughly.

254
00:16:27,460 --> 00:16:32,660
Right now you can talk about cyclomatic complexity, whether you covered actually all paths that

255
00:16:32,660 --> 00:16:34,020
are possible.

256
00:16:34,020 --> 00:16:40,060
The max built in is wonderful, but Python is powerful also due to its maturity.

257
00:16:40,060 --> 00:16:42,300
All the edge cases were already ironed out.

258
00:16:42,300 --> 00:16:48,020
You can pretty much use it without fear that some edge case was not covered.

259
00:16:48,020 --> 00:16:52,100
With functions that you're writing yourself, how lucky is it that there is going to be

260
00:16:52,100 --> 00:16:53,860
some edge case that slips in?

261
00:16:53,860 --> 00:16:56,400
Well, there might be a case like that.

262
00:16:56,400 --> 00:17:00,100
So I would recommend you dispatch early.

263
00:17:00,100 --> 00:17:04,780
Place the implementations with smaller functions that only respond to a subset of what's going

264
00:17:04,780 --> 00:17:06,100
on.

265
00:17:06,100 --> 00:17:13,300
This allows usually for shorter function signatures of those sub functions.

266
00:17:13,300 --> 00:17:14,700
Let's call them that.

267
00:17:14,700 --> 00:17:22,020
The external one will still have a horrible big function signature with long type annotations,

268
00:17:22,020 --> 00:17:23,980
but it is what it is.

269
00:17:23,980 --> 00:17:26,380
Life looks like that.

270
00:17:26,380 --> 00:17:34,140
Well, splitting the function into many sub functions allow us to now see the bird's eye

271
00:17:34,140 --> 00:17:35,580
view of what's going on.

272
00:17:35,580 --> 00:17:40,540
For example, to identify the bug that was on the screen all along, which is that we

273
00:17:40,540 --> 00:17:46,980
accept a Boolean as the function signature tells us, but Booleans happen to be integers.

274
00:17:46,980 --> 00:17:51,480
So maybe we don't actually want to parse it as an integer, which we are here because this

275
00:17:51,480 --> 00:17:55,380
is the ordering in which the ifs and elifs go.

276
00:17:55,380 --> 00:18:01,900
So by splitting the functions, it's more likely for you during testing to identify this problem.

277
00:18:01,900 --> 00:18:07,180
You can assert maybe that parse int does not want to get Booleans because they're not exactly

278
00:18:07,180 --> 00:18:09,940
what we want to deal with.

279
00:18:09,940 --> 00:18:15,420
If you look at the function signature of the sub function, it becomes pretty much trivial.

280
00:18:15,420 --> 00:18:20,260
One argument which is only an int, we return an item.

281
00:18:20,260 --> 00:18:22,920
Done.

282
00:18:23,160 --> 00:18:27,160
But I don't want you to only write trivial functions like this.

283
00:18:27,160 --> 00:18:28,880
This is no way to live.

284
00:18:28,880 --> 00:18:32,960
And the robustness principle tells us that we should be flexible in what we accept and

285
00:18:32,960 --> 00:18:35,200
strict with what we emit.

286
00:18:35,200 --> 00:18:40,440
When we're talking about functions, that first part applies to the arguments of the function

287
00:18:40,440 --> 00:18:44,280
and the other applies to what we return from the function.

288
00:18:44,280 --> 00:18:46,540
Let me give you an example from the black code base.

289
00:18:46,540 --> 00:18:48,940
We're looking for configuration.

290
00:18:48,940 --> 00:18:53,900
So we have a bunch of candidates for paths where configuration might hide.

291
00:18:53,900 --> 00:18:59,760
And then we're going to be returning a path to a configuration file if we find it or none

292
00:18:59,760 --> 00:19:01,760
if we don't.

293
00:19:01,760 --> 00:19:06,140
Well, do we need this argument to be a tuple?

294
00:19:06,140 --> 00:19:09,420
Maybe it's not really that important for it to be exactly a tuple.

295
00:19:09,420 --> 00:19:11,660
All we're doing here is iterating over it.

296
00:19:11,660 --> 00:19:17,540
So maybe saying just give me an iterable is a better idea because now the caller of this

297
00:19:17,580 --> 00:19:21,880
function is able to provide you a list that they already produced.

298
00:19:21,880 --> 00:19:23,500
So they don't have to convert anything.

299
00:19:23,500 --> 00:19:25,840
They can just pass this data right there.

300
00:19:25,840 --> 00:19:28,700
Maybe they have a set and maybe that's also fine.

301
00:19:28,700 --> 00:19:31,780
So this is what we mean about being flexible and what we accept.

302
00:19:31,780 --> 00:19:34,580
Are we strict in what we emit and are we here?

303
00:19:34,580 --> 00:19:35,580
Not really.

304
00:19:35,580 --> 00:19:38,120
Because we either give you a path or give you none.

305
00:19:38,120 --> 00:19:43,140
And this is not perfect because it forces the caller of the function to always check

306
00:19:43,140 --> 00:19:44,860
what is it that they received.

307
00:19:44,860 --> 00:19:45,920
Is it none?

308
00:19:45,920 --> 00:19:48,000
Sometimes people will forget to check.

309
00:19:48,000 --> 00:19:53,800
Sometimes they will just pass this responsibility on to further functions making none proliferate

310
00:19:53,800 --> 00:19:57,360
in your code base which isn't something that you particularly want.

311
00:19:57,360 --> 00:19:59,000
So how do you solve this?

312
00:19:59,000 --> 00:20:04,840
Well, you can in fact use exceptions for exceptional states.

313
00:20:04,840 --> 00:20:06,480
It's what Python wants you to do.

314
00:20:06,480 --> 00:20:12,160
In this particular case, you can use a lookup error, one of my favorite built-in exception

315
00:20:13,160 --> 00:20:15,920
and key error both inherit from it.

316
00:20:15,920 --> 00:20:22,080
But it's also useful for a wide array of cases like this where we're finding something and

317
00:20:22,080 --> 00:20:24,000
failing.

318
00:20:24,000 --> 00:20:27,680
So yes, you should be using exceptions for exceptional states.

319
00:20:27,680 --> 00:20:34,600
But there's another thing that you can do without having to modify types there.

320
00:20:34,600 --> 00:20:36,960
So you can use empty values.

321
00:20:36,960 --> 00:20:41,020
This is especially natural when you're dealing with collections.

322
00:20:41,020 --> 00:20:46,240
For example, if you have a function that lists all the users that are currently logged into

323
00:20:46,240 --> 00:20:52,520
our application, it's perfectly reasonable to return an empty list if no user happens

324
00:20:52,520 --> 00:20:57,100
to be logged in to your application at this point.

325
00:20:57,100 --> 00:21:01,920
But this makes also sense, depending on context, to do for scalars.

326
00:21:01,920 --> 00:21:06,760
So Python does allow for falsy values when we're talking about numbers.

327
00:21:06,760 --> 00:21:13,100
And it allows for falsy values with booleans and empty strings and so on.

328
00:21:13,100 --> 00:21:14,200
Sometimes that's dangerous.

329
00:21:14,200 --> 00:21:20,420
So what you want is actually an exception to inform the caller that we actually failed

330
00:21:20,420 --> 00:21:24,880
to find something and the default value would hide this fact.

331
00:21:24,880 --> 00:21:29,880
But if you ever used a default dict, you know that there's plenty of cases where an empty

332
00:21:29,880 --> 00:21:34,720
value makes perfect sense.

333
00:21:34,800 --> 00:21:40,480
So Python is a particular special example where returning it from a function is annoying.

334
00:21:40,480 --> 00:21:42,120
But it's not the only one.

335
00:21:42,120 --> 00:21:47,440
In fact, any kind of type union that you're returning from your function is going to be

336
00:21:47,440 --> 00:21:53,400
hurting your users because they will be forced to check which one did I get.

337
00:21:53,400 --> 00:21:58,800
And if they do this and they write some if LF chain and you later change your function,

338
00:21:58,800 --> 00:22:04,240
we already talked about booleans being ints, but this only stands in any form of subclassing.

339
00:22:04,240 --> 00:22:09,520
So in Python, code that looks like it works might not actually do what you want.

340
00:22:09,520 --> 00:22:18,920
So I always recommend avoiding returning unions from functions as much as you can help it.

341
00:22:18,920 --> 00:22:23,840
So coming back to this robustness principle, when we say that we want to be flexible in

342
00:22:23,840 --> 00:22:28,800
what we accept and strict in what we return, what we're really saying is that we want to

343
00:22:28,800 --> 00:22:33,480
be vague in what we accept and concrete in what we return.

344
00:22:33,520 --> 00:22:38,160
What I mean by this is that in the arguments here, we accept a collection.

345
00:22:38,160 --> 00:22:39,680
We don't really care what it is.

346
00:22:39,680 --> 00:22:43,760
You might give me a set, you might give me a dictionary, you might give me whatever else.

347
00:22:43,760 --> 00:22:46,120
We only need a collection.

348
00:22:46,120 --> 00:22:52,040
But when we are returning a list of items, we should say that to the user, not an iterable,

349
00:22:52,040 --> 00:22:53,040
not a sequence.

350
00:22:53,040 --> 00:22:55,000
Let's tell them what they received.

351
00:22:55,000 --> 00:22:59,880
By telling them exactly what they're getting, they can now utilize append methods, they

352
00:22:59,880 --> 00:23:03,560
can rely on the order of the things that they got and so on and so on.

353
00:23:03,560 --> 00:23:09,480
So that's pretty much the robustness principle in hindsight, right?

354
00:23:09,480 --> 00:23:13,320
Like in, I don't know, like high level.

355
00:23:13,320 --> 00:23:19,400
But sometimes it's not really that easy to be, you know, truthful to the dot.

356
00:23:19,400 --> 00:23:25,880
Typing might make it overly verbose or it might actually be not helpful because you're

357
00:23:25,880 --> 00:23:29,480
going to be spending a lot of time only to end up with something that's more brittle

358
00:23:29,480 --> 00:23:30,480
than what you wanted.

359
00:23:30,480 --> 00:23:32,920
Let me give you two examples of this.

360
00:23:32,920 --> 00:23:37,160
So the first example is another piece of code from Black where we split a single line into

361
00:23:37,160 --> 00:23:40,600
many lines and we're generating it because we're efficient.

362
00:23:40,600 --> 00:23:42,320
So we're yielding those lines.

363
00:23:42,320 --> 00:23:43,840
What that is is a generator.

364
00:23:43,840 --> 00:23:46,040
A generator generates lines.

365
00:23:46,040 --> 00:23:49,980
It does not accept anything being sent to it, so none.

366
00:23:49,980 --> 00:23:55,240
And it does not emit anything on stop iteration, so another none.

367
00:23:55,240 --> 00:24:02,480
But I'm not really super happy with this annotation because it is super verbose.

368
00:24:02,480 --> 00:24:07,520
So instead what I end up using is to say I'm returning an iterator offline.

369
00:24:07,520 --> 00:24:08,520
Is that more vague?

370
00:24:08,520 --> 00:24:09,520
Yes, a little.

371
00:24:09,520 --> 00:24:14,120
But what can you do with a generator that does not accept anything being sent to it

372
00:24:14,120 --> 00:24:16,600
and it doesn't do anything special on stop iteration?

373
00:24:16,600 --> 00:24:19,180
Well, you can pretty much only iterate over it.

374
00:24:19,180 --> 00:24:22,200
So it's pretty truthful to what you're wanting.

375
00:24:22,200 --> 00:24:28,200
And it's also a much simpler annotation to be reading.

376
00:24:28,200 --> 00:24:34,760
The opposite example would be in arguments where you're accepting a file argument, an

377
00:24:34,760 --> 00:24:36,160
open file.

378
00:24:36,160 --> 00:24:40,880
But you're looking at the body of your function and you're like I'm not really using the entire

379
00:24:40,880 --> 00:24:42,520
API of file.

380
00:24:42,520 --> 00:24:45,120
I'm only using the small slice.

381
00:24:45,120 --> 00:24:48,720
So maybe any file-like object will be great, you know?

382
00:24:48,720 --> 00:24:50,680
And how do you annotate that?

383
00:24:51,160 --> 00:24:55,560
Either you look at your application and see what are the possibilities of types that I

384
00:24:55,560 --> 00:24:59,800
could put there and there's going to be some big union of those types.

385
00:24:59,800 --> 00:25:06,320
Or you can use structural typing, so protocols, and actually define what methods and attributes

386
00:25:06,320 --> 00:25:13,200
you want people to have to implement to conform to your file-like object.

387
00:25:13,200 --> 00:25:19,360
Or you can just say any, which is essentially shutting the type checker up saying, you know,

388
00:25:19,400 --> 00:25:23,040
I'm going to be doing weird things here, please don't raise type errors.

389
00:25:23,040 --> 00:25:24,640
So you can do those three things.

390
00:25:24,640 --> 00:25:29,560
And I used to be in the camp that actually specified everything to the dot so that, you

391
00:25:29,560 --> 00:25:35,760
know, we sliced the contract as thinly as possible.

392
00:25:35,760 --> 00:25:38,240
But I grew to stop doing that.

393
00:25:38,240 --> 00:25:41,320
Now when I need a file, I'll tell you exactly that.

394
00:25:41,320 --> 00:25:45,120
Please just give me Iow of text and we're good.

395
00:25:45,120 --> 00:25:46,400
Why?

396
00:25:47,200 --> 00:25:54,480
Because of my previous experiences as a beginner core developer back in 2010, I was making

397
00:25:54,480 --> 00:25:56,960
config parser a little better.

398
00:25:56,960 --> 00:26:03,120
And I deprecated a function that had multiple issues with it with a better function, of

399
00:26:03,120 --> 00:26:05,040
course, read file.

400
00:26:05,040 --> 00:26:09,400
And I didn't want to have any duplication of the implementation.

401
00:26:09,400 --> 00:26:17,760
So I remade the read FP deprecated function to actually use the new one internally.

402
00:26:17,760 --> 00:26:21,240
The argument we accept here FP is an open file.

403
00:26:21,240 --> 00:26:29,400
So it wasn't really a problem to me that before we were calling read line on this open file.

404
00:26:29,400 --> 00:26:36,120
But now we were iterating over that new in that new implementation.

405
00:26:36,200 --> 00:26:41,600
Obviously it wasn't a problem for me, but it was for other people who were passing file-like

406
00:26:41,600 --> 00:26:45,400
objects to this function and that stopped working.

407
00:26:45,400 --> 00:26:50,040
So I had to put this piece of documentation that is still there now to shame me forever

408
00:26:50,040 --> 00:26:53,880
that I haven't really foreseen this problem.

409
00:26:53,880 --> 00:26:58,280
But you know, and if you have to rationalize your mistakes later in life, because, you

410
00:26:58,280 --> 00:27:02,160
know, otherwise you're going to just be a sad person with plenty of regret.

411
00:27:02,200 --> 00:27:09,160
So I tend to realize that, you know, maybe when I wanted a file and the documentation

412
00:27:09,160 --> 00:27:15,080
never said anything else, that please give me an open file, me changing my requirements

413
00:27:15,080 --> 00:27:20,840
as to which part of that file I want to use isn't really that unreasonable.

414
00:27:20,840 --> 00:27:27,520
So if you spend your time cutting your contract really neatly to expose only the minimum of

415
00:27:27,520 --> 00:27:30,200
what you want, that's perfect, that's great.

416
00:27:30,240 --> 00:27:33,160
But in the future you might actually want a little more.

417
00:27:33,160 --> 00:27:37,560
For example, if your function accepts a file-like object but later on you realize that you want

418
00:27:37,560 --> 00:27:44,160
to log an error case and actually tell people the path to, you know, where stuff gets wrong,

419
00:27:44,160 --> 00:27:48,720
now you have to use the .name attribute on a file-like object and you might have not

420
00:27:48,720 --> 00:27:50,840
required this before.

421
00:27:50,840 --> 00:27:56,480
This is not awesome because existing code, especially on PyPI, this is open source, might

422
00:27:56,480 --> 00:27:59,400
give you a lot of grief.

423
00:27:59,400 --> 00:28:05,680
So in the end I tend to simplify and just, you know, be concrete about the types that

424
00:28:05,680 --> 00:28:12,040
I expect people to be able to put, even if something more will be in fact accepted at

425
00:28:12,040 --> 00:28:13,040
runtime.

426
00:28:13,040 --> 00:28:20,320
I want to be concrete because it's my contract from me to you, from programmer to a programmer.

427
00:28:20,320 --> 00:28:25,720
So now let's talk about the mismatch between static typing and what Python allows to do

428
00:28:25,720 --> 00:28:28,600
at runtime because it allows for a lot.

429
00:28:28,600 --> 00:28:33,080
So you can perceive some of the limitations of static typing as like seat belts.

430
00:28:33,080 --> 00:28:34,320
You just put them on.

431
00:28:34,320 --> 00:28:37,040
You don't even, you know, think about it.

432
00:28:37,040 --> 00:28:42,120
Or you might think about those limitations more like the masks that you're wearing, you

433
00:28:42,120 --> 00:28:47,300
know, a sad, sad reality that we're in, but you know, you'd rather not.

434
00:28:47,300 --> 00:28:49,160
So let's see.

435
00:28:49,160 --> 00:28:50,960
Let's start with a simple thing.

436
00:28:50,960 --> 00:28:52,880
One variable, one type.

437
00:28:52,880 --> 00:28:58,280
Python will not complain if you reassign a given name to mean something entirely different,

438
00:28:58,280 --> 00:29:02,160
to have a different type, to have a totally incompatible value later on.

439
00:29:02,160 --> 00:29:07,720
It's all good, you know, in terms of how runtime perceives this.

440
00:29:07,720 --> 00:29:11,960
A type checker will be annoyed at you if you do this.

441
00:29:11,960 --> 00:29:14,800
So now the question is, who's right?

442
00:29:14,800 --> 00:29:17,080
Well, obviously, Python at runtime is right.

443
00:29:17,080 --> 00:29:18,900
It will run your code fine.

444
00:29:18,900 --> 00:29:23,000
But do you need this form of dynamicism all the time?

445
00:29:23,000 --> 00:29:27,880
If you even have a very simple example, that is a little jarring because your function

446
00:29:27,880 --> 00:29:33,400
signature tells you that argument is one thing, whereas after this conversion to daytime,

447
00:29:33,400 --> 00:29:35,600
it is suddenly something else.

448
00:29:35,600 --> 00:29:37,800
No, great.

449
00:29:37,800 --> 00:29:42,400
Especially when this conversion doesn't happen right there on line one, but happens on line

450
00:29:42,400 --> 00:29:48,080
20 of this function, or it happens only in some conditional, or better yet, if this is

451
00:29:48,080 --> 00:29:52,800
in an object and under in it creates a bunch of attributes of one type, but then some other

452
00:29:52,800 --> 00:29:56,040
method modifies them to mean something else.

453
00:29:56,040 --> 00:30:02,040
It is very confusing very quickly, and it's hard to say whether this was the intent of

454
00:30:02,040 --> 00:30:03,240
the programmer.

455
00:30:03,240 --> 00:30:08,920
So static typing errors on the side of caution saying, you know, this used to be a string,

456
00:30:08,920 --> 00:30:10,960
and now you're trying to make it a daytime.

457
00:30:10,960 --> 00:30:12,120
Are you sure?

458
00:30:12,120 --> 00:30:16,880
The solution here is obvious, and we should just move on, just use another name, right?

459
00:30:16,880 --> 00:30:22,000
Like, I know that there's implementers of Python interpreters in the room, so they will

460
00:30:22,880 --> 00:30:29,080
not exactly free, but for our intent and purpose here, they pretty much are.

461
00:30:29,080 --> 00:30:32,600
Adding just one more name is not going to destroy the world.

462
00:30:32,600 --> 00:30:37,760
In fact, it's useful, because if you ever debug this function and you list its locals,

463
00:30:37,760 --> 00:30:41,880
now you will be able to see the value pre-conversion and post-conversion.

464
00:30:41,880 --> 00:30:47,040
So if the bug is actually in the convert to daytime function, it will be easier for you

465
00:30:47,160 --> 00:30:52,120
to identify this, faster for you to identify this.

466
00:30:52,120 --> 00:30:58,320
This all comes down to the difference between dock typing, so structural typing, and nominal

467
00:30:58,320 --> 00:31:05,480
typing, so us telling that this is an int, this is a string, this is a list of string.

468
00:31:05,480 --> 00:31:10,920
This difference is highlighted sometimes, you know, when people talk about type annotations,

469
00:31:10,920 --> 00:31:15,360
but for me personally, they aren't actually that different.

470
00:31:15,520 --> 00:31:23,000
So it is true entirely that when we are running Python code, unless you're running its instance

471
00:31:23,000 --> 00:31:26,040
or subclass, Python doesn't care about the types.

472
00:31:26,040 --> 00:31:31,520
All it cares about is if you have an object and you look up some attribute on it, that

473
00:31:31,520 --> 00:31:33,160
it finds this attribute.

474
00:31:33,160 --> 00:31:37,440
Or if you're calling a method on an object, it finds that method and its signature is

475
00:31:37,440 --> 00:31:41,660
compatible with whatever arguments were given during the call.

476
00:31:41,660 --> 00:31:44,480
As long as that's fine, it doesn't care, right?

477
00:31:44,520 --> 00:31:49,680
If it quacks like a duck, it's a duck, as much as we care.

478
00:31:49,680 --> 00:31:56,760
Nominal subtyping means that in function signatures, in type annotations, we don't really specify

479
00:31:56,760 --> 00:32:01,500
what we're going to be using, we're saying what this thing should be, what it is.

480
00:32:01,500 --> 00:32:06,280
So we need an integer, we need a decimal, we need a string, we need a path object, this

481
00:32:06,280 --> 00:32:08,100
sort of thing.

482
00:32:08,100 --> 00:32:15,140
But if you look at a program, even at a big one, there's always only a finite set of which

483
00:32:15,140 --> 00:32:21,260
objects actually conform to the operations that you're doing on the object within your

484
00:32:21,260 --> 00:32:22,260
function.

485
00:32:22,260 --> 00:32:27,940
So at worst, what you will be dealing with is some union of possible types that can actually

486
00:32:27,940 --> 00:32:34,260
successfully respond to whatever the function is doing with a given argument.

487
00:32:34,260 --> 00:32:39,980
So with that in mind, nominally listing those, either one, in the happy case, or a union

488
00:32:39,980 --> 00:32:42,220
of a few, isn't really that bad.

489
00:32:42,220 --> 00:32:44,860
There is not really a huge disconnect there.

490
00:32:44,860 --> 00:32:51,500
And better yet, nominal typing doesn't mean you only have to specify concrete classes.

491
00:32:51,500 --> 00:32:57,100
There's abstract base classes now, so you can say iterable of string just as well if

492
00:32:57,100 --> 00:33:03,440
you don't mean a particular implementation, only care about some structure.

493
00:33:03,440 --> 00:33:08,640
And if you really want a flexible structure, protocols allow for that too.

494
00:33:08,640 --> 00:33:12,160
But giving nominal types is sometimes helpful for us.

495
00:33:12,160 --> 00:33:19,320
For example, when we're dealing with dynamicism of Python that can be sometimes dangerous.

496
00:33:19,320 --> 00:33:24,120
For example, in Python, a string is also an iterable of strings.

497
00:33:24,120 --> 00:33:29,280
If you pass a single string to a for loop, it will happily split the string character

498
00:33:29,280 --> 00:33:33,160
per character and do the iteration with no complaints.

499
00:33:33,160 --> 00:33:37,280
But if we look at the previous example, in the actual black code, what we have is not

500
00:33:37,280 --> 00:33:42,080
an iterable of path, which is a happy case, but an iterable of string, where a single

501
00:33:42,080 --> 00:33:43,640
string is also one.

502
00:33:43,640 --> 00:33:45,440
So do we want this?

503
00:33:45,440 --> 00:33:46,840
Is this a feature for us?

504
00:33:46,840 --> 00:33:51,800
If we by mistake specify a single string, now the for loop will cut the string into

505
00:33:51,800 --> 00:33:56,120
characters and happily try them as candidates.

506
00:33:56,120 --> 00:33:57,120
This is meaningless.

507
00:33:57,120 --> 00:34:03,040
So what we have to do is either to do this dreaded instance where duck type people will

508
00:34:03,040 --> 00:34:08,240
tell you don't use this instance, that's anti-duck typing, but you have to do it here,

509
00:34:08,240 --> 00:34:13,520
because otherwise you will be opening yourself up to this bug.

510
00:34:13,520 --> 00:34:18,280
What you can also do, though, is to just say we don't want iterable of string.

511
00:34:18,280 --> 00:34:19,800
We want a list of string.

512
00:34:19,800 --> 00:34:25,560
Yes, other types will be accepted too, but through this simplification, we are dealing

513
00:34:25,560 --> 00:34:30,720
with a class of errors that people can do.

514
00:34:30,800 --> 00:34:37,640
This leads us to typing things that are not quite clear to how to do.

515
00:34:37,640 --> 00:34:41,520
Very often you will be tempted to just put any there.

516
00:34:41,520 --> 00:34:44,440
So let's talk about this for a second.

517
00:34:44,440 --> 00:34:49,560
People who are just beginning with typing often ask me, you know, isn't object the base

518
00:34:49,560 --> 00:34:51,540
class of everything in Python?

519
00:34:51,540 --> 00:34:55,240
So why do we need to import any from typing?

520
00:34:55,240 --> 00:35:00,440
If I say this should be object, like, won't it be true as well?

521
00:35:00,440 --> 00:35:05,520
Well, for the typing use case, they're actually opposites.

522
00:35:05,520 --> 00:35:10,680
When you are typing an argument to be a string, what it tells the type checker is that any

523
00:35:10,680 --> 00:35:16,880
operation which is valid on a string, so concatenating it to another string or calling the upper

524
00:35:16,880 --> 00:35:19,240
method, all those things are fine.

525
00:35:19,240 --> 00:35:24,240
But if you call, say, append, the type checker will now complain because that operation is

526
00:35:24,280 --> 00:35:27,280
not implemented on strings.

527
00:35:27,280 --> 00:35:32,480
So if you would say object, right, if you would annotate an argument as object, what

528
00:35:32,480 --> 00:35:39,280
that tells the type checker is that any operation that is valid on the base object type is accepted

529
00:35:39,280 --> 00:35:41,240
and nothing else.

530
00:35:41,240 --> 00:35:43,440
What operations do objects accept?

531
00:35:43,440 --> 00:35:50,280
Well, you can check its ID, you can convert it to a Boolean, you can see its wrapper.

532
00:35:50,280 --> 00:35:51,280
Not much than that.

533
00:35:51,600 --> 00:35:57,800
All the upper appends and other attributes are not there on the base type.

534
00:35:57,800 --> 00:35:59,680
So any is the opposite.

535
00:35:59,680 --> 00:36:05,940
It tells the type checker that whatever operation the user will do inside that function should

536
00:36:05,940 --> 00:36:07,400
be considered valid.

537
00:36:07,400 --> 00:36:10,200
Please don't raise exceptions there.

538
00:36:10,200 --> 00:36:11,920
So any is tempting.

539
00:36:11,920 --> 00:36:17,220
You might be tempted to use it whenever you don't know what you should be putting instead.

540
00:36:17,220 --> 00:36:18,440
But it's not that great.

541
00:36:18,480 --> 00:36:25,600
The reason why it's not is it will, again, proliferate just like none does and silence

542
00:36:25,600 --> 00:36:32,440
actually valid warnings from the type checker because now it is instructed by you explicitly

543
00:36:32,440 --> 00:36:36,440
to ignore problems that it sees elsewhere in your code.

544
00:36:36,440 --> 00:36:43,440
So any should be sort of taken with a grain of salt and used with care.

545
00:36:43,520 --> 00:36:47,600
And let me just finish with another controversial thing because, you know, like I only had one

546
00:36:47,600 --> 00:36:56,400
so far, which is that I started considering strings to be not much better than any because

547
00:36:56,400 --> 00:36:59,320
a string can be an identifier from a database.

548
00:36:59,320 --> 00:37:00,640
It can be an email address.

549
00:37:00,640 --> 00:37:04,400
It can be an entire poem or a JSON encoded image.

550
00:37:04,400 --> 00:37:06,080
It can be whatever.

551
00:37:06,080 --> 00:37:11,200
So when you use strings as types everywhere, what are you getting?

552
00:37:11,200 --> 00:37:12,440
You don't actually know.

553
00:37:12,440 --> 00:37:16,120
So I'm not saying you should be not using strings from now on.

554
00:37:16,120 --> 00:37:20,160
But whenever you're seeing that your function accepts a bunch of strings everywhere, let's

555
00:37:20,160 --> 00:37:25,780
think about, like, hey, maybe there is some other representation that I can use that will

556
00:37:25,780 --> 00:37:31,920
explain my intent better and make sure that I'm not swapping a string that is incompatible

557
00:37:31,920 --> 00:37:35,600
with one that I actually wanted.

558
00:37:35,600 --> 00:37:41,560
So I could still keep talking and keep talking and keep you from the nice coffee break that

559
00:37:41,560 --> 00:37:44,000
I'll come after.

560
00:37:44,000 --> 00:37:51,440
But there's only that much of typing information a person can reasonably get at one point.

561
00:37:51,440 --> 00:37:53,720
So let me just give you some further reading.

562
00:37:53,720 --> 00:37:58,400
If you're actually dealing with JSON that I just mentioned, TypeDict will allow you

563
00:37:58,400 --> 00:38:04,600
to say that if the key is named email, it's going to be a string.

564
00:38:04,600 --> 00:38:09,280
But if it's named birth year, it's going to be a number.

565
00:38:09,280 --> 00:38:16,280
So you can actually now annotate strongly some random dictionaries you're getting from

566
00:38:16,280 --> 00:38:17,720
the internet.

567
00:38:17,720 --> 00:38:21,240
We already talked about giving meaningful names to strings.

568
00:38:21,240 --> 00:38:27,040
But there's still nothing stopping you from putting an artist name where a song name should

569
00:38:27,040 --> 00:38:28,040
go.

570
00:38:28,040 --> 00:38:33,240
So new type is a functionality of typing where you can actually semantically differentiate

571
00:38:33,240 --> 00:38:37,080
between two kinds of strings or numbers or whatever else.

572
00:38:37,080 --> 00:38:38,420
So look up new type.

573
00:38:38,420 --> 00:38:40,020
It is very good for that.

574
00:38:40,020 --> 00:38:45,020
And finally, in the talk, you might have gotten the impression that I'm not really that happy

575
00:38:45,020 --> 00:38:46,860
about structural typing.

576
00:38:46,860 --> 00:38:48,660
No, it's not what I'm saying.

577
00:38:48,660 --> 00:38:54,460
It's just that sometimes it is a little too heavy of a tool for what you actually need.

578
00:38:54,460 --> 00:38:57,860
But since my name is on the pep, please read the protocols.

579
00:38:57,860 --> 00:39:04,260
It's a wonderful feature of typing as well, which gives us a lot of flexibility to actually

580
00:39:04,260 --> 00:39:07,460
merge duck typing with type checkers.

581
00:39:07,460 --> 00:39:09,740
So go ahead and look.

582
00:39:09,740 --> 00:39:14,820
It will likely solve issues that you might be having later on in the future.

583
00:39:14,820 --> 00:39:19,780
And a class of errors that, you know, annotations that I like to talk about but there's no time

584
00:39:19,780 --> 00:39:21,700
right now is self-type.

585
00:39:21,700 --> 00:39:26,480
So whenever a function accepts some object and returns another one like it or accepts

586
00:39:26,480 --> 00:39:29,220
a type and returns an instance of it.

587
00:39:29,220 --> 00:39:33,980
This is a very, very popular scheme in Python because it's how methods and class methods

588
00:39:33,980 --> 00:39:34,980
work.

589
00:39:34,980 --> 00:39:40,100
So reading on self-type and how to use type bars and the newly added self is going to

590
00:39:40,100 --> 00:39:44,900
help you actually navigate this sort of thing, especially when subclassing is involved.

591
00:39:44,900 --> 00:39:51,820
And finally, variance is a word where I'm, like, you know, sure to lose the audience.

592
00:39:51,820 --> 00:39:55,740
So instead of talking about it right now, I'm going to be giving a lightning talk later

593
00:39:55,740 --> 00:39:59,660
today just in five minutes just about variance.

594
00:39:59,660 --> 00:40:04,660
You might just laugh at it later, but you might actually get what contravariance, covariance,

595
00:40:04,820 --> 00:40:06,780
and variance are.

596
00:40:06,780 --> 00:40:10,540
And the funny thing about this is that people hate static typing for variance.

597
00:40:10,540 --> 00:40:14,660
They're like, you know, those weird terms, like, why are you imposing this on me?

598
00:40:14,660 --> 00:40:18,260
But this is something that you're dealing with in collections even if you don't think

599
00:40:18,260 --> 00:40:19,580
about this.

600
00:40:19,580 --> 00:40:21,340
Same with list of substitution principle.

601
00:40:21,340 --> 00:40:25,060
You might be breaking it even if you never used a type checker.

602
00:40:25,060 --> 00:40:29,420
The type checker only exposes those classes of issues.

603
00:40:29,420 --> 00:40:33,780
So reading up on all of this is very, very useful.

604
00:40:33,780 --> 00:40:39,540
So, you know, there can be too much of a good thing just like with this talk.

605
00:40:39,540 --> 00:40:47,900
So for example, if you find yourself, you know, fighting type annotations, if you find

606
00:40:47,900 --> 00:40:56,900
yourself unable to express what is happening, you can take a step back and ask yourself,

607
00:40:56,900 --> 00:41:00,020
hey, like, Python is dynamic.

608
00:41:00,020 --> 00:41:01,180
Should I be using those features?

609
00:41:01,180 --> 00:41:02,180
Yes, of course.

610
00:41:02,220 --> 00:41:03,820
This is why we're on PyCon.

611
00:41:03,820 --> 00:41:04,820
Come on.

612
00:41:04,820 --> 00:41:06,180
Dynamicism is great.

613
00:41:06,180 --> 00:41:09,460
The flexibility that we have from run time introspection is wonderful.

614
00:41:09,460 --> 00:41:11,060
We should be using those things.

615
00:41:11,060 --> 00:41:14,700
But should you be 100% dynamic 100% of the time?

616
00:41:14,700 --> 00:41:16,660
I would argue that you don't have to.

617
00:41:16,660 --> 00:41:22,460
So whenever you find that your types are especially ugly, just consider refactoring.

618
00:41:22,460 --> 00:41:23,860
Maybe you can simplify.

619
00:41:23,860 --> 00:41:27,500
And if you cannot, maybe you can shove the complexity somewhere else.

620
00:41:27,500 --> 00:41:28,980
So divide and conquer.

621
00:41:29,020 --> 00:41:34,260
This doesn't fundamentally change the amount of complexity in the system, but it will let

622
00:41:34,260 --> 00:41:40,140
you deal with a smaller amount at a time, which even in the Zen of Python is a good

623
00:41:40,140 --> 00:41:41,340
thing.

624
00:41:41,340 --> 00:41:45,020
So with that in mind, I'm not sure if we have time for questions right now.

625
00:41:45,020 --> 00:41:46,180
If we do, that's great.

626
00:41:46,180 --> 00:41:50,340
If not, I'm happy to answer any questions you might be having if you find me at the

627
00:41:50,340 --> 00:41:51,340
conference.

628
00:41:51,340 --> 00:41:53,660
I'm going to be masked, so it's going to be a challenge for you.

629
00:41:53,660 --> 00:41:55,500
But I'm here for you.

630
00:41:55,500 --> 00:41:56,500
Thank you for your attention.

