1
00:00:00,000 --> 00:00:03,640
Hello everyone.

2
00:00:03,640 --> 00:00:06,720
Hi. Thanks for coming to this workshop.

3
00:00:06,720 --> 00:00:08,020
We're going to start in a minute.

4
00:00:08,020 --> 00:00:11,680
So just a couple of things around this.

5
00:00:11,680 --> 00:00:16,640
So this URL is going to be the URL with all the information

6
00:00:16,640 --> 00:00:19,360
for the workshop and it's a living workshop in the sense

7
00:00:19,360 --> 00:00:24,080
that it's going to change in the next few weeks or months.

8
00:00:24,080 --> 00:00:26,440
So I don't know if you've already seen strawberry.

9
00:00:26,440 --> 00:00:29,200
Strawberry is quite, well it's not really new anymore.

10
00:00:29,280 --> 00:00:31,280
It's been four years, but we're working a lot

11
00:00:31,280 --> 00:00:34,760
to make it more production ready or easier

12
00:00:34,760 --> 00:00:37,280
to make it production ready.

13
00:00:37,280 --> 00:00:39,920
So there's going to be quite a bit of changes in future

14
00:00:39,920 --> 00:00:43,520
in terms of less things you have to do manually to make

15
00:00:43,520 --> 00:00:46,760
like a GraphQL application more production ready,

16
00:00:46,760 --> 00:00:48,840
like more secure and faster and so on.

17
00:00:48,840 --> 00:00:52,400
So I definitely want you to keep this URL around.

18
00:00:52,400 --> 00:00:57,520
It's going to be updated in the next few months.

19
00:00:57,560 --> 00:01:01,320
And yeah, hopefully everyone has it.

20
00:01:01,320 --> 00:01:05,000
This, again, this workshop is going to be quite interactive.

21
00:01:05,000 --> 00:01:08,440
So we're going to build things together.

22
00:01:08,440 --> 00:01:10,400
I'm happy to take any questions.

23
00:01:10,400 --> 00:01:11,720
There's a microphone there.

24
00:01:11,720 --> 00:01:14,040
So anytime, just feel free to stop me

25
00:01:14,040 --> 00:01:17,680
to ask any questions and to repeat.

26
00:01:17,680 --> 00:01:21,040
We, yeah, I'm going to explain what GraphQL is,

27
00:01:21,040 --> 00:01:24,600
but if you want to kick off the setup while I'm going

28
00:01:24,600 --> 00:01:26,680
to talk a bit, there's two options.

29
00:01:26,680 --> 00:01:28,960
One is using Gitbot, so you can click here.

30
00:01:28,960 --> 00:01:33,240
It goes to the service called Gitbot, which is like a remote VM.

31
00:01:33,240 --> 00:01:40,200
There is VS code and allows you to quickly spin up a machine

32
00:01:40,200 --> 00:01:41,560
with Python, everything is also,

33
00:01:41,560 --> 00:01:43,360
you don't have to configure anything.

34
00:01:43,360 --> 00:01:47,520
A test this morning should work, but if there's any,

35
00:01:47,520 --> 00:01:51,080
just let me know, we'll figure it out.

36
00:01:51,080 --> 00:01:54,360
Yeah, once you open this, it's going to open a terminal.

37
00:01:54,400 --> 00:01:56,320
It's going to install Python 3.10.

38
00:01:56,320 --> 00:01:58,320
It's going to install other things.

39
00:01:58,320 --> 00:02:01,880
I guess one difference between this and the other option,

40
00:02:01,880 --> 00:02:04,880
the other option is using just VisualMV, and this one is using PDM,

41
00:02:04,880 --> 00:02:09,800
which is my package manager of choice, and I'm just using

42
00:02:09,800 --> 00:02:12,040
because it's convenient, but I think you don't have

43
00:02:12,040 --> 00:02:14,920
to do anything with PDM, and if you have any question on that,

44
00:02:14,920 --> 00:02:17,920
I'm happy to also answer those.

45
00:02:17,920 --> 00:02:19,400
But yeah, basically, once you click,

46
00:02:19,400 --> 00:02:22,120
it's going to install everything.

47
00:02:22,160 --> 00:02:25,960
And yeah, the other option is to just do it like standard,

48
00:02:25,960 --> 00:02:29,240
so you clone the repo, create VirtualMV,

49
00:02:29,240 --> 00:02:32,240
install the requirements, and then run a couple of commands

50
00:02:32,240 --> 00:02:36,200
to make sure that everything works, which I'm going to do now as well,

51
00:02:36,200 --> 00:02:41,320
so just to double check that everything is fine.

52
00:02:45,200 --> 00:02:49,680
Yeah, a couple of things more.

53
00:02:49,720 --> 00:02:53,480
So we're going to use Django for this, mostly because I'm very familiar

54
00:02:53,480 --> 00:02:55,920
with Django, I know how to use models and things like that,

55
00:02:55,920 --> 00:02:58,760
but again, this workshop is not really about Django.

56
00:02:58,760 --> 00:03:01,840
We're actually going to see things more in agnostic way,

57
00:03:01,840 --> 00:03:03,880
so we're going to use Django models, but we're not going

58
00:03:03,880 --> 00:03:09,160
to use any automatic generation of GraphQL types from Django models

59
00:03:09,160 --> 00:03:11,800
at all, because that's one way of doing things,

60
00:03:11,800 --> 00:03:15,800
but it's not really the way I would recommend to create a GraphQL API.

61
00:03:15,840 --> 00:03:19,760
So I guess a GraphQL API should be a basic book on the clients,

62
00:03:19,760 --> 00:03:23,000
not what you have on the database, but we'll see that in a moment.

63
00:03:23,000 --> 00:03:27,640
So this is installed, so if I run PyTest, it should work.

64
00:03:27,640 --> 00:03:29,600
There we go.

65
00:03:29,600 --> 00:03:32,080
So the output is verbose.

66
00:03:32,080 --> 00:03:35,920
At the moment I'm printing all the SQL queries, mostly to show you some

67
00:03:35,920 --> 00:03:37,640
performance optimization in the future.

68
00:03:37,640 --> 00:03:41,240
Yes? Again?

69
00:03:41,240 --> 00:03:45,080
Yeah. I don't know if there's a good way of putting this, but yeah,

70
00:03:45,120 --> 00:03:46,800
workshop.strawberrydorax.

71
00:03:53,080 --> 00:03:59,240
Cool. And yeah, so once everything is set up, you can run the tests,

72
00:03:59,240 --> 00:04:03,360
and then you can also import, it's written there,

73
00:04:03,360 --> 00:04:05,040
but I'll do it with you as well.

74
00:04:05,040 --> 00:04:08,600
You can import some podcasts, so we're going to build an API that allows you

75
00:04:08,600 --> 00:04:14,040
to list podcasts and podcast episodes, and so to get some data,

76
00:04:14,200 --> 00:04:18,080
we can import them like this.

77
00:04:18,080 --> 00:04:21,800
So I created a small command line application that just fetches data

78
00:04:21,800 --> 00:04:25,320
from SS feeds and loads them into the database.

79
00:04:25,320 --> 00:04:26,600
And again, this is very verbose

80
00:04:26,600 --> 00:04:30,800
because I am printing all the SQL code that's happening.

81
00:04:30,800 --> 00:04:35,080
Anyway, this is going to take maybe a bit of time

82
00:04:35,080 --> 00:04:38,400
since we are all on the internet.

83
00:04:38,400 --> 00:04:41,600
Cool. Yeah.

84
00:04:41,640 --> 00:04:45,520
So I guess, again, do a bit of introduction as well,

85
00:04:45,520 --> 00:04:47,080
introduction about myself.

86
00:04:47,080 --> 00:04:49,840
So my name is Patrick.

87
00:04:49,840 --> 00:04:52,360
I've been working on Strawberry for about four years.

88
00:04:52,360 --> 00:04:55,080
I created it, yeah, four years ago.

89
00:04:55,080 --> 00:04:57,960
I don't remember the exact date, but it's been quite a while,

90
00:04:57,960 --> 00:05:00,760
and it's becoming quite popular.

91
00:05:00,760 --> 00:05:04,360
It's still a niche project, I guess, for especially GraphQL in Python.

92
00:05:04,360 --> 00:05:07,640
It's not super popular, but I think it's growing over time.

93
00:05:07,640 --> 00:05:10,520
And yeah, over the last two years,

94
00:05:10,520 --> 00:05:13,280
I think there's been quite a few people using it in production,

95
00:05:13,280 --> 00:05:17,800
and basically like the community around it grew a lot.

96
00:05:17,800 --> 00:05:19,400
So I decided to start doing workshop

97
00:05:19,400 --> 00:05:22,200
and basically help people starting with this project.

98
00:05:22,200 --> 00:05:24,600
I work at a company called Apollo GraphQL,

99
00:05:24,600 --> 00:05:29,520
and we do tooling around GraphQL, but we're not going to see any of that.

100
00:05:29,520 --> 00:05:30,840
This is like what I'm doing here.

101
00:05:30,840 --> 00:05:32,280
It's like my own thing.

102
00:05:32,280 --> 00:05:36,880
It's not sponsored by my company, unfortunately.

103
00:05:36,920 --> 00:05:39,840
But yeah, if you have any questions about that, we can talk about that.

104
00:05:39,840 --> 00:05:46,600
But yeah, this workshop is purely on GraphQL and Strawberry.

105
00:05:46,600 --> 00:05:49,760
Okay, so what is GraphQL?

106
00:05:49,760 --> 00:05:52,920
So if you're not familiar with GraphQL, GraphQL is a query language

107
00:05:52,920 --> 00:05:56,920
that allows you to query APIs and get data from those APIs.

108
00:05:56,920 --> 00:05:58,520
You're going to see an example of that.

109
00:05:58,520 --> 00:06:05,120
But basically, GraphQL is, like to put it simply, it's an alternative to REST.

110
00:06:05,160 --> 00:06:07,760
It basically allows you to query APIs that you can use

111
00:06:07,760 --> 00:06:11,560
with your mobile application or website and so on.

112
00:06:11,560 --> 00:06:15,800
It was created by Facebook in 2012 and open sourced in 2015,

113
00:06:15,800 --> 00:06:18,960
and actually now is not tied to Facebook anymore.

114
00:06:18,960 --> 00:06:21,640
There's a GraphQL foundation which is fully open source

115
00:06:21,640 --> 00:06:25,680
and so anyone can use GraphQL without having to worry

116
00:06:25,680 --> 00:06:28,600
about licensing and things like that, which is quite nice.

117
00:06:28,600 --> 00:06:33,120
And this company, this foundation, GraphQL foundation is also responsible

118
00:06:33,120 --> 00:06:38,000
for growing GraphQL and updating the spec and making more,

119
00:06:38,000 --> 00:06:43,240
I guess, future proof and adding new features over time.

120
00:06:43,240 --> 00:06:46,800
Yeah, so in this workshop, we're going to learn how to use Strawberry

121
00:06:46,800 --> 00:06:48,200
to build GraphQL APIs.

122
00:06:48,200 --> 00:06:50,880
We're going to use Python 3.7 or later.

123
00:06:50,880 --> 00:06:56,400
I think at some point, this workshop, we're going to use mostly Python 3.10

124
00:06:56,400 --> 00:06:59,600
or more because there's quite a few typing features

125
00:06:59,600 --> 00:07:02,960
that make the code a bit nicer.

126
00:07:02,960 --> 00:07:07,480
But again, Strawberry at the moment works from 3.7 up until 3.11.

127
00:07:07,480 --> 00:07:08,640
So you can use anything.

128
00:07:08,640 --> 00:07:12,520
I use VS Code, but you can use anything as well there.

129
00:07:12,520 --> 00:07:16,480
Yeah, we're going to learn, well, this is actually,

130
00:07:16,480 --> 00:07:17,880
there's more things we're going to learn than this,

131
00:07:17,880 --> 00:07:21,600
so don't worry about that.

132
00:07:21,600 --> 00:07:25,480
Yeah, we're going to build an API for a podcast application.

133
00:07:25,480 --> 00:07:28,200
This is a project I was working on while ago, then I stopped,

134
00:07:28,200 --> 00:07:32,560
but I think it's quite useful to learn a few things about GraphQL.

135
00:07:33,040 --> 00:07:35,200
So we can list podcasts.

136
00:07:35,200 --> 00:07:36,520
We can get a single podcast.

137
00:07:36,520 --> 00:07:39,360
We can list all the latest episodes for a podcast,

138
00:07:39,360 --> 00:07:43,080
and we can also subscribe to a single podcast.

139
00:07:43,080 --> 00:07:46,480
Okay. So I mentioned the setup.

140
00:07:46,480 --> 00:07:48,600
So this is the setup.

141
00:07:48,600 --> 00:07:49,920
You can follow it.

142
00:07:49,920 --> 00:07:51,800
Again, if you have issues, try use Gitpod.

143
00:07:51,800 --> 00:07:54,960
It should work fine.

144
00:07:54,960 --> 00:07:57,280
And yeah, I did run everything here.

145
00:07:57,280 --> 00:07:59,800
So yeah, this is, I have all the data imported,

146
00:07:59,840 --> 00:08:05,960
and now I can run a server, and we're going to see GraphQL itself.

147
00:08:05,960 --> 00:08:08,320
So there is this tool called GraphiQL,

148
00:08:08,320 --> 00:08:11,840
which is a graphical interface for GraphQL, hence the name.

149
00:08:11,840 --> 00:08:18,480
And it basically allows you to run API calls to your GraphQL APIs.

150
00:08:18,480 --> 00:08:23,000
So I guess the first thing to note here, there is this text here,

151
00:08:23,000 --> 00:08:26,160
which is basically where you can write document to test the query.

152
00:08:26,160 --> 00:08:29,480
And so we do have one single query called hello.

153
00:08:30,440 --> 00:08:34,920
So this document is going to be sent to the server,

154
00:08:34,920 --> 00:08:38,000
and then the server is going to do, you know, its magic and fetch data.

155
00:08:38,000 --> 00:08:42,920
So if I click here, I'm going to see a response, right?

156
00:08:42,920 --> 00:08:47,320
And just want to show you a couple of things here of what is happening.

157
00:08:47,320 --> 00:08:51,600
So when I do this request, I'm actually doing a post request.

158
00:08:51,600 --> 00:08:53,280
This is a standard thing in GraphQL.

159
00:08:53,280 --> 00:08:55,720
Every request is a post request.

160
00:08:55,720 --> 00:08:59,320
And I think the reason why it's been always post request is

161
00:08:59,360 --> 00:09:03,280
because of the fact that this document can get quite long.

162
00:09:03,280 --> 00:09:08,240
And so you might end up, you know, having a document that doesn't fit

163
00:09:08,240 --> 00:09:12,960
into the URL of the, well, in the network.

164
00:09:12,960 --> 00:09:15,720
So they use post.

165
00:09:15,720 --> 00:09:17,720
But you can also change it to be get.

166
00:09:17,720 --> 00:09:21,000
So if you need to, you can change to be get,

167
00:09:21,000 --> 00:09:25,440
and it makes things a bit more, they make it easier to cache.

168
00:09:25,480 --> 00:09:28,680
But we can go into that later maybe.

169
00:09:28,680 --> 00:09:32,800
And yeah, when I send this document, I'm basically sending the query.

170
00:09:32,800 --> 00:09:37,560
And if I have some variables, like if I want to make a dynamic request,

171
00:09:37,560 --> 00:09:40,480
that's also going to be sent.

172
00:09:40,480 --> 00:09:42,640
And yeah, we're going to see, I guess,

173
00:09:42,640 --> 00:09:44,480
this API at the moment doesn't have really much.

174
00:09:44,480 --> 00:09:45,800
It's only this field.

175
00:09:45,800 --> 00:09:51,200
So we're not going to see all the power feature of GraphQL,

176
00:09:51,200 --> 00:09:54,640
but we'll see them while we implement everything.

177
00:09:54,680 --> 00:09:58,200
On top of that, there is also like a documentation.

178
00:09:58,200 --> 00:10:02,080
So this is built automatically by GraphQL.

179
00:10:02,080 --> 00:10:05,320
So every time you create a GraphQL API, it has a schema.

180
00:10:05,320 --> 00:10:08,440
And this schema has all the types that you can use

181
00:10:08,440 --> 00:10:10,360
and all the operations that you can do.

182
00:10:10,360 --> 00:10:14,480
So one thing to note here is that there is two types.

183
00:10:14,480 --> 00:10:17,280
One is called query, and one is called mutation.

184
00:10:17,280 --> 00:10:20,280
Query is basically fetching data.

185
00:10:20,280 --> 00:10:23,400
So it could be equivalent to a get request.

186
00:10:23,440 --> 00:10:25,840
In this case, we only have hello.

187
00:10:25,840 --> 00:10:31,480
And then we have mutation that's equivalent to like anything that's

188
00:10:31,480 --> 00:10:34,560
not get, like pause, delete, patch, put, and so on.

189
00:10:34,560 --> 00:10:40,760
It allows you to do anything that has side effects on your database,

190
00:10:40,760 --> 00:10:43,040
for example, on your server.

191
00:10:43,040 --> 00:10:45,080
Yeah. There's also another one.

192
00:10:45,080 --> 00:10:46,400
It's called subscription.

193
00:10:46,400 --> 00:10:48,440
We allow you to subscribe to events.

194
00:10:48,440 --> 00:10:50,560
We're not going to see that today.

195
00:10:50,600 --> 00:10:53,600
Also, mutation has one field called hello as well.

196
00:10:53,600 --> 00:10:56,400
But we're going to create one and see how everything works.

197
00:10:59,240 --> 00:11:03,800
Okay. Just so right there, you can follow the tutorial here,

198
00:11:03,800 --> 00:11:05,960
workshop.strawberrytherocks.

199
00:11:05,960 --> 00:11:09,840
And yeah, so that's basically like GraphQL in a nutshell.

200
00:11:09,840 --> 00:11:14,440
So you can send the query like this, and then you get data back.

201
00:11:14,440 --> 00:11:17,880
If you want to use a mutation, like the syntax is the same,

202
00:11:17,880 --> 00:11:20,560
but you change the operation type at the top.

203
00:11:20,560 --> 00:11:23,400
So you can do query or mutation.

204
00:11:23,400 --> 00:11:26,600
And if you omit it, that's going to be a query by default,

205
00:11:26,600 --> 00:11:30,720
just to make it be nicer to run queries.

206
00:11:30,720 --> 00:11:32,440
Cool. Let's see.

207
00:11:32,440 --> 00:11:37,560
Next. So as I mentioned, like GraphQL is similar to REST,

208
00:11:37,560 --> 00:11:40,720
but like the main difference is that you only have one endpoint,

209
00:11:40,720 --> 00:11:43,960
which is usually search GraphQL, or it could be just slash,

210
00:11:43,960 --> 00:11:46,240
if you have just an API.

211
00:11:46,280 --> 00:11:48,880
Oops. Yeah.

212
00:11:48,880 --> 00:11:51,320
So instead of using URLs, you send a document.

213
00:11:51,320 --> 00:11:55,520
So instead of going to slash user or slash hello, you go to slash GraphQL

214
00:11:55,520 --> 00:11:58,240
and you send this document like we sent.

215
00:11:58,240 --> 00:12:00,640
And then the server is going to return the data based

216
00:12:00,640 --> 00:12:02,400
on the request that you made.

217
00:12:02,400 --> 00:12:06,080
Which is quite nice because you can basically customize the response

218
00:12:06,080 --> 00:12:07,400
based on what you need.

219
00:12:07,400 --> 00:12:09,040
So if you need some fields, you can fetch them.

220
00:12:09,040 --> 00:12:11,520
If you don't need them, you're not going to get them,

221
00:12:11,520 --> 00:12:15,000
which is what happens with REST, for example.

222
00:12:15,000 --> 00:12:19,960
Yeah. This could be useful, but I think it's worth mentioning.

223
00:12:19,960 --> 00:12:23,280
So when you execute a GraphQL request, there's a few steps

224
00:12:23,280 --> 00:12:24,600
that happens on the server.

225
00:12:24,600 --> 00:12:29,040
And this is all done for you by server GraphQL and GraphQL core.

226
00:12:29,040 --> 00:12:31,200
So the first step is parsing.

227
00:12:31,200 --> 00:12:32,960
So we receive the JSON.

228
00:12:32,960 --> 00:12:35,960
We parse the query inside the JSON.

229
00:12:35,960 --> 00:12:37,800
And that already makes sure

230
00:12:37,800 --> 00:12:40,800
that you don't send documents that are not valid in terms of,

231
00:12:40,800 --> 00:12:42,080
you know, the shape.

232
00:12:42,080 --> 00:12:44,080
Then there's another step called validation.

233
00:12:44,120 --> 00:12:48,280
And this checks that you are basically requesting fields

234
00:12:48,280 --> 00:12:52,640
that exist passing the right type of variables and so on.

235
00:12:52,640 --> 00:12:54,400
And so, for example, if you send a document,

236
00:12:54,400 --> 00:12:59,040
which I maybe can show you, like this, this is not going to run.

237
00:12:59,040 --> 00:13:00,560
It's not going to do anything on the server

238
00:13:00,560 --> 00:13:02,680
because it's not a valid document.

239
00:13:02,680 --> 00:13:06,400
And this happens even if you parse multiple fields.

240
00:13:06,400 --> 00:13:07,720
So this query is not going to run.

241
00:13:07,720 --> 00:13:10,840
This field, hello, is not even going to fetch

242
00:13:10,880 --> 00:13:15,000
because the query is not valid, which is nice.

243
00:13:17,160 --> 00:13:20,280
Then the last step is the, well, there's actually just two steps

244
00:13:20,280 --> 00:13:23,640
into the execution, but basically when we have this document,

245
00:13:23,640 --> 00:13:25,360
we parse into an ST.

246
00:13:25,360 --> 00:13:27,360
We go and see all the fields that we want to fetch,

247
00:13:27,360 --> 00:13:29,880
and then we call something called a resolver,

248
00:13:29,880 --> 00:13:31,840
which is a Python function that fetches data

249
00:13:31,840 --> 00:13:34,200
for the specific field.

250
00:13:34,200 --> 00:13:37,160
And then before returning everything, we also check

251
00:13:37,160 --> 00:13:39,560
that the return type is actually the one

252
00:13:39,600 --> 00:13:40,840
that we're expecting.

253
00:13:40,840 --> 00:13:44,600
So, for example, if I go here, I can see that this is a string

254
00:13:44,600 --> 00:13:45,920
and it's required.

255
00:13:45,920 --> 00:13:50,040
So if I'm sending none, I'm not going to receive none

256
00:13:50,040 --> 00:13:51,360
in my response.

257
00:13:51,360 --> 00:13:55,600
I'm going to receive an error because this field is mandatory,

258
00:13:55,600 --> 00:13:57,920
which is a nice feature of GraphQL,

259
00:13:57,920 --> 00:13:59,240
because every time you do a request,

260
00:13:59,240 --> 00:14:01,560
you know what you're getting back.

261
00:14:03,760 --> 00:14:06,160
And, yeah, when you receive a GraphQL request,

262
00:14:06,160 --> 00:14:09,400
you get everything into data, which you can see here,

263
00:14:10,240 --> 00:14:11,080
or errors.

264
00:14:11,080 --> 00:14:13,320
If there's any error, you're going to see here.

265
00:14:15,560 --> 00:14:16,400
Cool.

266
00:14:19,280 --> 00:14:20,720
Okay, let's see.

267
00:14:22,040 --> 00:14:24,360
Oh, actually, is there any question on this?

268
00:14:26,120 --> 00:14:26,960
Okay.

269
00:14:29,640 --> 00:14:32,000
So now I'm going to do a quick overview of how strawberry

270
00:14:32,000 --> 00:14:34,320
works, because there's a few things that might be a bit

271
00:14:34,320 --> 00:14:35,160
confusing.

272
00:14:35,520 --> 00:14:40,600
So, yeah, maybe I'm going to do also an introduction

273
00:14:40,600 --> 00:14:43,640
of the folder and everything.

274
00:14:43,640 --> 00:14:47,120
So there's a couple of things here that you can worry,

275
00:14:47,120 --> 00:14:48,080
and not worry about.

276
00:14:48,080 --> 00:14:51,360
There's just the CLI docs and exercises.

277
00:14:52,560 --> 00:14:56,280
So the rest is all, almost everything Django specific.

278
00:14:56,280 --> 00:15:01,280
So there is a user folder application that has the,

279
00:15:01,440 --> 00:15:03,440
all the models for the users.

280
00:15:03,440 --> 00:15:06,400
We're going to use that to authenticate later

281
00:15:06,400 --> 00:15:08,040
in the workshop.

282
00:15:08,040 --> 00:15:09,880
Then there is one folder called DB,

283
00:15:09,880 --> 00:15:12,240
which I put all the models ready to the podcast,

284
00:15:12,240 --> 00:15:15,480
just because I was lazy and I put everything into one file.

285
00:15:15,480 --> 00:15:18,400
But there's only two models, so it's not crazy.

286
00:15:18,400 --> 00:15:21,120
So we're going to use these models to store data

287
00:15:21,120 --> 00:15:22,600
into the backend.

288
00:15:22,600 --> 00:15:26,480
And then inside DB, we also have a data folder,

289
00:15:26,480 --> 00:15:27,960
sorry, data module.

290
00:15:27,960 --> 00:15:30,160
This is kind of a service layer.

291
00:15:30,160 --> 00:15:33,600
So this is an abstraction on top of what Django provides.

292
00:15:34,640 --> 00:15:36,600
And I maybe go a bit more into the details,

293
00:15:36,600 --> 00:15:40,640
but this makes it easier to focus just on the GraphQL part

294
00:15:40,640 --> 00:15:42,760
and not focusing on Django.

295
00:15:42,760 --> 00:15:44,400
Like for example, there is a couple of things

296
00:15:44,400 --> 00:15:46,040
that are specific to Django here,

297
00:15:46,880 --> 00:15:51,880
which then are strictly related to GraphQL.

298
00:15:52,960 --> 00:15:56,520
I also created some utilities for pagination.

299
00:15:56,520 --> 00:16:00,440
And we are going to work mostly into the API folder.

300
00:16:00,440 --> 00:16:04,760
So there's a view, which is basically the GraphQL view.

301
00:16:04,760 --> 00:16:08,920
I customized a bit to basically have a function

302
00:16:08,920 --> 00:16:10,880
to get the user in async,

303
00:16:10,880 --> 00:16:13,200
because there are some issues with Django

304
00:16:13,200 --> 00:16:14,440
with async at the moment.

305
00:16:15,680 --> 00:16:19,280
And we also see why we're using async in this case.

306
00:16:19,280 --> 00:16:20,440
It's for performance reason,

307
00:16:20,440 --> 00:16:24,400
but we'll see specifically why I'm doing everything

308
00:16:24,400 --> 00:16:26,000
in async here.

309
00:16:26,000 --> 00:16:29,080
So the URL is just such a GraphQL.

310
00:16:29,080 --> 00:16:30,080
This is the schema.

311
00:16:31,960 --> 00:16:35,840
This is basically where our GraphQL API starts from.

312
00:16:35,840 --> 00:16:38,560
So as I mentioned, every GraphQL API has a schema.

313
00:16:39,520 --> 00:16:42,200
And for a schema, there is like usually a couple

314
00:16:42,200 --> 00:16:43,400
of root types.

315
00:16:43,400 --> 00:16:45,400
So in this case, there's a query and limitation.

316
00:16:45,400 --> 00:16:49,000
The names, I mean, usually it's called query,

317
00:16:49,000 --> 00:16:50,680
but it doesn't have to be query.

318
00:16:51,840 --> 00:16:54,040
But basically these two are the entry points

319
00:16:54,040 --> 00:16:56,000
of our GraphQL API.

320
00:16:56,000 --> 00:16:57,560
So when I'm doing a query,

321
00:16:57,560 --> 00:16:59,880
all the fields I'm gonna fetch for the query

322
00:16:59,880 --> 00:17:02,480
are gonna come from this query type here.

323
00:17:03,400 --> 00:17:07,360
And we can see this reflects to what we were doing before.

324
00:17:07,360 --> 00:17:08,960
So there is a field called hello.

325
00:17:10,560 --> 00:17:12,480
And then in this case returns hello words.

326
00:17:12,480 --> 00:17:14,160
I'm gonna explain this index in a moment,

327
00:17:14,160 --> 00:17:18,400
but again, this is exactly the same that we are seeing here.

328
00:17:18,400 --> 00:17:19,640
So there's the query type,

329
00:17:19,640 --> 00:17:22,000
which has one field called hello or type string.

330
00:17:23,000 --> 00:17:26,800
And ignoring this for a second,

331
00:17:26,800 --> 00:17:30,160
as strawberry wrap, it's using Python type ins.

332
00:17:30,160 --> 00:17:32,360
Don't know if you've seen, this is like,

333
00:17:32,360 --> 00:17:35,040
the syntax is basically the same as data classes.

334
00:17:35,040 --> 00:17:37,680
So you basically use a decorator to tell strawberry

335
00:17:37,680 --> 00:17:39,600
that this type is a GraphQL type.

336
00:17:39,600 --> 00:17:41,600
And then we go and read all the properties

337
00:17:41,600 --> 00:17:42,880
defined like this.

338
00:17:42,880 --> 00:17:44,200
So there's the name of the property

339
00:17:44,200 --> 00:17:45,680
and the type of the property.

340
00:17:46,840 --> 00:17:50,280
And this is quite useful because when you use a type checker

341
00:17:50,280 --> 00:17:54,400
like mypy, which I, there we go.

342
00:17:54,400 --> 00:17:56,040
So it's gonna complain, for example,

343
00:17:56,040 --> 00:17:57,680
an argument is missing, but for example,

344
00:17:57,680 --> 00:18:01,360
if I pass a different type, it's also gonna come, oh yeah.

345
00:18:03,320 --> 00:18:06,160
It's gonna complain about the type as well,

346
00:18:06,160 --> 00:18:08,080
because it's expecting a string.

347
00:18:08,960 --> 00:18:11,240
And I think this is one of the best feature of strawberry

348
00:18:11,240 --> 00:18:13,840
because it basically gives you the benefit

349
00:18:13,840 --> 00:18:17,360
of using types in Python, but also types in GraphQL,

350
00:18:18,360 --> 00:18:21,200
which then you can also reuse in your clients

351
00:18:21,200 --> 00:18:23,840
if you have steps to generate the types

352
00:18:23,840 --> 00:18:25,000
from the GraphQL query.

353
00:18:26,600 --> 00:18:28,360
Don't know if I have time to show you that,

354
00:18:28,360 --> 00:18:30,240
but I think that's pretty cool.

355
00:18:35,080 --> 00:18:36,800
So yeah, and then this other thing,

356
00:18:36,800 --> 00:18:40,080
this is again inspired by data classes.

357
00:18:40,080 --> 00:18:43,520
So this is a way to attach metadata to a field.

358
00:18:43,520 --> 00:18:45,720
So for example, you could give a custom name.

359
00:18:45,720 --> 00:18:47,240
So for example, if you wanna call it from,

360
00:18:48,080 --> 00:18:50,400
which is not a valid Python keyword,

361
00:18:50,400 --> 00:18:53,200
you can do from underscore and then the name from.

362
00:18:55,040 --> 00:18:56,600
But the main thing here that we're doing

363
00:18:56,600 --> 00:18:59,040
is passing this resolver.

364
00:18:59,040 --> 00:19:01,360
And a resolver is basically a Python function

365
00:19:01,360 --> 00:19:03,880
that gets called when I request this field,

366
00:19:03,880 --> 00:19:04,720
this specific field.

367
00:19:04,720 --> 00:19:07,880
So for example, if I change this and I do a load 12,

368
00:19:07,880 --> 00:19:09,680
gonna call this and I get a load 12.

369
00:19:11,320 --> 00:19:15,120
So you can see GraphQL as maybe a glorified

370
00:19:15,120 --> 00:19:16,880
remote procedure call.

371
00:19:16,880 --> 00:19:19,240
So it basically allows you to run functions

372
00:19:19,240 --> 00:19:24,000
in your server, which I don't know,

373
00:19:24,000 --> 00:19:26,480
once you put it this way, I think it's quite safe

374
00:19:26,480 --> 00:19:29,200
over to understand what's happening.

375
00:19:29,200 --> 00:19:32,160
So you can say I wanna call the function

376
00:19:32,160 --> 00:19:34,560
for the field that load and that's what happens.

377
00:19:39,080 --> 00:19:41,000
Let's see if I missed something.

378
00:19:41,000 --> 00:19:43,640
Yeah, I guess I mentioned we took inspiration

379
00:19:43,640 --> 00:19:45,400
from data classes and we're actually using

380
00:19:45,440 --> 00:19:47,480
data classes on the dude.

381
00:19:47,480 --> 00:19:52,080
And data classes basically a Python built in library

382
00:19:52,080 --> 00:19:55,880
that allows you to create classes that have

383
00:19:55,880 --> 00:19:58,120
all the useful methods like constructor,

384
00:19:58,120 --> 00:20:00,240
representation equality methods and so on,

385
00:20:00,240 --> 00:20:03,000
with just a couple of lines, which is quite nice.

386
00:20:04,440 --> 00:20:07,360
Yeah, we mentioned resolvers and if you wanna also,

387
00:20:07,360 --> 00:20:09,600
if you have everything running, you can try this out

388
00:20:09,600 --> 00:20:12,200
and change this and see what happens.

389
00:20:13,200 --> 00:20:17,520
You can also see if we do this, this is gonna complain.

390
00:20:17,520 --> 00:20:21,160
I think, actually no, there is a, if I do this.

391
00:20:22,400 --> 00:20:27,280
Yeah, so if I'm returning something that's no null

392
00:20:27,280 --> 00:20:30,600
for a field that should be non-nullable,

393
00:20:30,600 --> 00:20:31,800
that the field is gonna complain,

394
00:20:31,800 --> 00:20:33,840
that GraphQL is gonna complain.

395
00:20:33,840 --> 00:20:37,320
So that makes safe on your clients to assume

396
00:20:37,320 --> 00:20:39,360
that this field is always gonna be there.

397
00:20:40,200 --> 00:20:41,040
Yeah.

398
00:20:42,200 --> 00:20:47,200
Oh, and if I return like one, so there is a question step

399
00:20:47,680 --> 00:20:50,880
in GraphQL that converts the types that are compatible

400
00:20:50,880 --> 00:20:53,520
to one to the other.

401
00:20:54,880 --> 00:20:55,720
Yeah.

402
00:20:58,960 --> 00:21:00,920
Do you have any questions about this?

403
00:21:02,160 --> 00:21:05,320
I know it was a lot in just a short amount of time,

404
00:21:05,320 --> 00:21:07,720
so yeah, here we go.

405
00:21:08,720 --> 00:21:12,760
Okay, so let's go with our first API.

406
00:21:12,760 --> 00:21:16,560
So this API is gonna allow us to fetch a podcast by ID

407
00:21:17,480 --> 00:21:20,160
and if the podcast does not exist, it returns none.

408
00:21:20,160 --> 00:21:25,160
So in REST, use the HTTP status code

409
00:21:26,800 --> 00:21:30,040
to basically tell the user what happens.

410
00:21:30,040 --> 00:21:33,000
So for example, if you haven't found something

411
00:21:33,000 --> 00:21:35,000
you can do for a fort.

412
00:21:35,000 --> 00:21:37,080
In GraphQL, everything is like 200.

413
00:21:38,120 --> 00:21:41,640
Maybe sometimes you can use 401 for authentication reasons,

414
00:21:41,640 --> 00:21:44,480
but by default, everything is 200, even if you have errors.

415
00:21:44,480 --> 00:21:47,760
So if I, for example, do this,

416
00:21:47,760 --> 00:21:49,600
this is probably gonna be, for run,

417
00:21:53,120 --> 00:21:55,360
let me do this, yeah.

418
00:21:55,360 --> 00:21:58,320
This is gonna be 200 because, yeah,

419
00:21:58,320 --> 00:22:01,400
the way GraphQL is modeled is always to return 200,

420
00:22:01,400 --> 00:22:04,400
which makes it be annoying to monitor things.

421
00:22:04,440 --> 00:22:05,680
That's why there's a lot of tools,

422
00:22:05,680 --> 00:22:08,360
like the ones from Apollo for these kind of things,

423
00:22:08,360 --> 00:22:12,880
but basically, instead of using HTTP for the meaning,

424
00:22:12,880 --> 00:22:15,120
use the schema for the meaning.

425
00:22:15,120 --> 00:22:16,680
So for example, if you wanna say,

426
00:22:18,120 --> 00:22:21,000
get me a podcast, to say that the podcast does not exist,

427
00:22:21,000 --> 00:22:24,800
you return none instead of returning an error, for example.

428
00:22:24,800 --> 00:22:28,040
So just something convention that you can have.

429
00:22:29,600 --> 00:22:31,920
Okay, so this is our data model.

430
00:22:31,920 --> 00:22:36,360
So again, everything lives inside the models inside DB.

431
00:22:36,360 --> 00:22:39,600
We're not gonna touch any of this, this should work.

432
00:22:39,600 --> 00:22:42,600
So the podcast has an ID, has a title, subtitle,

433
00:22:42,600 --> 00:22:44,960
hosted by, and it's normal things

434
00:22:44,960 --> 00:22:46,720
you would expect from a podcast.

435
00:22:49,240 --> 00:22:52,720
Yeah, so to expose this into an API,

436
00:22:52,720 --> 00:22:53,640
we need to create a type.

437
00:22:53,640 --> 00:22:56,760
So by default, I guess one misconception in GraphQL

438
00:22:56,760 --> 00:22:59,240
is I expose everything, but it's not the case

439
00:22:59,240 --> 00:23:04,240
like you expose what you want to expose in your API.

440
00:23:04,360 --> 00:23:06,320
I mean, there's tools that allow you to create

441
00:23:06,320 --> 00:23:09,840
a GraphQL API from a database, but I don't know,

442
00:23:09,840 --> 00:23:11,440
I don't think it's the best way of doing that,

443
00:23:11,440 --> 00:23:13,880
because it's very easy to expose things

444
00:23:13,880 --> 00:23:14,720
that you don't wanna expose,

445
00:23:14,720 --> 00:23:18,360
and also it ties your GraphQL API, or your API in general,

446
00:23:18,360 --> 00:23:20,720
to a database, which I don't know,

447
00:23:20,720 --> 00:23:23,880
I don't think it's the right way of doing an API.

448
00:23:23,880 --> 00:23:26,640
Okay, so let's keep it simple.

449
00:23:26,640 --> 00:23:28,160
Let's say on expose three fields,

450
00:23:28,160 --> 00:23:30,880
so ID, title, and description.

451
00:23:30,880 --> 00:23:35,880
So we can do this together, or I can do it for you as well.

452
00:23:36,400 --> 00:23:39,000
We can go to Podcast Types,

453
00:23:40,380 --> 00:23:43,580
and I just import everything here.

454
00:23:45,600 --> 00:23:46,440
Let me see.

455
00:23:48,120 --> 00:23:48,940
Okay.

456
00:23:49,840 --> 00:23:52,280
I think my editor is a bit messed up anyway.

457
00:23:53,800 --> 00:23:56,440
So to recap, I created a class called Podcast.

458
00:23:56,440 --> 00:24:00,000
This is gonna be used for the name of the GraphQL type.

459
00:24:00,000 --> 00:24:02,120
Again, this can be changed using the strawberry type,

460
00:24:02,120 --> 00:24:05,800
so if you wanna change the name, you can do that as well.

461
00:24:05,800 --> 00:24:07,760
But by default, it gets the name of the class.

462
00:24:07,760 --> 00:24:09,240
And then there's three fields here.

463
00:24:09,240 --> 00:24:11,440
Title and description are both strings,

464
00:24:11,440 --> 00:24:16,560
and then ID is using a custom type called ID.

465
00:24:16,560 --> 00:24:20,200
This is a type in GraphQL that represents

466
00:24:20,200 --> 00:24:22,520
Biscuit and ID, a unique identifier

467
00:24:22,520 --> 00:24:24,260
for something in your API.

468
00:24:25,260 --> 00:24:29,300
You could use integer or string here,

469
00:24:29,300 --> 00:24:34,300
but ID, it's helpful to tell the consumer of the API

470
00:24:34,380 --> 00:24:37,420
that this is a unique identifier for this type.

471
00:24:38,780 --> 00:24:42,900
Yeah, and then once we have this field,

472
00:24:42,900 --> 00:24:45,180
we can create a GraphQL query.

473
00:24:45,180 --> 00:24:49,300
So we go to Podcast slash query.

474
00:24:49,300 --> 00:24:50,860
We're gonna go here.

475
00:24:50,860 --> 00:24:53,260
So now there is an empty query,

476
00:24:54,060 --> 00:24:56,620
and I'm gonna just change this to use the,

477
00:24:59,020 --> 00:25:00,620
to add the Podcast field.

478
00:25:00,620 --> 00:25:02,420
So here we've done something a bit different

479
00:25:02,420 --> 00:25:05,460
than what we have done in our schema.

480
00:25:05,460 --> 00:25:07,580
So let me put this side by side.

481
00:25:07,580 --> 00:25:12,020
So in strawberry, there is two ways

482
00:25:12,020 --> 00:25:17,020
of defining a resolver, mostly for convenience reason.

483
00:25:17,300 --> 00:25:20,500
So the first way is to pass the resolver as a,

484
00:25:20,500 --> 00:25:23,820
just as a parameter to the server, the field function.

485
00:25:23,820 --> 00:25:26,780
This could be also a function like this.

486
00:25:26,780 --> 00:25:28,740
It doesn't have to be a lambda.

487
00:25:28,740 --> 00:25:31,980
Lambda is useful for testing and showing example.

488
00:25:31,980 --> 00:25:34,700
The other way is to using as a kind of decorator

489
00:25:34,700 --> 00:25:36,580
on a method.

490
00:25:36,580 --> 00:25:39,500
So you can see this as a class method

491
00:25:39,500 --> 00:25:41,180
or static method decorator.

492
00:25:42,140 --> 00:25:45,060
And basically it's almost the same.

493
00:25:46,980 --> 00:25:49,100
Under the hood, there's no difference between this

494
00:25:49,100 --> 00:25:50,380
and this.

495
00:25:50,380 --> 00:25:52,140
It's just a nicer way.

496
00:25:52,140 --> 00:25:54,580
Sometimes it makes it easier to kind of define

497
00:25:56,620 --> 00:25:58,460
resolver for a specific field in a class,

498
00:25:58,460 --> 00:26:00,220
because otherwise we would need to create

499
00:26:00,220 --> 00:26:02,260
the podcast like this.

500
00:26:02,260 --> 00:26:03,180
Podcast.

501
00:26:08,020 --> 00:26:11,060
And then we need to pass the resolver here.

502
00:26:11,060 --> 00:26:15,700
So we do everything in one step, which is quite nice.

503
00:26:15,700 --> 00:26:17,300
And what strawberry is gonna do

504
00:26:17,300 --> 00:26:20,460
is gonna get the return type of the resolver

505
00:26:20,460 --> 00:26:22,940
and put it into the schema.

506
00:26:22,940 --> 00:26:24,140
We're gonna see that in a moment.

507
00:26:24,140 --> 00:26:26,420
And it does the same for the arguments.

508
00:26:27,300 --> 00:26:31,740
So if I go back to my API now and I refresh,

509
00:26:31,740 --> 00:26:34,060
I should see the schema being updated.

510
00:26:34,060 --> 00:26:37,460
And so there is this new field called podcast,

511
00:26:37,460 --> 00:26:39,340
which accept ID, which is not,

512
00:26:41,300 --> 00:26:43,060
which cannot be null.

513
00:26:43,060 --> 00:26:45,460
So the question, the exhibition mark means

514
00:26:45,460 --> 00:26:48,620
that you always have to pass this field

515
00:26:48,620 --> 00:26:50,300
or this argument in this case.

516
00:26:50,300 --> 00:26:52,900
And podcast in this case, there's no exclamation marks.

517
00:26:52,900 --> 00:26:55,660
So it means that it can be null.

518
00:26:55,660 --> 00:26:57,500
So if I go and try this now,

519
00:26:59,780 --> 00:27:03,300
if I go podcast ID, something random,

520
00:27:03,300 --> 00:27:06,900
and I try to get the ID and title,

521
00:27:06,900 --> 00:27:09,100
this is how you can fetch nested fields.

522
00:27:10,540 --> 00:27:12,820
So like that.

523
00:27:12,820 --> 00:27:15,260
And if I try to get this, I'm gonna get null,

524
00:27:16,100 --> 00:27:19,660
which is the JavaScript equivalent of none,

525
00:27:19,660 --> 00:27:20,700
which is what we expect.

526
00:27:20,700 --> 00:27:23,060
And because basically we're returning none here.

527
00:27:24,140 --> 00:27:27,820
And we are allowing us to return none

528
00:27:27,820 --> 00:27:32,820
by using the optional class or type from the typing module.

529
00:27:34,060 --> 00:27:35,420
So inside this typing module,

530
00:27:35,420 --> 00:27:37,340
there is a lot of classes that you can use

531
00:27:37,340 --> 00:27:40,660
to basically say what type is something.

532
00:27:40,660 --> 00:27:44,980
So for example, you can have tuple, list, unions, and so on.

533
00:27:45,820 --> 00:27:50,180
And in modern Python, I think from Python 3.9 or 10,

534
00:27:50,180 --> 00:27:52,940
you can also do, well, this syntax,

535
00:27:52,940 --> 00:27:54,340
you can do it from Python 3.10.

536
00:27:54,340 --> 00:27:55,900
So you can do podcasts or none.

537
00:27:56,820 --> 00:27:58,900
It's the same, it's just a bit nicer.

538
00:27:58,900 --> 00:28:00,980
And this is one of the reasons why I recommend you

539
00:28:00,980 --> 00:28:02,780
to use the latest version of Python,

540
00:28:02,780 --> 00:28:05,460
because it makes typing a bit nicer, a bit cleaner.

541
00:28:06,700 --> 00:28:07,700
And in the past, for example,

542
00:28:07,700 --> 00:28:09,500
if you wanted to return a list,

543
00:28:09,500 --> 00:28:12,820
you needed to do this, importing a list from here.

544
00:28:12,820 --> 00:28:15,020
But now you can do lists like it's lowercase,

545
00:28:15,820 --> 00:28:16,660
so you can use the built-in.

546
00:28:18,740 --> 00:28:20,900
Okay, so now we created a query

547
00:28:20,900 --> 00:28:22,500
that allows you to fetch a podcast by ID,

548
00:28:22,500 --> 00:28:24,620
but it doesn't really do anything.

549
00:28:24,620 --> 00:28:25,740
So it's a big user.

550
00:28:25,740 --> 00:28:27,140
So let's go and update this

551
00:28:27,140 --> 00:28:30,660
to use our Django database to fetch data.

552
00:28:33,180 --> 00:28:34,020
There we go.

553
00:28:34,020 --> 00:28:35,540
So this is, we've seen this.

554
00:28:36,500 --> 00:28:37,420
And now we're gonna do this.

555
00:28:37,420 --> 00:28:41,500
So there is this data module inside DB,

556
00:28:41,500 --> 00:28:42,860
which exposes a couple of functions

557
00:28:42,860 --> 00:28:46,420
that makes it easier to fetch data from our Django database.

558
00:28:46,420 --> 00:28:47,740
So I'm gonna use that.

559
00:28:48,820 --> 00:28:50,060
So I'm gonna import data,

560
00:28:50,060 --> 00:28:53,580
and then I'm gonna do podcast equals,

561
00:28:56,540 --> 00:28:58,140
find podcasts by ID, there we go.

562
00:29:00,020 --> 00:29:01,980
And so this function is gonna try

563
00:29:01,980 --> 00:29:05,660
and fetch the podcast by ID from the Django database.

564
00:29:06,540 --> 00:29:09,900
And it's also async.

565
00:29:09,900 --> 00:29:12,700
Again, we're gonna see why that's the case in the moment.

566
00:29:13,660 --> 00:29:18,100
In summary, you can both use async and sync resolver,

567
00:29:18,100 --> 00:29:19,860
so I can change this.

568
00:29:19,860 --> 00:29:21,700
Well, I cannot change this one specifically,

569
00:29:21,700 --> 00:29:26,460
but if I wanted to make this non-sync, async, sorry,

570
00:29:26,460 --> 00:29:29,100
you can do that, and it works.

571
00:29:29,100 --> 00:29:30,420
The issue with Django at the moment

572
00:29:30,420 --> 00:29:33,300
is that if you're trying to run a database query

573
00:29:33,300 --> 00:29:35,020
inside an async context,

574
00:29:35,020 --> 00:29:40,020
so even if this field is sync,

575
00:29:40,820 --> 00:29:42,860
the GraphQL view that we're using is the async one,

576
00:29:42,860 --> 00:29:44,060
so Django is gonna complain

577
00:29:44,060 --> 00:29:47,380
because it's not safe to run database calls

578
00:29:47,380 --> 00:29:48,540
inside async context.

579
00:29:48,540 --> 00:29:50,820
You have to use sync to async.

580
00:29:50,820 --> 00:29:53,060
But hopefully that's gonna change in future.

581
00:29:53,060 --> 00:29:55,260
Django is working, it's adding,

582
00:29:55,260 --> 00:29:57,580
every new release is adding more async features,

583
00:29:57,580 --> 00:30:00,300
so things like this is gonna be easier.

584
00:30:02,180 --> 00:30:05,020
Yeah, so if we get, let me,

585
00:30:05,020 --> 00:30:07,100
just gonna copy this to make it easier.

586
00:30:07,140 --> 00:30:10,660
So I'm getting a podcast from database,

587
00:30:10,660 --> 00:30:11,900
then if there is a podcast,

588
00:30:11,900 --> 00:30:16,900
I'm gonna return a podcast from my GraphQL API.

589
00:30:19,500 --> 00:30:21,260
Just gonna do something quickly

590
00:30:22,340 --> 00:30:25,580
to hide some of these errors.

591
00:30:30,700 --> 00:30:32,220
Cool.

592
00:30:32,220 --> 00:30:35,620
So there is PyLens, it's an alternative to MyPy,

593
00:30:35,660 --> 00:30:37,100
it's a bit more straight on types,

594
00:30:37,100 --> 00:30:39,020
so in this case it's telling me

595
00:30:39,020 --> 00:30:41,420
that UID is not compatible with ID,

596
00:30:41,420 --> 00:30:45,460
so I could just train maybe, that should work.

597
00:30:49,100 --> 00:30:50,700
And this doesn't matter too much at the moment,

598
00:30:50,700 --> 00:30:52,660
so we can ignore it.

599
00:30:55,700 --> 00:30:57,340
Okay, so as I mentioned,

600
00:30:57,340 --> 00:30:58,460
we fetching this podcast

601
00:30:58,460 --> 00:31:03,460
and then we're returning a podcast instance.

602
00:31:03,460 --> 00:31:07,220
So one thing that I think it's a bit annoying

603
00:31:07,220 --> 00:31:09,860
from the way this API works,

604
00:31:09,860 --> 00:31:13,420
or like this, the way this structure I put

605
00:31:13,420 --> 00:31:16,740
is that this podcast is a podcast model,

606
00:31:16,740 --> 00:31:17,900
this is a podcast type,

607
00:31:17,900 --> 00:31:20,060
so there is two types named the same thing,

608
00:31:20,060 --> 00:31:21,820
which is a bit annoying and confusing sometimes,

609
00:31:21,820 --> 00:31:25,580
so we're gonna see a nicer way

610
00:31:25,580 --> 00:31:27,100
to maybe at least prevent this,

611
00:31:27,100 --> 00:31:28,820
or to make it generic,

612
00:31:28,820 --> 00:31:31,140
but as I mentioned,

613
00:31:31,900 --> 00:31:35,180
this is a trade off of my creating

614
00:31:35,180 --> 00:31:36,620
graphical API from a database,

615
00:31:36,620 --> 00:31:38,940
so you either return everything,

616
00:31:38,940 --> 00:31:43,940
so you convert a Django model directly to a graphical type,

617
00:31:44,780 --> 00:31:46,980
or you do this kind of second step

618
00:31:46,980 --> 00:31:49,980
of creating an additional type and returning it out.

619
00:31:49,980 --> 00:31:51,060
I do prefer this way,

620
00:31:51,060 --> 00:31:53,820
because it makes me think more about the API

621
00:31:53,820 --> 00:31:55,300
and the use case,

622
00:31:55,300 --> 00:31:57,460
and this is what I would recommend you.

623
00:31:57,460 --> 00:32:00,340
And the nice thing of this is that you don't have

624
00:32:00,340 --> 00:32:01,620
to worry too much about database,

625
00:32:01,620 --> 00:32:03,220
because you create this type,

626
00:32:03,220 --> 00:32:06,100
and then inside the resolver,

627
00:32:06,100 --> 00:32:08,260
you can maybe fetch multiple things if you need to,

628
00:32:08,260 --> 00:32:10,260
so for example, if you needed some things

629
00:32:10,260 --> 00:32:12,380
that come from another model,

630
00:32:12,380 --> 00:32:13,620
you can do that as well.

631
00:32:14,500 --> 00:32:16,460
Cool, so this should work now,

632
00:32:16,460 --> 00:32:17,660
so I'm gonna save it,

633
00:32:17,660 --> 00:32:19,700
and I'm gonna try again.

634
00:32:19,700 --> 00:32:21,500
So actually, with this way,

635
00:32:21,500 --> 00:32:24,060
it's gonna complain because this is not a valid UID,

636
00:32:24,060 --> 00:32:26,460
so we're gonna see an error here.

637
00:32:27,460 --> 00:32:29,260
So this is something that

638
00:32:31,740 --> 00:32:35,660
is not something you should keep available,

639
00:32:35,660 --> 00:32:37,460
so in server, there is,

640
00:32:37,460 --> 00:32:39,660
oh, I just wanna explain this a bit better.

641
00:32:39,660 --> 00:32:42,780
So this message is coming straight from the exception

642
00:32:42,780 --> 00:32:44,060
that Django is raising.

643
00:32:44,060 --> 00:32:46,140
So Django is trying to convert this one, two, three,

644
00:32:46,140 --> 00:32:48,660
to a UID, and so it raises an exception,

645
00:32:48,660 --> 00:32:50,260
because it's not able to do that.

646
00:32:50,260 --> 00:32:55,260
So we should not throw errors like this with an API,

647
00:32:56,460 --> 00:33:01,460
so in server, there is an extension called mask errors.

648
00:33:02,500 --> 00:33:04,620
Let's see if I can, here we go.

649
00:33:04,620 --> 00:33:06,380
This extension that you can enable,

650
00:33:06,380 --> 00:33:09,060
and then this is basically gonna hide

651
00:33:09,060 --> 00:33:10,660
all these errors for you,

652
00:33:10,660 --> 00:33:12,460
so you don't have to worry about

653
00:33:12,460 --> 00:33:14,780
leaking some parts of your code base

654
00:33:14,780 --> 00:33:18,500
because they were an exception.

655
00:33:18,500 --> 00:33:19,340
I'm not gonna enable this

656
00:33:19,340 --> 00:33:21,060
because it's gonna be useful for the workshop,

657
00:33:21,060 --> 00:33:25,940
but basically, if you're working with a GraphQL API,

658
00:33:25,940 --> 00:33:27,420
hide all the errors if possible,

659
00:33:27,420 --> 00:33:30,900
because the default implementation in,

660
00:33:30,900 --> 00:33:32,860
I think in almost any language,

661
00:33:32,860 --> 00:33:35,860
GraphQL is just to return the error message like that,

662
00:33:35,860 --> 00:33:39,060
so you need an extension to hide the message.

663
00:33:39,060 --> 00:33:41,660
You also get the, I should get the,

664
00:33:43,420 --> 00:33:47,660
you also get the exception here on the command line.

665
00:33:47,660 --> 00:33:51,300
Okay, let's actually go and get an ID.

666
00:33:52,060 --> 00:33:55,780
See, I might have, yeah, I created a small

667
00:33:55,780 --> 00:33:58,220
util function to get the IDs,

668
00:33:58,220 --> 00:34:01,460
so we can use any of this.

669
00:34:04,620 --> 00:34:05,460
Oh, sorry.

670
00:34:08,380 --> 00:34:11,340
Okay, now if I try this and I run it,

671
00:34:11,340 --> 00:34:13,220
I should get the old information that I wanted,

672
00:34:13,220 --> 00:34:16,620
so this is coming from the database and it's actual data.

673
00:34:16,620 --> 00:34:19,220
And again, one of the powerful things of GraphQL

674
00:34:19,220 --> 00:34:22,100
is that you can basically decide what to get.

675
00:34:22,100 --> 00:34:23,740
So if I wanna only get the title,

676
00:34:23,740 --> 00:34:25,980
I can do that just like that.

677
00:34:29,540 --> 00:34:34,540
Yes, and if I try to maybe fetch an ID that's not valid,

678
00:34:34,540 --> 00:34:36,540
that does not exist but still valid,

679
00:34:36,540 --> 00:34:41,540
I'm gonna get this empty response.

680
00:34:41,540 --> 00:34:46,540
Okay, so yeah, this is where we go.

681
00:34:46,540 --> 00:34:50,300
Is there any question about this now?

682
00:34:54,460 --> 00:34:57,180
Okay, now we're gonna see pagination.

683
00:34:57,180 --> 00:35:00,260
So pagination is a bit tricky in GraphQL,

684
00:35:04,020 --> 00:35:06,820
mostly because every time there is a new,

685
00:35:06,820 --> 00:35:08,180
kind of new way of doing things,

686
00:35:08,180 --> 00:35:11,340
like we try to reinvent everything from scratch.

687
00:35:11,340 --> 00:35:13,780
How do I do pagination in GraphQL?

688
00:35:15,340 --> 00:35:18,620
But the other thing, you're basically not limited

689
00:35:18,620 --> 00:35:21,300
by GraphQL, you can do anything that you want.

690
00:35:21,300 --> 00:35:22,940
So you can return something like this,

691
00:35:22,940 --> 00:35:24,820
so you can do a basic pagination,

692
00:35:25,780 --> 00:35:29,180
which you basically can pass a page number,

693
00:35:29,180 --> 00:35:32,860
and you can pass a number of items that you wanna get

694
00:35:32,860 --> 00:35:34,180
for that specific page.

695
00:35:35,940 --> 00:35:37,540
So I think I did implement this, yeah,

696
00:35:37,540 --> 00:35:40,340
so we can see how this works in a moment.

697
00:35:40,340 --> 00:35:43,300
We're also gonna see why this might not be the best,

698
00:35:43,300 --> 00:35:46,420
and we're gonna see a slightly more complicated version

699
00:35:46,420 --> 00:35:47,900
but it's a bit more useful.

700
00:35:47,900 --> 00:35:50,060
So, but let's start with this.

701
00:35:52,500 --> 00:35:55,540
So we're gonna create a new field called podcasts.

702
00:35:57,260 --> 00:36:01,260
We got, I'm gonna import this here, as I mentioned.

703
00:36:03,060 --> 00:36:08,060
There you go, so here, we basically did the same thing

704
00:36:08,620 --> 00:36:11,420
that we've done before, but it's a couple of different.

705
00:36:11,420 --> 00:36:16,420
So first thing, we are using default values for the fields.

706
00:36:16,740 --> 00:36:18,740
So for example, here, page, we always say,

707
00:36:18,740 --> 00:36:20,020
we wanna fetch the first page,

708
00:36:20,020 --> 00:36:22,380
unless it's someone passes another one,

709
00:36:22,380 --> 00:36:24,140
and we always say we wanna fetch 10 items,

710
00:36:24,140 --> 00:36:25,460
unless otherwise.

711
00:36:26,380 --> 00:36:29,780
Then we use this function called podcast,

712
00:36:29,780 --> 00:36:32,180
which basically does all the pagination for us.

713
00:36:33,420 --> 00:36:35,500
And that's pretty much it.

714
00:36:35,500 --> 00:36:38,380
And I guess, once you know how to create a resolver,

715
00:36:38,380 --> 00:36:41,100
it's pretty simple to create another one, yeah.

716
00:36:41,100 --> 00:36:45,820
Do you mind showing the podcast CLI command again?

717
00:36:45,820 --> 00:36:46,660
Yes.

718
00:36:48,300 --> 00:36:49,140
Yeah, this one.

719
00:36:49,140 --> 00:36:50,780
You just run that with the terminal?

720
00:36:50,780 --> 00:36:51,620
Yes.

721
00:36:52,620 --> 00:36:53,460
Okay, thanks.

722
00:36:53,460 --> 00:36:54,300
Yeah.

723
00:36:55,300 --> 00:36:56,140
Yeah, you.

724
00:36:58,900 --> 00:37:00,260
That's quite moving, indeed.

725
00:37:00,260 --> 00:37:01,100
Oh yes, sorry.

726
00:37:01,100 --> 00:37:01,940
Okay.

727
00:37:05,260 --> 00:37:06,260
Gonna make a bit.

728
00:37:06,260 --> 00:37:08,260
Is there any discussion?

729
00:37:15,420 --> 00:37:16,260
Okay.

730
00:37:22,140 --> 00:37:24,260
Any other question?

731
00:37:24,260 --> 00:37:25,380
Just feel free to stop me,

732
00:37:25,380 --> 00:37:27,180
because I might be going too fast.

733
00:37:28,180 --> 00:37:30,540
Again, there's quite a few things to do.

734
00:37:32,420 --> 00:37:34,380
Yeah, in this resolver, again,

735
00:37:34,380 --> 00:37:37,060
we pass into parameters and returning a list of podcasts.

736
00:37:37,060 --> 00:37:40,860
So I can go here, and I can try this again.

737
00:37:40,860 --> 00:37:42,580
If I refresh the schema,

738
00:37:42,580 --> 00:37:44,580
I should be able to see this new field here.

739
00:37:44,580 --> 00:37:47,940
So there is a podcast field here.

740
00:37:47,940 --> 00:37:50,460
You can see that the default values

741
00:37:50,460 --> 00:37:52,900
are also specifying into the schema.

742
00:37:52,900 --> 00:37:54,500
So you can also see all of that.

743
00:37:57,300 --> 00:37:58,620
So I'm gonna try that now.

744
00:37:59,500 --> 00:38:01,580
Podcasts, and I'm gonna do,

745
00:38:01,580 --> 00:38:03,780
well, I'm just gonna do podcasts like this,

746
00:38:03,780 --> 00:38:05,500
and I'm gonna get ID and title.

747
00:38:07,020 --> 00:38:08,220
And yeah, that works.

748
00:38:08,220 --> 00:38:10,540
It's basically what we would expect.

749
00:38:11,860 --> 00:38:13,220
I guess one thing to note is that

750
00:38:13,220 --> 00:38:15,700
when you're working with lists,

751
00:38:15,700 --> 00:38:17,460
like the syntax of GraphQL is the same.

752
00:38:17,460 --> 00:38:21,140
There is no, like you don't have to use square brackets

753
00:38:21,140 --> 00:38:24,260
for saying I wanna fetch all the items for that.

754
00:38:24,260 --> 00:38:25,980
It's exactly the same.

755
00:38:27,180 --> 00:38:28,340
Which sometimes it might be confusing

756
00:38:28,340 --> 00:38:31,420
because this would be one item,

757
00:38:31,420 --> 00:38:32,980
this is like multiple items.

758
00:38:34,420 --> 00:38:36,860
And yeah, we can also pass parameters like this.

759
00:38:36,860 --> 00:38:41,300
So I wanna do page one and per page, do two.

760
00:38:41,300 --> 00:38:42,780
And now it's only getting two.

761
00:38:42,780 --> 00:38:45,860
And if I go page two, it's gonna get the other ones.

762
00:38:47,260 --> 00:38:50,420
And I guess maybe this is a good time

763
00:38:50,420 --> 00:38:51,620
to introduce also variables.

764
00:38:51,620 --> 00:38:55,020
So in, like when you're working with GraphQL,

765
00:38:55,020 --> 00:38:56,580
like passing parameters like this,

766
00:38:56,580 --> 00:38:59,220
it's fine if you're doing some testing,

767
00:38:59,220 --> 00:39:02,980
but it's not great if you're using a query

768
00:39:02,980 --> 00:39:04,100
inside your GraphQL app,

769
00:39:04,100 --> 00:39:05,460
because basically that means that

770
00:39:05,460 --> 00:39:06,300
if you wanna go to page two,

771
00:39:06,300 --> 00:39:08,100
you have to change your old query.

772
00:39:08,100 --> 00:39:11,820
And so the way to kind of fix this is to use variables.

773
00:39:11,820 --> 00:39:16,140
So for example, you can do query like this,

774
00:39:16,140 --> 00:39:17,380
and then I can pass,

775
00:39:19,180 --> 00:39:20,940
fetch podcasts.

776
00:39:20,940 --> 00:39:24,540
So this first thing is the operation type.

777
00:39:24,540 --> 00:39:25,980
It's basically saying I'm gonna do a query

778
00:39:25,980 --> 00:39:28,020
for our mutation, in this case it's a query.

779
00:39:28,020 --> 00:39:33,020
The second thing here is a name for this operation.

780
00:39:33,860 --> 00:39:35,740
And this is actually not mandatory,

781
00:39:35,740 --> 00:39:37,300
so you can skip it,

782
00:39:37,300 --> 00:39:40,140
but it's basically useful if you wanna do logging

783
00:39:40,140 --> 00:39:44,060
and basically kind of see like a quick glance

784
00:39:44,060 --> 00:39:47,180
on a monitoring tool, what operations someone was doing.

785
00:39:47,180 --> 00:39:50,780
And then you can specify all the variables here.

786
00:39:50,780 --> 00:39:54,020
So I wanna do page of, sorry,

787
00:39:54,060 --> 00:39:57,660
there are page of type number integer,

788
00:39:57,660 --> 00:39:59,380
and in this case it's mandatory.

789
00:39:59,380 --> 00:40:01,300
So fetch right around this is gonna complain

790
00:40:01,300 --> 00:40:03,420
because I haven't passed any variables,

791
00:40:03,420 --> 00:40:06,660
and you pass variables in this case here.

792
00:40:06,660 --> 00:40:07,620
So page one.

793
00:40:08,580 --> 00:40:11,480
And if I check the network response,

794
00:40:12,620 --> 00:40:15,860
I can see here that inside my payload,

795
00:40:15,860 --> 00:40:17,020
I'm doing an operation name,

796
00:40:17,020 --> 00:40:19,140
which is called fetch podcasts,

797
00:40:19,140 --> 00:40:21,940
then the query, and then the variables.

798
00:40:21,940 --> 00:40:25,060
So it's just a nicer way of dealing with like dynamic data

799
00:40:25,060 --> 00:40:27,940
and passing multiple things.

800
00:40:27,940 --> 00:40:30,740
And this is actually gonna be useful

801
00:40:30,740 --> 00:40:32,660
like in more advanced use cases,

802
00:40:32,660 --> 00:40:35,100
if you wanna do, other than monitor,

803
00:40:35,100 --> 00:40:39,820
you can also say I wanna only allow some specific queries,

804
00:40:39,820 --> 00:40:43,040
so you can use the names and the document to do that.

805
00:40:44,020 --> 00:40:46,180
More than the name, you would use a document

806
00:40:46,180 --> 00:40:48,660
because you can basically have an allow list of queries,

807
00:40:48,660 --> 00:40:52,300
and I'd say have this query in my database or in my store,

808
00:40:52,300 --> 00:40:56,020
and I only wanna allow this query to run some other way,

809
00:40:56,020 --> 00:40:58,020
which I don't think we,

810
00:40:58,020 --> 00:41:01,300
we might be able to see that today, but I don't know.

811
00:41:01,300 --> 00:41:02,140
Cool.

812
00:41:04,940 --> 00:41:07,740
Yeah, one issue of this is at the moment,

813
00:41:07,740 --> 00:41:11,620
like if I'm trying to fetch page, I don't know,

814
00:41:11,620 --> 00:41:13,300
minus one, it's gonna work.

815
00:41:15,220 --> 00:41:16,500
Well, it's gonna turn an error,

816
00:41:16,500 --> 00:41:21,500
but like, I mean, that's actually a good error.

817
00:41:22,580 --> 00:41:26,580
Let me do something a bit more annoying.

818
00:41:26,580 --> 00:41:30,220
So if I do per page and if I do something like this,

819
00:41:31,380 --> 00:41:35,860
it's not gonna complain because we not put any validation,

820
00:41:35,860 --> 00:41:38,060
and like allowing users to do something like this

821
00:41:38,060 --> 00:41:42,340
is not ideal because we don't want them to fetch so much data

822
00:41:42,340 --> 00:41:45,460
because they can easily DDoS our server

823
00:41:45,740 --> 00:41:49,100
if there are multiple requests like this and so on.

824
00:41:49,100 --> 00:41:52,380
So one quick way of fixing this

825
00:41:52,380 --> 00:41:54,860
is by just doing an assert inside your code,

826
00:41:55,820 --> 00:41:58,780
which I'm just gonna copy and paste like this.

827
00:42:00,540 --> 00:42:05,180
So, let me just fix this.

828
00:42:05,180 --> 00:42:08,380
So here, I'm basically checking if the page is less than one,

829
00:42:08,380 --> 00:42:09,660
then I return an error.

830
00:42:09,660 --> 00:42:12,060
If it's per page is less than one,

831
00:42:12,060 --> 00:42:12,900
I also return an error,

832
00:42:12,980 --> 00:42:16,460
and the same for max length.

833
00:42:16,460 --> 00:42:21,460
So I only wanna allow a maximum 50 items return.

834
00:42:21,940 --> 00:42:23,460
So if I go and try this,

835
00:42:27,420 --> 00:42:29,340
see, per page must be less than 50.

836
00:42:29,340 --> 00:42:32,940
And so if I go to, I don't know, 40, that's gonna work.

837
00:42:32,940 --> 00:42:37,700
So this is a very quick way of kind of, yeah,

838
00:42:37,700 --> 00:42:39,740
doing validation in GraphQL.

839
00:42:39,740 --> 00:42:42,060
We do also have some support for Pydantic.

840
00:42:42,060 --> 00:42:43,500
I don't think it's great at the moment.

841
00:42:43,500 --> 00:42:45,580
It's a bit annoying the way I use it,

842
00:42:46,660 --> 00:42:49,140
but you could also use Pydantic here.

843
00:42:51,940 --> 00:42:54,420
Well, I really wanna have Pydantic

844
00:42:54,420 --> 00:42:55,980
as first class support at some point,

845
00:42:55,980 --> 00:42:57,820
but that's gonna take quite a while.

846
00:42:59,220 --> 00:43:00,900
But yeah, basically this is something, again,

847
00:43:00,900 --> 00:43:02,580
for every API that you're building,

848
00:43:02,580 --> 00:43:05,260
you should definitely make sure that you're not returning

849
00:43:05,260 --> 00:43:07,380
more than specific amount of data.

850
00:43:07,380 --> 00:43:09,900
You can do this inside of here,

851
00:43:09,900 --> 00:43:10,900
well, inside the resolver.

852
00:43:10,900 --> 00:43:13,300
You can also do this inside the paginate function,

853
00:43:13,300 --> 00:43:14,620
which already was doing it.

854
00:43:15,660 --> 00:43:18,180
But again, just make sure that you do these kind of things

855
00:43:18,180 --> 00:43:20,500
so you don't allow people to return too much data,

856
00:43:20,500 --> 00:43:21,340
especially in GraphQL,

857
00:43:21,340 --> 00:43:23,980
since you could even do something like this.

858
00:43:26,020 --> 00:43:30,140
So you can request this field using an alias multiple times.

859
00:43:31,860 --> 00:43:32,980
Let me do this.

860
00:43:34,860 --> 00:43:35,940
And so you can see,

861
00:43:35,940 --> 00:43:38,340
I'm basically doing this request multiple times,

862
00:43:38,340 --> 00:43:40,620
and this is gonna do two SQL call in my data

863
00:43:41,460 --> 00:43:43,020
and it's not gonna be great.

864
00:43:43,020 --> 00:43:47,180
So just putting some limit in place would be nice.

865
00:43:47,180 --> 00:43:51,100
And I'm working on another extension for Strawberry

866
00:43:51,100 --> 00:43:54,260
to prevent these kind of things from happening.

867
00:43:54,260 --> 00:43:58,100
So you can say, I wanna allow maximum three aliases.

868
00:43:58,100 --> 00:43:59,860
At the moment, you can still do a query

869
00:43:59,860 --> 00:44:03,480
that's not great like this and doing a big document.

870
00:44:05,060 --> 00:44:09,060
And yeah, that's gonna be annoying for your server.

871
00:44:11,140 --> 00:44:12,260
So this is some of the feature

872
00:44:12,260 --> 00:44:13,860
that's coming up hopefully soon.

873
00:44:16,100 --> 00:44:18,340
The gist of this is like every time you allow someone

874
00:44:18,340 --> 00:44:21,700
to kind of do filters on your database,

875
00:44:21,700 --> 00:44:25,020
you make sure that you limit them for doing too much.

876
00:44:25,020 --> 00:44:26,260
So like fetching too much data

877
00:44:26,260 --> 00:44:28,620
or even filtering too many things

878
00:44:28,620 --> 00:44:30,780
that they might not be able to see

879
00:44:30,780 --> 00:44:32,640
or should not be, not see.

880
00:44:34,420 --> 00:44:37,340
Yeah, so one additional addition of this

881
00:44:37,340 --> 00:44:40,540
is that at the moment, we just get a list of items.

882
00:44:41,460 --> 00:44:44,580
So we don't have a way to basically say,

883
00:44:44,580 --> 00:44:47,220
oh, there's another page or this is the previous page.

884
00:44:47,220 --> 00:44:51,900
So a way to fix that is to basically change our schema

885
00:44:51,900 --> 00:44:55,700
to add more, an additional level.

886
00:44:55,700 --> 00:44:57,720
So you can do items like this

887
00:44:57,720 --> 00:44:59,780
and inside items I'm returning the podcast

888
00:44:59,780 --> 00:45:03,380
and then I can have something called page info

889
00:45:03,380 --> 00:45:05,340
or this could be anything to be honest.

890
00:45:05,340 --> 00:45:09,060
And you can do something like ask next, ask prev and so on.

891
00:45:09,060 --> 00:45:12,900
So this allows your client to basically understand

892
00:45:14,580 --> 00:45:15,780
what's in the response.

893
00:45:15,780 --> 00:45:17,620
So if you have more data or less data.

894
00:45:19,140 --> 00:45:19,980
I'm gonna close this page

895
00:45:19,980 --> 00:45:21,940
because I'm getting there all the time.

896
00:45:23,820 --> 00:45:26,220
Yeah, so again, we can do something like this

897
00:45:27,500 --> 00:45:29,980
which is called paginate the podcast.

898
00:45:29,980 --> 00:45:32,100
I mean, this one is a bit simpler.

899
00:45:32,100 --> 00:45:34,260
So maybe let's actually implement this.

900
00:45:34,780 --> 00:45:38,580
So we have this.

901
00:45:38,580 --> 00:45:42,020
So again, I can spray forward to create new types.

902
00:45:42,020 --> 00:45:44,300
So instead of returning a list of podcasts,

903
00:45:44,300 --> 00:45:46,900
I'm returning a kind of container

904
00:45:46,900 --> 00:45:48,780
like a wrapper on top of that.

905
00:45:48,780 --> 00:45:52,540
And I also have an additional field called ask next page.

906
00:45:52,540 --> 00:45:54,060
So here, instead of returning this,

907
00:45:54,060 --> 00:45:58,300
I do paginate the podcast items equals this and

908
00:46:01,060 --> 00:46:02,260
this I think this is wrong.

909
00:46:02,300 --> 00:46:05,860
Let me just copy this to be easier.

910
00:46:05,860 --> 00:46:07,380
There we go.

911
00:46:07,380 --> 00:46:08,740
Next page is this.

912
00:46:08,740 --> 00:46:10,420
And now this is complaining

913
00:46:10,420 --> 00:46:12,020
because I haven't updated the type here.

914
00:46:12,020 --> 00:46:13,820
So I'm gonna do this quickly here.

915
00:46:14,660 --> 00:46:15,780
And now it works.

916
00:46:15,780 --> 00:46:18,260
And so if I go and try this query again,

917
00:46:18,260 --> 00:46:19,900
gonna refresh here.

918
00:46:19,900 --> 00:46:22,540
So items works and then I need to change this.

919
00:46:23,780 --> 00:46:26,780
And you can see here that now we have a nicer shape,

920
00:46:26,780 --> 00:46:29,180
a shape that's more useful for our clients.

921
00:46:29,180 --> 00:46:30,980
And again, this is something that you

922
00:46:31,820 --> 00:46:33,500
kind of need to think about.

923
00:46:33,500 --> 00:46:35,300
How is this API is gonna be used?

924
00:46:36,460 --> 00:46:38,260
If you know that for example, this page,

925
00:46:38,260 --> 00:46:42,260
you need to always, you have to show the next item.

926
00:46:44,260 --> 00:46:46,060
This is a very basic example.

927
00:46:46,060 --> 00:46:50,700
Like just try to model the query based on the usage.

928
00:46:50,700 --> 00:46:51,540
That's what I'm saying.

929
00:46:51,540 --> 00:46:53,180
Don't think about the data that you have,

930
00:46:53,180 --> 00:46:54,700
think about how it's gonna be used.

931
00:46:54,700 --> 00:46:56,540
So you make an API that's very easy to use

932
00:46:56,540 --> 00:46:57,620
and very flexible.

933
00:46:58,620 --> 00:47:01,420
So in this case again, we have the as next page.

934
00:47:01,420 --> 00:47:04,300
We don't have a prev because we might not need it,

935
00:47:04,300 --> 00:47:06,580
but we can also add that one in.

936
00:47:08,980 --> 00:47:11,180
Let me check one more thing.

937
00:47:11,180 --> 00:47:13,020
Yeah, this is how we tested it.

938
00:47:13,020 --> 00:47:17,420
And before showing another way of doing the pagination,

939
00:47:17,420 --> 00:47:20,180
just wanna show one thing that I usually do

940
00:47:20,180 --> 00:47:22,580
for kind of getting rid of the duplicate code.

941
00:47:22,580 --> 00:47:25,900
So here we are doing this code all over again,

942
00:47:25,900 --> 00:47:28,620
like we're doing here, we're doing here,

943
00:47:28,620 --> 00:47:30,740
and we might be doing in other places in future.

944
00:47:30,740 --> 00:47:33,620
So one thing that I usually do is to create a class method

945
00:47:33,620 --> 00:47:37,220
on the podcast, which allows us to convert this,

946
00:47:37,220 --> 00:47:40,380
a Django model into this type.

947
00:47:40,380 --> 00:47:42,220
And so this is what I usually do.

948
00:47:42,220 --> 00:47:46,660
So I create a class method like this.

949
00:47:48,220 --> 00:47:50,340
And, sorry, it's gonna be dead.

950
00:47:52,500 --> 00:47:53,340
There we go.

951
00:47:54,340 --> 00:47:56,980
It's gonna also fix the typing issues.

952
00:47:58,500 --> 00:48:00,900
So yeah, basically I create a helper method

953
00:48:00,900 --> 00:48:05,060
on the podcast type that basically knows how to convert

954
00:48:05,060 --> 00:48:07,300
a Django model into itself.

955
00:48:08,420 --> 00:48:11,820
And this is quite useful because you only have one way

956
00:48:11,820 --> 00:48:15,300
of converting this into a Django model into this.

957
00:48:15,300 --> 00:48:19,180
And yeah, there's also other ways of creating

958
00:48:19,180 --> 00:48:21,540
like a generic converter, but I think this is like

959
00:48:21,700 --> 00:48:25,180
the cleanest and the one I do prefer the most.

960
00:48:25,180 --> 00:48:27,980
And it also helps a bit with types, because for example,

961
00:48:27,980 --> 00:48:30,660
if you do something like this, it's gonna tell you like,

962
00:48:30,660 --> 00:48:34,460
look, this member does not exist on the podcast model.

963
00:48:36,220 --> 00:48:38,260
And if you're not familiar with types as well,

964
00:48:38,260 --> 00:48:41,940
like this thing here, the reason why I'm putting

965
00:48:44,020 --> 00:48:47,340
quotes around it is because this type is not defined yet.

966
00:48:47,340 --> 00:48:50,460
And so we need to basically change it to be a forward

967
00:48:50,460 --> 00:48:53,220
reference, a reference to a type that's gonna be

968
00:48:53,220 --> 00:48:54,980
evaluated later.

969
00:48:54,980 --> 00:48:56,980
There's also another way which is from

970
00:48:56,980 --> 00:48:58,940
future import annotation,

971
00:49:00,740 --> 00:49:02,580
which is basically changing all the annotation

972
00:49:02,580 --> 00:49:04,460
to be strings for us on the dot.

973
00:49:04,460 --> 00:49:07,020
So you could do this as well, but again,

974
00:49:07,020 --> 00:49:07,940
it's not too important.

975
00:49:07,940 --> 00:49:11,100
This is something that might change a bit in future,

976
00:49:11,100 --> 00:49:15,140
like there was a big, I don't know, debate on how this

977
00:49:15,140 --> 00:49:17,100
should work in future, because at the moment,

978
00:49:17,100 --> 00:49:20,380
like this, again, is making this a string.

979
00:49:21,180 --> 00:49:24,100
It's making the coding side strawberry in other library.

980
00:49:24,100 --> 00:49:25,580
By then, it can be more complicated,

981
00:49:25,580 --> 00:49:27,860
because you have to deal either with types or strings,

982
00:49:27,860 --> 00:49:30,180
and it's been messy, but in future, hopefully,

983
00:49:30,180 --> 00:49:32,980
we can remove some of that code that we have.

984
00:49:33,900 --> 00:49:35,540
But yeah, basically, this is a way to say,

985
00:49:35,540 --> 00:49:38,260
this is the type that does not yet exist,

986
00:49:38,260 --> 00:49:39,700
but it's gonna exist.

987
00:49:39,700 --> 00:49:43,620
And type checkers like Pylance and MyPy,

988
00:49:43,620 --> 00:49:46,860
they know, or even Flakate, they know that this is a

989
00:49:46,860 --> 00:49:50,140
reference, so they're gonna check if that type exists or not.

990
00:49:51,380 --> 00:49:56,100
And so now that we have this util function or method,

991
00:49:56,100 --> 00:50:00,020
we can change this, and we can do from db like this,

992
00:50:00,020 --> 00:50:02,700
and we can do the same here.

993
00:50:03,700 --> 00:50:06,980
So a bit more nicer and easier to read,

994
00:50:06,980 --> 00:50:08,460
so it's a nice code there.

995
00:50:10,700 --> 00:50:13,380
Cool, do you have any question about this?

996
00:50:15,420 --> 00:50:16,260
Okay.

997
00:50:18,260 --> 00:50:19,100
Cool.

998
00:50:19,180 --> 00:50:23,420
So how do we actually get the next pages?

999
00:50:23,420 --> 00:50:24,940
How do we get the next pages?

1000
00:50:27,620 --> 00:50:30,420
Do you wanna know how we get if there's more pages or?

1001
00:50:30,420 --> 00:50:34,020
No, so if we turn the next pages,

1002
00:50:34,020 --> 00:50:37,420
so how do we go for the next page?

1003
00:50:37,420 --> 00:50:38,540
Yeah, that's a good question.

1004
00:50:38,540 --> 00:50:42,380
So the question is basically, how do we get the next page?

1005
00:50:42,380 --> 00:50:45,260
So in this case, in your frontend,

1006
00:50:45,260 --> 00:50:47,900
you can check if as next page is true,

1007
00:50:47,900 --> 00:50:51,060
then you can increment this, this variable.

1008
00:50:51,060 --> 00:50:53,140
Another option, you can also do next page,

1009
00:50:53,140 --> 00:50:55,620
and this will be an integer, so you can use that

1010
00:50:55,620 --> 00:50:58,380
inside your variable as well,

1011
00:50:58,380 --> 00:51:01,300
so if you wanna do less computation on the frontend.

1012
00:51:01,300 --> 00:51:03,820
Yeah, so this both ways, yeah.

1013
00:51:03,820 --> 00:51:06,020
So either you increment the counter if this is true,

1014
00:51:06,020 --> 00:51:08,620
or you return the next page number as well.

1015
00:51:10,260 --> 00:51:12,860
Again, this is like preference as well.

1016
00:51:12,860 --> 00:51:14,940
I think as next page is quite common,

1017
00:51:14,940 --> 00:51:16,540
and then you increment things.

1018
00:51:18,660 --> 00:51:22,780
So the other pagination I wanna show,

1019
00:51:22,780 --> 00:51:24,020
it's a bit more involved,

1020
00:51:24,020 --> 00:51:26,540
but I think it's important to kinda see this

1021
00:51:26,540 --> 00:51:28,940
because this is gonna come up a lot if you use GraphQL,

1022
00:51:28,940 --> 00:51:31,020
which is the relay specification,

1023
00:51:31,020 --> 00:51:33,100
and again, this was created by Facebook

1024
00:51:35,460 --> 00:51:38,780
to basically solve the way they do pagination,

1025
00:51:38,780 --> 00:51:41,380
and this works very well if you have pagination

1026
00:51:41,380 --> 00:51:43,980
that has a lot of data, so for example,

1027
00:51:43,980 --> 00:51:45,700
feed on Facebook has a lot of data,

1028
00:51:45,700 --> 00:51:50,700
and using offset in most databases quite slow

1029
00:51:50,900 --> 00:51:54,900
because it has to scan the old table and go to the offset,

1030
00:51:54,900 --> 00:51:59,900
and so one way of fixing this is gonna be by using cursors,

1031
00:52:00,300 --> 00:52:04,420
which we gonna use a Django cursor pagination,

1032
00:52:04,420 --> 00:52:06,580
this library that basically implements

1033
00:52:06,580 --> 00:52:11,580
the cursors on Django,

1034
00:52:12,060 --> 00:52:13,980
so basically it's an additional paginator

1035
00:52:13,980 --> 00:52:18,420
that allows you to kinda use a cursor instead of a offset

1036
00:52:18,420 --> 00:52:23,420
to navigate to like a point in time or like next items.

1037
00:52:25,500 --> 00:52:27,780
I honestly forgot how it works,

1038
00:52:27,780 --> 00:52:30,340
but usually if you're working with this,

1039
00:52:30,340 --> 00:52:33,380
you don't have to worry too much how it works,

1040
00:52:33,380 --> 00:52:34,540
but if I remember correctly,

1041
00:52:34,540 --> 00:52:37,300
you basically need an ID that's stable and sequential,

1042
00:52:38,660 --> 00:52:39,740
or maybe a date time.

1043
00:52:40,980 --> 00:52:43,460
Anyway, again, this is not too important for what we're seeing.

1044
00:52:43,460 --> 00:52:46,940
I mostly wanted to show you this pagination

1045
00:52:46,940 --> 00:52:50,140
because it's used a lot in GafQL,

1046
00:52:50,140 --> 00:52:52,140
because again, it's being polarized by Facebook

1047
00:52:52,140 --> 00:52:54,060
by this relay specification,

1048
00:52:55,020 --> 00:52:56,860
and we also gonna see a couple of,

1049
00:52:56,860 --> 00:52:59,300
well, one feature that I think is really interesting

1050
00:52:59,300 --> 00:53:03,300
in Sorbet, which is the generics,

1051
00:53:03,300 --> 00:53:05,100
so we gonna see that as well.

1052
00:53:05,100 --> 00:53:08,420
So the way the relay pagination works

1053
00:53:08,420 --> 00:53:12,260
is that it's a bit verbose, it has a connection type,

1054
00:53:12,540 --> 00:53:16,780
which is similar to our wrapper type

1055
00:53:16,780 --> 00:53:18,780
that we created for paginated podcasts,

1056
00:53:18,780 --> 00:53:22,300
so it includes these items,

1057
00:53:22,300 --> 00:53:27,220
but every connection, so this is gonna be,

1058
00:53:27,220 --> 00:53:29,500
this podcast is a connection for podcasts,

1059
00:53:29,500 --> 00:53:32,380
there's gonna be a page info like we seen before,

1060
00:53:32,380 --> 00:53:34,180
and then there's gonna be a list of edges,

1061
00:53:34,180 --> 00:53:36,140
and inside every edge is gonna be a node.

1062
00:53:36,140 --> 00:53:37,420
Again, this is quite verbose,

1063
00:53:37,420 --> 00:53:39,540
but it can also be simplified,

1064
00:53:39,540 --> 00:53:42,500
like some people just do nodes instead of edges,

1065
00:53:42,500 --> 00:53:44,940
I just wanted to show you how it works,

1066
00:53:44,940 --> 00:53:46,460
because it's gonna be useful.

1067
00:53:48,020 --> 00:53:50,100
Yeah, I'm gonna go more into the details

1068
00:53:50,100 --> 00:53:51,400
while we implement this.

1069
00:53:53,860 --> 00:53:57,260
One thing of this, so there is a,

1070
00:53:57,260 --> 00:54:00,060
let me see if I can find it, there we go.

1071
00:54:00,060 --> 00:54:04,100
This request has been going on for a couple of maybe months

1072
00:54:04,100 --> 00:54:07,420
in Sorbet to make the implementation relay

1073
00:54:07,420 --> 00:54:12,420
a bit easier, so instead of doing these types

1074
00:54:12,620 --> 00:54:14,420
that you have to do now manually,

1075
00:54:14,420 --> 00:54:15,980
it's gonna be handled for you.

1076
00:54:18,260 --> 00:54:19,860
I don't have a code now,

1077
00:54:19,860 --> 00:54:21,740
so this is one of those things I mentioned

1078
00:54:21,740 --> 00:54:23,080
that it's gonna be easier in future,

1079
00:54:23,080 --> 00:54:26,100
so once that's merged, I'm gonna update this workshop

1080
00:54:26,100 --> 00:54:28,420
to include that feature instead of us

1081
00:54:28,420 --> 00:54:29,940
creating the types manually,

1082
00:54:29,940 --> 00:54:32,820
but again, it's not that difficult anyway.

1083
00:54:32,820 --> 00:54:34,940
I guess the most difficult part is to implement

1084
00:54:34,940 --> 00:54:38,180
the course of pagination that in this case is done

1085
00:54:38,180 --> 00:54:39,540
by this Django package.

1086
00:54:44,700 --> 00:54:46,940
Yeah, so we're gonna create three types now.

1087
00:54:46,940 --> 00:54:49,620
We're gonna create one, which is the connection

1088
00:54:49,620 --> 00:54:52,980
that returns all this information, so page info edges,

1089
00:54:52,980 --> 00:54:55,580
and then we're gonna create the page info type,

1090
00:54:55,580 --> 00:54:57,460
which is all the information for the page,

1091
00:54:57,460 --> 00:55:01,060
then we're gonna create the edge type,

1092
00:55:01,060 --> 00:55:04,580
which is basically what contains our item.

1093
00:55:07,260 --> 00:55:09,580
One reason why there is edges is that

1094
00:55:10,580 --> 00:55:14,780
like for root level things, so like things that come

1095
00:55:14,780 --> 00:55:17,300
from the APIs, like from the root level,

1096
00:55:17,300 --> 00:55:19,140
they're not too important, but if you are doing

1097
00:55:19,140 --> 00:55:21,460
a pagination, for example, if you have a person

1098
00:55:21,460 --> 00:55:23,700
that wanna do a friends pagination,

1099
00:55:24,540 --> 00:55:26,880
instead of having, for example, if you wanna show

1100
00:55:26,880 --> 00:55:29,460
the relationship type between these two friends,

1101
00:55:29,500 --> 00:55:31,100
instead of having inside the node,

1102
00:55:31,100 --> 00:55:33,580
which might not make sense, because it's a field

1103
00:55:33,580 --> 00:55:36,860
that's specific to a connection, you can have it on edges.

1104
00:55:36,860 --> 00:55:41,780
So for example, if this was friends on a user,

1105
00:55:41,780 --> 00:55:45,020
you would have edges, and then for example, relations type.

1106
00:55:46,020 --> 00:55:48,740
This is the reason why there is this additional edge field,

1107
00:55:48,740 --> 00:55:53,060
so you can add additional fields that are specific

1108
00:55:53,060 --> 00:55:54,460
to that connection.

1109
00:55:56,260 --> 00:55:58,460
Don't know if that makes sense, but it's basically

1110
00:55:58,700 --> 00:56:00,860
another place where you can put metadata

1111
00:56:00,860 --> 00:56:04,060
to a specific connection between types.

1112
00:56:05,940 --> 00:56:08,300
Okay, so again, I mentioned like we're using

1113
00:56:08,300 --> 00:56:10,580
Django cluster pagination, so that's gonna do everything

1114
00:56:10,580 --> 00:56:14,060
for us, which is quite nice, and we're gonna use

1115
00:56:14,060 --> 00:56:15,100
the generic type.

1116
00:56:15,100 --> 00:56:18,300
So Python has support for generic types

1117
00:56:18,300 --> 00:56:20,700
inside the standard library for types,

1118
00:56:20,700 --> 00:56:22,980
and that allows you to basically create types

1119
00:56:22,980 --> 00:56:25,260
that can be reused over time.

1120
00:56:25,260 --> 00:56:26,900
We actually seen a couple of these already,

1121
00:56:26,900 --> 00:56:29,060
so we seen optional, we seen list.

1122
00:56:29,060 --> 00:56:31,940
These are generic types that basically allow you to,

1123
00:56:33,340 --> 00:56:36,140
basically, they can be reused for any kind of thing.

1124
00:56:36,140 --> 00:56:39,980
So here I'm using list, here I'm using podcasts.

1125
00:56:41,500 --> 00:56:45,340
Well, this is not really readable,

1126
00:56:45,340 --> 00:56:46,980
but I'll show you an example how it works.

1127
00:56:46,980 --> 00:56:49,940
So we actually created already some for you.

1128
00:56:49,940 --> 00:56:53,180
So we do have here, we have these three types.

1129
00:56:53,180 --> 00:56:56,220
So let's start with page info is like a normal type.

1130
00:56:56,220 --> 00:56:58,540
So as all the information that we mentioned,

1131
00:56:58,540 --> 00:57:01,260
has next page as previous start and end cursor.

1132
00:57:01,260 --> 00:57:04,180
So this allow you to go back and forth into the page.

1133
00:57:04,180 --> 00:57:07,580
There's also a helper method that allows you

1134
00:57:07,580 --> 00:57:12,580
to convert the database page into a page info.

1135
00:57:14,580 --> 00:57:17,900
Then there's these two types here, hedge and connection.

1136
00:57:17,900 --> 00:57:21,060
So the first thing that we did is to create a type var.

1137
00:57:21,060 --> 00:57:24,020
So a type var is basically like a placeholder for type.

1138
00:57:24,020 --> 00:57:27,860
So when you create a type like this, a class like this,

1139
00:57:27,860 --> 00:57:30,500
I'm saying this is a generic class on node,

1140
00:57:30,500 --> 00:57:33,140
and this becomes a placeholder inside your class.

1141
00:57:33,140 --> 00:57:36,380
So if I go in my code and I do something like this,

1142
00:57:36,380 --> 00:57:41,380
edge of string, the node here is gonna be a string.

1143
00:57:44,260 --> 00:57:45,620
And cursor is gonna be a string as well.

1144
00:57:45,620 --> 00:57:47,620
So if I do, for example, this,

1145
00:57:47,620 --> 00:57:49,780
I can see here in the autocomplete,

1146
00:57:49,780 --> 00:57:52,140
it's gonna say node is a string.

1147
00:57:52,140 --> 00:57:53,700
If I change this to integer,

1148
00:57:56,500 --> 00:57:58,460
it's gonna change to integer.

1149
00:57:58,460 --> 00:58:01,420
So this is a very nice way of defining types

1150
00:58:01,420 --> 00:58:04,180
that can be reused into multiple contexts.

1151
00:58:04,180 --> 00:58:06,540
Because this ready pagination is generic,

1152
00:58:06,540 --> 00:58:08,660
you can work with any type that you might want.

1153
00:58:08,660 --> 00:58:11,300
So you can add podcasts, you might have episodes,

1154
00:58:11,300 --> 00:58:13,180
you might have users and things like that.

1155
00:58:13,180 --> 00:58:15,820
You don't have to create all the types all over again,

1156
00:58:15,820 --> 00:58:19,460
because that's gonna, this is gonna be done for you.

1157
00:58:20,220 --> 00:58:24,220
And I'll show you what happens when you use this in server.

1158
00:58:25,500 --> 00:58:27,460
So yeah, again, we created these three types,

1159
00:58:27,460 --> 00:58:28,740
and now we can reuse them.

1160
00:58:31,340 --> 00:58:35,020
So now we're gonna override the podcast field

1161
00:58:35,020 --> 00:58:37,460
to use the podcast connection.

1162
00:58:37,460 --> 00:58:40,260
The code is similar to what we had before.

1163
00:58:40,260 --> 00:58:41,820
There's just a couple of more things

1164
00:58:41,820 --> 00:58:46,820
for kind of conforming to the connection shape.

1165
00:58:47,020 --> 00:58:52,020
So I need to import this here from API.pagination.types.

1166
00:58:56,900 --> 00:58:59,100
I'm gonna import everything, here we go.

1167
00:58:59,100 --> 00:59:01,180
So this is what we had before.

1168
00:59:01,180 --> 00:59:05,300
So we're fetching, we're gonna remove this check for now.

1169
00:59:06,980 --> 00:59:10,780
So we're using our database utils to find the podcast

1170
00:59:12,180 --> 00:59:15,740
from, yeah, after this cursor,

1171
00:59:15,780 --> 00:59:17,860
and then we can also have a first.

1172
00:59:17,860 --> 00:59:21,220
So I wanna fetch first 10, first 20 and so on.

1173
00:59:21,220 --> 00:59:22,820
Then I'm converting the page info

1174
00:59:22,820 --> 00:59:27,220
from the one from database to the one for the GraphQL API.

1175
00:59:27,220 --> 00:59:30,020
And then finally, are we creating this connection?

1176
00:59:30,020 --> 00:59:32,420
And again, this is where things can be more verbose.

1177
00:59:32,420 --> 00:59:36,700
And this is something we did that progress

1178
00:59:36,700 --> 00:59:37,860
that I showed you is gonna make easier.

1179
00:59:37,860 --> 00:59:39,660
So this will be one line.

1180
00:59:39,660 --> 00:59:43,340
So you can just return the list of podcasts.

1181
00:59:43,740 --> 00:59:46,060
Yeah, basically that's it.

1182
00:59:46,060 --> 00:59:49,060
This is gonna create three more types

1183
00:59:49,060 --> 00:59:52,860
for you automatically from the generic types.

1184
00:59:52,860 --> 00:59:57,860
So if I go here and I change this query

1185
00:59:58,020 --> 01:00:02,140
to be the one that we just created.

1186
01:00:02,140 --> 01:00:05,380
So let's do, it's gonna remove this for now.

1187
01:00:06,740 --> 01:00:08,420
So I'm gonna fetch the first 10 podcasts.

1188
01:00:08,420 --> 01:00:11,300
And now you're gonna see how verbose it is.

1189
01:00:11,300 --> 01:00:15,260
So there is the page info has next page as prev.

1190
01:00:15,260 --> 01:00:17,380
Oh, well as prev.

1191
01:00:17,380 --> 01:00:18,620
It's gonna do first one.

1192
01:00:18,620 --> 01:00:20,620
And you can see now there is edges.

1193
01:00:20,620 --> 01:00:22,380
Inside edges there is node.

1194
01:00:22,380 --> 01:00:24,580
And then there's the information that we're looking for.

1195
01:00:24,580 --> 01:00:25,940
Again, this is a bit verbose.

1196
01:00:25,940 --> 01:00:28,300
It could be changed to be nodes.

1197
01:00:30,820 --> 01:00:33,260
Oh, sorry, nodes like this.

1198
01:00:33,260 --> 01:00:34,900
I just wanted to show you the full API

1199
01:00:34,900 --> 01:00:38,420
that's from the specification in RIDD.

1200
01:00:39,420 --> 01:00:40,420
There we go.

1201
01:00:41,900 --> 01:00:44,980
So if I try to fetch this, I can see now that there is a,

1202
01:00:46,260 --> 01:00:47,660
you know, there's this the page info

1203
01:00:47,660 --> 01:00:50,260
which has all the information that we wanted

1204
01:00:50,260 --> 01:00:52,140
and also all the edges.

1205
01:00:52,140 --> 01:00:57,100
And I can also get the start and poster.

1206
01:00:57,100 --> 01:01:02,100
So this is gonna be a basic C4 encoded string

1207
01:01:02,700 --> 01:01:04,100
of the type and the ID.

1208
01:01:05,260 --> 01:01:07,900
I don't know why they chose this, but I think relay.

1209
01:01:07,940 --> 01:01:09,340
Yeah, I think relay is using this

1210
01:01:09,340 --> 01:01:10,500
for caching on the front end.

1211
01:01:10,500 --> 01:01:14,300
So it basically has a key value store

1212
01:01:14,300 --> 01:01:15,460
where the ID is this one

1213
01:01:15,460 --> 01:01:17,940
and then the cache is the value of the node.

1214
01:01:17,940 --> 01:01:21,100
But anyway, this is just an implementation detail.

1215
01:01:21,100 --> 01:01:24,300
And then I can do after this cursor

1216
01:01:24,300 --> 01:01:25,860
and I should get another one.

1217
01:01:25,860 --> 01:01:27,140
It's all quite into me.

1218
01:01:27,140 --> 01:01:29,940
And if I change this again, I should get this as well.

1219
01:01:31,260 --> 01:01:33,020
And so this is how you can also do

1220
01:01:33,020 --> 01:01:34,380
pagination with the cursor.

1221
01:01:34,380 --> 01:01:37,020
So you get the end cursor

1222
01:01:37,020 --> 01:01:38,900
which is gonna be the cursor for the next page

1223
01:01:38,900 --> 01:01:41,020
and then you can go from there.

1224
01:01:43,140 --> 01:01:46,820
Yeah, and with the generic types,

1225
01:01:46,820 --> 01:01:49,660
you basically created this podcasts connection,

1226
01:01:49,660 --> 01:01:51,580
podcast edge automatically

1227
01:01:51,580 --> 01:01:54,180
without you having to write any additional code.

1228
01:01:54,180 --> 01:01:55,660
And this is gonna be useful also

1229
01:01:55,660 --> 01:01:59,380
like once we do for example, pagination for episodes,

1230
01:01:59,380 --> 01:02:01,020
we're gonna create another two types,

1231
01:02:01,020 --> 01:02:03,340
one for the episode edge,

1232
01:02:03,340 --> 01:02:04,980
one for the episode connection and so on,

1233
01:02:04,980 --> 01:02:05,820
which is quite nice

1234
01:02:05,820 --> 01:02:07,500
because you don't have to go

1235
01:02:07,500 --> 01:02:09,460
and create all these types manually.

1236
01:02:09,460 --> 01:02:12,060
So you don't have to create a new connection

1237
01:02:12,060 --> 01:02:13,540
for a specific type.

1238
01:02:16,380 --> 01:02:17,220
Okay.

1239
01:02:20,580 --> 01:02:24,620
There is a useful article here.

1240
01:02:24,620 --> 01:02:27,260
It's a bit old, but it's like the specification hasn't changed

1241
01:02:27,260 --> 01:02:32,260
and it explains all the information about the relay

1242
01:02:32,500 --> 01:02:35,300
and also the difference within the standard pagination.

1243
01:02:35,300 --> 01:02:38,420
If somebody shows the Google pagination here,

1244
01:02:38,420 --> 01:02:39,900
which is a page pagination.

1245
01:02:41,500 --> 01:02:43,660
This is like page pagination is something you cannot do

1246
01:02:43,660 --> 01:02:46,900
with relay because it uses cursor.

1247
01:02:46,900 --> 01:02:49,700
So there is no way to jump to a specific page.

1248
01:02:49,700 --> 01:02:51,380
And so that's one of the trade off

1249
01:02:51,380 --> 01:02:52,780
for also this pagination.

1250
01:02:52,780 --> 01:02:55,180
It allows you to list a lot of data,

1251
01:02:55,180 --> 01:02:56,180
like quite performantly,

1252
01:02:56,180 --> 01:03:00,740
but you cannot jump straight to a specific page, unfortunately.

1253
01:03:01,980 --> 01:03:05,020
Yeah, definitely recommend to read that

1254
01:03:05,020 --> 01:03:05,860
if you're curious.

1255
01:03:09,540 --> 01:03:12,700
I'm gonna pause a bit and see if there's any question.

1256
01:03:30,860 --> 01:03:31,700
Oh yeah.

1257
01:03:31,700 --> 01:03:33,820
So yeah, what are the benefits of generics?

1258
01:03:33,820 --> 01:03:36,980
So let me show you this again.

1259
01:03:36,980 --> 01:03:39,300
So if I didn't have generic,

1260
01:03:39,300 --> 01:03:43,940
I would need to create a class called podcast connection,

1261
01:03:44,820 --> 01:03:47,900
which has a list of edges.

1262
01:03:49,260 --> 01:03:52,860
Also notice that here I'm using the lowercase versions.

1263
01:03:52,860 --> 01:03:55,700
This list of edge,

1264
01:03:57,940 --> 01:03:59,620
a podcast edge and then page info.

1265
01:03:59,620 --> 01:04:02,540
So this, I would basically need to duplicate all this code.

1266
01:04:03,860 --> 01:04:06,100
For every connection that I need to make.

1267
01:04:06,100 --> 01:04:08,460
So this would be a podcast connection,

1268
01:04:10,820 --> 01:04:13,940
sorry, podcast edge and this would be a podcast.

1269
01:04:13,940 --> 01:04:15,140
This would be like this.

1270
01:04:23,020 --> 01:04:23,860
Yes.

1271
01:04:25,100 --> 01:04:30,020
Yeah, this is exactly what the relay pagination,

1272
01:04:30,020 --> 01:04:33,540
the relay implementation is gonna do for you.

1273
01:04:34,180 --> 01:04:36,220
Let me see if there is an example of this.

1274
01:04:36,220 --> 01:04:39,340
Actually before going into that, is that clear?

1275
01:04:42,860 --> 01:04:47,620
So this connection podcast.

1276
01:04:49,460 --> 01:04:53,940
So these three, four lines are basically done in one

1277
01:04:53,940 --> 01:04:56,260
using this and it's the same here.

1278
01:04:56,260 --> 01:05:00,340
So edge, podcast and it's fine if you have one,

1279
01:05:00,340 --> 01:05:01,780
but once you have more, like for example,

1280
01:05:01,780 --> 01:05:03,060
if you're gonna do episode,

1281
01:05:04,300 --> 01:05:07,140
you will need to duplicate all the code over again.

1282
01:05:07,140 --> 01:05:08,260
So it's quite nice.

1283
01:05:11,540 --> 01:05:14,740
Yeah, let me see if there is an example of this.

1284
01:05:14,740 --> 01:05:18,820
Again, this progress is quite big and it's quite nice.

1285
01:05:18,820 --> 01:05:20,940
It does have quite a couple of features

1286
01:05:20,940 --> 01:05:22,660
that I think are really useful.

1287
01:05:23,980 --> 01:05:25,260
Oh yeah, there's a guides.

1288
01:05:32,620 --> 01:05:36,460
Yeah, this is, I'm thinking maybe a bit more time, but.

1289
01:05:42,380 --> 01:05:43,940
I cannot find it now, but yeah,

1290
01:05:43,940 --> 01:05:46,820
basically it's gonna be something like,

1291
01:05:46,820 --> 01:05:49,580
let me see, sorry, the relayed of field

1292
01:05:50,860 --> 01:05:53,180
and then you pass this and you will return

1293
01:05:54,180 --> 01:05:56,580
maybe just a list of podcasts.

1294
01:05:56,580 --> 01:05:58,220
So you could return maybe this.

1295
01:06:02,780 --> 01:06:06,340
And that would be, and all the machinery that I've done now,

1296
01:06:06,340 --> 01:06:09,100
it would be done by strawberry itself.

1297
01:06:09,100 --> 01:06:10,740
We're just taking a bit of time to make sure

1298
01:06:10,740 --> 01:06:14,060
that we gather all the cases

1299
01:06:14,060 --> 01:06:18,140
because this progress is coming from strawberry Django,

1300
01:06:18,140 --> 01:06:22,260
which is tied to Django and it's basically useful.

1301
01:06:22,260 --> 01:06:25,940
It's really useful if you wanna convert something directly

1302
01:06:25,940 --> 01:06:29,660
from a Django model to a graphical type,

1303
01:06:29,660 --> 01:06:31,940
but we want to make sure that this also works

1304
01:06:31,940 --> 01:06:33,100
in a generic way.

1305
01:06:33,100 --> 01:06:34,300
So taking a bit of time to make sure

1306
01:06:34,300 --> 01:06:35,460
that there's all the old cases.

1307
01:06:35,460 --> 01:06:38,100
Like for example, if you wanna do this,

1308
01:06:38,100 --> 01:06:40,540
the first implementation didn't have a way to do conversion

1309
01:06:40,540 --> 01:06:42,660
from one time to the other manually.

1310
01:06:43,700 --> 01:06:46,580
So hopefully that some comes soon.

1311
01:06:47,500 --> 01:06:48,340
Cool.

1312
01:06:49,660 --> 01:06:52,460
Again, if there is any question, just feel free to stop me.

1313
01:06:53,860 --> 01:06:55,260
So we're gonna see now

1314
01:06:55,860 --> 01:07:00,860
the, just a bit of data fetching optimization.

1315
01:07:00,860 --> 01:07:02,660
So this is something that's gonna be quite important

1316
01:07:02,660 --> 01:07:03,500
in GraphQL.

1317
01:07:03,500 --> 01:07:05,180
So the patterns are a bit different

1318
01:07:05,180 --> 01:07:08,020
in than what you would do with REST.

1319
01:07:08,020 --> 01:07:09,300
I mean, you can still do some of the things

1320
01:07:09,300 --> 01:07:11,620
you can do in REST, but there's other ways of,

1321
01:07:11,620 --> 01:07:15,900
which are more, I guess, GraphQL native

1322
01:07:15,900 --> 01:07:18,780
to the optimization.

1323
01:07:18,780 --> 01:07:23,380
So yeah, before I guess understanding

1324
01:07:23,380 --> 01:07:24,740
how the data fetching works,

1325
01:07:24,740 --> 01:07:26,180
like we need to do a bit of work

1326
01:07:26,180 --> 01:07:30,940
to show an issue of fetching data in GraphQL.

1327
01:07:30,940 --> 01:07:34,020
For example, if I'm doing this query, here I am,

1328
01:07:36,820 --> 01:07:37,900
let me do this again.

1329
01:07:39,940 --> 01:07:44,540
I'm actually only doing one single database code,

1330
01:07:44,540 --> 01:07:49,340
which is fine, but it doesn't show what we wanted to show.

1331
01:07:49,340 --> 01:07:51,660
So we gonna introduce now a list of episodes.

1332
01:07:51,660 --> 01:07:54,700
So we gonna allow us to fetch the latest episodes

1333
01:07:55,700 --> 01:07:56,540
from a podcast.

1334
01:07:56,540 --> 01:07:59,780
So we gonna see what's gonna happen in that case,

1335
01:07:59,780 --> 01:08:01,460
or maybe the other way around.

1336
01:08:01,460 --> 01:08:02,300
Let's see.

1337
01:08:03,380 --> 01:08:04,540
Yeah.

1338
01:08:04,540 --> 01:08:05,700
So the first thing it's gonna do,

1339
01:08:05,700 --> 01:08:07,620
we gonna create a new type called episode,

1340
01:08:07,620 --> 01:08:10,300
and this is gonna represent one single episode.

1341
01:08:10,300 --> 01:08:12,780
And there's a couple of things that are interesting here.

1342
01:08:12,780 --> 01:08:15,580
So, and let me do that.

1343
01:08:15,580 --> 01:08:17,420
So podcasts, types.

1344
01:08:20,100 --> 01:08:20,940
From.

1345
01:08:24,860 --> 01:08:28,860
I'm gonna fix this as well.

1346
01:08:30,260 --> 01:08:32,300
Finance is very strict on some stuff.

1347
01:08:32,300 --> 01:08:36,060
So the couple of things that are interesting here.

1348
01:08:36,060 --> 01:08:40,540
So first one is we using something called survey.private.

1349
01:08:40,540 --> 01:08:45,540
So every time you put a property on a survey type

1350
01:08:46,620 --> 01:08:50,340
on a class here, that's gonna be exposed to GraphQL.

1351
01:08:50,340 --> 01:08:52,660
But in this case, we don't wanna expose this podcast study

1352
01:08:52,660 --> 01:08:56,220
to GraphQL, because it's gonna be inside the podcast type.

1353
01:08:56,220 --> 01:09:01,220
So there is another generic type called survey.private,

1354
01:09:01,460 --> 01:09:03,820
which basically it's a wrapper on any type.

1355
01:09:03,820 --> 01:09:06,980
So you can say, I want to put a podcast ID

1356
01:09:06,980 --> 01:09:08,820
onto the episode class, but I don't want that

1357
01:09:08,820 --> 01:09:10,820
to live in GraphQL.

1358
01:09:10,820 --> 01:09:12,580
And so this is a way to do that.

1359
01:09:15,100 --> 01:09:16,620
Yeah, I think it's also quite nice.

1360
01:09:16,620 --> 01:09:19,700
And the reason why we create this is so that we can

1361
01:09:20,700 --> 01:09:24,460
use the podcast ID inside the podcast field.

1362
01:09:27,500 --> 01:09:29,620
So basically this episode type is gonna have an ID,

1363
01:09:29,620 --> 01:09:32,900
title, notes, published art, and a podcast.

1364
01:09:32,900 --> 01:09:37,220
And the podcast is a field that returns the podcast.

1365
01:09:37,220 --> 01:09:39,340
So it's gonna return this podcast here.

1366
01:09:39,340 --> 01:09:43,860
And to be able to, instead of instantiating the episode

1367
01:09:43,860 --> 01:09:45,780
with the podcast all the time,

1368
01:09:45,780 --> 01:09:48,740
we only pass the podcast ID,

1369
01:09:48,740 --> 01:09:51,620
and we only fetch the podcast when it's requested.

1370
01:09:51,620 --> 01:09:54,820
And I'm gonna show that how it works in a second,

1371
01:09:54,820 --> 01:09:57,260
and why it's actually useful to do that way.

1372
01:09:57,260 --> 01:09:59,320
And also we have the same thing that we've done before.

1373
01:09:59,320 --> 01:10:03,260
So conversion from the database model to a GraphQL type.

1374
01:10:05,480 --> 01:10:06,880
I did write these things here.

1375
01:10:09,100 --> 01:10:10,620
And let's also add this query.

1376
01:10:10,620 --> 01:10:11,460
Oops.

1377
01:10:12,500 --> 01:10:15,580
So now if I go to podcast, query.

1378
01:10:16,580 --> 01:10:20,340
And I'm adding a new query that fetches the latest episodes.

1379
01:10:20,340 --> 01:10:23,540
So last five episodes, for example, and returns them.

1380
01:10:26,460 --> 01:10:27,340
Perfect.

1381
01:10:27,340 --> 01:10:30,700
So if I go back to my GraphQL API,

1382
01:10:30,700 --> 01:10:33,780
move everything, and I fetch the scheme again.

1383
01:10:34,700 --> 01:10:37,700
Latest episodes, and I'm gonna fetch the title

1384
01:10:37,700 --> 01:10:38,740
for every episode.

1385
01:10:38,740 --> 01:10:42,700
So I'm able to see all the latest five episodes.

1386
01:10:43,540 --> 01:10:48,540
And we can also see there's only one database code,

1387
01:10:49,700 --> 01:10:51,620
which is fetching all the episodes,

1388
01:10:51,620 --> 01:10:53,220
all the latest five episodes.

1389
01:10:53,220 --> 01:10:54,980
This is quite nice,

1390
01:10:54,980 --> 01:10:57,380
because it's not fetching any information about the podcast,

1391
01:10:57,380 --> 01:10:59,060
because I haven't requested it.

1392
01:10:59,060 --> 01:11:03,660
But now if I go and try to fetch the podcast,

1393
01:11:03,660 --> 01:11:06,540
I guess one thing, we're not able to fetch the podcast ID

1394
01:11:06,540 --> 01:11:07,900
because that's private.

1395
01:11:07,900 --> 01:11:10,500
And the other thing, we are able to fetch

1396
01:11:10,500 --> 01:11:13,180
all the other information straight from the podcast.

1397
01:11:13,180 --> 01:11:15,420
So one cool thing of GraphQL is that allows you

1398
01:11:15,420 --> 01:11:16,620
to nest fields.

1399
01:11:16,620 --> 01:11:18,620
So you can have resolvers that nested,

1400
01:11:18,620 --> 01:11:21,660
and they only get called if you request them.

1401
01:11:21,660 --> 01:11:23,620
So in this case, I'm gonna request information

1402
01:11:23,620 --> 01:11:26,180
for the podcast for every episode.

1403
01:11:26,180 --> 01:11:30,100
And I can see here I'm getting all the data

1404
01:11:30,100 --> 01:11:33,100
for these episodes and the podcasts.

1405
01:11:33,100 --> 01:11:37,660
But at the same time, I'm also doing one call

1406
01:11:37,660 --> 01:11:40,460
for every episode, which is not what you want,

1407
01:11:41,460 --> 01:11:43,300
because this is like, if you have a lot of episodes,

1408
01:11:43,300 --> 01:11:46,780
this is gonna do a lot of database calls.

1409
01:11:46,780 --> 01:11:49,100
And this is known as the N plus one problem

1410
01:11:51,260 --> 01:11:53,340
in SQL, I guess.

1411
01:11:55,580 --> 01:11:57,940
So there is two ways of solving this.

1412
01:11:57,940 --> 01:12:01,140
So one way of doing this is by introspecting

1413
01:12:01,140 --> 01:12:02,620
the GraphQL request.

1414
01:12:02,620 --> 01:12:04,740
So let's see.

1415
01:12:04,740 --> 01:12:06,740
Okay, I do have an example here.

1416
01:12:06,740 --> 01:12:10,100
So in Subway, you can pass an additional parameter

1417
01:12:10,100 --> 01:12:15,100
to the resolver, which is called info.

1418
01:12:16,980 --> 01:12:20,180
And this parameter is basically similar to the request

1419
01:12:20,180 --> 01:12:23,740
in Django or Fast API.

1420
01:12:23,740 --> 01:12:25,260
And it basically gives you all the information

1421
01:12:25,260 --> 01:12:28,140
of this GraphQL query.

1422
01:12:28,140 --> 01:12:30,780
So you can see an example of this here.

1423
01:12:30,780 --> 01:12:33,180
So if I pass info here, I need to import.

1424
01:12:40,100 --> 01:12:40,940
Okay.

1425
01:12:41,900 --> 01:12:43,660
This is not important for now.

1426
01:12:48,460 --> 01:12:50,260
I need to put this before.

1427
01:12:59,180 --> 01:13:00,580
So now when I do this request,

1428
01:13:00,580 --> 01:13:05,580
I'm also gonna print this object, which is here.

1429
01:13:05,580 --> 01:13:07,220
It's a bit hard to read, but it basically has

1430
01:13:07,220 --> 01:13:08,660
all the information about this request.

1431
01:13:08,660 --> 01:13:11,260
So it does something that's very important,

1432
01:13:11,260 --> 01:13:13,540
which we're gonna use when we do the authentication,

1433
01:13:13,540 --> 01:13:17,980
which is the context, which allows us to get the request.

1434
01:13:17,980 --> 01:13:20,700
And using requests, we can also get the current user.

1435
01:13:21,540 --> 01:13:24,380
It has, let me see what else.

1436
01:13:24,380 --> 01:13:26,180
It has the current schema if you need to.

1437
01:13:26,180 --> 01:13:29,820
But the most important thing for optimization,

1438
01:13:29,820 --> 01:13:34,820
if you wanna do that, is the selected fields.

1439
01:13:35,540 --> 01:13:38,620
To have an example here, it's a bit easier to read.

1440
01:13:39,620 --> 01:13:41,420
So it allows you to basically see all the fields

1441
01:13:41,420 --> 01:13:44,220
that have been requested in this GraphQL API,

1442
01:13:44,220 --> 01:13:46,380
sorry, in this API call.

1443
01:13:46,380 --> 01:13:49,580
Let me, maybe I can print them.

1444
01:13:59,260 --> 01:14:01,740
Okay, I'm gonna try again.

1445
01:14:01,740 --> 01:14:03,260
And hopefully, we're gonna see.

1446
01:14:04,420 --> 01:14:05,260
There we go.

1447
01:14:06,220 --> 01:14:08,660
And this is not, the way I'm printing it,

1448
01:14:08,660 --> 01:14:10,340
it's not super useful, but basically,

1449
01:14:10,340 --> 01:14:11,700
you can see that we fetching title,

1450
01:14:11,700 --> 01:14:13,140
and we fetching podcast.

1451
01:14:13,140 --> 01:14:18,140
So in this resolver, we can see that we fetching the title

1452
01:14:19,140 --> 01:14:20,100
and the podcast.

1453
01:14:20,100 --> 01:14:22,420
So this gives a lot of information to us,

1454
01:14:22,420 --> 01:14:24,700
to the optimization, because I can say,

1455
01:14:24,700 --> 01:14:25,780
oh, I'm fetching the podcast,

1456
01:14:25,780 --> 01:14:30,420
then I'm gonna do some additional optimizations.

1457
01:14:30,420 --> 01:14:32,300
So for example, I can fetch all the episodes

1458
01:14:32,300 --> 01:14:33,420
with the podcast with them.

1459
01:14:33,420 --> 01:14:35,860
So in Django, you could do select related on,

1460
01:14:35,860 --> 01:14:37,460
if you're not using Django, you can do a join

1461
01:14:37,460 --> 01:14:39,300
and things like that.

1462
01:14:44,380 --> 01:14:45,220
I mean, this works.

1463
01:14:45,220 --> 01:14:47,020
The only thing is that this is coupling, again,

1464
01:14:47,020 --> 01:14:48,860
your GraphQL API to your database.

1465
01:14:48,860 --> 01:14:51,260
So if you change the shape of your database,

1466
01:14:51,260 --> 01:14:55,620
you have to go and update this kind of code

1467
01:14:55,620 --> 01:14:58,820
that does the optimization, which is a bit annoying.

1468
01:14:58,820 --> 01:15:02,420
There is, if you're using Django specifically,

1469
01:15:02,420 --> 01:15:04,860
so there is a strawberry Django Plus,

1470
01:15:06,340 --> 01:15:10,100
which is done by the community, which has a optimizer,

1471
01:15:10,100 --> 01:15:11,340
which does all of this for you.

1472
01:15:11,340 --> 01:15:13,740
So basically, you can add this extension,

1473
01:15:13,740 --> 01:15:15,100
then it's gonna do,

1474
01:15:18,460 --> 01:15:19,300
doesn't show the example,

1475
01:15:19,300 --> 01:15:23,060
it basically is gonna do all this optimization for you.

1476
01:15:23,060 --> 01:15:25,260
So it's gonna check what fields have been requested,

1477
01:15:25,260 --> 01:15:27,900
and then it's gonna fetch those

1478
01:15:27,900 --> 01:15:31,180
with a single database code with Django,

1479
01:15:31,180 --> 01:15:34,340
or it's gonna optimize it, like, yeah, here we go.

1480
01:15:34,340 --> 01:15:36,100
For example, it's gonna do prefetch related,

1481
01:15:36,100 --> 01:15:39,700
and in some cases, select related as well,

1482
01:15:39,700 --> 01:15:40,540
which is quite neat.

1483
01:15:40,540 --> 01:15:42,260
But again, this only works if you're using Django

1484
01:15:42,260 --> 01:15:45,260
and Django models, or it can be implemented

1485
01:15:45,260 --> 01:15:48,780
for other databases, but it's not the best way

1486
01:15:48,780 --> 01:15:52,820
of doing this kind of optimization in GraphQL.

1487
01:15:55,260 --> 01:15:58,760
So we're gonna see what's actually better than this.

1488
01:15:59,680 --> 01:16:03,320
Oh, not better, like, more GraphQL native again.

1489
01:16:04,240 --> 01:16:05,400
And it's data loaders.

1490
01:16:05,400 --> 01:16:07,960
So data loaders are a generic way

1491
01:16:07,960 --> 01:16:10,920
to do optimized data fetching in GraphQL,

1492
01:16:10,920 --> 01:16:13,720
but they can also be used without GraphQL, to be honest.

1493
01:16:15,240 --> 01:16:16,440
Let's see, okay.

1494
01:16:16,440 --> 01:16:19,160
So the way this works is that you create a data loader,

1495
01:16:19,160 --> 01:16:22,680
which is a class that knows how to fetch something

1496
01:16:22,680 --> 01:16:27,240
from a database, and basically, this class needs to know

1497
01:16:27,320 --> 01:16:29,920
how to fetch something from a database in a batched way.

1498
01:16:29,920 --> 01:16:31,920
So instead of fetching one item,

1499
01:16:31,920 --> 01:16:34,260
you fetch two, three at a time.

1500
01:16:35,200 --> 01:16:37,360
Let's actually see that in a moment.

1501
01:16:37,360 --> 01:16:38,200
Here we go.

1502
01:16:40,080 --> 01:16:41,720
Yeah, let's do this.

1503
01:16:50,440 --> 01:16:52,960
Okay, so the first thing you need for a data loader

1504
01:16:52,960 --> 01:16:55,820
is to basically create a loader function

1505
01:16:55,820 --> 01:16:58,340
that you then pass to the data loaders.

1506
01:16:58,340 --> 01:17:03,340
So in this case, we already have a Django wrapper function

1507
01:17:03,820 --> 01:17:06,860
that allows to fetch a list of podcasts by this.

1508
01:17:06,860 --> 01:17:10,100
So we're just using id in, so it's doing select

1509
01:17:10,100 --> 01:17:11,860
where id is in this list.

1510
01:17:12,700 --> 01:17:14,480
And then what we're doing here,

1511
01:17:14,480 --> 01:17:19,480
we're just returning a list of podcasts by id

1512
01:17:19,700 --> 01:17:22,960
in the same order of the id that we're getting back from,

1513
01:17:22,960 --> 01:17:24,080
but that we requested.

1514
01:17:24,080 --> 01:17:28,040
So for example, if I'm getting, if I'm doing this,

1515
01:17:29,520 --> 01:17:34,520
so three, I'm gonna receive something like object one,

1516
01:17:40,000 --> 01:17:41,420
object two, and so on.

1517
01:17:42,400 --> 01:17:44,880
The order is quite important.

1518
01:17:44,880 --> 01:17:47,280
I think we might change this API to allow you

1519
01:17:47,280 --> 01:17:49,680
to return dictionary directly,

1520
01:17:49,680 --> 01:17:52,900
but the reason why I did this is sometimes Django,

1521
01:17:52,900 --> 01:17:55,740
even if you're passing a list of id's,

1522
01:17:55,740 --> 01:17:57,580
it might return a different order

1523
01:17:57,580 --> 01:17:59,580
as you need to make sure that you're returning

1524
01:17:59,580 --> 01:18:00,420
the same order.

1525
01:18:00,420 --> 01:18:02,600
So this id need to match this id here.

1526
01:18:03,560 --> 01:18:04,560
But yeah, basically this is a way

1527
01:18:04,560 --> 01:18:07,640
to fetch multiple items in one go.

1528
01:18:08,600 --> 01:18:12,200
Okay, and then we create a podcast data loader,

1529
01:18:12,200 --> 01:18:16,020
which is this, passing the function

1530
01:18:16,020 --> 01:18:18,980
to load a list of podcasts by this.

1531
01:18:18,980 --> 01:18:20,560
And that's pretty much it.

1532
01:18:20,560 --> 01:18:24,280
This is pretty much the API of using data loader.

1533
01:18:24,280 --> 01:18:25,440
So you create a function that allows

1534
01:18:25,440 --> 01:18:27,480
to fetch a batch of items,

1535
01:18:27,480 --> 01:18:30,160
and then you create a data loader for that batch.

1536
01:18:31,120 --> 01:18:33,820
And then the way you use it is to,

1537
01:18:36,880 --> 01:18:38,620
changing all the code in the,

1538
01:18:39,720 --> 01:18:41,760
in your resolver to use the podcast loader

1539
01:18:41,760 --> 01:18:44,200
instead of what we had before.

1540
01:18:47,000 --> 01:18:48,060
Just gonna run this.

1541
01:18:51,360 --> 01:18:55,840
So inside our episode here,

1542
01:18:55,840 --> 01:18:58,720
instead of doing this fetch one database directly,

1543
01:18:58,720 --> 01:19:00,500
we use the data loader here.

1544
01:19:03,720 --> 01:19:05,040
This might be enough.

1545
01:19:11,800 --> 01:19:13,680
So now double check one thing here.

1546
01:19:15,800 --> 01:19:16,640
Yeah.

1547
01:19:17,800 --> 01:19:19,920
I forgot to mention, we also doing the conversion

1548
01:19:19,920 --> 01:19:24,920
from the Django database to the GraphQL type directly here.

1549
01:19:24,920 --> 01:19:26,760
So we don't have to do externally.

1550
01:19:28,480 --> 01:19:30,320
Yeah, basically this is it.

1551
01:19:30,320 --> 01:19:32,000
The reason why I'm doing the import here

1552
01:19:32,000 --> 01:19:34,040
is to prevent circling ports.

1553
01:19:34,040 --> 01:19:36,200
There's also other ways of doing this,

1554
01:19:36,200 --> 01:19:40,160
but this is the fastest way for this workshop.

1555
01:19:42,240 --> 01:19:44,760
Yeah, and it's basically, by doing this,

1556
01:19:44,760 --> 01:19:47,540
we resolve the M plus one problem.

1557
01:19:48,540 --> 01:19:50,700
We're gonna be doing two queries,

1558
01:19:50,700 --> 01:19:52,220
one to fetch the episodes

1559
01:19:52,220 --> 01:19:55,420
and one to fetch all the podcasts by the end.

1560
01:19:55,420 --> 01:19:56,980
That's it.

1561
01:19:56,980 --> 01:20:00,300
So you can see here, first query fetching all the episodes

1562
01:20:00,300 --> 01:20:04,040
and then I'm fetching all the podcasts with those IDs.

1563
01:20:06,260 --> 01:20:08,220
And the way this works,

1564
01:20:08,220 --> 01:20:10,980
and the reason why we're using async

1565
01:20:11,860 --> 01:20:15,380
is basically the inside data loader.

1566
01:20:15,420 --> 01:20:16,500
The code is a bit complex,

1567
01:20:16,500 --> 01:20:21,500
but basically there is a function that creates a batch

1568
01:20:22,020 --> 01:20:24,660
and then it dispatches the batch into the next event loop.

1569
01:20:24,660 --> 01:20:27,700
So the way the Python, as it works, there is an event loop

1570
01:20:27,700 --> 01:20:32,700
and then you can say run this code in the next event loop.

1571
01:20:32,740 --> 01:20:35,940
And so this gives enough time to the server

1572
01:20:35,940 --> 01:20:39,340
and Python to basically say fetch this,

1573
01:20:39,340 --> 01:20:42,180
but do it just later, just a bit later.

1574
01:20:42,180 --> 01:20:46,460
So it allows you to basically get all these IDs.

1575
01:20:46,460 --> 01:20:48,700
So these resolvers are gonna be called ones

1576
01:20:48,700 --> 01:20:50,020
for every episode,

1577
01:20:50,020 --> 01:20:52,620
then it's gonna put them into the next batch

1578
01:20:52,620 --> 01:20:54,940
and then when the next event loop runs,

1579
01:20:54,940 --> 01:20:56,740
it's gonna fetch all of them in ones.

1580
01:20:58,060 --> 01:21:03,060
Which is a quite neat API and it basically does,

1581
01:21:03,080 --> 01:21:05,480
in terms of the code, it's just this in Python.

1582
01:21:05,480 --> 01:21:08,780
So it just get this class and does everything for you.

1583
01:21:08,780 --> 01:21:12,580
There's also some checks and it allows you also

1584
01:21:12,580 --> 01:21:15,580
to use a cache, for example, with Redis, I think.

1585
01:21:18,740 --> 01:21:20,740
Yeah, so you can create a cache.

1586
01:21:20,740 --> 01:21:23,740
But if instead of saving this data in memory,

1587
01:21:23,740 --> 01:21:26,220
you wanna save on Redis, you can also do that.

1588
01:21:26,220 --> 01:21:28,700
You can customize it and it's quite a nice API

1589
01:21:28,700 --> 01:21:30,380
and it's quite easy to use.

1590
01:21:31,460 --> 01:21:34,180
And it also allows you to prevent

1591
01:21:34,180 --> 01:21:35,900
from fetching too much data at once.

1592
01:21:35,900 --> 01:21:37,440
So for example, if you, I don't know,

1593
01:21:37,440 --> 01:21:38,600
fetching a thousand items,

1594
01:21:38,600 --> 01:21:42,480
instead of doing one SQL call for a thousand IDs,

1595
01:21:42,480 --> 01:21:47,480
you can do, I don't know, 10 for 100 IDs at a time.

1596
01:21:47,560 --> 01:21:49,140
So you can also batch them.

1597
01:21:51,800 --> 01:21:53,920
Yeah, again, this is something that's built into strawberry

1598
01:21:53,920 --> 01:21:57,360
and the theme here is to reduce the amount of code

1599
01:21:57,360 --> 01:22:00,360
you have to write to make all this kind of optimization.

1600
01:22:02,640 --> 01:22:06,680
And yeah, there is also a very nice blog post about this,

1601
01:22:06,720 --> 01:22:08,920
which is a bit, it goes a bit more in depth

1602
01:22:08,920 --> 01:22:13,360
into how to explain also as like a nice graphics.

1603
01:22:13,360 --> 01:22:15,480
It kind of makes it more easy to understand

1604
01:22:15,480 --> 01:22:17,520
what's actually happening here.

1605
01:22:17,520 --> 01:22:20,400
So you can see, for example, like these are the resolvers

1606
01:22:20,400 --> 01:22:22,320
and they're called one at a time.

1607
01:22:23,680 --> 01:22:27,680
And so like you can see how the optimization works.

1608
01:22:29,440 --> 01:22:32,160
Yeah, do you have any questions about this?

1609
01:22:33,480 --> 01:22:35,080
Could I give you a second?

1610
01:22:36,800 --> 01:22:37,640
Okay.

1611
01:22:51,400 --> 01:22:55,760
So this is, I haven't put anything about

1612
01:22:55,760 --> 01:22:58,640
other kinds of optimization here,

1613
01:22:58,640 --> 01:23:01,160
but this is optimization about how you fetch data

1614
01:23:01,160 --> 01:23:04,840
in GraphQL, so like if you're using SQL database

1615
01:23:05,640 --> 01:23:08,720
or an external API as well,

1616
01:23:08,720 --> 01:23:10,400
like one cool thing of data loaders

1617
01:23:10,400 --> 01:23:11,640
that this works with anything.

1618
01:23:11,640 --> 01:23:15,000
It doesn't have to be a SQL database.

1619
01:23:15,000 --> 01:23:15,840
It could be NoSQL.

1620
01:23:15,840 --> 01:23:20,120
It can also be a CPAPI as long as it supports batching

1621
01:23:20,120 --> 01:23:25,120
or yeah, basically it's a very nice API

1622
01:23:25,280 --> 01:23:28,760
that makes it generic to optimize things.

1623
01:23:28,760 --> 01:23:30,960
Like for example, if we could change this to,

1624
01:23:31,560 --> 01:23:35,000
yeah, this function could also do ACP calls

1625
01:23:35,000 --> 01:23:37,120
and I think it's quite nice that you're able

1626
01:23:37,120 --> 01:23:39,920
to do this kind of optimization in GraphQL.

1627
01:23:43,480 --> 01:23:44,960
And again, we might change this API

1628
01:23:44,960 --> 01:23:48,240
to just return a dictionary or allow you to return

1629
01:23:48,240 --> 01:23:51,080
a dictionary instead of a list to make it be nicer to use.

1630
01:23:51,080 --> 01:23:53,880
It's been requested, but I never had the time to do that.

1631
01:23:55,400 --> 01:23:56,800
Yeah.

1632
01:23:56,800 --> 01:23:59,680
And again, this is the reason,

1633
01:23:59,680 --> 01:24:02,520
the only reason why we're using async is because of this,

1634
01:24:03,440 --> 01:24:05,080
but this async is also very useful

1635
01:24:05,080 --> 01:24:08,760
if you're doing ACP calls like to external APIs,

1636
01:24:08,760 --> 01:24:10,040
like it's quite common in GraphQL

1637
01:24:10,040 --> 01:24:13,240
to basically create a GraphQL API that wraps REST APIs

1638
01:24:13,240 --> 01:24:14,680
or other kind of APIs.

1639
01:24:14,680 --> 01:24:17,440
And so async would be quite beneficial there

1640
01:24:17,440 --> 01:24:20,040
because it allows you to run multiple requests

1641
01:24:20,040 --> 01:24:24,360
in parallel as well and also batch them.

1642
01:24:24,360 --> 01:24:27,280
There is some work done for also allowing some of this

1643
01:24:27,280 --> 01:24:28,520
in a sync context.

1644
01:24:30,520 --> 01:24:33,120
But there is an external project,

1645
01:24:33,120 --> 01:24:35,720
but I don't know if it's stable yet.

1646
01:24:35,720 --> 01:24:37,960
So if you wanna check that,

1647
01:24:37,960 --> 01:24:39,640
there's also a way to do it in sync,

1648
01:24:39,640 --> 01:24:43,560
but that basically changes the execution of store-bary.

1649
01:24:43,560 --> 01:24:46,000
So there is more code involved,

1650
01:24:46,000 --> 01:24:48,520
which might have some issues in future.

1651
01:24:50,280 --> 01:24:51,120
Cool.

1652
01:24:51,120 --> 01:24:53,440
Oh, we're doing quite well on time actually.

1653
01:24:53,440 --> 01:24:57,560
So the next step, we're gonna see authentication.

1654
01:24:57,560 --> 01:25:00,320
We're also gonna see mutations.

1655
01:25:00,320 --> 01:25:04,680
So it's a way to do anything with side effects

1656
01:25:04,680 --> 01:25:08,160
like deleting data or even sending an email for that matter.

1657
01:25:10,600 --> 01:25:13,480
So in terms of authentication,

1658
01:25:13,480 --> 01:25:15,680
again, this is nothing special of GraphQL.

1659
01:25:17,000 --> 01:25:19,960
GraphQL uses HTTP, so you can use API keys,

1660
01:25:19,960 --> 01:25:23,120
you can use JWT tokens or cookie-based authentication

1661
01:25:23,120 --> 01:25:25,360
or even basic authentication.

1662
01:25:25,360 --> 01:25:28,920
I usually do a cookie-based because I use Django

1663
01:25:28,920 --> 01:25:30,120
and that's built into Django,

1664
01:25:30,120 --> 01:25:32,560
so I don't have to worry too much about that.

1665
01:25:32,560 --> 01:25:34,480
But JWT is quite common.

1666
01:25:34,480 --> 01:25:37,200
And there's also third-party packages for a server

1667
01:25:37,200 --> 01:25:41,240
that allows you to do all the things that are necessary

1668
01:25:41,240 --> 01:25:45,160
for JWTs like refreshing token, getting tokens and so on.

1669
01:25:47,320 --> 01:25:48,160
Okay.

1670
01:25:48,560 --> 01:25:53,560
So yeah, mutations, I did mention this.

1671
01:25:56,120 --> 01:25:58,920
It's basically a way to run anything with side effect.

1672
01:25:58,920 --> 01:26:02,840
And the main difference is that instead of doing query

1673
01:26:02,840 --> 01:26:05,320
or not passing anything, you write mutation here,

1674
01:26:05,320 --> 01:26:07,240
then you can run a mutation like this.

1675
01:26:08,120 --> 01:26:10,080
When this case returns an error because it's not implemented.

1676
01:26:10,080 --> 01:26:15,080
But in terms of GraphQL, it's almost the same as a query,

1677
01:26:16,080 --> 01:26:17,280
but the semantic is different.

1678
01:26:17,280 --> 01:26:19,480
So one thing that's different is that basically

1679
01:26:19,480 --> 01:26:21,600
mutation means you're doing some side effects.

1680
01:26:21,600 --> 01:26:24,360
So this is something that should not be cast

1681
01:26:24,360 --> 01:26:25,880
or not tried more than once.

1682
01:26:26,800 --> 01:26:29,440
And also if you're running,

1683
01:26:29,440 --> 01:26:31,960
if you're doing multiple field selection

1684
01:26:31,960 --> 01:26:33,560
at the root level in a mutation,

1685
01:26:33,560 --> 01:26:36,040
so this is something that you can do in a query.

1686
01:26:36,040 --> 01:26:39,960
So you can fetch podcasts, you can fetch podcasts and so on.

1687
01:26:41,920 --> 01:26:44,400
This also works in mutation, but there is one key difference.

1688
01:26:44,400 --> 01:26:47,960
So this is gonna be run in parallel,

1689
01:26:47,960 --> 01:26:50,920
like concurrently in a query in this array.

1690
01:26:50,920 --> 01:26:53,880
So you're gonna run those two resolvers at the same time,

1691
01:26:55,000 --> 01:26:56,080
more or less.

1692
01:26:56,080 --> 01:26:58,720
In mutation, if you have multiple things,

1693
01:26:58,720 --> 01:27:01,880
like if you have mutation one or two,

1694
01:27:01,880 --> 01:27:03,280
they're gonna be sequential.

1695
01:27:04,480 --> 01:27:06,840
That's the main difference between query mutation

1696
01:27:06,840 --> 01:27:08,960
in terms of the execution step.

1697
01:27:08,960 --> 01:27:11,640
And this is done so that if there's an error here,

1698
01:27:11,640 --> 01:27:13,240
the other mutation doesn't run.

1699
01:27:15,320 --> 01:27:17,000
But that's basically it.

1700
01:27:17,000 --> 01:27:19,080
And if you're using get,

1701
01:27:19,080 --> 01:27:22,080
so if you, don't know if this actually works on me,

1702
01:27:22,080 --> 01:27:23,600
let me show an example of this.

1703
01:27:29,440 --> 01:27:31,160
So again, I mentioned I can,

1704
01:27:32,120 --> 01:27:34,200
in most graphical implementation,

1705
01:27:34,200 --> 01:27:37,240
you can also do queries like this,

1706
01:27:38,600 --> 01:27:39,720
like via get.

1707
01:27:39,720 --> 01:27:43,120
You cannot do this in for mutation,

1708
01:27:43,120 --> 01:27:47,480
because again, you don't wanna run mutation in a get.

1709
01:27:48,720 --> 01:27:51,840
If I try to do this, it's gonna deny,

1710
01:27:51,840 --> 01:27:53,240
it's gonna not allow it.

1711
01:27:53,240 --> 01:27:55,400
So you cannot run mutation using get.

1712
01:27:55,400 --> 01:27:57,440
This is also the other thing, a mutation.

1713
01:27:57,440 --> 01:27:59,280
It's just, there's some safety check

1714
01:27:59,280 --> 01:28:02,600
that doesn't allow you to do mutations using get.

1715
01:28:04,600 --> 01:28:06,120
That's quite nice.

1716
01:28:06,120 --> 01:28:09,600
Okay, so we are going to do a mutation

1717
01:28:09,600 --> 01:28:12,680
for logging in a user.

1718
01:28:13,360 --> 01:28:15,040
Again, we're gonna use most of the things

1719
01:28:15,040 --> 01:28:15,880
that are built by Django.

1720
01:28:15,880 --> 01:28:18,680
So our mutation is gonna be pretty simple.

1721
01:28:18,680 --> 01:28:21,600
But the way it works, it's basically the same as a query.

1722
01:28:21,600 --> 01:28:24,160
So you create a type, and then you create resolvers

1723
01:28:24,160 --> 01:28:26,240
for the fields in that type.

1724
01:28:27,240 --> 01:28:30,480
So, okay, we, I'm just gonna copy this,

1725
01:28:30,480 --> 01:28:33,480
and I'm gonna go through every single line here.

1726
01:28:33,480 --> 01:28:35,880
So if I go to authentication, mutation.

1727
01:28:39,400 --> 01:28:41,400
Well, I did copy this a couple times, okay.

1728
01:28:43,360 --> 01:28:45,320
Yeah, we're importing strawberry,

1729
01:28:45,320 --> 01:28:46,560
importing this info type.

1730
01:28:46,560 --> 01:28:49,280
So this is, again, I mentioned this earlier.

1731
01:28:49,280 --> 01:28:53,280
This is important for, allows us to fetch the request

1732
01:28:54,320 --> 01:28:56,200
from strawberry.

1733
01:28:56,200 --> 01:28:58,200
And then we have a class called context.

1734
01:28:59,320 --> 01:29:03,440
Info is a generic type, and in info, there is a context,

1735
01:29:03,440 --> 01:29:05,440
which it's what holds the request.

1736
01:29:05,440 --> 01:29:08,520
So if I go here, this is a type dictionary,

1737
01:29:08,520 --> 01:29:09,960
which has a request and response.

1738
01:29:09,960 --> 01:29:12,880
So I can use this to get the user,

1739
01:29:13,600 --> 01:29:15,080
and I can also use this to change the status code,

1740
01:29:15,080 --> 01:29:15,920
for example.

1741
01:29:17,920 --> 01:29:20,720
And then I have a function called authenticate the login,

1742
01:29:22,000 --> 01:29:25,840
which basically gets a request, email and password,

1743
01:29:25,840 --> 01:29:30,840
and then it runs the authentication on Django,

1744
01:29:31,080 --> 01:29:33,000
and it's doing the conversion from sync to sync

1745
01:29:33,000 --> 01:29:35,000
to prevent any issue with the database.

1746
01:29:36,080 --> 01:29:36,920
What else?

1747
01:29:38,440 --> 01:29:41,280
Yeah, oh, then I have a type called login payload.

1748
01:29:41,320 --> 01:29:44,440
This is basically the return type of my login mutation.

1749
01:29:45,280 --> 01:29:50,000
And then I have the, this is the old mutation I have.

1750
01:29:50,000 --> 01:29:51,960
So I have a class, which is like query,

1751
01:29:53,200 --> 01:29:56,760
which basically holds all the fields of this mutation.

1752
01:29:56,760 --> 01:29:58,800
It's one field called login,

1753
01:29:58,800 --> 01:30:02,120
which has the info parameter.

1754
01:30:02,120 --> 01:30:04,680
This is passed automatically by strawberry,

1755
01:30:04,680 --> 01:30:07,920
and it's what we can use to get the request from the context.

1756
01:30:07,920 --> 01:30:10,720
And then the two parameters, email and password.

1757
01:30:11,000 --> 01:30:12,520
And then it returns login payload.

1758
01:30:12,520 --> 01:30:16,720
So we try to login, if the user is none, return false.

1759
01:30:16,720 --> 01:30:18,280
If it's not none, return true.

1760
01:30:20,760 --> 01:30:23,560
And let's actually go and try this now.

1761
01:30:25,160 --> 01:30:26,840
Oh yeah, one thing here,

1762
01:30:26,840 --> 01:30:28,560
usually we do sort of a field.

1763
01:30:28,560 --> 01:30:30,360
This case I'm doing mutation.

1764
01:30:30,360 --> 01:30:31,800
But if you go and see the implementation

1765
01:30:31,800 --> 01:30:34,360
is basically the same at the moment.

1766
01:30:34,360 --> 01:30:38,800
Like mutations are not different than field per se.

1767
01:30:38,800 --> 01:30:42,000
Like the only difference is the way they run,

1768
01:30:42,000 --> 01:30:44,840
but that depends on the fact that you're doing a mutation

1769
01:30:44,840 --> 01:30:48,440
and not the way you actually implemented it.

1770
01:30:49,560 --> 01:30:52,440
The reason why we have this as a field like this,

1771
01:30:52,440 --> 01:30:53,840
like as a alias,

1772
01:30:53,840 --> 01:30:56,840
is that in future we want to put like more safety guards.

1773
01:30:56,840 --> 01:31:01,840
If you're doing, if using a DOM mutation in a query,

1774
01:31:02,120 --> 01:31:03,720
we want to return an error

1775
01:31:03,720 --> 01:31:06,600
because that's something that doesn't make sense.

1776
01:31:06,600 --> 01:31:10,120
Just to make it a bit easier to prevent mistakes.

1777
01:31:11,160 --> 01:31:13,000
Okay, so now I created this.

1778
01:31:13,000 --> 01:31:15,800
I don't have any users, so this is gonna return false.

1779
01:31:16,720 --> 01:31:19,920
But oh yeah, if I try to do login here,

1780
01:31:19,920 --> 01:31:22,160
it doesn't work because I need to do a mutation.

1781
01:31:22,160 --> 01:31:23,560
So I do a mutation.

1782
01:31:25,000 --> 01:31:26,800
And I do email.

1783
01:31:26,800 --> 01:31:28,000
Just gonna use my email.

1784
01:31:32,960 --> 01:31:33,800
Password.

1785
01:31:37,040 --> 01:31:38,200
And then I'm gonna fetch the field,

1786
01:31:38,200 --> 01:31:40,560
which is there's only one field, it's called okay.

1787
01:31:42,440 --> 01:31:44,440
Oh no, I do have a user, okay.

1788
01:31:44,440 --> 01:31:46,320
I think I created this a while ago.

1789
01:31:47,920 --> 01:31:51,560
Yeah, basically once I do this, I'm logged in.

1790
01:31:51,560 --> 01:31:54,280
And I'm gonna show you what's actually happening here.

1791
01:31:54,280 --> 01:31:57,080
Like this doesn't really give you much information

1792
01:31:57,080 --> 01:32:00,440
because it's just saying everything is fine.

1793
01:32:00,440 --> 01:32:03,680
But when I do this here,

1794
01:32:03,680 --> 01:32:08,520
in my response headers, there's gonna be a set cookie

1795
01:32:08,520 --> 01:32:12,480
and also set cookie for the CRF token

1796
01:32:12,480 --> 01:32:14,080
and one for the session ID.

1797
01:32:14,080 --> 01:32:16,480
So this is basically what it's logging me in.

1798
01:32:16,480 --> 01:32:17,600
This is done by Django.

1799
01:32:17,600 --> 01:32:21,120
So the function that's called authenticate and login,

1800
01:32:21,120 --> 01:32:23,880
this one is gonna use this authenticate function

1801
01:32:23,880 --> 01:32:28,240
which is gonna create the cookie for us

1802
01:32:28,240 --> 01:32:29,080
based on the backend.

1803
01:32:29,080 --> 01:32:30,480
But the default one is the session one,

1804
01:32:30,480 --> 01:32:31,600
which is this cookie.

1805
01:32:32,600 --> 01:32:34,280
And now every time I do another request,

1806
01:32:34,280 --> 01:32:35,680
I'm gonna be logged in.

1807
01:32:36,840 --> 01:32:39,240
And if I do, for example, if I change the password

1808
01:32:39,240 --> 01:32:41,480
and it's wrong, I'm gonna receive false

1809
01:32:41,480 --> 01:32:44,480
and I'm not gonna get that set cookie.

1810
01:32:48,080 --> 01:32:50,520
Sorry, response headers, there's no set cookie here.

1811
01:32:50,520 --> 01:32:53,040
Sorry, because I didn't get logged in.

1812
01:32:54,200 --> 01:32:55,240
Does that make sense?

1813
01:32:55,480 --> 01:33:00,480
So the, just maybe for reference for the future,

1814
01:33:01,560 --> 01:33:05,920
like if you're doing JWT,

1815
01:33:05,920 --> 01:33:07,840
like for the standard basic implementation,

1816
01:33:07,840 --> 01:33:09,440
it will be similar to this,

1817
01:33:09,440 --> 01:33:12,200
but you might either get a token like this here

1818
01:33:12,200 --> 01:33:13,920
or you can still use cookies.

1819
01:33:13,920 --> 01:33:15,720
With JWT, you can also use cookies,

1820
01:33:15,720 --> 01:33:19,680
which is like another way to transport them.

1821
01:33:21,040 --> 01:33:24,360
Yeah, there's many ways of doing authentication,

1822
01:33:24,360 --> 01:33:25,200
which is a bit annoying.

1823
01:33:25,200 --> 01:33:27,760
So this is why I stick to cookie authentication.

1824
01:33:27,760 --> 01:33:31,360
It's just, almost everything is handled by us

1825
01:33:31,360 --> 01:33:36,120
for a Django or FastAPI libraries.

1826
01:33:37,600 --> 01:33:40,540
Okay, so we've done this.

1827
01:33:42,320 --> 01:33:45,040
Okay, I already created a user for you.

1828
01:33:45,040 --> 01:33:47,680
So we can, we already did this.

1829
01:33:47,680 --> 01:33:51,420
So we tested everything and we also got the cookie.

1830
01:33:51,780 --> 01:33:56,780
So now we also wanna do something with the user.

1831
01:33:59,420 --> 01:34:02,940
So we wanna check if the user is authenticated for,

1832
01:34:02,940 --> 01:34:05,580
for example, preventing non-authenticated user

1833
01:34:05,580 --> 01:34:09,980
to the mutation or wanna allow only user,

1834
01:34:09,980 --> 01:34:12,140
specific user to the mutation.

1835
01:34:12,140 --> 01:34:13,720
For example, if you wanna maybe check

1836
01:34:13,720 --> 01:34:14,900
if they're subscribed or not,

1837
01:34:14,900 --> 01:34:18,380
we can prevent them to do something.

1838
01:34:18,380 --> 01:34:19,380
In this case, I'm just gonna check

1839
01:34:19,460 --> 01:34:21,700
if they're authenticated to keep it simple.

1840
01:34:21,700 --> 01:34:26,700
So I created already a, is authenticated class here.

1841
01:34:27,660 --> 01:34:29,380
So Strawberry supports permissions

1842
01:34:29,380 --> 01:34:31,280
similar to Django REST framework.

1843
01:34:33,120 --> 01:34:37,260
And basically the way it works is that you can pass

1844
01:34:37,260 --> 01:34:40,260
a permission to a field and every time the field runs,

1845
01:34:41,260 --> 01:34:43,380
so it's gonna check for the permissions.

1846
01:34:43,380 --> 01:34:46,620
And if any of those permission return false,

1847
01:34:47,620 --> 01:34:51,980
then the server is gonna raise an error,

1848
01:34:51,980 --> 01:34:54,220
it's not gonna run the field.

1849
01:34:54,220 --> 01:34:56,440
So in this case, we're checking if there is a user,

1850
01:34:56,440 --> 01:35:00,680
if the user is authenticated, then we can get the field.

1851
01:35:03,180 --> 01:35:05,940
So let's actually go and implement this mutation here.

1852
01:35:05,940 --> 01:35:08,680
So this mutation is gonna subscribe me to a podcast.

1853
01:35:12,660 --> 01:35:14,940
Okay, so this is similar to what we had before,

1854
01:35:14,940 --> 01:35:17,460
we're using the info parameter to get the current user,

1855
01:35:17,460 --> 01:35:19,900
and we're getting the is authenticated permission,

1856
01:35:19,900 --> 01:35:22,700
and then we're using the permission inside

1857
01:35:22,700 --> 01:35:24,960
the permission classes mutation.

1858
01:35:26,100 --> 01:35:28,860
And this is basically allowing us to make sure

1859
01:35:28,860 --> 01:35:33,020
that this mutation only runs if there is a user logged in.

1860
01:35:33,020 --> 01:35:35,840
In this case, we could even remove it

1861
01:35:35,840 --> 01:35:38,620
because otherwise the user would be none,

1862
01:35:38,620 --> 01:35:39,880
so we could do a check there,

1863
01:35:39,880 --> 01:35:43,060
but you can see this having, I don't know,

1864
01:35:43,060 --> 01:35:46,020
this premium user, for example, something like that.

1865
01:35:46,020 --> 01:35:47,700
So you can make this authentication,

1866
01:35:47,700 --> 01:35:50,240
like these permissions as custom as you want.

1867
01:35:51,860 --> 01:35:52,760
And just one note here,

1868
01:35:52,760 --> 01:35:56,020
we might change these permissions a bit in future

1869
01:35:56,020 --> 01:36:00,500
to be more flexible because for example,

1870
01:36:00,500 --> 01:36:04,020
at the moment you cannot do like all conditions

1871
01:36:04,020 --> 01:36:06,820
inside the authentication, sorry, inside the permissions.

1872
01:36:06,820 --> 01:36:08,260
So for example, if you wanted to do something

1873
01:36:08,260 --> 01:36:12,180
like is authenticated or is something,

1874
01:36:13,900 --> 01:36:15,460
this is not possible at the moment.

1875
01:36:15,460 --> 01:36:17,940
We want to implement that at some point in future,

1876
01:36:17,940 --> 01:36:20,100
and we might also get rid of the underscore classes,

1877
01:36:20,100 --> 01:36:21,320
so we can just do this,

1878
01:36:22,300 --> 01:36:26,300
but that hopefully is gonna come sooner rather than later.

1879
01:36:26,300 --> 01:36:28,660
But yeah, basically we checked this,

1880
01:36:28,660 --> 01:36:33,660
so we now are sure that every time this mutation runs,

1881
01:36:33,660 --> 01:36:35,740
it's only gonna run if there is a user.

1882
01:36:35,740 --> 01:36:38,660
And then we can do all the things that we did before,

1883
01:36:38,660 --> 01:36:42,420
so we can get requests, we can get the podcasts by ID,

1884
01:36:42,420 --> 01:36:44,500
if there is no podcasts return false,

1885
01:36:45,620 --> 01:36:48,980
and then we get the user and then we subscribe to user.

1886
01:36:48,980 --> 01:36:50,960
And if there is an error, return false.

1887
01:36:53,380 --> 01:36:55,340
Let me, let's actually try that.

1888
01:36:57,820 --> 01:36:59,820
Reputation, subscribe.

1889
01:37:01,780 --> 01:37:03,020
I need to refresh this.

1890
01:37:03,020 --> 01:37:03,860
Okay.

1891
01:37:10,460 --> 01:37:12,220
Need to get one ID from.

1892
01:37:21,020 --> 01:37:21,860
Okay, this one.

1893
01:37:24,980 --> 01:37:27,420
So now this mutation is a very basic mutation,

1894
01:37:27,420 --> 01:37:29,220
only returns true or false,

1895
01:37:29,220 --> 01:37:31,100
it makes it be harder to read.

1896
01:37:31,100 --> 01:37:32,660
So in this case, it returns false,

1897
01:37:33,300 --> 01:37:35,700
it means I'm already subscribed to something went wrong.

1898
01:37:35,700 --> 01:37:40,420
But if I try to run this, for example, in Neutro,

1899
01:37:40,420 --> 01:37:45,420
so if I create a new browser,

1900
01:37:45,420 --> 01:37:48,540
if I try to run the mutation, I should get an error.

1901
01:37:48,540 --> 01:37:52,260
So this is how you get errors using permissions,

1902
01:37:52,260 --> 01:37:56,300
which is maybe one thing we wanna make it easier to change,

1903
01:37:56,300 --> 01:37:58,660
but basically you get an error into the error response

1904
01:37:58,660 --> 01:38:00,820
and saying user is not authenticated,

1905
01:38:00,820 --> 01:38:03,420
because again, I'm not authenticated in this case.

1906
01:38:06,500 --> 01:38:09,380
But yeah, that's, let me see.

1907
01:38:13,980 --> 01:38:15,140
So that's pretty much it,

1908
01:38:15,140 --> 01:38:18,300
like it's one line to make sure that you are authenticated,

1909
01:38:18,300 --> 01:38:20,340
you have some specific permissions,

1910
01:38:20,340 --> 01:38:22,100
which is, I think it's quite nice.

1911
01:38:23,180 --> 01:38:25,860
And again, this is implementation of the permission.

1912
01:38:25,860 --> 01:38:27,380
So you have all the information

1913
01:38:28,260 --> 01:38:31,900
that could be useful for you to do permissions.

1914
01:38:31,900 --> 01:38:34,620
Like for example, there's source, which is the root type.

1915
01:38:34,620 --> 01:38:37,700
So for example, if this were an asset field,

1916
01:38:37,700 --> 01:38:39,900
you could get the parent to check some more information

1917
01:38:39,900 --> 01:38:42,260
on the parent, for example, if the parent owner

1918
01:38:42,260 --> 01:38:44,540
is the current user, you can do something like that.

1919
01:38:44,540 --> 01:38:47,380
You also get the context, the info,

1920
01:38:47,380 --> 01:38:50,260
which allows you to get the current user from the context,

1921
01:38:50,260 --> 01:38:52,860
and also additional keyword arguments

1922
01:38:52,860 --> 01:38:54,540
for the specific field.

1923
01:38:55,340 --> 01:38:58,340
Again, this is inspired by Django REST framework,

1924
01:38:58,340 --> 01:39:00,300
and we might slightly change it a bit in future,

1925
01:39:00,300 --> 01:39:02,900
but it's not gonna change very much.

1926
01:39:06,620 --> 01:39:09,860
Yeah, so again, is there any question about this?

1927
01:39:09,860 --> 01:39:12,420
Because I wanted to show you something related to the error.

1928
01:39:12,420 --> 01:39:17,140
So like this, this mutation is a bad mutation.

1929
01:39:17,140 --> 01:39:19,220
This is not something you should do with GraphQL,

1930
01:39:19,220 --> 01:39:20,980
like returning true or false,

1931
01:39:20,980 --> 01:39:24,380
so that claim to imitation is not,

1932
01:39:27,020 --> 01:39:30,060
or it's not, I don't know, it's not a great developer

1933
01:39:30,060 --> 01:39:33,500
experience or user experience for two reasons.

1934
01:39:33,500 --> 01:39:35,500
One, this false is a bit generic,

1935
01:39:35,500 --> 01:39:38,340
it doesn't really give you a lot of meaning on what happened,

1936
01:39:38,340 --> 01:39:41,700
why did I get false, right?

1937
01:39:41,700 --> 01:39:43,820
Because it could be for multiple reasons.

1938
01:39:43,820 --> 01:39:46,100
Like it could be because the podcast does not exist,

1939
01:39:46,100 --> 01:39:48,780
it could be because I'm already subscribed,

1940
01:39:48,780 --> 01:39:50,580
and on top of that, I'm not really taking

1941
01:39:51,220 --> 01:39:53,500
a lot of advantages from GraphQL,

1942
01:39:53,500 --> 01:39:56,420
like when you're doing mutations or queries in general,

1943
01:39:56,420 --> 01:39:58,420
you should return like rich types,

1944
01:39:58,420 --> 01:40:01,980
so in this case, we could return a podcast,

1945
01:40:03,380 --> 01:40:06,260
so I can get also all the information back.

1946
01:40:06,260 --> 01:40:07,620
So for example, if I'm doing a mutation

1947
01:40:07,620 --> 01:40:10,660
that changes a podcast title,

1948
01:40:10,660 --> 01:40:14,420
I can make it so that it returns the actual podcast

1949
01:40:14,420 --> 01:40:16,860
with a new title, and so that I can use that title

1950
01:40:16,860 --> 01:40:19,860
to update the UI in my application.

1951
01:40:19,900 --> 01:40:21,180
And this is something that's actually handled

1952
01:40:21,180 --> 01:40:24,140
automatically by clients like Apollo client or Oracle.

1953
01:40:24,140 --> 01:40:26,580
Like if you're returning a type, sorry,

1954
01:40:26,580 --> 01:40:29,100
an object with a specific type and ID,

1955
01:40:29,100 --> 01:40:32,340
it's gonna update the cache and update all the pages

1956
01:40:32,340 --> 01:40:35,260
automatically in your client, which is quite nice.

1957
01:40:35,260 --> 01:40:37,780
But the main thing is not be able to understand

1958
01:40:37,780 --> 01:40:39,500
why, what this false means.

1959
01:40:41,700 --> 01:40:44,980
So we're gonna see how to handle errors a bit better.

1960
01:40:45,940 --> 01:40:49,900
And we've seen this, so we've seen an example

1961
01:40:49,900 --> 01:40:52,260
of using just like standard exceptions,

1962
01:40:52,260 --> 01:40:54,420
so returning, raising a value error,

1963
01:40:54,420 --> 01:40:57,660
and we get something like this in our GraphQL response,

1964
01:40:57,660 --> 01:41:01,620
which is okay, but it's not a great, great experience.

1965
01:41:01,620 --> 01:41:06,620
So like one strategy is to use something called union types.

1966
01:41:07,700 --> 01:41:10,220
And union types are basically a way to say

1967
01:41:10,220 --> 01:41:13,460
this field is gonna return not just one type,

1968
01:41:13,460 --> 01:41:16,020
but like to return two different types,

1969
01:41:16,020 --> 01:41:16,900
always one at a time.

1970
01:41:16,900 --> 01:41:18,860
So I'm gonna see that in a second.

1971
01:41:18,860 --> 01:41:22,900
So let's change this addition that we had before,

1972
01:41:22,900 --> 01:41:26,820
which is returning bold, to return different types

1973
01:41:26,820 --> 01:41:29,460
based on either the podcast does not exist

1974
01:41:29,460 --> 01:41:31,220
or the user is already subscribed.

1975
01:41:32,980 --> 01:41:37,100
I guess one takeaway of this is also like

1976
01:41:37,100 --> 01:41:40,220
there is two different types of errors in general

1977
01:41:41,060 --> 01:41:44,380
or is that expected errors and unexpected errors.

1978
01:41:44,380 --> 01:41:47,340
Expected errors are like this one that we just mentioned,

1979
01:41:47,340 --> 01:41:49,500
are errors that we know that can happen

1980
01:41:49,500 --> 01:41:52,340
and errors that might happen a lot

1981
01:41:52,340 --> 01:41:55,660
that you might want to show different UI to users.

1982
01:41:55,660 --> 01:41:58,140
For example, like the podcast does not exist

1983
01:41:58,140 --> 01:41:59,700
or the user is already subscribed.

1984
01:41:59,700 --> 01:42:01,220
It's a good example of that.

1985
01:42:01,220 --> 01:42:03,060
Unexpected errors, anything else,

1986
01:42:03,060 --> 01:42:04,940
like for example, database being down

1987
01:42:04,940 --> 01:42:08,740
or I don't know, something else like not going well

1988
01:42:08,740 --> 01:42:10,140
with this mutation.

1989
01:42:12,180 --> 01:42:15,060
The idea is that you always kind of take into account

1990
01:42:15,060 --> 01:42:16,860
all these expected errors or these errors

1991
01:42:16,860 --> 01:42:21,860
that you want to kind of present in a nicer way to your user

1992
01:42:21,940 --> 01:42:25,380
and then the unexpected errors you basically do,

1993
01:42:25,380 --> 01:42:27,140
you just leave them as it is,

1994
01:42:27,140 --> 01:42:28,540
like you return them like this

1995
01:42:28,540 --> 01:42:31,260
and then there's a generic message on your UI.

1996
01:42:33,700 --> 01:42:37,580
Yeah, so we mentioned that we're gonna handle errors

1997
01:42:37,620 --> 01:42:41,940
using union types and we have three cases.

1998
01:42:41,940 --> 01:42:44,900
So podcast does not exist, users are already subscribed,

1999
01:42:44,900 --> 01:42:47,820
everything went well and we're gonna model these three cases

2000
01:42:47,820 --> 01:42:49,420
using three different types.

2001
01:42:50,500 --> 01:42:53,020
The first one is gonna be a type called

2002
01:42:53,020 --> 01:42:56,820
podcast does not exist error, which has just a message

2003
01:42:56,820 --> 01:42:59,660
and then the second one is gonna be already subscribed

2004
01:42:59,660 --> 01:43:00,820
to podcast error.

2005
01:43:00,820 --> 01:43:02,460
They're very verbose but they make it very easy

2006
01:43:02,460 --> 01:43:04,340
to understand what happened

2007
01:43:04,340 --> 01:43:07,340
and then the last one is subscribe to podcast success

2008
01:43:08,100 --> 01:43:08,940
and it returns a podcast.

2009
01:43:10,580 --> 01:43:12,780
And then we're gonna use a union type.

2010
01:43:14,460 --> 01:43:16,260
Let's put those here.

2011
01:43:19,020 --> 01:43:22,100
So these three types are basically straightforward.

2012
01:43:22,100 --> 01:43:26,060
They're just like classes that have like a field each.

2013
01:43:26,060 --> 01:43:27,860
This type is a bit different,

2014
01:43:27,860 --> 01:43:30,060
it uses something that's not really Python

2015
01:43:30,060 --> 01:43:31,460
and we might change in future,

2016
01:43:31,460 --> 01:43:34,940
which is in server.union to create a union from this type.

2017
01:43:34,940 --> 01:43:39,500
This is actually equivalent of doing this,

2018
01:43:41,300 --> 01:43:42,940
which we might actually do now

2019
01:43:42,940 --> 01:43:45,500
because it's something I want to change in future.

2020
01:43:57,460 --> 01:44:00,940
So basically this is a union of these three types

2021
01:44:00,940 --> 01:44:02,380
and you can see here, I mean,

2022
01:44:02,940 --> 01:44:06,140
if you wanna use a variable of this type,

2023
01:44:06,140 --> 01:44:09,100
you need to check what type it is before.

2024
01:44:09,100 --> 01:44:12,100
So we're gonna do that as well in GaffiCode.

2025
01:44:14,420 --> 01:44:16,900
So I'm gonna actually put this in line,

2026
01:44:16,900 --> 01:44:19,740
maybe it's a bit nicer like this.

2027
01:44:19,740 --> 01:44:22,340
So here I'm saying that this subscribe to podcast

2028
01:44:22,340 --> 01:44:25,020
is returning one of these three types

2029
01:44:25,020 --> 01:44:27,700
and I'm already getting an error from my Python.

2030
01:44:27,700 --> 01:44:28,860
I need to change that.

2031
01:44:28,860 --> 01:44:31,060
Obviously when I'm using this on the client,

2032
01:44:31,900 --> 01:44:34,420
I need to basically tell,

2033
01:44:34,420 --> 01:44:37,620
I wanna fetch this field for this type and so on.

2034
01:44:38,980 --> 01:44:41,700
Gonna show you that in a second.

2035
01:44:41,700 --> 01:44:43,500
So if we don't have a podcast,

2036
01:44:43,500 --> 01:44:47,100
we return, podcast does not exist error.

2037
01:44:47,100 --> 01:44:49,220
If we, this is already subscribed,

2038
01:44:49,220 --> 01:44:50,460
we return already subscribed,

2039
01:44:50,460 --> 01:44:55,460
otherwise we return the subscribe to podcast success

2040
01:44:55,940 --> 01:44:58,260
with the podcast from database.

2041
01:44:59,260 --> 01:45:01,420
So let's see that now.

2042
01:45:01,420 --> 01:45:03,740
So let me do a fake podcast.

2043
01:45:03,740 --> 01:45:06,980
So if I, actually, if I refresh this,

2044
01:45:06,980 --> 01:45:08,980
if I refresh the schema, I'm gonna get already an error

2045
01:45:08,980 --> 01:45:10,820
because I need to fetch the subfields.

2046
01:45:14,660 --> 01:45:17,860
So, oh, when you do,

2047
01:45:20,020 --> 01:45:21,060
control space here,

2048
01:45:21,060 --> 01:45:23,060
you're gonna get the suggestion for this.

2049
01:45:23,060 --> 01:45:25,980
If I try to do a suggestion for subscribe to podcast,

2050
01:45:25,980 --> 01:45:28,420
I'm only gonna get type name.

2051
01:45:28,420 --> 01:45:33,420
And this is because this type returns a union type.

2052
01:45:34,940 --> 01:45:39,220
So when I try to fetch this, I get the type name,

2053
01:45:39,220 --> 01:45:40,620
but I'm not getting any other field

2054
01:45:40,620 --> 01:45:43,340
because in with unions in GraphQL,

2055
01:45:43,340 --> 01:45:46,100
there is a special syntax to basically say,

2056
01:45:46,100 --> 01:45:48,220
I wanna fetch this union, sorry,

2057
01:45:48,220 --> 01:45:50,140
I wanna fetch this field for this union.

2058
01:45:50,140 --> 01:45:52,940
And it's the, it's called fragment syntax.

2059
01:45:52,940 --> 01:45:56,140
So you can do triple dot on specific type.

2060
01:45:56,140 --> 01:45:58,020
So one of these three types,

2061
01:45:58,020 --> 01:46:01,740
for example, if there is the podcast does not exist error,

2062
01:46:01,740 --> 01:46:03,220
you can do message.

2063
01:46:04,580 --> 01:46:08,940
And we can do the same for ready subscribe.

2064
01:46:10,540 --> 01:46:13,580
And finally on success,

2065
01:46:14,500 --> 01:46:17,380
we can get the podcasts and maybe getting the,

2066
01:46:17,380 --> 01:46:18,580
and this could be,

2067
01:46:20,100 --> 01:46:22,660
we can also have maybe subscribers

2068
01:46:23,340 --> 01:46:25,220
and this could be useful to kind of get the updated value

2069
01:46:25,220 --> 01:46:27,500
of the subscribers, which I don't have now.

2070
01:46:27,500 --> 01:46:31,100
So when I run this, I'm gonna get the type name,

2071
01:46:31,100 --> 01:46:32,220
which I guess I could ignore it,

2072
01:46:32,220 --> 01:46:34,540
but it could be useful to kind of do a switch

2073
01:46:34,540 --> 01:46:35,820
in your clients.

2074
01:46:35,820 --> 01:46:38,180
And in this case, I'm gonna get the proper message.

2075
01:46:38,180 --> 01:46:40,060
So podcast does not exist.

2076
01:46:40,060 --> 01:46:42,180
If I try and put the right podcast,

2077
01:46:42,180 --> 01:46:45,220
I'm gonna get already subscribed to podcast.

2078
01:46:45,220 --> 01:46:47,820
And if I put the podcast I'm not subscribed,

2079
01:46:47,820 --> 01:46:50,020
I will get the podcast back.

2080
01:46:50,020 --> 01:46:54,420
And this is one of the nicest way of doing

2081
01:46:56,700 --> 01:46:57,820
error handling in GraphQL.

2082
01:46:57,820 --> 01:47:00,940
So basically you put the errors into the schema.

2083
01:47:00,940 --> 01:47:05,380
So basically giving your user a way to identify

2084
01:47:05,380 --> 01:47:09,100
what's happening in a specific mutation.

2085
01:47:09,100 --> 01:47:10,620
And when you go and see the docs,

2086
01:47:10,620 --> 01:47:14,860
you can see that subscribe to podcast has this type.

2087
01:47:16,020 --> 01:47:17,020
It's a Biver post,

2088
01:47:17,060 --> 01:47:20,740
but it's a union type of these three types.

2089
01:47:24,900 --> 01:47:25,740
Okay.

2090
01:47:26,900 --> 01:47:30,180
There's one thing that's been annoying on this though,

2091
01:47:30,180 --> 01:47:32,620
is the fact that we have basically the same selection

2092
01:47:32,620 --> 01:47:35,820
for these two fields, sorry, for these two types.

2093
01:47:35,820 --> 01:47:39,540
So there is a way to improve this using interfaces.

2094
01:47:39,540 --> 01:47:41,420
So I think I put it there.

2095
01:47:43,620 --> 01:47:44,460
Yeah.

2096
01:47:44,460 --> 01:47:49,460
So as I mentioned, these two types are basically the same.

2097
01:47:50,060 --> 01:47:53,580
So we can use an interface to basically model

2098
01:47:53,580 --> 01:47:58,580
like a generic error message.

2099
01:47:58,660 --> 01:48:01,780
And we can still get the GAN type,

2100
01:48:01,780 --> 01:48:04,260
but we can also make it easier to kind of fetch

2101
01:48:04,260 --> 01:48:06,700
the same field from this interface.

2102
01:48:06,700 --> 01:48:09,500
I think it's gonna make sense if I show you.

2103
01:48:09,500 --> 01:48:11,060
So I'm gonna update these two type

2104
01:48:11,060 --> 01:48:13,460
and I'm gonna create a new interface at the top.

2105
01:48:15,060 --> 01:48:16,660
Okay.

2106
01:48:16,660 --> 01:48:19,700
So in Subrary, like interfaces are basically the same

2107
01:48:19,700 --> 01:48:22,060
as types in terms of how you implement them.

2108
01:48:22,060 --> 01:48:25,180
We did difference that instead of doing Subrary.type,

2109
01:48:25,180 --> 01:48:26,900
you do Subrary.interface.

2110
01:48:26,900 --> 01:48:29,620
And then when you wanna implement an interface,

2111
01:48:29,620 --> 01:48:32,580
you just extend from the interface.

2112
01:48:32,580 --> 01:48:34,900
And now when I go back to my schema,

2113
01:48:34,900 --> 01:48:36,980
I'm gonna see that these two types here

2114
01:48:37,980 --> 01:48:39,900
are implementing the interface,

2115
01:48:39,900 --> 01:48:43,100
meaning that I can fetch the field directly

2116
01:48:43,100 --> 01:48:44,580
from the interface.

2117
01:48:44,580 --> 01:48:49,460
So if I refresh this, I'm gonna go into my schema here.

2118
01:48:49,460 --> 01:48:52,420
I can see that this one implements error

2119
01:48:52,420 --> 01:48:55,180
and don't know if I go back,

2120
01:48:55,180 --> 01:48:57,900
but this one also implements error.

2121
01:48:57,900 --> 01:49:02,380
So now instead of doing this double fetch here,

2122
01:49:02,380 --> 01:49:06,300
I can do onError and then I can just do this.

2123
01:49:06,300 --> 01:49:09,980
And this is much nicer and it gives you a generic way

2124
01:49:09,980 --> 01:49:11,380
to handle all the errors.

2125
01:49:11,380 --> 01:49:14,060
And you still have a way to kind of pull more information

2126
01:49:14,060 --> 01:49:14,900
on the specific type.

2127
01:49:14,900 --> 01:49:19,900
So for example, if you wanted to do this

2128
01:49:21,020 --> 01:49:23,780
on already subscribed, you wanted to fetch, for example,

2129
01:49:24,700 --> 01:49:29,700
subscribed on, and you wanted to show,

2130
01:49:30,540 --> 01:49:32,820
you already subscribed, you subscribed on,

2131
01:49:32,820 --> 01:49:35,900
I don't know, first of March, 23, you can do,

2132
01:49:35,900 --> 01:49:38,940
you can still pass additional fields

2133
01:49:38,940 --> 01:49:41,740
so you can make these errors very, very garner

2134
01:49:41,740 --> 01:49:45,540
and very powerful as well.

2135
01:49:47,620 --> 01:49:48,460
Cool.

2136
01:49:49,980 --> 01:49:53,060
That's pretty much it for the errors.

2137
01:49:53,060 --> 01:49:55,580
Again, do you have any questions?

2138
01:49:58,860 --> 01:50:01,020
Okay, just gonna keep going.

2139
01:50:02,180 --> 01:50:04,780
So these two sections are quite basic

2140
01:50:06,060 --> 01:50:07,980
in the sense that they don't have a lot of information

2141
01:50:07,980 --> 01:50:12,420
because this is something I want to work on more

2142
01:50:12,420 --> 01:50:14,340
in so that I can make it easier to,

2143
01:50:15,380 --> 01:50:19,180
making your GraphQL API secure and perform it.

2144
01:50:19,180 --> 01:50:21,900
So the first one is about safety.

2145
01:50:21,900 --> 01:50:23,740
And again, we already seen some of this.

2146
01:50:23,740 --> 01:50:26,580
So we already seen that, like if I'm allowing user

2147
01:50:26,580 --> 01:50:31,580
to fetch anything, I should put some safeguards into place.

2148
01:50:33,700 --> 01:50:37,180
Like I don't want them to fetch everything.

2149
01:50:37,580 --> 01:50:40,100
And so the first thing, like the first,

2150
01:50:40,100 --> 01:50:43,060
or the most basic thing you can do in GraphQL

2151
01:50:43,060 --> 01:50:44,780
is to limit the query depth.

2152
01:50:44,780 --> 01:50:47,420
So for example, if I'm trying to do,

2153
01:50:47,420 --> 01:50:49,260
let's say that we implemented a list of episodes

2154
01:50:49,260 --> 01:50:50,100
for a podcast.

2155
01:50:50,100 --> 01:50:52,220
So we could do, you can fetch a list of podcasts,

2156
01:50:52,220 --> 01:50:56,140
you can get the episodes for the podcasts.

2157
01:50:56,140 --> 01:50:58,820
But on our episodes, we also have a podcast field.

2158
01:50:58,820 --> 01:51:00,460
So we could do a query like this,

2159
01:51:01,420 --> 01:51:04,780
which can be deeply nested.

2160
01:51:04,820 --> 01:51:09,620
And so that's gonna be very draining for your service.

2161
01:51:09,620 --> 01:51:13,100
It's gonna do a lot of SQL calls, it's gonna have a lot of data.

2162
01:51:13,100 --> 01:51:17,180
And so one basic way of doing this is to basically say,

2163
01:51:17,180 --> 01:51:19,340
I'm not gonna run any GraphQL query

2164
01:51:19,340 --> 01:51:23,820
that has more than seven levels of nesting.

2165
01:51:23,820 --> 01:51:26,380
And this is pretty safe for what you just do,

2166
01:51:26,380 --> 01:51:29,900
an extension and implement it like that.

2167
01:51:29,900 --> 01:51:31,700
Just gonna show you this.

2168
01:51:31,700 --> 01:51:32,540
So.

2169
01:51:45,060 --> 01:51:46,380
And this case I'm gonna do two,

2170
01:51:46,380 --> 01:51:49,220
because I don't think I have something that's more than eight.

2171
01:51:49,220 --> 01:51:51,020
But basically when I try to run a query

2172
01:51:51,020 --> 01:51:53,140
that's more than two levels of nesting,

2173
01:51:53,140 --> 01:51:54,220
I'm gonna get an error.

2174
01:51:56,140 --> 01:51:57,100
Maybe not this.

2175
01:52:02,500 --> 01:52:07,500
So I'm trying to fetch podcasts, I'm gonna fetch the D.

2176
01:52:08,500 --> 01:52:12,100
Oh, I think it's, yeah.

2177
01:52:14,180 --> 01:52:15,020
Wait.

2178
01:52:22,220 --> 01:52:24,020
I need to check, oh, there we go.

2179
01:52:26,500 --> 01:52:28,060
Should I work with two as well?

2180
01:52:28,220 --> 01:52:29,060
Okay.

2181
01:52:31,140 --> 01:52:33,740
Okay, I think it counts from downwards, okay.

2182
01:52:33,740 --> 01:52:36,820
It skips the first level, which makes sense.

2183
01:52:36,820 --> 01:52:38,340
Yeah, so basically if I try to run a query

2184
01:52:38,340 --> 01:52:40,980
that's more than one level of depth,

2185
01:52:40,980 --> 01:52:43,340
in this case it's gonna throw an error.

2186
01:52:43,340 --> 01:52:46,300
And this anonymous here is the name of the query.

2187
01:52:46,300 --> 01:52:51,300
So again, we can see that that goes there as well.

2188
01:52:53,540 --> 01:52:55,380
And this works in some cases,

2189
01:52:55,380 --> 01:52:57,540
it might not work in other cases.

2190
01:52:57,540 --> 01:53:00,180
So it really depends on what you're doing.

2191
01:53:00,180 --> 01:53:01,460
There's another powerful thing,

2192
01:53:01,460 --> 01:53:03,300
which unfortunately we haven't implemented

2193
01:53:03,300 --> 01:53:06,100
in Soberty just yet, but it's gonna come soon,

2194
01:53:07,260 --> 01:53:10,660
which is the query complexity calculation.

2195
01:53:10,660 --> 01:53:14,020
So this is a way to kind of give you a way

2196
01:53:14,020 --> 01:53:16,980
to calculate if a request has the potential

2197
01:53:16,980 --> 01:53:18,780
of fetching too much data.

2198
01:53:18,780 --> 01:53:20,380
So in this case I'm saying I wanna fetch

2199
01:53:20,380 --> 01:53:23,700
the first 50 podcasts, and for every podcast

2200
01:53:23,700 --> 01:53:26,220
I wanna fetch the first 50 episodes.

2201
01:53:27,740 --> 01:53:30,980
And the way, in this case you can do

2202
01:53:30,980 --> 01:53:32,620
some kind of weight calculations.

2203
01:53:32,620 --> 01:53:36,060
So I'm gonna say this field is gonna weigh 50,

2204
01:53:36,060 --> 01:53:39,500
and then every field of this is gonna be 50 as well.

2205
01:53:39,500 --> 01:53:43,340
And I'm gonna do 50 by 50, and then the result

2206
01:53:43,340 --> 01:53:45,700
will be 2,500.

2207
01:53:47,180 --> 01:53:48,980
And so the total complexity would be

2208
01:53:50,020 --> 01:53:52,780
this multiplication here, because there is gonna be,

2209
01:53:52,780 --> 01:53:55,540
it's fetching 50 episodes for every single podcast.

2210
01:53:55,540 --> 01:53:57,220
So it would be 50 times 50.

2211
01:53:57,900 --> 01:54:01,220
And then the complexity of the podcast here is 50.

2212
01:54:01,220 --> 01:54:04,420
So the total complexity would be this one plus this one,

2213
01:54:04,420 --> 01:54:06,700
which is 2,550.

2214
01:54:08,620 --> 01:54:10,780
And you can basically have some piece of code say,

2215
01:54:10,780 --> 01:54:15,780
oh, if the complexity is more than 3,000,

2216
01:54:16,300 --> 01:54:18,220
don't try to run this query at all.

2217
01:54:18,220 --> 01:54:20,980
I mean, that query might request just one,

2218
01:54:20,980 --> 01:54:24,820
might return only one item, but it has the potential

2219
01:54:24,820 --> 01:54:25,860
of returning a lot of items.

2220
01:54:25,860 --> 01:54:29,740
So you can basically skip all the requests being done there.

2221
01:54:30,900 --> 01:54:33,660
Which is, again, it's a nice way of doing something like that

2222
01:54:33,660 --> 01:54:36,300
in GraphQL.

2223
01:54:36,300 --> 01:54:37,140
There is also,

2224
01:54:42,620 --> 01:54:47,620
this is for node, but there is also this kind of plugin

2225
01:54:47,660 --> 01:54:51,180
called GraphQL Armor, which I'm gonna implement

2226
01:54:51,180 --> 01:54:54,740
for Stray as well, which gives you all this nice way

2227
01:54:54,740 --> 01:54:58,540
of limiting what someone can do with your GraphQL API.

2228
01:54:58,540 --> 01:55:00,380
So the first one is using the costs.

2229
01:55:01,420 --> 01:55:02,580
I mean, this has a lot of options,

2230
01:55:02,580 --> 01:55:05,280
but basically it prevents you to do,

2231
01:55:06,260 --> 01:55:09,260
I can create that's more than X amount of cost.

2232
01:55:11,860 --> 01:55:13,420
But there's also like dialysis.

2233
01:55:13,420 --> 01:55:17,460
Like I showed you before, like you can do like this.

2234
01:55:25,500 --> 01:55:26,620
Let me disable that.

2235
01:55:32,860 --> 01:55:35,100
So you can do this like you're fetching A and B,

2236
01:55:35,100 --> 01:55:37,780
and basically you're kind of circumventing any limit

2237
01:55:37,780 --> 01:55:39,180
that your API might have.

2238
01:55:39,180 --> 01:55:41,100
And so like a nice way of, well,

2239
01:55:41,100 --> 01:55:42,740
an easy way of preventing something like this

2240
01:55:42,740 --> 01:55:44,940
is to have a type of code that says,

2241
01:55:44,940 --> 01:55:49,940
oh, you can only have maximum 10 indices in your code.

2242
01:55:50,580 --> 01:55:51,660
Like this is called an audio.

2243
01:55:51,660 --> 01:55:52,780
So it's basically giving,

2244
01:55:52,780 --> 01:55:54,900
it's a way to give another name to a field

2245
01:55:54,900 --> 01:55:57,300
and also to fetch the same field multiple times.

2246
01:55:58,980 --> 01:56:02,460
And yeah, so that's pretty safe for work to implement.

2247
01:56:02,460 --> 01:56:05,580
Probably gonna be done by the end of the spring this week.

2248
01:56:06,860 --> 01:56:10,220
This is something we already have, which is the max depth.

2249
01:56:10,220 --> 01:56:13,260
There's also a way to limit the number of directives,

2250
01:56:13,260 --> 01:56:16,540
which we haven't seen, but in GraphQL,

2251
01:56:16,540 --> 01:56:19,220
we can have directives, which is a way to change

2252
01:56:19,220 --> 01:56:22,060
the execution of a field.

2253
01:56:22,060 --> 01:56:23,660
So in this case, I wanna do,

2254
01:56:23,660 --> 01:56:25,460
I wanna include only if this,

2255
01:56:27,220 --> 01:56:28,220
this will be a variable.

2256
01:56:28,220 --> 01:56:29,780
So if the variable is true,

2257
01:56:29,780 --> 01:56:31,140
I'm gonna include that field,

2258
01:56:31,140 --> 01:56:33,140
otherwise I'm not gonna include it.

2259
01:56:33,140 --> 01:56:34,140
For example, if I do false,

2260
01:56:34,140 --> 01:56:35,580
this is only gonna return B,

2261
01:56:36,460 --> 01:56:38,340
which is a nice way to have a generic,

2262
01:56:41,300 --> 01:56:43,420
a generic query, but like an issue of,

2263
01:56:45,140 --> 01:56:47,860
of directives, that you can put a lot of them,

2264
01:56:47,860 --> 01:56:49,660
and those are gonna run code,

2265
01:56:49,660 --> 01:56:52,340
and sometimes also the parser might be slow,

2266
01:56:52,340 --> 01:56:55,380
and so running, this case actually doesn't,

2267
01:56:55,380 --> 01:56:57,780
doesn't run multiple times, which is nice.

2268
01:56:57,780 --> 01:56:59,540
But there are some parser that basically,

2269
01:56:59,540 --> 01:57:00,740
if you have a lot of directives,

2270
01:57:00,740 --> 01:57:02,900
they're gonna slow down a lot,

2271
01:57:02,900 --> 01:57:06,300
and it's gonna lead to dos attacks.

2272
01:57:07,540 --> 01:57:08,380
What else?

2273
01:57:10,460 --> 01:57:13,900
And there's also max token or character limit,

2274
01:57:13,900 --> 01:57:17,220
which is basically a way to say,

2275
01:57:17,260 --> 01:57:20,540
if this document is too long, don't run it,

2276
01:57:21,700 --> 01:57:23,420
could be useful in some cases,

2277
01:57:23,420 --> 01:57:25,620
and yeah, this is gonna be implemented

2278
01:57:25,620 --> 01:57:27,420
to police on in summary.

2279
01:57:28,580 --> 01:57:31,820
There's also one thing here, which is, again, about safety.

2280
01:57:33,420 --> 01:57:36,780
When you put a graphical API on production,

2281
01:57:36,780 --> 01:57:41,780
one of the key suggestion from people in security

2282
01:57:42,340 --> 01:57:44,180
is like you should hide the introspection,

2283
01:57:44,180 --> 01:57:47,220
so if I, what I'm doing here,

2284
01:57:47,220 --> 01:57:49,540
basically using the information about the API

2285
01:57:49,540 --> 01:57:51,500
to build the documentation,

2286
01:57:51,500 --> 01:57:56,500
and people say, hide that, because it might give you

2287
01:57:56,780 --> 01:57:59,820
information about your schema to attackers.

2288
01:57:59,820 --> 01:58:02,300
There's one additional thing that you could do that,

2289
01:58:02,300 --> 01:58:03,580
you can hide introspection,

2290
01:58:03,580 --> 01:58:07,540
I think we have also an extension for that,

2291
01:58:07,540 --> 01:58:10,300
but you can still do something like this.

2292
01:58:10,300 --> 01:58:12,460
Maybe let me, I don't know if this is in.

2293
01:58:14,700 --> 01:58:15,540
Okay.

2294
01:58:19,020 --> 01:58:20,740
Yeah, so if you try to fetch a field

2295
01:58:20,740 --> 01:58:22,420
that's a similar name to another one,

2296
01:58:22,420 --> 01:58:25,420
you're gonna get a nice helpful message

2297
01:58:25,420 --> 01:58:27,340
that's gonna tell you, oh, this is the field

2298
01:58:27,340 --> 01:58:30,060
that you meant, probably, and there are tools like,

2299
01:58:31,420 --> 01:58:35,420
let's see, GraphQL, yeah, like this one,

2300
01:58:35,420 --> 01:58:37,980
that basically use this feature of GraphQL

2301
01:58:37,980 --> 01:58:41,420
to find all the schema automatically for you.

2302
01:58:41,460 --> 01:58:45,100
So like, disabling the schema might not be the best option,

2303
01:58:45,100 --> 01:58:47,340
because there's still ways to find out.

2304
01:58:47,340 --> 01:58:49,020
Again, this is something that we,

2305
01:58:49,020 --> 01:58:50,700
you're gonna make easier to disable in,

2306
01:58:50,700 --> 01:58:52,580
so like, if you're running in dev,

2307
01:58:52,580 --> 01:58:53,820
you're gonna get this nice message,

2308
01:58:53,820 --> 01:58:55,380
but if you're not running in dev,

2309
01:58:55,380 --> 01:58:57,180
you're not gonna get any suggestion.

2310
01:58:59,260 --> 01:59:00,100
Yeah.

2311
01:59:01,540 --> 01:59:04,140
And again, this is gonna come up, hopefully, soon,

2312
01:59:05,620 --> 01:59:06,620
rather than later.

2313
01:59:08,500 --> 01:59:10,380
Yeah, do you have any questions about security?

2314
01:59:10,380 --> 01:59:12,940
Because I think there's a lot of things to talk about,

2315
01:59:12,940 --> 01:59:16,980
and I'm definitely skip some of them, so just let me know.

2316
01:59:30,980 --> 01:59:33,020
Okay, the last thing I wanted to show you

2317
01:59:33,020 --> 01:59:36,740
before doing a recap, maybe, and taking more questions,

2318
01:59:36,740 --> 01:59:39,460
is the tracing part, so, and this is something

2319
01:59:39,500 --> 01:59:42,020
that's still quite new in GraphQL,

2320
01:59:42,020 --> 01:59:44,500
so I mentioned, like, GraphQL,

2321
01:59:44,500 --> 01:59:47,980
every request responds with 200, usually,

2322
01:59:47,980 --> 01:59:51,940
which makes tracing and monitoring quite difficult, so.

2323
01:59:53,380 --> 01:59:56,460
So there is tools like Apollo Studio from GraphQL

2324
01:59:56,460 --> 01:59:58,620
that allow you to, oh, sorry, from Apollo.

2325
02:00:01,740 --> 02:00:03,780
Let me see if there is an example of this.

2326
02:00:03,780 --> 02:00:08,780
Yeah, so basically, there are tools like Apollo Studio

2327
02:00:11,060 --> 02:00:14,220
that allow you to get the metrics for all the queries.

2328
02:00:14,220 --> 02:00:16,940
There's quite a few others as well,

2329
02:00:16,940 --> 02:00:19,060
so you can see all the information, like, for example,

2330
02:00:19,060 --> 02:00:21,060
if the requests have been requested the most,

2331
02:00:21,060 --> 02:00:23,260
sorry, the operations have been requested the most,

2332
02:00:23,260 --> 02:00:25,740
the ones are the slowest, and so on,

2333
02:00:25,740 --> 02:00:27,980
and all of this is quite nice.

2334
02:00:27,980 --> 02:00:30,820
The only thing is that you need to use some of these tools

2335
02:00:30,860 --> 02:00:35,860
which are usually paid, and it's another tool

2336
02:00:36,300 --> 02:00:37,940
on top of what you already have,

2337
02:00:39,260 --> 02:00:41,660
but you can also still use tracing,

2338
02:00:41,660 --> 02:00:44,100
and you can also send this information

2339
02:00:44,100 --> 02:00:45,660
to, like, service-like Datadog,

2340
02:00:45,660 --> 02:00:48,180
and in Surberry, we have implementation

2341
02:00:48,180 --> 02:00:52,340
for Datadog Open Tracing and So-Nothing Sentry,

2342
02:00:53,260 --> 02:00:55,380
and they basically work the same way

2343
02:00:55,380 --> 02:00:58,900
as the other extension, and so basically,

2344
02:00:58,900 --> 02:01:02,940
every time you run a SQL query, sorry, a GraphQL query,

2345
02:01:02,940 --> 02:01:05,300
this extension is gonna kinda check all the things

2346
02:01:05,300 --> 02:01:07,340
that you're doing, and it's gonna send it to Datadog,

2347
02:01:07,340 --> 02:01:08,740
and you can get something like this,

2348
02:01:08,740 --> 02:01:11,700
which is, kinda send this is not super useful,

2349
02:01:11,700 --> 02:01:14,740
but you basically can see all those over there being called,

2350
02:01:14,740 --> 02:01:17,380
how much, how long they take, and so on,

2351
02:01:17,380 --> 02:01:21,700
which is the, it's the way that you would do

2352
02:01:23,780 --> 02:01:26,980
tracing in GraphQL, so basically, it's a nice way

2353
02:01:26,980 --> 02:01:29,380
to understand how long a field would take.

2354
02:01:30,500 --> 02:01:31,700
Something that we've done in the past

2355
02:01:31,700 --> 02:01:33,620
is also to add additional metrics,

2356
02:01:33,620 --> 02:01:35,460
and for example, using operation name

2357
02:01:35,460 --> 02:01:39,660
to send information about the operation,

2358
02:01:39,660 --> 02:01:41,660
so every time there's an operation,

2359
02:01:41,660 --> 02:01:45,700
you log how much it takes, and then you send it to Datadog,

2360
02:01:47,580 --> 02:01:48,700
which is something that's pretty simple

2361
02:01:48,700 --> 02:01:49,940
to implement as well.

2362
02:01:51,140 --> 02:01:53,460
I don't know if I have an example of this, I...

2363
02:01:57,580 --> 02:02:00,980
Wanna check, I wanted to try Sentry today,

2364
02:02:00,980 --> 02:02:04,460
but I didn't manage to make it work in time,

2365
02:02:04,460 --> 02:02:06,660
because it's a bit nicer, actually, I may have Sentry,

2366
02:02:08,980 --> 02:02:10,900
I may have Sentry for another project.

2367
02:02:17,020 --> 02:02:18,220
Hopefully it's Google.

2368
02:02:27,020 --> 02:02:27,860
Okay.

2369
02:02:30,780 --> 02:02:31,700
There we go.

2370
02:02:42,860 --> 02:02:44,700
Now, fortunately, I don't think we have it here,

2371
02:02:44,700 --> 02:02:46,540
but you basically will get something like this,

2372
02:02:46,540 --> 02:02:49,380
and here, instead of getting a generic ASG requests,

2373
02:02:49,380 --> 02:02:52,660
like this one, you will get one transaction

2374
02:02:52,660 --> 02:02:55,140
for GraphQL request, which makes it very easy

2375
02:02:55,140 --> 02:02:57,020
to understand the slow ones,

2376
02:02:57,020 --> 02:03:01,580
and the ones that you have to optimize,

2377
02:03:01,580 --> 02:03:04,820
so you can use things like this to basically say,

2378
02:03:04,820 --> 02:03:09,580
this is taking too much time, and yeah,

2379
02:03:09,580 --> 02:03:12,980
we do have some, like tracing here is not really pretty well,

2380
02:03:12,980 --> 02:03:14,620
but that's basically what you would do

2381
02:03:14,620 --> 02:03:18,180
for just optimizing the GraphQL queries,

2382
02:03:18,180 --> 02:03:20,220
and again, you can use tools like Apollo Studio,

2383
02:03:20,220 --> 02:03:23,380
or there's others, which I don't remember the name,

2384
02:03:24,380 --> 02:03:28,100
which makes it easier to optimize your GraphQL requests,

2385
02:03:28,100 --> 02:03:32,620
but again, it's a very supports a data dog and open tracing,

2386
02:03:32,620 --> 02:03:36,020
so you can use those tools to optimize all the requests,

2387
02:03:36,020 --> 02:03:38,260
so you don't have to use a third-party service.

2388
02:03:40,540 --> 02:03:43,260
Yeah, and that's, I think I went very fast on this,

2389
02:03:43,260 --> 02:03:48,020
so I'm just gonna take some time to answer some questions,

2390
02:03:48,020 --> 02:03:51,140
you might have one, I guess one thing,

2391
02:03:51,180 --> 02:03:53,540
additional thing I wanted to mention on this,

2392
02:03:53,540 --> 02:03:57,940
like we have a very friendly Discord,

2393
02:03:57,940 --> 02:03:59,540
so there's quite a few people there

2394
02:03:59,540 --> 02:04:00,900
that usually answer questions,

2395
02:04:00,900 --> 02:04:04,260
but otherwise I'm also there to answer anything

2396
02:04:07,060 --> 02:04:10,140
you might want to know, and yeah, the website,

2397
02:04:10,140 --> 02:04:11,860
actually working on a new website,

2398
02:04:11,860 --> 02:04:15,220
which is gonna be released, not gonna say soon,

2399
02:04:15,220 --> 02:04:18,140
but hopefully by the end of this month or next one,

2400
02:04:19,140 --> 02:04:24,140
and yeah, again, I'm really passionate about this project,

2401
02:04:24,980 --> 02:04:28,180
so if you have any questions, you can reach out to me

2402
02:04:28,180 --> 02:04:31,060
on Discord, you can also find me on GitHub,

2403
02:04:31,060 --> 02:04:33,660
if you go to Stradivari, you should be able to find me

2404
02:04:33,660 --> 02:04:38,660
pretty easily, and there's my email on here,

2405
02:04:39,020 --> 02:04:40,260
so you can send me an email there,

2406
02:04:40,260 --> 02:04:42,740
or any place where you can reach me,

2407
02:04:42,740 --> 02:04:44,620
I'm happy to take any questions.

2408
02:04:45,460 --> 02:04:47,340
And yeah, before doing a quick recap,

2409
02:04:47,340 --> 02:04:51,620
if it might be helpful, just if you have any questions,

2410
02:04:51,620 --> 02:04:54,300
just fire away, I'll be happy to answer.

2411
02:04:56,380 --> 02:04:57,220
Yeah.

2412
02:04:57,220 --> 02:05:01,180
Have you done any benchmarking against REST framework?

2413
02:05:01,180 --> 02:05:04,180
Like, like particularly in the field?

2414
02:05:06,060 --> 02:05:09,140
Yeah, so the question is, have you done any benchmark

2415
02:05:09,140 --> 02:05:10,540
against REST framework?

2416
02:05:10,740 --> 02:05:14,660
No, at the moment we only done benchmarks

2417
02:05:14,660 --> 02:05:17,300
against other GraphQL implementation in Python,

2418
02:05:17,300 --> 02:05:18,620
and the performance is the same,

2419
02:05:18,620 --> 02:05:22,620
because like all the Python GraphQL APIs

2420
02:05:24,900 --> 02:05:26,700
are using something called GraphQL Core,

2421
02:05:26,700 --> 02:05:29,660
which is the core implementation of this library,

2422
02:05:29,660 --> 02:05:32,460
like it implements the execution,

2423
02:05:32,460 --> 02:05:36,420
like we are basically like a syntactic sugar on top of this,

2424
02:05:37,380 --> 02:05:41,580
and so there is some performance issues here,

2425
02:05:41,580 --> 02:05:44,140
mostly when you return a lot of data,

2426
02:05:44,140 --> 02:05:46,420
so if you're returning tens of thousands of items,

2427
02:05:46,420 --> 02:05:48,860
it's gonna be a bit slow, because what's happening there

2428
02:05:48,860 --> 02:05:51,460
is it's validating every single item

2429
02:05:51,460 --> 02:05:54,380
against the GraphQL schema, which is quite annoying.

2430
02:05:56,020 --> 02:05:59,260
So this is something that we're trying to work on

2431
02:05:59,260 --> 02:06:00,420
to make it better.

2432
02:06:00,420 --> 02:06:03,900
There's a project a friend of mine is working on,

2433
02:06:03,900 --> 02:06:06,740
it's called Rustberry, which is replacing

2434
02:06:06,740 --> 02:06:09,420
some parts of GraphQL Core in Rust.

2435
02:06:09,420 --> 02:06:13,020
At the moment it's gonna be mostly validation and parsing,

2436
02:06:13,020 --> 02:06:14,420
and that's gonna make things a bit faster,

2437
02:06:14,420 --> 02:06:17,460
but my goal in future is to get as fast,

2438
02:06:17,460 --> 02:06:20,140
if not faster, than Django REST framework.

2439
02:06:20,140 --> 02:06:22,140
Some ideas there, it's just I don't have enough time,

2440
02:06:22,140 --> 02:06:22,980
unfortunately.

2441
02:06:27,940 --> 02:06:31,940
So what do you think the go back to the question

2442
02:06:32,140 --> 02:06:36,100
that you're considering going to the rest of the project?

2443
02:06:36,100 --> 02:06:38,180
Yeah, so drawbacks of GraphQL,

2444
02:06:38,180 --> 02:06:39,500
so that's a very good question.

2445
02:06:39,500 --> 02:06:42,260
There's different sides of seeing that.

2446
02:06:42,260 --> 02:06:44,940
Definitely one thing is if you never use GraphQL,

2447
02:06:45,820 --> 02:06:49,820
it's quite foreign, so understanding all these things

2448
02:06:49,820 --> 02:06:53,140
about not even just performance,

2449
02:06:53,140 --> 02:06:55,340
but also security and monitoring,

2450
02:06:56,180 --> 02:06:58,220
those things take a bit more time,

2451
02:06:58,220 --> 02:07:00,820
especially you have to use tools and things like that.

2452
02:07:02,460 --> 02:07:07,460
And yeah, it also depends why you're building.

2453
02:07:07,540 --> 02:07:10,260
So if you wanna, like my suggestion,

2454
02:07:10,260 --> 02:07:14,140
if you wanna try GraphQL in your work or for a side project,

2455
02:07:14,140 --> 02:07:16,220
try to do something small,

2456
02:07:16,220 --> 02:07:17,820
but also start from the front end.

2457
02:07:17,820 --> 02:07:20,740
Try to implement, maybe do a small API,

2458
02:07:20,740 --> 02:07:23,860
but try to implement soon as possible on the client,

2459
02:07:23,860 --> 02:07:27,540
because where you get the benefits, it's on the client,

2460
02:07:27,540 --> 02:07:32,020
because you have this nice way of fetching data.

2461
02:07:32,020 --> 02:07:36,740
Maybe I can show you an example of this.

2462
02:07:39,300 --> 02:07:41,820
Don't know if you're familiar with React,

2463
02:07:41,820 --> 02:07:46,820
but in, let's see if there's an example.

2464
02:07:48,940 --> 02:07:52,820
Yeah, in React, you can use tools like Apollo Client,

2465
02:07:52,820 --> 02:07:55,460
where you basically define a query like this.

2466
02:07:55,460 --> 02:07:58,180
So this is a query that we've been working on before,

2467
02:07:58,180 --> 02:08:01,220
and you can use Hook,

2468
02:08:01,220 --> 02:08:04,660
which is basically returning you loading errors and data.

2469
02:08:04,660 --> 02:08:06,540
It's like this line is basically giving you

2470
02:08:06,540 --> 02:08:09,500
all the GraphQL things, which is very nice,

2471
02:08:09,500 --> 02:08:11,340
very easy to use.

2472
02:08:11,340 --> 02:08:13,860
So you will get a lot of benefits

2473
02:08:13,860 --> 02:08:16,540
from just trying this on the front end.

2474
02:08:16,540 --> 02:08:18,060
That's definitely my suggestion.

2475
02:08:18,060 --> 02:08:21,060
But in terms of trade-offs,

2476
02:08:21,060 --> 02:08:23,980
like one thing that GraphQL is not really good at is,

2477
02:08:25,660 --> 02:08:28,580
public API, so if you're doing an API

2478
02:08:28,580 --> 02:08:30,860
that's gonna be used by third parties,

2479
02:08:30,860 --> 02:08:32,220
like for example, if you, I don't know,

2480
02:08:32,220 --> 02:08:35,180
for example, the GitHub API is used by other developers

2481
02:08:35,180 --> 02:08:37,060
that are not from GitHub.

2482
02:08:37,060 --> 02:08:40,100
Building an API, public API in GraphQL is quite difficult,

2483
02:08:40,100 --> 02:08:41,500
because again, you should make an API

2484
02:08:41,500 --> 02:08:45,380
that's more focused on the use case.

2485
02:08:45,380 --> 02:08:46,900
And when you're building a public API,

2486
02:08:46,900 --> 02:08:48,300
you don't know what use case is gonna be,

2487
02:08:48,300 --> 02:08:50,660
so people are gonna implement random things

2488
02:08:50,660 --> 02:08:53,660
and gonna make things that don't make sense

2489
02:08:53,660 --> 02:08:56,860
in the way you shape your GraphQL schema.

2490
02:08:56,860 --> 02:08:59,900
So public API is definitely, it's doable,

2491
02:08:59,900 --> 02:09:01,460
but it's not simple.

2492
02:09:01,460 --> 02:09:05,540
And on top of that, service-to-service communication,

2493
02:09:05,540 --> 02:09:07,980
I don't think GraphQL is the right place for doing that,

2494
02:09:07,980 --> 02:09:10,180
because if you, I don't know,

2495
02:09:10,180 --> 02:09:13,780
if you're microservices, you wanna communicate between them,

2496
02:09:13,780 --> 02:09:15,460
I will use gRPC, because it's faster

2497
02:09:15,460 --> 02:09:18,220
and also it's made for that use case.

2498
02:09:18,220 --> 02:09:20,180
And GraphQL, I don't know, the fact that you have

2499
02:09:20,180 --> 02:09:22,460
to specify the query is powerful for the client,

2500
02:09:22,460 --> 02:09:24,740
but when you're service-to-server,

2501
02:09:24,740 --> 02:09:27,260
I don't know if you get the benefits of being able

2502
02:09:27,260 --> 02:09:28,780
to specify the fields that you want.

2503
02:09:28,780 --> 02:09:30,980
Maybe you can reuse the API, but again,

2504
02:09:30,980 --> 02:09:32,940
the API should be made on the use case,

2505
02:09:32,940 --> 02:09:35,740
and again, use case should be done

2506
02:09:35,740 --> 02:09:37,940
for a client using API.

2507
02:09:43,220 --> 02:09:45,900
Have you ever encountered situations

2508
02:09:45,900 --> 02:09:50,900
where someone is using an app that's not on GraphQL

2509
02:09:51,260 --> 02:09:53,300
and the app is not on the API?

2510
02:09:53,300 --> 02:09:55,540
Have you ever encountered that?

2511
02:09:55,540 --> 02:09:59,020
Yeah, so the question is if I ever encountered places

2512
02:09:59,020 --> 02:10:02,220
where I have to have for the APIs rest

2513
02:10:02,220 --> 02:10:03,700
and I have for the APIs GraphQL.

2514
02:10:04,700 --> 02:10:06,340
Let me try to think.

2515
02:10:11,420 --> 02:10:13,860
We had something like that, but not exactly that.

2516
02:10:13,860 --> 02:10:17,660
So one thing I've seen in the past is like people creating,

2517
02:10:18,540 --> 02:10:20,340
which I definitely wouldn't recommend,

2518
02:10:20,340 --> 02:10:24,460
is creating kind of GraphQL resolvers on your front end.

2519
02:10:24,460 --> 02:10:26,980
So you will use GraphQL on your front end,

2520
02:10:29,020 --> 02:10:31,100
but also on the front end you would call rest.

2521
02:10:31,100 --> 02:10:33,820
So you would create an interface on top of rest

2522
02:10:33,820 --> 02:10:36,940
inside your front end, which is okay,

2523
02:10:36,940 --> 02:10:39,260
but you're still doing a lot of requests there.

2524
02:10:39,260 --> 02:10:43,140
So like something that's quite common is to do

2525
02:10:43,140 --> 02:10:46,500
tiny GraphQL API, try without, prove it that works,

2526
02:10:46,500 --> 02:10:50,020
and then slowly migrate things from rest

2527
02:10:50,860 --> 02:10:54,580
to GraphQL and you can still wrap your rest API

2528
02:10:54,580 --> 02:10:55,660
with the GraphQL API.

2529
02:10:55,660 --> 02:10:58,100
So you can do, like for example, the podcast field

2530
02:10:58,100 --> 02:11:00,940
could be, that we had, could be backed by rest API

2531
02:11:00,940 --> 02:11:03,860
and then if you wanna move it to be, to the skip rest,

2532
02:11:03,860 --> 02:11:06,140
you could do that as well.

2533
02:11:06,140 --> 02:11:09,020
But like using GraphQL to wrap rest API is quite common.

2534
02:11:09,020 --> 02:11:11,580
It's something I was doing in my previous work.

2535
02:11:12,940 --> 02:11:13,780
Yeah.

2536
02:11:20,860 --> 02:11:24,060
Do you have any other question?

2537
02:11:25,060 --> 02:11:25,900
Cool.

2538
02:11:27,260 --> 02:11:29,860
Yeah, so I guess the recap is basically we seen

2539
02:11:29,860 --> 02:11:33,340
how to kind of set up a GraphQL API with,

2540
02:11:33,340 --> 02:11:36,460
so we've been using Django, but Django again,

2541
02:11:36,460 --> 02:11:39,060
is something that's just an implementation detail.

2542
02:11:40,140 --> 02:11:43,980
And we, I can show this again, we had these models here,

2543
02:11:43,980 --> 02:11:47,260
but we were not looking at them directly.

2544
02:11:47,260 --> 02:11:49,820
Like all the code that was doing the data fetching

2545
02:11:50,660 --> 02:11:54,820
was kind of hidden by this service layer, I call it,

2546
02:11:54,820 --> 02:11:56,900
which is inspired by domain driven design.

2547
02:11:56,900 --> 02:12:01,900
It's basically like a facade on top of your database.

2548
02:12:02,180 --> 02:12:03,980
Makes it easier to work with these kind of things

2549
02:12:03,980 --> 02:12:06,380
and you don't have to think about all the implementation

2550
02:12:06,380 --> 02:12:07,780
of your database.

2551
02:12:07,780 --> 02:12:09,980
And it also makes it easier to reuse this, for example,

2552
02:12:09,980 --> 02:12:13,860
if you need to create a rest API for some specific use case

2553
02:12:13,860 --> 02:12:15,980
or if you need to create a CLI.

2554
02:12:16,940 --> 02:12:19,580
From this you can reuse this service layer.

2555
02:12:20,300 --> 02:12:21,220
And so you don't have anything that's specific

2556
02:12:21,220 --> 02:12:23,340
to data fetching inside GraphQL.

2557
02:12:25,340 --> 02:12:29,780
And we use async for data loaders,

2558
02:12:29,780 --> 02:12:33,380
which is a way to optimize the requests.

2559
02:12:33,380 --> 02:12:36,020
So to batch multiple requests into one.

2560
02:12:36,020 --> 02:12:38,540
And in Django, like there's some issues at the moment

2561
02:12:38,540 --> 02:12:42,740
with running async requests, async,

2562
02:12:42,740 --> 02:12:44,740
well, database call inside async context.

2563
02:12:44,740 --> 02:12:47,660
So I guess it's worth showing you since we have time,

2564
02:12:48,180 --> 02:12:50,340
there's this function called sync to async,

2565
02:12:50,340 --> 02:12:53,020
which converts async function into an async function.

2566
02:12:53,020 --> 02:12:56,180
So you can do a wait and it basically prevents

2567
02:12:56,180 --> 02:12:57,380
those issues with Django.

2568
02:12:58,820 --> 02:13:01,460
Basically what happens, like things run into a thread,

2569
02:13:03,380 --> 02:13:07,140
which it's a thread where the database also runs.

2570
02:13:08,100 --> 02:13:09,860
I'm sorry, the database connection also runs.

2571
02:13:09,860 --> 02:13:12,900
I'm not clear on the details why this is an issue,

2572
02:13:12,900 --> 02:13:14,180
but this is what's happening.

2573
02:13:14,180 --> 02:13:19,020
There's also, let me see.

2574
02:13:19,020 --> 02:13:21,220
In Django you can also do a filter.

2575
02:13:25,020 --> 02:13:25,860
Let me show this.

2576
02:13:34,300 --> 02:13:36,060
Oh, okay, no, a filter is not there yet,

2577
02:13:36,060 --> 02:13:38,380
but there's also things like a get,

2578
02:13:38,380 --> 02:13:41,980
which are the asynchronous variants of get

2579
02:13:41,980 --> 02:13:43,260
and a delete and so on.

2580
02:13:45,180 --> 02:13:48,340
This underdue that's still doing the sync to async

2581
02:13:48,340 --> 02:13:50,300
at the moment because the database layer

2582
02:13:50,300 --> 02:13:52,300
in Django is now async,

2583
02:13:52,300 --> 02:13:54,980
but hopefully that's gonna change in future.

2584
02:13:54,980 --> 02:13:58,100
And again, it's also one additional reason why,

2585
02:13:58,100 --> 02:14:01,900
to create like a wrapper layer

2586
02:14:01,900 --> 02:14:04,260
that makes it easier to work with database.

2587
02:14:04,260 --> 02:14:05,740
And I've done this for everything.

2588
02:14:05,740 --> 02:14:08,580
And you can see sync to async is done on list

2589
02:14:08,580 --> 02:14:11,740
in most cases because like Django is lazy.

2590
02:14:11,740 --> 02:14:15,860
So up until you don't use, for example,

2591
02:14:15,860 --> 02:14:19,580
a query set is not gonna do the actual query database.

2592
02:14:19,580 --> 02:14:21,980
Sync tracing is on list, which is a bit confusing.

2593
02:14:24,260 --> 02:14:25,820
Okay, what else?

2594
02:14:29,700 --> 02:14:32,460
Yeah, we've seen how to do pagination.

2595
02:14:32,460 --> 02:14:35,400
So you can do basic pagination using pages.

2596
02:14:36,340 --> 02:14:38,940
My suggestion is to think about the use case.

2597
02:14:38,940 --> 02:14:41,380
If you need to have page pagination,

2598
02:14:41,900 --> 02:14:43,500
you can use something like this,

2599
02:14:43,500 --> 02:14:48,500
but make sure that you can nest it a wrapper type

2600
02:14:48,580 --> 02:14:50,540
so you can do as next page.

2601
02:14:50,540 --> 02:14:53,060
You can give you more information about the pagination.

2602
02:14:53,060 --> 02:14:56,100
And on top of that,

2603
02:14:56,100 --> 02:14:58,500
make sure that you have some basic validation

2604
02:14:58,500 --> 02:15:01,300
so you don't allow users to fetch too much data.

2605
02:15:01,300 --> 02:15:03,140
We also see now to do some of those things

2606
02:15:03,140 --> 02:15:05,580
with the just safety features.

2607
02:15:05,580 --> 02:15:09,220
And hopefully this is gonna be easier

2608
02:15:09,220 --> 02:15:11,020
in the next version of Strawberry,

2609
02:15:11,020 --> 02:15:13,020
hopefully from next week.

2610
02:15:13,020 --> 02:15:16,940
So you can kind of prevent users to do too many fetches

2611
02:15:16,940 --> 02:15:20,220
in one single GraphQL query.

2612
02:15:20,220 --> 02:15:25,220
And we also seen the course of pagination,

2613
02:15:27,220 --> 02:15:28,980
which is useful for,

2614
02:15:28,980 --> 02:15:30,860
if you're working with a GraphQL API

2615
02:15:30,860 --> 02:15:31,700
that's already existing,

2616
02:15:31,700 --> 02:15:35,100
it's probably gonna use the release specification,

2617
02:15:35,100 --> 02:15:36,140
which is very common.

2618
02:15:36,140 --> 02:15:38,740
And again, this is something that looks like this.

2619
02:15:38,740 --> 02:15:43,740
So you have a field that returns a list of edges

2620
02:15:44,300 --> 02:15:45,620
and every edge is a node,

2621
02:15:45,620 --> 02:15:47,700
and every edge is also cursor,

2622
02:15:47,700 --> 02:15:50,740
which is how you can paginate and get things from there.

2623
02:15:50,740 --> 02:15:52,260
And you can also, again,

2624
02:15:52,260 --> 02:15:53,340
the reason why you have edges

2625
02:15:53,340 --> 02:15:55,820
is that you can add additional metadata here.

2626
02:15:55,820 --> 02:15:57,780
So for example, the user,

2627
02:15:57,780 --> 02:16:01,060
the friends can have relations together,

2628
02:16:01,060 --> 02:16:03,900
and it would only make sense in this context.

2629
02:16:03,900 --> 02:16:07,180
It wouldn't make sense to the single friend

2630
02:16:07,180 --> 02:16:09,860
to have a relation connection.

2631
02:16:11,800 --> 02:16:15,660
Yeah, the relay, it's a bit verbose,

2632
02:16:15,660 --> 02:16:17,340
but it's quite powerful.

2633
02:16:17,340 --> 02:16:21,540
And we've seen the generic types.

2634
02:16:21,540 --> 02:16:22,980
We've seen how this makes it very easy

2635
02:16:22,980 --> 02:16:26,100
to reuse types in Python

2636
02:16:26,100 --> 02:16:28,300
for creating multiple GraphQL types.

2637
02:16:31,020 --> 02:16:33,420
Oh, then we've seen a couple of ways

2638
02:16:33,580 --> 02:16:37,220
of improving the optimization, sorry,

2639
02:16:37,220 --> 02:16:38,860
improving the performance of application

2640
02:16:38,860 --> 02:16:40,220
by introspecting the query,

2641
02:16:41,100 --> 02:16:42,820
which is something I don't really recommend

2642
02:16:42,820 --> 02:16:45,420
because this time your database,

2643
02:16:45,420 --> 02:16:48,380
your GraphQL created too much to your database.

2644
02:16:48,380 --> 02:16:49,660
So I would definitely recommend you

2645
02:16:49,660 --> 02:16:51,620
to use data loaders when possible.

2646
02:16:51,620 --> 02:16:54,020
And for data loaders, you have to use async code.

2647
02:16:55,140 --> 02:16:56,740
Whereas we've seen authentication,

2648
02:16:56,740 --> 02:17:00,460
we've seen a basic way of doing authentication using cookies.

2649
02:17:00,460 --> 02:17:03,060
Again, you can use anything that you want.

2650
02:17:03,780 --> 02:17:06,460
But again, my personal,

2651
02:17:06,460 --> 02:17:08,380
I always use cookie-based authentication

2652
02:17:08,380 --> 02:17:09,900
just so much easier to use.

2653
02:17:09,900 --> 02:17:12,500
And I think you can also easily use them

2654
02:17:12,500 --> 02:17:13,940
in native applications.

2655
02:17:16,020 --> 02:17:18,140
And then, yeah, we've seen mutations,

2656
02:17:18,140 --> 02:17:19,100
synoptical mutation,

2657
02:17:19,100 --> 02:17:21,060
which are basically the same thing as query

2658
02:17:21,060 --> 02:17:22,500
with some additional changes

2659
02:17:24,100 --> 02:17:27,060
on how the execution works.

2660
02:17:28,380 --> 02:17:29,220
What else?

2661
02:17:30,580 --> 02:17:31,780
Yeah, we've seen the permissions.

2662
02:17:31,780 --> 02:17:34,820
Hopefully this is gonna be much more powerful in the future,

2663
02:17:34,820 --> 02:17:36,860
but it's already a good way to start.

2664
02:17:38,620 --> 02:17:40,580
And we've seen how to handle the errors.

2665
02:17:40,580 --> 02:17:44,460
So I think this is one of the most common patterns

2666
02:17:44,460 --> 02:17:45,660
if it's just for errors,

2667
02:17:45,660 --> 02:17:48,780
like just using the union types

2668
02:17:48,780 --> 02:17:52,860
to make sure that you basically tell your clients

2669
02:17:52,860 --> 02:17:56,140
how to handle multiple responses.

2670
02:17:58,180 --> 02:18:00,940
And yeah, that's pretty much it.

2671
02:18:00,940 --> 02:18:02,820
Again, keep an eye on this page.

2672
02:18:02,820 --> 02:18:04,580
I'm gonna update it to add more things

2673
02:18:04,580 --> 02:18:08,980
and also to remove some of the code

2674
02:18:08,980 --> 02:18:10,260
that's not gonna be needed in the future,

2675
02:18:10,260 --> 02:18:12,100
like for example, for relay.

2676
02:18:12,100 --> 02:18:15,020
Again, hopefully this is gonna be all implemented.

2677
02:18:15,020 --> 02:18:17,700
Most of this is gonna be implemented by Strawberry itself,

2678
02:18:17,700 --> 02:18:20,260
so you don't have to do all of this.

2679
02:18:20,260 --> 02:18:22,660
And same thing goes for the safety part.

2680
02:18:22,660 --> 02:18:25,300
There's gonna be a lot more options here.

2681
02:18:25,300 --> 02:18:27,420
And I think we're also gonna have a way

2682
02:18:27,420 --> 02:18:29,860
to kind of set the same defaults,

2683
02:18:29,860 --> 02:18:31,900
maybe even by default,

2684
02:18:31,900 --> 02:18:33,660
like when you install Strawberry

2685
02:18:33,660 --> 02:18:34,820
and you try to run queries,

2686
02:18:34,820 --> 02:18:37,980
there is a lot of these things enabled by default,

2687
02:18:37,980 --> 02:18:39,620
so you don't have to worry too much.

2688
02:18:39,620 --> 02:18:40,460
Yep.

2689
02:18:41,460 --> 02:18:43,180
Kind of going back to the,

2690
02:18:43,180 --> 02:18:44,460
a little bit back to the beginning,

2691
02:18:44,460 --> 02:18:47,700
when you were importing those podcast feeds,

2692
02:18:49,060 --> 02:18:54,060
how does GraphQL know what the parameters are

2693
02:18:54,900 --> 02:18:59,060
that it would use to get feedback on those feeds?

2694
02:18:59,060 --> 02:19:00,460
So the way we,

2695
02:19:01,420 --> 02:19:03,020
so if we go back to the CLI,

2696
02:19:03,900 --> 02:19:04,740
sorry, this,

2697
02:19:04,740 --> 02:19:06,900
well, I haven't showed you the CLI actually.

2698
02:19:06,900 --> 02:19:07,980
So this is just a,

2699
02:19:09,100 --> 02:19:10,420
it's not really part of the workshop,

2700
02:19:10,420 --> 02:19:14,620
but basically I'm fetching RSS feeds for the podcast

2701
02:19:14,620 --> 02:19:16,660
and I'm putting them into database.

2702
02:19:16,660 --> 02:19:20,420
And the modules,

2703
02:19:20,420 --> 02:19:21,660
so these are all the options,

2704
02:19:21,660 --> 02:19:23,620
all the things are available in the database.

2705
02:19:23,620 --> 02:19:26,860
So there is the title, subtitle, description, and so on,

2706
02:19:26,860 --> 02:19:28,580
and there's also the episodes.

2707
02:19:28,580 --> 02:19:32,620
And when I go back to my podcast query,

2708
02:19:32,620 --> 02:19:37,100
when I'm fetching a single podcast,

2709
02:19:37,100 --> 02:19:41,020
so I'm fetching that bad ID on the database,

2710
02:19:41,020 --> 02:19:43,140
and here I'm getting a Django module,

2711
02:19:43,140 --> 02:19:45,180
which has all the title, all the,

2712
02:19:45,180 --> 02:19:49,780
well, as the title, the ID, description, and so on.

2713
02:19:49,780 --> 02:19:52,540
And then when I'm doing the conversion,

2714
02:19:52,540 --> 02:19:55,100
I'm creating a GraphQL type,

2715
02:19:55,100 --> 02:19:56,980
which this is where you're telling GraphQL

2716
02:19:56,980 --> 02:19:58,660
what fields you can fetch.

2717
02:19:59,620 --> 02:20:02,140
But you have to know beforehand what you're getting

2718
02:20:02,140 --> 02:20:05,100
so you can apply the model of what the,

2719
02:20:05,100 --> 02:20:06,980
what it is, right?

2720
02:20:06,980 --> 02:20:10,980
This is my feed and I know I'm gonna get these.

2721
02:20:12,980 --> 02:20:14,860
And I put them in your model,

2722
02:20:14,860 --> 02:20:16,940
and you have to query them, right?

2723
02:20:16,940 --> 02:20:19,340
Yes, yes, yeah.

2724
02:20:19,340 --> 02:20:21,820
I mean, the way I've done this is a bit backwards,

2725
02:20:21,820 --> 02:20:22,940
maybe not too much.

2726
02:20:22,940 --> 02:20:25,980
Like I really have a data source to work with.

2727
02:20:26,140 --> 02:20:27,940
But for example, if you're working

2728
02:20:27,940 --> 02:20:30,260
with your own business logic, with your data,

2729
02:20:30,260 --> 02:20:32,420
you know what data you have,

2730
02:20:32,420 --> 02:20:34,700
and you know how to shape that for GraphQL.

2731
02:20:34,700 --> 02:20:36,380
Because again, it should be shaped

2732
02:20:36,380 --> 02:20:40,340
on based on the kind of use case that you have.

2733
02:20:41,380 --> 02:20:43,660
So for example, in this case, I mean, this is,

2734
02:20:43,660 --> 02:20:45,340
again, it's a very simple use case,

2735
02:20:45,340 --> 02:20:49,020
but I didn't have a hosted by field here.

2736
02:20:49,020 --> 02:20:50,700
If I wanted, I can add it,

2737
02:20:50,700 --> 02:20:53,940
but in my application, I didn't need to show that,

2738
02:20:53,940 --> 02:20:56,900
so it's not present in the GraphQL API.

2739
02:20:58,620 --> 02:21:02,180
Yeah, again, I think, I haven't mentioned this,

2740
02:21:02,180 --> 02:21:04,220
but in GraphQL, like, well, something that's pretty cool,

2741
02:21:04,220 --> 02:21:08,540
like adding new fields is very easy.

2742
02:21:08,540 --> 02:21:12,860
So you can do ABC and string, and that's done.

2743
02:21:12,860 --> 02:21:13,980
You don't have to do anything else

2744
02:21:13,980 --> 02:21:16,700
other than putting here when you fetch it.

2745
02:21:16,700 --> 02:21:18,540
I can do ABC.

2746
02:21:18,540 --> 02:21:19,900
I can also put a default,

2747
02:21:19,900 --> 02:21:23,780
so you don't have to do anything.

2748
02:21:24,740 --> 02:21:25,820
This is something that, for example,

2749
02:21:25,820 --> 02:21:27,260
in REST might be a bit annoying,

2750
02:21:27,260 --> 02:21:29,700
because once you add a field to REST endpoint,

2751
02:21:29,700 --> 02:21:32,340
it's gonna be returned to all the clients

2752
02:21:32,340 --> 02:21:33,220
using that endpoint.

2753
02:21:33,220 --> 02:21:36,260
In GraphQL, this field is only gonna be returned

2754
02:21:36,260 --> 02:21:38,900
if someone requests it, which is very powerful.

2755
02:21:38,900 --> 02:21:41,660
And so my recommendation is only add the fields

2756
02:21:41,660 --> 02:21:42,980
that you need at the moment,

2757
02:21:42,980 --> 02:21:45,460
and always add them in future if you need more.

2758
02:21:46,620 --> 02:21:49,900
Because once you have a field in your schema,

2759
02:21:49,900 --> 02:21:52,300
like you're moving, it's a bit non-trivial,

2760
02:21:52,300 --> 02:21:55,140
because you need to make sure that it's not being used.

2761
02:21:56,220 --> 02:21:58,580
Which there are some, like Apollo Studio tells you

2762
02:21:58,580 --> 02:22:00,340
how many times a field has been used,

2763
02:22:00,340 --> 02:22:02,180
for example, last week.

2764
02:22:02,180 --> 02:22:03,940
You can check that, but again,

2765
02:22:03,940 --> 02:22:07,100
it's an operation that requires some step.

2766
02:22:07,100 --> 02:22:09,420
And you can also deprecate fields if you need to.

2767
02:22:09,420 --> 02:22:11,180
So for example, if you don't wanna,

2768
02:22:13,380 --> 02:22:16,780
if you wanna tell user to not use the description field,

2769
02:22:16,780 --> 02:22:17,900
you can deprecate it.

2770
02:22:19,300 --> 02:22:22,060
And so they get a warning inside there,

2771
02:22:22,860 --> 02:22:24,140
and they say, I see it gonna work,

2772
02:22:24,140 --> 02:22:27,060
but they know that it's gonna be deleted at some point.

2773
02:22:29,060 --> 02:22:29,900
Yeah.

2774
02:22:34,820 --> 02:22:37,220
Yeah, that's again, pretty much it.

2775
02:22:37,220 --> 02:22:39,140
Again, if you have any question,

2776
02:22:39,140 --> 02:22:40,900
you can go to Sorry The Rocks.

2777
02:22:40,900 --> 02:22:42,340
There is all the links there.

2778
02:22:43,300 --> 02:22:45,820
Yeah, I'm gonna be around for us today

2779
02:22:45,820 --> 02:22:47,220
and all the rest of the conference.

2780
02:22:47,220 --> 02:22:51,300
I'm organizing the sprints, which I forgot,

2781
02:22:51,300 --> 02:22:53,500
if they're on Saturday or Sunday.

2782
02:22:53,500 --> 02:22:55,540
But basically I'm gonna work on,

2783
02:22:55,540 --> 02:22:58,100
all the things I'm missing for the safety,

2784
02:22:58,100 --> 02:23:00,100
and hopefully maybe improving the workshop as well,

2785
02:23:00,100 --> 02:23:00,940
with more information.

2786
02:23:00,940 --> 02:23:03,500
So make sure you take an eye on this.

2787
02:23:05,340 --> 02:23:07,900
Yeah, that's pretty much everything.

2788
02:23:07,900 --> 02:23:08,740
Thank you.

2789
02:23:09,620 --> 02:23:10,740
Alright, thank you.

2790
02:23:10,740 --> 02:23:11,580
Thank you.

2791
02:23:11,580 --> 02:23:12,420
Thank you.

2792
02:23:13,660 --> 02:23:16,640
Thank you, thank you for coming.

2793
02:23:16,640 --> 02:23:17,820
Oh, my gosh.

2794
02:23:17,820 --> 02:23:21,820
I wanna say thank you toן

2795
02:23:21,820 --> 02:23:25,740
for all the noble love I have forG1.

2796
02:23:25,740 --> 02:23:28,020
Thank you very much.

2797
02:23:28,020 --> 02:23:30,860
Thank you very much for being here.

2798
02:23:30,860 --> 02:23:33,820
Go to our YouTube channel,

2799
02:23:33,820 --> 02:23:36,020
or to GoYouTube YouTube channel,

2800
02:23:36,020 --> 02:23:38,020
and take some YouTubeенной percent less fun

