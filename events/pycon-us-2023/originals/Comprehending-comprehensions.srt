1
00:00:00,000 --> 00:00:09,620
Okay. Well, let's start. Excellent. Wow. No one told me so many people come to tutorials

2
00:00:09,620 --> 00:00:16,520
at PyCon. So, excellent. Excellent. Welcome, everyone. My name is Reuven. Just a word or

3
00:00:16,520 --> 00:00:21,960
two about who I am, what I do, and then we'll jump right into things. So, I have been freelancing

4
00:00:21,960 --> 00:00:27,800
since 1995. I've been using Python for about 30 years now. And nowadays, I'm a full-time

5
00:00:27,880 --> 00:00:31,280
Python trainer. So, I work with companies all around the world, individuals all around the

6
00:00:31,280 --> 00:00:35,000
world, helping them to improve their Python skills. I do a lot of corporate training.

7
00:00:35,000 --> 00:00:38,360
I have a lot of videos. I have all sorts of stuff. And I'll even have a booth here at

8
00:00:38,360 --> 00:00:42,000
PyCon so you can come by and talk to me more and hear more about stuff and get T-shirts

9
00:00:42,000 --> 00:00:49,280
because you are coders and all coders need more T-shirts or so I tell my family. So,

10
00:00:49,280 --> 00:00:52,280
what are we going to be talking about today? We're going to be talking about comprehensions.

11
00:00:52,280 --> 00:00:57,300
And I must say, comprehensions are at once one of the things that I most love using and

12
00:00:57,340 --> 00:01:03,340
teaching about. They're also one of the things that are incredibly mysterious, off-putting,

13
00:01:03,460 --> 00:01:10,180
frustrating, on, on, and on. A number of years ago, I was interviewed on a podcast, and the

14
00:01:10,180 --> 00:01:16,380
two hosts of the podcast asked me, so what is the hardest thing for people when I'm teaching

15
00:01:16,380 --> 00:01:20,860
them Python? I said, oh, hands down, it's comprehensions. And both the hosts said, oh,

16
00:01:20,860 --> 00:01:27,500
yeah, we don't quite get them either. So, it is a very, very widespread frustration.

17
00:01:27,500 --> 00:01:30,740
And many people are like, well, you don't need them. I'll just use a regular for loop.

18
00:01:30,740 --> 00:01:34,580
Or they're just confusing. Or on, on, and on. And what I'm hoping that you're going

19
00:01:34,580 --> 00:01:39,580
to find today is that comprehensions are, you know, to use the phrase, comprehensible,

20
00:01:39,580 --> 00:01:44,180
they are understandable, and they're even desirable in many, many cases. And they're

21
00:01:44,180 --> 00:01:49,500
definitely part of idiomatic Python. And so, we're going to be doing, I'm going to be going

22
00:01:49,540 --> 00:01:52,940
through a lot of demonstrations here. I'll explain to you in a moment how I teach. We're

23
00:01:52,940 --> 00:01:57,980
going to be doing a lot of exercises. And I'm very, very, very much hoping that if you

24
00:01:57,980 --> 00:02:02,740
are frustrated, confused, things aren't working for you in the exercise, or you don't get

25
00:02:02,740 --> 00:02:06,700
what I'm saying, that you will tell me. My job is to make sure that you understand what's

26
00:02:06,700 --> 00:02:12,860
going on. And so, if you leave here not understanding, then I haven't done my job well. And so, also,

27
00:02:12,860 --> 00:02:17,620
the odds are staggeringly high that if you have a question, someone else has the same

28
00:02:17,700 --> 00:02:21,900
question. And so, you will be doing them a favor if you ask the question, because otherwise,

29
00:02:21,900 --> 00:02:25,620
the two of you are like, well, I don't want to embarrass myself. So, if you want, you

30
00:02:25,620 --> 00:02:29,500
can just raise your hand, and I'll call on you. And you can take a question, I'll repeat

31
00:02:29,500 --> 00:02:33,980
it here. If you have a long, complex question, I won't repeat it well, because we'll be paying

32
00:02:33,980 --> 00:02:38,740
like Python telephone, you can get up to the microphone. I like my classes to be super

33
00:02:38,740 --> 00:02:42,380
interactive. I don't just like lecturing, although my children would perhaps disagree

34
00:02:42,380 --> 00:02:46,180
with that. I definitely want this to be a lot of give and take, a lot of what ifs, a

35
00:02:46,220 --> 00:02:50,980
lot of sort of bringing up your own experiences. Now, the other thing is I don't use slides

36
00:02:50,980 --> 00:02:55,020
when I teach. Instead, I use Jupyter. I think I sent email about this. I hope I sent email

37
00:02:55,020 --> 00:02:57,820
about this. And so, basically, here, I'm going to show you. This is my Jupyter notebook.

38
00:02:57,820 --> 00:03:02,380
I've enlarged it so you, oh, I have this screen here. Fantastic. Wow. It's like they thought

39
00:03:02,380 --> 00:03:06,620
of everything. I'm going to make this a little smaller so it doesn't seem so ridiculously

40
00:03:06,620 --> 00:03:11,620
comical. I hope that those of you in the back can see this. If not, I guess that will be

41
00:03:11,620 --> 00:03:15,580
the first question, right? And so, I'm going to be typing into Jupyter live coding, both

42
00:03:15,620 --> 00:03:21,420
some documentation and a lot of code. And this is uploaded to GitHub on a regular basis,

43
00:03:21,420 --> 00:03:24,780
about once every minute or two. In fact, let me just turn on auto save 30 so it will be

44
00:03:24,780 --> 00:03:30,100
even faster than that. And so, that GitHub repo will be available to you while we are

45
00:03:30,100 --> 00:03:37,100
here. And if you go to GitHub, and I'm at GitHub.com slash Reuven, spelled the way it's

46
00:03:37,100 --> 00:03:43,100
pronounced, haha. All right. I can put this here as well. So, GitHub repo for this course.

47
00:03:43,220 --> 00:03:49,740
And I'm using something called git auto push. And so, every, as I said, like minute or so,

48
00:03:49,740 --> 00:03:52,460
whatever I do will be pushed up there and you can look at it. And you can look at it

49
00:03:52,460 --> 00:03:56,260
after the tutorial is done as well, you know, if you want to refresh your memory or are

50
00:03:56,260 --> 00:04:00,740
having trouble falling asleep at night. We will be using some files that I put in that

51
00:04:00,740 --> 00:04:04,180
GitHub repo as well. I also sent you a link where you can download them. I think I made

52
00:04:04,180 --> 00:04:08,060
them downloadable via the platform that we're using for PyCon. We're not going to use all

53
00:04:08,060 --> 00:04:11,780
those files, but we are going to use some of them. And the idea is basically that we're

54
00:04:11,780 --> 00:04:16,500
going to be using some files for things. So, it would be useful to have them, right? Okay.

55
00:04:16,500 --> 00:04:21,780
So, let's do a little agenda here. So, the first thing is like what are comprehensions?

56
00:04:21,780 --> 00:04:25,860
Right? And then we're going to talk about list comprehensions. We're going to talk

57
00:04:25,860 --> 00:04:29,660
that and we're going to do that for quite a while. We're going to talk about list comprehensions

58
00:04:29,660 --> 00:04:35,140
and files. We are going to then talk about set comprehensions. We're going to talk about

59
00:04:35,140 --> 00:04:39,940
dict comprehensions. The word comprehensions is going to come up a lot today. Then we're

60
00:04:39,940 --> 00:04:45,900
going to talk about nested comprehensions and finally we will talk about generator expressions.

61
00:04:45,900 --> 00:04:50,180
These last two topics we're going to cover relatively briefly. Also, like the way I teach,

62
00:04:50,180 --> 00:04:55,860
it's often a lot of flexibility here in terms of time. But don't worry, we will get to everything

63
00:04:55,860 --> 00:05:00,060
and we will practice everything and we will get to your questions. And if I have to stay

64
00:05:00,060 --> 00:05:06,060
a little bit later and answer your questions, that is okay too. The only, only rule is that

65
00:05:06,180 --> 00:05:11,020
there is a break at three with food and if I stop you from getting to that, then there

66
00:05:11,020 --> 00:05:15,940
will be no second half of this tutorial because I will be a rotting corpse after you have

67
00:05:15,940 --> 00:05:21,460
dealt with it for not getting to your food. So, I recognize there are important constraints

68
00:05:21,460 --> 00:05:28,460
in the universe. Okay. So, let's start talking about what is a comprehension. And let's say,

69
00:05:28,860 --> 00:05:33,460
I know this is going to be very similar to the work that you all do day after day. Let's

70
00:05:33,500 --> 00:05:40,500
say I have a list of numbers of integers and I want to create a list of those integers

71
00:05:41,780 --> 00:05:46,180
to, you know, squared, to the second power. Right? Right? That's what you do all day.

72
00:05:46,180 --> 00:05:49,420
That's what it's like in big companies, I know. So, how am I going to do this? Well,

73
00:05:49,420 --> 00:05:53,780
I can say here numbers equals, I'll just say it's a range. Actually, I'll make a list.

74
00:05:53,780 --> 00:05:57,580
Not that it matters that much, but I have to stick true to the documentation. Otherwise,

75
00:05:57,580 --> 00:06:01,900
the next, you know, at the next meeting they'll get me. And then we can look at numbers here

76
00:06:01,900 --> 00:06:05,820
and sure enough that's a list of ten numbers. And I can say then, well, I'll create output

77
00:06:05,820 --> 00:06:12,820
is an empty list. And I'll say for one number in numbers, I'll say output append one number

78
00:06:12,860 --> 00:06:19,860
to the second power. And sure enough, wow, amazing. The next IPO in tech is waiting right

79
00:06:20,100 --> 00:06:24,660
here in Salt Lake City. So, what is going on here? Well, I'm creating a list, output

80
00:06:24,660 --> 00:06:28,860
equals empty list. And then I go through it one element at a time. And each of those elements

81
00:06:28,860 --> 00:06:33,100
is then squared and we append that to output. And so our list is growing and growing over

82
00:06:33,100 --> 00:06:38,660
time. And sure enough, then we get that output. Fantastic. And this is where I say, as I so

83
00:06:38,660 --> 00:06:45,380
like to, unfortunately, this works. You absolutely positively do get the right answer in doing

84
00:06:45,380 --> 00:06:50,360
this way. And an awful lot of Python developers will say it's so obvious, it's so straightforward,

85
00:06:50,360 --> 00:06:56,060
why not just stick with this syntax? To which experience Python people are like, oh, my

86
00:06:56,060 --> 00:06:59,940
God, another person I've got to convince this of. No, no, no. It's natural that you want

87
00:06:59,940 --> 00:07:05,320
to stick with things that are familiar and less sort of daunting. So, what is another

88
00:07:05,320 --> 00:07:12,320
way to do this? Well, it's going to be a list comprehension. And so here's what I'm going

89
00:07:12,360 --> 00:07:16,100
to do. I'm going to take that same code and I'm going to rewrite it as a comprehension.

90
00:07:16,100 --> 00:07:19,340
I'm going to run it to prove to you that it actually works. And then we're going to go

91
00:07:19,340 --> 00:07:24,440
through it and talk about what it's doing and how it's doing it and what it's not doing.

92
00:07:24,440 --> 00:07:30,060
So I'm going to say here, one, let's start by spelling it right, one number to the second

93
00:07:30,060 --> 00:07:37,580
power for one number in numbers. First of all, it works. Second of all, writing code

94
00:07:37,580 --> 00:07:41,640
like this guarantees me job security because no one else will ever be able to understand

95
00:07:41,640 --> 00:07:46,920
what I'm doing and they'll have to keep me around. But what is actually going on here?

96
00:07:46,920 --> 00:07:55,980
This is, of course, a list comprehension. And it's much easier to write and understand

97
00:07:55,980 --> 00:08:04,660
if we pick it apart and write it on multiple lines. And you might be saying, wait, how

98
00:08:04,660 --> 00:08:10,040
can we do that? Python is so persnickety about how we do indentation. That is true except

99
00:08:10,040 --> 00:08:13,900
when we've opened parentheses. Because the moment you open parentheses, then Python's

100
00:08:13,900 --> 00:08:17,360
like, oh, yeah, that's part of the same line. We're just going to sort of ignore it. So

101
00:08:17,360 --> 00:08:21,620
I'm going to put these on two separate lines. And once I do that, first of all, from my

102
00:08:21,620 --> 00:08:26,380
perspective, it becomes much, much more obvious what's going on. And second of all, now we

103
00:08:26,380 --> 00:08:30,340
can start to reason about what it's doing. And I'll tell you, the moment that I started

104
00:08:30,340 --> 00:08:35,680
writing my list comprehension on multiple lines, things got way easier for me and for the participants

105
00:08:35,680 --> 00:08:39,880
in my courses. This was probably, I don't know, 10 years ago, something like that. And

106
00:08:40,880 --> 00:08:46,120
I remember I have a very, very, very low score on Stack Overflow, in part because years ago

107
00:08:46,120 --> 00:08:51,680
I posted something about list comprehensions and I posted it using this kind of syntax.

108
00:08:51,680 --> 00:08:55,160
And someone was like, that's ridiculous. That's terrible. And I was so put off, I was like,

109
00:08:55,160 --> 00:08:59,220
I'm never coming back to this site, which was a lie. But fine, we need somewhere to

110
00:08:59,220 --> 00:09:04,280
copy and paste from. In any case, what's actually going on here? So the first thing that you

111
00:09:04,280 --> 00:09:09,000
want to understand is that there are two parts to this comprehension. We're going to grow

112
00:09:09,000 --> 00:09:13,840
that over time. But the two basic parts. And the first part here is what I call the expression.

113
00:09:13,840 --> 00:09:20,840
And this can be any Python expression at all, which means any function call, any method

114
00:09:20,840 --> 00:09:27,080
call, any operator, anything at all that returns a value. That last part is kind of important.

115
00:09:27,080 --> 00:09:30,200
And if you're not familiar with the whole idea of what is an expression in Python, it's

116
00:09:30,200 --> 00:09:33,640
something that gives me back a value. So it could just be a plain old variable. It could

117
00:09:33,640 --> 00:09:38,080
be calling a function or method on that variable. It could be the interaction among several

118
00:09:38,080 --> 00:09:42,040
variables, whatever. But whatever that expression gives back, that's what we're going to have.

119
00:09:42,040 --> 00:09:49,240
And then here is the iteration. Any Python loop. And once again, this works. And many

120
00:09:49,240 --> 00:09:53,160
people look at this and they say, oh, I get it. A comprehension is just a really, really

121
00:09:53,160 --> 00:10:00,220
short for loop. It's like a compact way of writing a for loop. And that's sort of true.

122
00:10:00,220 --> 00:10:05,800
But it's mostly not true. Because and here's the big distinction. Well, actually, we'll

123
00:10:05,800 --> 00:10:10,360
get to the distinction a little bit. Let's talk through a little more here. So one of

124
00:10:10,360 --> 00:10:14,920
the things that's frustrating for people is that comprehensions seem to run backwards.

125
00:10:14,920 --> 00:10:23,920
So in a comprehension, the first thing, first, boy, oh, boy, thing that runs is the loop.

126
00:10:23,920 --> 00:10:30,000
And the second thing is the expression. So it's like written backwards. And that's very

127
00:10:30,000 --> 00:10:34,760
sort of surprising to many people. And so what's happening here is our for loop is running

128
00:10:34,760 --> 00:10:38,680
just like a regular for loop. Well, mostly like a regular for loop. And so we're going

129
00:10:38,680 --> 00:10:42,800
to iterate over numbers. And so it has to be iterable. Numbers is a list. It's iterable.

130
00:10:42,800 --> 00:10:46,240
So the for loop sets the numbers. Are you iterable? Yes. So give me your next thing.

131
00:10:46,240 --> 00:10:49,640
The next thing is put into one number. And then we get our expression back. And then

132
00:10:49,640 --> 00:10:53,880
we go to the next thing. Here's the thing. At least the way that I've written the comprehension

133
00:10:53,880 --> 00:11:01,020
here, we will have so the result of a list comprehension is a list. We have created a

134
00:11:01,020 --> 00:11:12,020
new list. And we can pass it as an argument to a function or assign it to a variable or

135
00:11:12,020 --> 00:11:17,100
just enjoy its exquisite beauty. I don't know. We can do whatever we can do with a list.

136
00:11:17,100 --> 00:11:22,380
This is a new list. It is completely unconnected to the previous list. And the new list is

137
00:11:22,380 --> 00:11:29,340
the result of evaluating our expression on every element of the input. Input we'll call

138
00:11:29,340 --> 00:11:34,900
a list. So basically what's happening, every single element of numbers is passing through

139
00:11:34,900 --> 00:11:40,500
that expression. And whatever the result of that expression is, that's what is put in

140
00:11:40,500 --> 00:11:49,220
the output list. So as a result, the output list will have the same number of elements

141
00:11:49,220 --> 00:11:55,100
as the input list. So here numbers is ten elements, ten numbers. The output from this,

142
00:11:55,100 --> 00:11:58,920
which I haven't named here, I'm just seeing it in Jupyter, the output is also ten elements.

143
00:11:58,920 --> 00:12:02,320
And each of those elements you can think of it as mapping one to the other. So the

144
00:12:02,320 --> 00:12:07,160
zero index is zero, kind of appropriate. And then the output is also going to be zero because

145
00:12:07,160 --> 00:12:12,840
zero squared is zero. Let's go past one. So at index zero one two, we've got the number

146
00:12:12,840 --> 00:12:18,000
two and that squared is four. So we can see them as two parallel lists, the input and

147
00:12:18,000 --> 00:12:22,040
the output, where the difference between them is the expression. You can sort of kind of

148
00:12:22,040 --> 00:12:26,480
think of this as working with a spreadsheet in Excel, right, where you've got a column

149
00:12:26,480 --> 00:12:31,400
of numbers and you apply some expression to all of those numbers and you paste it into

150
00:12:31,400 --> 00:12:37,040
a column next to that. That's kind of what we're doing here in our comprehension. Now,

151
00:12:37,040 --> 00:12:41,720
the fact that so many things in Python are iterable and that we have more or less an

152
00:12:41,720 --> 00:12:47,600
infinite number of expressions means that list comprehensions are huge, right? We can

153
00:12:47,600 --> 00:12:52,680
use them in all sorts of places. But let's back up for a moment. Why? Why would I use

154
00:12:52,680 --> 00:12:56,920
them? What is the advantage of using a list comprehension rather than just using a regular

155
00:12:56,920 --> 00:13:01,880
old for loop? Like, if it's going to frustrate people, right, which is good for the tutorial

156
00:13:01,880 --> 00:13:07,080
business but bad for humanity in general, then maybe we should just stick with regular

157
00:13:07,080 --> 00:13:12,160
for loops. And the distinction is basically one of what do you want to do with things,

158
00:13:13,000 --> 00:13:26,840
right? So when use a loop and when a comprehension? And so basically the big distinction is between

159
00:13:26,840 --> 00:13:41,920
getting a new value back and having side effects. Meaning, if you have an existing list and

160
00:13:41,920 --> 00:13:49,880
you want a new list and you can describe the sort of mapping from the first to the

161
00:13:49,880 --> 00:13:57,360
second, then you should use a comprehension. And the idea is I want to get that list back,

162
00:13:57,360 --> 00:14:10,720
right? I want the list. But if you are assigning repeatedly, if you are modifying things repeatedly,

163
00:14:10,720 --> 00:14:16,480
then use a regular for loop. That's the big distinction. Am I doing it for the side effects

164
00:14:16,480 --> 00:14:22,120
of what I assign and change and mutate or am I doing it to get a list back? Now, when

165
00:14:22,120 --> 00:14:28,480
you start off with comprehensions, these two ideas seem almost completely like the same.

166
00:14:28,480 --> 00:14:34,080
It takes time. It takes years of using comprehensions to slowly but surely see when you would use

167
00:14:34,080 --> 00:14:39,840
one versus the other, right? It's not a super, super obvious distinction. And again, the

168
00:14:39,840 --> 00:14:45,400
fact is you can use a regular for loop in many cases. Now, I'll tell you the other reason

169
00:14:45,400 --> 00:14:51,400
to use comprehensions, which is the bad reason. And the bad reason is that it is more efficient.

170
00:14:51,400 --> 00:14:54,920
Now, why is that the bad reason? Because it's not always more efficient. It's not always

171
00:14:54,920 --> 00:14:59,000
hugely more efficient. When I teach people who come from a C background, they're like,

172
00:14:59,000 --> 00:15:03,360
oh, well, that's why I'm going to use it. I must use the thing that's faster. Okay. Calm

173
00:15:04,360 --> 00:15:10,240
down, C people. Yes, yes, we do want it to be faster, but that's not our ultimate goal

174
00:15:10,240 --> 00:15:15,680
in Python. Here the idea is that semantically it's expressing something more powerfully

175
00:15:15,680 --> 00:15:19,560
and more compactly. And you're going to see as today goes on that we can do very, very

176
00:15:19,560 --> 00:15:25,400
sophisticated things with comprehensions if we want to. Okay. So let me show you some

177
00:15:25,400 --> 00:15:32,400
more sort of useful examples, right? So let's do this. What if I say here, so for example,

178
00:15:34,360 --> 00:15:40,440
let's say that I have a list of strings. So I'm going to say here s equals, well, my list

179
00:15:40,440 --> 00:15:47,440
equals abcd, ef, gh, i. And I want to have a new string based on my list with stars between

180
00:15:51,560 --> 00:15:57,600
the elements. Okay. Well, as you know, might know, I can say star dot join of my list.

181
00:15:57,600 --> 00:16:02,500
Fantastic. That worked just great. Right? So the join method, rather counterintuitively

182
00:16:02,500 --> 00:16:07,740
for many people, we invoke it on what I call the glue, right? The string that's going to

183
00:16:07,740 --> 00:16:12,620
go between the elements. And we pass the argument of my list. And fantastic. We get back the

184
00:16:12,620 --> 00:16:19,620
string. But what if I have a list of integers? So if I say my list equals 10, 20, 30, and

185
00:16:22,380 --> 00:16:29,380
now I say star join of my list, bad news. We get an error. And the reason is that join

186
00:16:29,580 --> 00:16:34,300
expects its argument to be an iterable of strings. You can pass it whatever you want.

187
00:16:34,300 --> 00:16:38,700
A string, a list, a tuple, whatever. But the things that it's going to iterate over have

188
00:16:38,700 --> 00:16:45,700
to be strings. Uh-huh. So we have a list of integers. We want a list of strings. And we

189
00:16:47,700 --> 00:16:54,700
can convert one into one string with stir. So I can say, open square brackets, stir of

190
00:16:54,820 --> 00:17:01,820
one item for one item in my list. And sure enough, I get back a list of strings. Have

191
00:17:05,780 --> 00:17:12,300
I modified my list? No. Have I assigned this anywhere? No. But I can if I want to. I've

192
00:17:12,300 --> 00:17:16,020
created a new list and I can do something with it. For example, I could say here, star

193
00:17:16,020 --> 00:17:23,020
dot join of that whole thing, stir of one item for one item in my list. And there we

194
00:17:23,020 --> 00:17:30,020
go. Now it worked. I did not change the original list, but I got back a new list based on it

195
00:17:30,060 --> 00:17:34,860
that join was okay with. And this is a classic sort of example of where we're going to use

196
00:17:34,860 --> 00:17:40,460
a comprehension. That I have some iterable. I want to do some transformation on each element.

197
00:17:40,460 --> 00:17:45,940
And the comprehension allows me to do that. Some of you might be familiar with either

198
00:17:45,940 --> 00:17:52,340
in Python or other languages with a map function. And the map function does basically this.

199
00:17:52,340 --> 00:17:58,620
In fact, Python has map and it has filter. And we're going to see in a little bit where

200
00:17:58,620 --> 00:18:03,540
filter fits into this whole puzzle. But basically nowadays people don't use map and people don't

201
00:18:03,540 --> 00:18:07,820
use filter because we have list comprehension. They've basically obviated the need for those

202
00:18:07,820 --> 00:18:12,340
built ins even though they do still exist. And this is definitely considered to be the

203
00:18:12,340 --> 00:18:17,700
modern idiomatic way to do this sort of thing. Let me show you one more example. So let's

204
00:18:17,860 --> 00:18:24,860
say I have a string and I want to capitalize each, the start of each word. Well, if I say,

205
00:18:30,500 --> 00:18:37,500
you know, this is a sample sentence for my tutorial. So I can say s.title. And the title

206
00:18:39,820 --> 00:18:44,500
method is a string method. And it returns a new string. Can't modify the original string

207
00:18:44,580 --> 00:18:49,060
because strings are immutable. And I get back a new string where each and every word, the

208
00:18:49,060 --> 00:18:56,060
first letter is capitalized and the rest of the letters are lowercase. So what if s.title

209
00:18:56,060 --> 00:19:03,060
didn't exist? Could I still do something like this? And the answer is, of course I can.

210
00:19:03,660 --> 00:19:10,660
It's Python. So what if, for example, I were to break the string into individual words?

211
00:19:10,660 --> 00:19:17,660
Then I have a list of strings. I want a list of strings whose first letters are capitalized.

212
00:19:24,100 --> 00:19:31,100
I can use str.capitalize, not to be confused with str.title, which capitalizes the first

213
00:19:31,220 --> 00:19:38,220
letter and makes all the rest lowercase. So if I now say s.capitalize, or I'm sorry, let's

214
00:19:38,260 --> 00:19:45,260
do one word dot capitalize for one word in s.split. And look at that. So I use split.

215
00:19:47,220 --> 00:19:51,900
I got back a list of strings. And because I didn't specify any argument, so it uses

216
00:19:51,900 --> 00:19:56,540
any whitespace, any combination of whitespace. And so I got back a list, a list of strings.

217
00:19:56,540 --> 00:20:00,700
And we iterate over that list of strings. Each string then we run one word dot capitalize

218
00:20:00,700 --> 00:20:04,820
on. We get back that list. Well, that's fantastic, but, you know, wouldn't I like to see it put

219
00:20:04,820 --> 00:20:09,340
back together? Well, I'm sorry. Putting back together is more advanced. I have to say then

220
00:20:09,340 --> 00:20:16,340
space dot join of this whole thing. And look at that. And so many, many times the way that

221
00:20:18,420 --> 00:20:23,420
we use comprehension is that we start with something big. We break it apart. You just

222
00:20:23,420 --> 00:20:27,820
put it here. I'll have it later. Or put it back. Put it back. Thanks. Sorry, there was

223
00:20:27,820 --> 00:20:31,260
a whole mix up with kosher food earlier. Very exciting. I can bore you to tears with it

224
00:20:31,260 --> 00:20:38,160
later on. In any event, so I'm going to split things up, break things apart, apply my expression

225
00:20:38,160 --> 00:20:43,140
to each element, and then I'll mush it all back together. So split and join when you're

226
00:20:43,140 --> 00:20:47,100
working with comprehensions are like, you know, your best friends. All the time. All

227
00:20:47,100 --> 00:20:52,860
the time. Can I use functions that I've written? Yeah. Can I use methods that I've written

228
00:20:52,860 --> 00:20:58,900
on classes? Yes, absolutely. There is no limit to what expressions we can use and what we

229
00:20:58,900 --> 00:21:03,940
can iterate over. All right. Let me stop here. Any questions, confusion, so on and

230
00:21:03,940 --> 00:21:10,940
so forth? Yeah, please. Yes. Especially as they get bigger, they are definitely more

231
00:21:17,460 --> 00:21:21,900
performant than for loops, but every time I demonstrate this, I discover that they're

232
00:21:21,900 --> 00:21:26,540
not in my little examples. So I'm not going to take that risk and let everyone know. Right,

233
00:21:27,220 --> 00:21:32,180
exactly. I use time it and I'm like, look, it's oh, no. So you need something a little

234
00:21:32,180 --> 00:21:37,820
bigger than I show people. But yeah, the other thing, and I think I wrote something about

235
00:21:37,820 --> 00:21:43,300
this on Twitter a while ago. I've got to write more about it. But in a list comprehension,

236
00:21:43,300 --> 00:21:48,100
it has its own scope because there's a little function hidden inside of there. So any variables

237
00:21:48,100 --> 00:21:54,340
you define, like this one word, does not leak out. So it's not going to affect your global

238
00:21:54,340 --> 00:22:00,980
scope. If that sounded like gobbledygook to you, ignore it. It is not that important.

239
00:22:00,980 --> 00:22:07,980
If that was like, oh, wow, scoping, then yeah, you're my kind of people. Anyway, other questions?

240
00:22:09,420 --> 00:22:16,420
Okay. So let's do some exercises to practice with this and try it out. Oops. There we go.

241
00:22:17,020 --> 00:22:24,020
So what I want to do is first of all ask the user to enter a string containing numbers

242
00:22:24,500 --> 00:22:31,500
separated by spaces and then add those numbers together as integers and print the result.

243
00:22:36,940 --> 00:22:43,940
And it's okay to use the built-in sum function. And the second thing is ask the user to enter

244
00:22:44,340 --> 00:22:51,340
a string and print the length of the string except for whitespace. And it's not going

245
00:22:54,420 --> 00:22:59,420
to work. It's not okay to use store replace. There's always someone. Always someone. All

246
00:22:59,420 --> 00:23:03,260
right. So I'll give you folks a few minutes to work on this. If you have questions, problems,

247
00:23:03,260 --> 00:23:10,260
whatever, I'm happy to come over to you and take a look at whatever's going on. All right.

248
00:23:10,260 --> 00:23:17,260
So we'll give... I'm sorry, what? Oh, how many numbers? Five. You failed the tutorial if

249
00:23:17,780 --> 00:23:24,780
you do it with four. By the way, obviously everyone here is at a different level of Python

250
00:23:24,780 --> 00:23:28,900
and so people are going to know different sort of tricks and tips and methods and functions.

251
00:23:28,900 --> 00:23:31,620
So if you find yourself like, oh, I don't know what's going on, or like if you need

252
00:23:31,620 --> 00:23:36,660
some help, it's okay. I can help you. Not that school should be that way, but like this

253
00:23:36,660 --> 00:23:43,660
is not school. I'm happy to help. Okay. Let's start to look at this together. So I'm going

254
00:23:44,300 --> 00:23:51,300
to say s equals, I can say input, enter a string, or enter numbers separated by white

255
00:23:51,580 --> 00:23:58,580
space. Strip there. So I'll do like 10, 20, 30, 40, 45. What a rebel. So I have s here

256
00:24:01,780 --> 00:24:07,180
and this is a string. So what if I try to say sum of s? That will obviously not work

257
00:24:07,180 --> 00:24:14,180
at all. That's because sum looks at this thing that it got and actually tries to iterate

258
00:24:14,220 --> 00:24:17,620
over. It's like, wait, wait, wait, wait. I'm trying to start with zero and I'm trying to

259
00:24:17,620 --> 00:24:22,460
add to that and I can't add a string there. So we have this problem now where we've got

260
00:24:22,460 --> 00:24:29,460
an iterable string. So what I have is a string and what I want is the sum of the integers

261
00:24:29,460 --> 00:24:36,460
in that string. Maybe I should start off with something different. Maybe I should do a list

262
00:24:38,300 --> 00:24:45,300
of strings and then containing digits. So how can I do that? I can transform one to

263
00:24:48,700 --> 00:24:55,700
the other with int. So I can say here, for example, one item, the int of one item for

264
00:24:56,700 --> 00:25:03,700
one item in s split and look at that. It's a list of integers. So now I can say sum of

265
00:25:04,540 --> 00:25:11,540
int one item for one item in s split. There we go. Add them together just fine. Because

266
00:25:12,660 --> 00:25:19,300
what's going on? Right? Sum never sees our list of strings. As far as it's concerned,

267
00:25:19,300 --> 00:25:24,340
sum is getting a list of integers as its input. And so we're able to sort of mediate between

268
00:25:24,340 --> 00:25:31,340
the two of them. Questions about this one at all? Yeah, please. Oh, because, well, I

269
00:25:36,940 --> 00:25:43,940
didn't define items. I could say items equals s split. Oh. Okay. Excellent. Excellent question.

270
00:25:47,420 --> 00:25:54,220
Watch this. What if I were to say here sum of int of one item for one item in s? So I

271
00:25:55,220 --> 00:26:00,220
could say, yeah, so it's going to go very poorly. Why? What's going on? What's the problem?

272
00:26:00,220 --> 00:26:06,020
Well, it turns out that I had spaces between my numbers here. So it was going to add one.

273
00:26:06,020 --> 00:26:11,300
So far so good. Zero. So far so good. Space. Kablui. Now, that is a totally, totally legitimate

274
00:26:11,300 --> 00:26:18,300
other thing. Sometimes I give that as an exercise, too. Okay. No, no, no. That's fine. That's

275
00:26:19,100 --> 00:26:24,100
fine. Everyone in all software always pays attention to all specifications. So it's never

276
00:26:24,100 --> 00:26:31,100
an issue. Yes, someone had a question back there? No? Any other questions? Okay. So let's

277
00:26:31,260 --> 00:26:37,100
look at the second one here. Oh, and I'll try to remember to repeat the questions that

278
00:26:37,100 --> 00:26:40,780
people are asking because the video is not getting them. I'm sorry about that, people

279
00:26:40,780 --> 00:26:47,380
on video. You should be here with us. Okay. So now the second thing that I said was find

280
00:26:47,380 --> 00:26:54,380
the lengths of the words, not the whitespace, in the user's input. So if I say s equals

281
00:26:55,900 --> 00:27:02,900
input, enter a sentence. And then what I want to do is I want to know how, well, I can find

282
00:27:03,980 --> 00:27:10,980
out len of s, how many characters in the entire sentence. So if I say this is a test sentence,

283
00:27:11,980 --> 00:27:18,980
it's going to say 23, which is true, but that's not what I wanted. How long is this if we

284
00:27:20,540 --> 00:27:27,540
ignore the whitespace? So what I'm going to do is if I use s.split, I get a list of strings

285
00:27:30,860 --> 00:27:37,860
without any whitespace. And then I have a list of strings. I want the sum of their lengths.

286
00:27:38,860 --> 00:27:45,860
Right? And I can apply len. So if I now say, for example, one word for one word in s.split,

287
00:27:50,740 --> 00:27:57,740
let's just get the sentence there, okay? This is a test sentence. Now I can say len of one

288
00:27:57,740 --> 00:28:04,140
word, not len-m, one word. Now I have a list of integers. And now what I can do is I can

289
00:28:04,140 --> 00:28:09,860
say sum of this whole business, and there we go. And I get the sum of the lengths of

290
00:28:09,860 --> 00:28:14,660
the words without the whitespace. And again, it's this sort of breaking down and building

291
00:28:14,660 --> 00:28:18,660
back up that's key to using comprehension. You're thinking about what can I do for each

292
00:28:18,660 --> 00:28:25,660
of these little pieces? Questions about this? Yeah, please. Oh, so the question is why do

293
00:28:34,340 --> 00:28:40,060
strip take away the whitespaces from the count? Oh, why didn't it? Oh, I see. So you're asking

294
00:28:40,060 --> 00:28:45,900
like my original strip back when I got input. So when I did strip here, shouldn't that have

295
00:28:45,900 --> 00:28:52,180
taken care of the whitespace? And the answer is, as always with me, yes and no. So strip

296
00:28:52,180 --> 00:28:56,800
removes all the whitespace from either side of a string but does not touch the whitespace

297
00:28:56,800 --> 00:29:03,800
inside of the string. So if I say, for example, like s equals a, b, c, and then I get a string

298
00:29:04,300 --> 00:29:11,300
and I say s.strip, it'll still leave the whitespace inside. Okay? So the question is split automatically

299
00:29:17,020 --> 00:29:23,300
splits by space, and the answer is once again yes and no. If you split without any argument,

300
00:29:23,300 --> 00:29:29,140
then it will take any whitespace character, which is space, character term, tab, new line,

301
00:29:29,140 --> 00:29:33,860
and my favorite, vertical tab. So any one or more of those together are all considered

302
00:29:33,860 --> 00:29:39,460
one space and those get out and that's where we cut. So yes, it spaces, but it's more.

303
00:29:39,460 --> 00:29:45,740
It's space plus. And so basically, if you want to split a sentence into words, then

304
00:29:45,740 --> 00:29:52,740
not giving an argument to split is just super, super easy. Any other questions so far? Okay.

305
00:29:53,580 --> 00:30:00,580
Let me go back to this for a moment here. Let me go back to one of the previous comprehensions

306
00:30:00,620 --> 00:30:05,020
just to sort of show you one other way to think about this. So I'm going to just grab

307
00:30:05,020 --> 00:30:11,500
this because I can. All right. So what I have here is, of course, what I said before, my

308
00:30:11,500 --> 00:30:16,220
two lines, and I call this first one the expression and the second one the iteration. There is

309
00:30:16,220 --> 00:30:23,220
another way to think about this, and that is if you know SQL, this is a lot like select

310
00:30:24,180 --> 00:30:30,060
and this is a lot like from. Now, if you don't know SQL, now I've confused you twice as much,

311
00:30:30,060 --> 00:30:35,340
but if you do, then this is like exactly the same sort of mindset. And just as with select

312
00:30:35,340 --> 00:30:40,460
and SQL, I can apply all sorts of different functions, methods. I just want an expression.

313
00:30:40,460 --> 00:30:46,580
And if I use from, well, it's from any interval. And basically everything in Python is iterable,

314
00:30:46,580 --> 00:30:51,580
so that's great. Oh, okay. This split didn't really do what we wanted, but fine. Doesn't

315
00:30:51,580 --> 00:30:56,580
matter. Right? If I say your SQL is 10, 20, 30, now it won't blow up. There we go. Let

316
00:30:56,860 --> 00:31:02,580
me show you one more thing, one very, very common mistake that people make with comprehensions.

317
00:31:02,580 --> 00:31:09,580
So let's say, so I have a string with words, and I want to print each word with some sort

318
00:31:10,460 --> 00:31:14,540
of stars around it, like we're moving to Hollywood or something. So if I say s equals,

319
00:31:14,540 --> 00:31:21,540
this is fantastic. And so I'm going to say here, I'm going to say print star one word,

320
00:31:24,780 --> 00:31:31,220
I'm going to use an f string here, for one word in s split. So what's going to happen

321
00:31:31,220 --> 00:31:35,500
here? Well, I'm splitting s, I'm going to get back a list of strings, I'm going to go

322
00:31:35,500 --> 00:31:41,220
through that list one element at a time, and then I'm going to print it out. Fantastic,

323
00:31:41,220 --> 00:31:48,220
right? Sort of. See, this is why I always say yes and no. It did print what we wanted,

324
00:31:49,340 --> 00:31:56,340
but what the heck? None, none, none. So you have to remember that the list that we get

325
00:31:56,820 --> 00:32:03,820
back from a comprehension contains the values that the expression returned. And that's

326
00:32:05,500 --> 00:32:12,500
when print always returns none, no matter what you print. So here it printed on the

327
00:32:15,900 --> 00:32:22,900
screen, but it returned none, which affected our output comprehension rather dramatically.

328
00:32:22,900 --> 00:32:29,900
And so you basically never ever want to use print inside of a comprehension. Right? It's

329
00:32:35,700 --> 00:32:42,700
just like a bad idea, and yet I see people do it all the time. Okay. So we can iterate

330
00:32:43,300 --> 00:32:48,820
inside of our comprehensions over strings, lists, tuples, dictionaries, right? You want

331
00:32:48,820 --> 00:32:55,100
to do that, you can totally do that as well. All that's fine. But there's another thing

332
00:32:55,100 --> 00:33:02,100
that we can do. How about iterating over files? Well, files are iterable. And I'm using the

333
00:33:03,540 --> 00:33:07,980
term file even though technically speaking we should say file-like objects in modern

334
00:33:07,980 --> 00:33:12,980
Python. But come on, who says that? We all just say files and we all just sort of roll

335
00:33:12,980 --> 00:33:17,060
our eyes at the documentation. So how about iterating over files? Can I do that? Well,

336
00:33:17,620 --> 00:33:23,340
I can say here one line for one line in open, and here I'm going to use one of the files

337
00:33:23,340 --> 00:33:27,460
that I gave to you. Here, let's see, what do I have here in this direction? Oh, fine.

338
00:33:27,460 --> 00:33:34,460
I'll just say Linux, Etsy, password, TXT. So what happens here? I get a list of strings

339
00:33:36,980 --> 00:33:43,980
back. Right? So what's going on? Open returns a new file object, an open file for reading.

340
00:33:44,140 --> 00:33:49,300
The for loop inside the comprehension turns to that file and says, are you iterable? The

341
00:33:49,300 --> 00:33:52,740
answer is yes, I am. So it says, okay, give me your next thing, your next thing, your

342
00:33:52,740 --> 00:33:57,180
next thing. And the way the files work is with every iteration, we get up to and including

343
00:33:57,180 --> 00:34:01,780
the next new line character, that backslash n. The result is then that we have created

344
00:34:01,780 --> 00:34:08,780
a list of strings where each string is one line from that file. Now, I should warn you,

345
00:34:09,420 --> 00:34:15,700
if the file is really big, this will not end well. If you decide to do this with a 2 terabyte

346
00:34:15,700 --> 00:34:19,580
file, well, it could end well. Your IT department might give you the upgrade you've always been

347
00:34:19,580 --> 00:34:25,780
asking for. However, that seems unlikely, and so you should try to avoid doing this

348
00:34:25,780 --> 00:34:31,340
with big files. But small files, medium-sized files, it's fantastic. Well, wait a second.

349
00:34:31,340 --> 00:34:35,700
Maybe I can do some interesting things with a file, like if I'm already opening it. So

350
00:34:35,700 --> 00:34:42,700
what if, right, can I get the user names from this password file? And for those of

351
00:34:43,300 --> 00:34:48,220
you unfamiliar with it, this is a kind of file that's available on all Unix systems,

352
00:34:48,220 --> 00:34:53,500
Unix, Linux, Mac and so forth, and originally contained user names and passwords. Someone

353
00:34:53,500 --> 00:34:58,500
then realized perhaps having the passwords right there in the file was not such a smart

354
00:34:58,500 --> 00:35:04,340
idea. It might be used by bad people somewhere. And so you can see now that in the second

355
00:35:04,340 --> 00:35:09,220
field here, so each of these are records, and the second field here used to have a

356
00:35:09,220 --> 00:35:12,740
password now just as X is and the passwords are elsewhere. And I lost this and they don't

357
00:35:12,740 --> 00:35:16,820
even use this anymore, on and on and on. But they're great files for practicing working

358
00:35:16,820 --> 00:35:23,460
with files in Python. So here's what I want to do. On each of these records, we can see

359
00:35:23,460 --> 00:35:30,460
that the fields are separated with colons. Can I grab all the user names from this file?

360
00:35:30,460 --> 00:35:37,460
Maybe. Right? So the user names are, you know, so each record contains fields, and the field,

361
00:35:40,780 --> 00:35:47,780
the first field, you know, fields are separated by colons, and the first field is the user

362
00:35:48,940 --> 00:35:55,940
name. So what if I were to say here, one line split colon zero for one line in open Linux

363
00:35:56,940 --> 00:36:03,380
Etsy password TXT. So I'm going to open the file, I'm going to go over each line, and

364
00:36:03,380 --> 00:36:08,020
each line I'm going to split it into a list on colons, and I'm going to grab the first

365
00:36:08,020 --> 00:36:13,900
element from that resulting list. And there's good news and bad news. The good news is that

366
00:36:13,900 --> 00:36:19,540
I did indeed get a list of strings. And those strings are basically user names. The bad

367
00:36:19,540 --> 00:36:24,540
news is that this file also contains things that are not user names. And in case you think

368
00:36:24,540 --> 00:36:30,620
that this is just completely contrived, there's a small company called Apple that puts comments

369
00:36:30,620 --> 00:36:35,780
in its password files. And I am so thankful that they provide me with these pedagogical

370
00:36:35,780 --> 00:36:41,220
opportunities in between all of their other things that they do as a business. So you

371
00:36:41,220 --> 00:36:44,660
will have files with all sorts of weird stuff that you've got to get rid of and ignore and

372
00:36:44,660 --> 00:36:50,500
so on and so forth. How do you do that? Because everything I've told you until now says that

373
00:36:50,500 --> 00:36:55,140
the number of elements in the input and the number of elements in the output have to

374
00:36:55,140 --> 00:36:59,580
be identical. So what am I supposed to do? What's the guy supposed to do? And the answer

375
00:36:59,580 --> 00:37:05,540
is we make things more complicated. That's right, because we're programmers. So basically,

376
00:37:05,540 --> 00:37:12,540
it is true that I have two parts to my comprehension. The first part is going to be the expression,

377
00:37:12,820 --> 00:37:18,180
sort of like select. The second part is going to be the iteration, sort of like where. And

378
00:37:18,220 --> 00:37:22,540
that's right. I'm not where. It's going to be from. Jumping the gun already. And the

379
00:37:22,540 --> 00:37:29,540
third part, on the third line, is going to be the condition where. And this is where

380
00:37:29,580 --> 00:37:33,300
things start to get complex because we're going to end up jumping around a little bit.

381
00:37:33,300 --> 00:37:39,940
And so I can say, for example, if, let's just say like colon in one line. So if there is

382
00:37:39,940 --> 00:37:46,660
a colon there, then we're going to assume it's okay. I think this will work. Now, how

383
00:37:46,660 --> 00:37:53,660
the heck does this work? The first thing to execute is the for loop as before. And

384
00:37:53,900 --> 00:38:00,900
for every single element, for every value of one line, we then go to this if. And if

385
00:38:01,460 --> 00:38:08,460
that is true, if the condition is true, then and only then do we go to the first line and

386
00:38:08,460 --> 00:38:15,460
produce output and evaluate our expression. Meaning the expression will not be evaluated

387
00:38:15,460 --> 00:38:20,460
all the time, only if the condition is true. What can I put in that condition? Anything

388
00:38:20,460 --> 00:38:25,460
I want. Anything that returns true or false or anything that's like truish in a Boolean

389
00:38:25,460 --> 00:38:31,460
context in Python, totally okay to put there. And so you can make it simple. You can make

390
00:38:32,460 --> 00:38:39,460
it complex. Don't make it complex. But you can. And so this combination of three things,

391
00:38:40,460 --> 00:38:44,620
of the expression, of the iteration of the condition, or if you prefer, select from and

392
00:38:44,620 --> 00:38:51,060
where, databases have had a pretty good run using this kind of query language. And it's

393
00:38:51,060 --> 00:38:56,060
no surprise that the comprehensions are similarly powerful and, believe it or not, popular in

394
00:38:56,060 --> 00:39:00,500
Python because they allow us that same kind of power. And now the number of lines in the

395
00:39:00,500 --> 00:39:04,500
output doesn't have to be the same as the number of lines in the input. It can be the

396
00:39:04,500 --> 00:39:09,500
same or fewer. All right. Questions until here. Yeah, please. So the question is, is

397
00:39:19,500 --> 00:39:26,500
there also a possibility of putting an else? And the answer is not really. There is a version

398
00:39:26,500 --> 00:39:31,500
of if else in Python that is designed for this kind of place where you want to make

399
00:39:31,500 --> 00:39:38,500
things conditional. And I find it so horrible to use, let alone explain, that I basically

400
00:39:38,500 --> 00:39:42,500
tell people it doesn't exist unless they really press me. But it's meant for this kind of

401
00:39:42,500 --> 00:39:47,500
place where you're sort of stuck. But don't do it. Yeah. Other questions? Yeah, please.

402
00:39:47,500 --> 00:39:54,500
It's just me. For better or worse.

403
00:40:17,500 --> 00:40:23,500
So my impression, and I haven't really checked into this super fully, is that Python was

404
00:40:23,500 --> 00:40:27,500
not the first language with comprehensions that they came from elsewhere. And I would

405
00:40:27,500 --> 00:40:33,500
not be surprised if all that stems back to some similar theory of queries that has a

406
00:40:33,500 --> 00:40:42,500
common ancestor. But where, how, I don't know. I will say the moment I sort of stumbled

407
00:40:42,500 --> 00:40:48,500
on this, I was like, oh, my God. And the more I talk to people, again, it doesn't help

408
00:40:48,500 --> 00:40:59,500
everyone, but it helps some subset of the population where they know. Yes, please. Oh,

409
00:40:59,500 --> 00:41:05,500
so the question is, are there places where we would use lambda instead of this? So lambda

410
00:41:05,500 --> 00:41:09,500
allows you to create anonymous functions. And it goes hand in hand with map and filter,

411
00:41:09,500 --> 00:41:14,500
which are kind of the predecessors to list comprehensions. And I think one of the motivating

412
00:41:14,500 --> 00:41:17,500
factors, again, I'm not sure, but one of the motivating factors behind comprehensions was

413
00:41:17,500 --> 00:41:22,500
to dump lambda as much as possible. That get rid of the word lambda, which confuses people,

414
00:41:22,500 --> 00:41:27,500
get rid of the argument, the parameter there, and just use the body of the lambda, which

415
00:41:27,500 --> 00:41:33,500
is what we've got here effectively. I would say lambda is increasingly passe in the Python

416
00:41:33,500 --> 00:41:39,500
world, except in the Pandas world where they're having a lambda party every day. But people

417
00:41:39,500 --> 00:41:50,500
are trying to avoid it because of this. Yeah, if you're using lambda in Pandas, you're in

418
00:41:50,500 --> 00:41:54,500
good company. A lot of people are doing that. But it's basically as far as I can tell only

419
00:41:54,500 --> 00:42:05,500
in Pandas. Okay. So let's play with this a little bit. Let's do a little exercise. So I have

420
00:42:05,500 --> 00:42:14,500
here a file called nums.txt, which contains numbers. And so basically, let's do this exercise,

421
00:42:14,500 --> 00:42:23,500
some numbers. So basically I want you to use a comprehension to read through nums.txt, and

422
00:42:23,500 --> 00:42:34,500
sum the numbers it contains. Each line of the file contains either zero integers or one

423
00:42:34,500 --> 00:42:40,500
integer. There's no way that there's going to be more than that. And the integer might well have

424
00:42:40,500 --> 00:42:50,500
whitespace before or after it. All right? So see what you can do to play with this, and we'll go

425
00:42:50,500 --> 00:42:55,500
over it together in a few minutes and then look at all sorts of additional stuff. And again, if you

426
00:42:55,500 --> 00:43:01,500
have questions, feel free. Okay. So let's look at this together. And I'll admit, this is one of

427
00:43:01,500 --> 00:43:07,500
those exercises that's really, really short and really, really annoying. Well, for the people who

428
00:43:07,500 --> 00:43:17,500
have to do it. I'm fine with it. So let's do this. I'm going to say here, I have a file whose lines

429
00:43:17,500 --> 00:43:26,500
contain numbers. Right? And I want basically a list of numbers, a list of integers. All right? So

430
00:43:26,500 --> 00:43:33,500
I can transform from the string whose lines, which will be strings, so I can transform from a

431
00:43:33,500 --> 00:43:45,500
string to an int with int. So I could naively say one line for one line in open nums.txt. Well,

432
00:43:45,500 --> 00:43:51,500
that will give me the lines. And we can see it's a horrible mess there with new lines and tabs and

433
00:43:51,500 --> 00:43:57,500
spaces. So I could say one line.strip. I could, by the way, int does that for us automatically.

434
00:43:57,500 --> 00:44:03,500
But fine. And we see, okay, there's a blank line there. And what if I say int here? And that's

435
00:44:03,500 --> 00:44:10,500
where it blows up. And it blows up because it turns out, here's fun facts for you. If I say int of

436
00:44:10,500 --> 00:44:18,500
five, that gives me five. Hopefully not too surprising. If I say int of five, that's also fine.

437
00:44:18,500 --> 00:44:26,500
But if I say int of spaces, that blows up. Or int of an empty string. So it's totally fine as long

438
00:44:26,500 --> 00:44:31,500
as I have something in there that can be an integer. But giving it an empty string, not good. And

439
00:44:31,500 --> 00:44:36,500
that's exactly what we're doing here. Right? We even saw this before. When I didn't have the int, we

440
00:44:36,500 --> 00:44:44,500
saw that that line was stripped down to just be an empty string. So luckily for us, we have conditions.

441
00:44:44,500 --> 00:44:49,500
Right? So what I can do is I can implement my condition here, add a condition. Now, what kind of

442
00:44:49,500 --> 00:44:54,500
condition will I add? And there are a whole bunch of different things we could do. One would be to say,

443
00:44:54,500 --> 00:45:03,500
like, if one line strip. Right? So here, just check that the line isn't empty. Because an empty

444
00:45:03,500 --> 00:45:09,500
string returns false in a Boolean context. Any other string returns true. So assuming we're willing to

445
00:45:09,500 --> 00:45:15,500
believe the people writing the specifications that if there is something on that line that it is an

446
00:45:15,500 --> 00:45:19,500
integer, then this will work just fine. And sure enough, that works great. We get our list of

447
00:45:19,500 --> 00:45:25,500
integers. And then I can run some on this sucker. And it's great. Right? If I want to be a little more

448
00:45:25,500 --> 00:45:32,500
cautious, then I could, you know, do that. In fact, I can get rid of the strip here when I do int.

449
00:45:32,500 --> 00:45:37,500
Because it's going to do that automatically for me. And do I have the right number? Yeah. That works

450
00:45:37,500 --> 00:45:43,500
fine. So here I could say int of one line. So that stays the same. Good. And here I could say, like,

451
00:45:43,500 --> 00:45:49,500
if one line strip is digit. Right? And is digit basically says does this is a string method. Does

452
00:45:49,500 --> 00:45:54,500
this string only contain digits zero through nine. Nothing else. And if it passes that, then we're

453
00:45:54,500 --> 00:45:59,500
totally fine. It won't work on negative numbers because it doesn't allow for negative numbers.

454
00:45:59,500 --> 00:46:11,500
But let's not be so negative. Okay. So if one, so the question is, what is that the first condition

455
00:46:11,500 --> 00:46:16,500
doing? If one line dot strip. So it's taking one line, it's taking the current line. It's removing any

456
00:46:16,500 --> 00:46:21,500
white space that might be on its edges. Again, not in the middle. And then it's returning a string.

457
00:46:21,500 --> 00:46:27,500
And if looks to its right, and it requires a true or false value. It won't accept a string. So it says,

458
00:46:27,500 --> 00:46:32,500
hey, string, are you true or are you false? Are you trueish or falseish? And basically every string in

459
00:46:32,500 --> 00:46:38,500
Python is true in that context except for the empty string. So the only way that that if will be

460
00:46:38,500 --> 00:46:44,500
false is if we have an empty string. Meaning if the line only contained white space, then that line will

461
00:46:44,500 --> 00:46:49,500
return false and then we will not try to run int on it. So this is a safeguard to make sure that we're

462
00:46:49,500 --> 00:46:59,500
not trying to call int on an empty string or just a white space only string. Other questions about this?

463
00:46:59,500 --> 00:47:10,500
Okay. So let me show you one or two other examples of cool things we can do with this. And then we'll

464
00:47:10,500 --> 00:47:16,500
even do something a little more exciting. Meaning difficult. So what if I want to know how many

465
00:47:16,500 --> 00:47:22,500
vowels are in a word or in a string? So how can I use a comprehension for that? So if I say like S

466
00:47:22,500 --> 00:47:30,500
equals whatever. So I could say here, well, how would I use a comprehension? Well, how about this?

467
00:47:30,500 --> 00:47:40,500
What if my expression is one for one letter, let's say one character in S. And we say if one character in

468
00:47:40,500 --> 00:47:50,500
AOU. And so I'm going to get three ones. Right? So now I can say, well, how many vowels are in

469
00:47:50,500 --> 00:48:00,500
a string? And we say if one character in AOU. And so I'm going to get three ones. Right? So now I can

470
00:48:00,500 --> 00:48:06,500
just say sum this up. And there we go. We find out there are three. And you will definitely find places where

471
00:48:06,500 --> 00:48:12,500
people do this kind of thing in Python. Where the expression turns out to be super, super simple. And the

472
00:48:12,500 --> 00:48:16,500
real power here is in the loop and the condition.

473
00:48:21,500 --> 00:48:35,500
Okay. So if I can do this with files, right, like I can do all sorts of things. What if I've got, let's see.

474
00:48:35,500 --> 00:48:41,500
Well, what if I have a much more complex file? Let's do this for a little bit. So I'm going to look at

475
00:48:41,500 --> 00:48:51,500
shoedata.txt. So this here is a file with 100 lines in it. Oops. Come back, come back, come back.

476
00:48:51,500 --> 00:49:03,500
Here we go. Shoedata.txt contains 100 lines. And each line contains three fields. A brand, a color, and a size.

477
00:49:03,500 --> 00:49:09,500
By the way, these are not clown shoes. These are European sizes. Although with some of these color choices,

478
00:49:09,500 --> 00:49:16,500
maybe they should be clown shoes. In any event, so basically the idea is let's, I'm going to just give this to you

479
00:49:16,500 --> 00:49:26,500
as an exercise right now. All right? So I want you to know, I'll mark it as such. We're going to say shoedicts.

480
00:49:26,500 --> 00:49:35,500
What I want you to do is use a list comprehension to turn this file into a list of dictionaries.

481
00:49:35,500 --> 00:49:49,500
Each line should be turned into a dict whose keys are brand, color, and size. And the values can remain strings.

482
00:49:49,500 --> 00:50:04,500
Don't worry about the sizes. So here I recommend that you write an external function that takes a string as input

483
00:50:04,500 --> 00:50:17,500
and returns a dict. And then invoke that in your comprehension. Okay? And so the result will be a list of, you know,

484
00:50:17,500 --> 00:50:31,500
it will be like this. It will be like, you know, brand, Adidas, I don't know, like color, black. I don't know what I actually have there in the file.

485
00:50:31,500 --> 00:50:41,500
And then like size, you know, 45, something like that. And then we'll just have a whole bunch of those.

486
00:50:41,500 --> 00:50:45,500
All right? So see what you can do with that. This is going to take a few minutes. I recognize that.

487
00:50:45,500 --> 00:50:53,500
This is to show you that you can really start to do very, very, very sophisticated things in terms of data manipulation with these pieces.

488
00:50:53,500 --> 00:51:00,500
By the way, this is a good way to get friendly with people. I should have mentioned this at the beginning.

489
00:51:00,500 --> 00:51:08,500
It is always best if two people work on one computer. Programmers hate that, hate it because they're like, no, I'm going to struggle through this myself.

490
00:51:08,500 --> 00:51:15,500
If you're sitting next to someone you know or would like to know, definitely like talking it over, trying to do it is always good.

491
00:51:15,500 --> 00:51:23,500
Oh, I'm sorry. I thought I mentioned this before, but I'm looking over now. I didn't. The fields are separated by tabs.

492
00:51:23,500 --> 00:51:32,500
Everyone's like, oh, hopefully that doesn't mess things up too much for you or makes it blindingly obvious and easy.

493
00:51:32,500 --> 00:51:39,500
Okay, let's start to look at this together, see what we can do with it.

494
00:51:39,500 --> 00:51:48,500
So first of all, let's remember a list comprehension returns a list. I'm not trying to create a dictionary here.

495
00:51:48,500 --> 00:51:56,500
I'm trying to get a list of dictionaries. And so each what I want to get back from my expression is one dictionary.

496
00:51:56,500 --> 00:52:02,500
And then when I run the list comprehension on this file, I'll want to get a whole lot of dictionaries, a list of dictionaries.

497
00:52:02,500 --> 00:52:10,500
So I can start off by saying like one line for one line in open shoe data dot txt.

498
00:52:10,500 --> 00:52:19,500
And it looks like a horrible mess. Fine. But now what am I going to do with it? Well, I can say one line dot split on tab.

499
00:52:19,500 --> 00:52:28,500
And that looks pretty good already. And I want to turn these though into a dictionary. And here, could I do it in one line? Yes.

500
00:52:28,500 --> 00:52:35,500
Is it a good idea? I think not so much. So I'm going to split this off here.

501
00:52:35,500 --> 00:52:43,500
I'm going to say here like let's do this. Def line to dict one line.

502
00:52:43,500 --> 00:52:52,500
Let's say here return this line to dict of one line. So what's happening here? Nothing. Nothing has changed.

503
00:52:52,500 --> 00:52:58,500
Right. What I've done now is I've simply shifted that functionality from this line here to the function here.

504
00:52:58,500 --> 00:53:04,500
But really, it's doing exactly the same thing. However, now I have a little more sort of room to play with things.

505
00:53:04,500 --> 00:53:10,500
So a simple not working approach.

506
00:53:10,500 --> 00:53:16,500
All right. Let's try to make it work a little better here. So I'm going to do.

507
00:53:16,500 --> 00:53:22,500
So what if I get it a simple working approach? That's always better. Working is better than not working. I mean, let's for the computer.

508
00:53:22,500 --> 00:53:28,500
So what am I going to do? Well, I can say here like return. I can say fields equals that.

509
00:53:28,500 --> 00:53:37,500
And then I'm going to say here return a dictionary. I'm going to say here like brand field zero and color.

510
00:53:37,500 --> 00:53:43,500
Oops. Fields one and size fields too.

511
00:53:43,500 --> 00:53:51,500
And what do you know? I get a list of dictionaries back. Pretty snazzy, I'd say, for very, very little code.

512
00:53:51,500 --> 00:53:57,500
Right now I can do this even better. I can shrink my function down quite a bit more.

513
00:53:57,500 --> 00:54:02,500
We'll do one one thing. I'm not going to go the whole distance here through other things to cover.

514
00:54:02,500 --> 00:54:09,500
But basically, I could, for example, you know, a little better.

515
00:54:09,500 --> 00:54:13,500
Using what's it called unpacking.

516
00:54:13,500 --> 00:54:19,500
Where I can say here brand color size and I can say here.

517
00:54:19,500 --> 00:54:23,500
Brand color size.

518
00:54:23,500 --> 00:54:30,500
And then I get the same thing. It's just, I think, a little more readable because split. Oh, actually, it's still a little bug in there, which is the new line.

519
00:54:30,500 --> 00:54:34,500
Get rid of that new line.

520
00:54:34,500 --> 00:54:36,500
There we go.

521
00:54:36,500 --> 00:54:45,500
Basically, what's happening here? Well, we're going through our file one line at a time for each line. We're invoking the function. The function gets called.

522
00:54:45,500 --> 00:54:49,500
It says I'm going to take this line, remove the white space on either side here being the new line.

523
00:54:49,500 --> 00:54:53,500
I'm going to split that across tabs and we know that there should be three elements.

524
00:54:53,500 --> 00:54:57,500
Those three elements are assigned in parallel to brand color and size.

525
00:54:57,500 --> 00:55:04,500
And then we return a new dictionary based on it. So if I had a thousand shoes in there, then we would have a list of a thousand shoes.

526
00:55:04,500 --> 00:55:07,500
Right. There are only a hundred here. So.

527
00:55:07,500 --> 00:55:10,500
Poor thing.

528
00:55:10,500 --> 00:55:13,500
Questions or comments about this.

529
00:55:13,500 --> 00:55:17,500
Yeah, please.

530
00:55:17,500 --> 00:55:29,500
No, I didn't. No, I didn't use from keys. I could. Yeah, absolutely. Absolutely. I could use from keys. I could use zip. There are a few different different ways we can sort of play this. Yeah, absolutely.

531
00:55:29,500 --> 00:55:34,500
Other questions.

532
00:55:34,500 --> 00:55:36,500
Okay.

533
00:55:36,500 --> 00:55:54,500
So basically we see here that I can like call. I can write a function. I can work on files and really the moment that you have that mindset of right. I have this interval. I want to get this sort of result and I know how to map from the first to the second.

534
00:55:54,500 --> 00:56:00,500
You know the world, a world of possibilities opens up, opens up.

535
00:56:00,500 --> 00:56:02,500
Okay.

536
00:56:02,500 --> 00:56:10,500
Let me show you one other fun example of what we can do with this sort of thing. Just double check what files I have here. Excellent. Excellent. Excellent.

537
00:56:10,500 --> 00:56:16,500
Okay, so I have here.

538
00:56:16,500 --> 00:56:26,500
By the way, those of you not familiar with this in Jupiter, you can. Oh, not very helpful. You can like run a command line program with exclamation point.

539
00:56:26,500 --> 00:56:39,500
So I'm just like, you know, I'll say I need to. But here. So I'm just looking at the top of mini access log. That's this file that I have. I think it's like a hundred, 200 lines that are from an Apache log file from like years and years ago. When is it from?

540
00:56:39,500 --> 00:56:57,500
2010, which back then seemed very modern and fancy, but now we know it was not. So basically what do I want to do with this file? Well, what I might want to do is I want to retrieve all of the IP addresses from mini access log.

541
00:56:57,500 --> 00:56:59,500
Log.

542
00:56:59,500 --> 00:57:11,500
Okay, sounds pretty good. And this is very, very similar to what we did before with FC password. So I can say here like one line for one line in open open.

543
00:57:11,500 --> 00:57:13,500
Mini access log.

544
00:57:13,500 --> 00:57:21,500
And I get a list of the whole file. I don't want everything though. And this is by the way where I always like to say know your data.

545
00:57:21,500 --> 00:57:27,500
Right. If I can look at this and say, well, the IP addresses at the start of the line, it comes before any white space.

546
00:57:27,500 --> 00:57:41,500
Who cares about the rest of the line? Right. I'm just going to do a split here and grab the first thing. I don't need to really parse the whole line just to get this to work. And there we go. Now I have the IP addresses.

547
00:57:41,500 --> 00:57:43,500
Well, now what?

548
00:57:43,500 --> 00:57:53,500
Well, you know, first of all, it might be useful to have. But what if I want to know how many times each IP address access my server?

549
00:57:57,500 --> 00:58:07,500
And for this, I'm going to reach into the standard library and pull out the counter class. Counter is amazing. Amazing.

550
00:58:07,500 --> 00:58:15,500
And I used it wrong for years. Luckily before I started teaching. Right. So I would say like from collections import counter.

551
00:58:17,500 --> 00:58:25,500
And then I would say like the bad wrong way to use counter is as a cheap default dict.

552
00:58:25,500 --> 00:58:33,500
Right. So I would say like C equals a counter. Then I'd say like, you know, C of a plus equal five and C of B plus equal three and so on and so forth.

553
00:58:33,500 --> 00:58:45,500
And it's happy to do that. But this is not what it was designed to do. Right. The real way to use counter is to initialize it with an interval.

554
00:58:46,500 --> 00:58:55,500
And so it will count how many times each element of that interval is there and make.

555
00:58:55,500 --> 00:58:59,500
So then each element becomes the keys.

556
00:58:59,500 --> 00:59:01,500
Becomes a key.

557
00:59:01,500 --> 00:59:05,500
And the number of times becomes the value.

558
00:59:05,500 --> 00:59:13,500
In other words, if I now say counter of one line split by one.

559
00:59:13,500 --> 00:59:23,500
One line split zero for one line in open in open mini access log.

560
00:59:23,500 --> 00:59:25,500
I think I got something wrong there.

561
00:59:25,500 --> 00:59:33,500
It now tells me how often each of these IP addresses access my system.

562
00:59:33,500 --> 00:59:37,500
Not too shabby for two lines of code.

563
00:59:37,500 --> 00:59:43,500
And of course, if I want to, I can assign this counter to available to a variable.

564
00:59:43,500 --> 00:59:51,500
And then I can run methods on that variable. For example, so counter has a is so inherits.

565
00:59:51,500 --> 00:59:53,500
From dict.

566
00:59:53,500 --> 00:59:59,500
So I could do like four key value in in C dot items.

567
00:59:59,500 --> 01:00:03,500
Print key value.

568
01:00:03,500 --> 01:00:07,500
And now I have right. I've printed out basically what I did before.

569
01:00:07,500 --> 01:00:14,500
But let's say let's say your boss has asked you to create something based on this and your boss.

570
01:00:14,500 --> 01:00:17,500
You know, it's been a while since they did tough math.

571
01:00:17,500 --> 01:00:24,500
So you want to give them something graphical so you can give them a little histogram.

572
01:00:24,500 --> 01:00:28,500
Right. Because you can multiply integers by strings in Python.

573
01:00:28,500 --> 01:00:31,500
Oh, but wait, like it doesn't start from the even space there.

574
01:00:31,500 --> 01:00:34,500
So fine. So I'll do like, you know, colon like 18.

575
01:00:34,500 --> 01:00:36,500
There we go.

576
01:00:36,500 --> 01:00:44,500
So with very, very little code, thanks to comprehensions and thanks to counter working together, I can produce all sorts of reports like this.

577
01:00:44,500 --> 01:00:50,500
I can also call special methods on counter so I can say C dot most common.

578
01:00:50,500 --> 01:00:53,500
And then this is a counter method.

579
01:00:53,500 --> 01:01:02,500
That returns a list of tuples from the most common to the least based on the counter.

580
01:01:02,500 --> 01:01:07,500
And so now if I'm you know, I can just sort of grab those and print them out.

581
01:01:07,500 --> 01:01:11,500
Or, of course, I can I can invoke.

582
01:01:11,500 --> 01:01:14,500
Most common with an argument.

583
01:01:14,500 --> 01:01:19,500
And then I get only that many elements in the output list.

584
01:01:19,500 --> 01:01:22,500
So I say C most common five.

585
01:01:22,500 --> 01:01:25,500
I get only the five most common there.

586
01:01:25,500 --> 01:01:27,500
So comprehensions are pretty amazing.

587
01:01:27,500 --> 01:01:38,500
But when you mix them together with other things that we do in Python, like counter in the standard library, then it's almost like magical.

588
01:01:38,500 --> 01:01:45,500
Questions or comments so far?

589
01:01:45,500 --> 01:01:47,500
Oh, yeah, please.

590
01:01:47,500 --> 01:01:55,500
Absolutely, absolutely.

591
01:01:55,500 --> 01:02:03,500
To to to to to here. Yeah, absolutely.

592
01:02:03,500 --> 01:02:09,500
When and what you can see here also is very often I'll just pass a list.

593
01:02:09,500 --> 01:02:11,500
I'm not exactly passing a list comprehension.

594
01:02:11,500 --> 01:02:13,500
I am passing.

595
01:02:13,500 --> 01:02:24,500
I'm putting a comprehension in a functions as a functions argument, knowing that the comprehension is going to run first and its list, whatever produces will then be passed as the argument to the function.

596
01:02:24,500 --> 01:02:26,500
I'm not interested in storing a variable somewhere.

597
01:02:26,500 --> 01:02:28,500
I don't have to do that.

598
01:02:28,500 --> 01:02:35,500
I can just like put it there in the parentheses and do its thing.

599
01:02:35,500 --> 01:02:39,500
OK.

600
01:02:39,500 --> 01:02:43,500
So let's see.

601
01:02:43,500 --> 01:02:48,500
Let me just check one more thing here.

602
01:02:48,500 --> 01:02:51,500
Fine.

603
01:02:51,500 --> 01:02:58,500
OK, so we've basically seen a whole lot of stuff that we can do with our list comprehension.

604
01:02:58,500 --> 01:03:01,500
I'm just looking at the time also because we have like 10 minutes until the break.

605
01:03:01,500 --> 01:03:03,500
Does anyone know how long the break is supposed to be?

606
01:03:03,500 --> 01:03:05,500
By the way, I heard 10 minutes.

607
01:03:05,500 --> 01:03:07,500
I heard 30 minutes.

608
01:03:07,500 --> 01:03:08,500
15.

609
01:03:08,500 --> 01:03:09,500
OK, there we go.

610
01:03:09,500 --> 01:03:11,500
Someone actually is knowledgeable about the stuff.

611
01:03:11,500 --> 01:03:13,500
It's certainly not me.

612
01:03:13,500 --> 01:03:14,500
Excellent.

613
01:03:14,500 --> 01:03:15,500
All right.

614
01:03:15,500 --> 01:03:16,500
So let's see.

615
01:03:16,500 --> 01:03:18,500
So we've now seen what we can do with this comprehension.

616
01:03:18,500 --> 01:03:21,500
We use them all over the place.

617
01:03:21,500 --> 01:03:25,500
And the same rules apply for list comprehension as for lists in general.

618
01:03:25,500 --> 01:03:31,500
So like you can't put it in like because lists are unhashable and can't be used as dictionary keys,

619
01:03:31,500 --> 01:03:35,500
you can't put a dictionary, you can't put a list comprehension where you would use a dict key

620
01:03:35,500 --> 01:03:37,500
or something else of that sort that would be hashable.

621
01:03:37,500 --> 01:03:40,500
But otherwise, anywhere you can put a list, you can put it.

622
01:03:40,500 --> 01:03:42,500
And it's really terrific.

623
01:03:42,500 --> 01:03:44,500
OK.

624
01:03:44,500 --> 01:03:46,500
This is all very nice and everything.

625
01:03:46,500 --> 01:03:53,500
But we can do better than this also because let's say I'm going to go back to my user names.

626
01:03:53,500 --> 01:04:03,500
I'm going to say user names equals say one line split on a colon zero for one line in open Linux

627
01:04:03,500 --> 01:04:10,500
Etsy password TXT if colon in one line.

628
01:04:10,500 --> 01:04:13,500
And sure enough, I now look at user names and I have them.

629
01:04:13,500 --> 01:04:17,500
And now that I have them in a list, of course, I can search for them, right?

630
01:04:17,500 --> 01:04:24,500
So we can now search for user names in this list using in.

631
01:04:24,500 --> 01:04:27,500
So I can say is there a root in user names?

632
01:04:27,500 --> 01:04:29,500
The answer is yes.

633
01:04:29,500 --> 01:04:31,500
Is there a roovin in user names?

634
01:04:31,500 --> 01:04:32,500
Yes.

635
01:04:32,500 --> 01:04:34,500
Is there a blah blah blah blah blah in user names?

636
01:04:34,500 --> 01:04:36,500
Probably not. No.

637
01:04:36,500 --> 01:04:38,500
OK.

638
01:04:38,500 --> 01:04:40,500
So the good news is that this works.

639
01:04:40,500 --> 01:04:43,500
The bad news, though, is that I'm searching in a list.

640
01:04:43,500 --> 01:04:47,500
And searching in a list takes linear time by definition, right?

641
01:04:47,500 --> 01:04:50,500
Because we have to step through how is in working behind the scenes.

642
01:04:50,500 --> 01:04:58,500
In runs a for loop behind the scenes and goes element by element by element through each thing that we have in the list

643
01:04:58,500 --> 01:05:03,500
until it either finds it and says true or does not find it and goes to the end and it returns false.

644
01:05:03,500 --> 01:05:20,500
So if I'm going to be searching a lot through my user names, then maybe I should use a different data structure.

645
01:05:20,500 --> 01:05:22,500
Right?

646
01:05:22,500 --> 01:05:23,500
Well, what else would I use?

647
01:05:23,500 --> 01:05:24,500
What searches faster?

648
01:05:24,500 --> 01:05:26,500
And the answer is a set.

649
01:05:26,500 --> 01:05:28,500
Sets.

650
01:05:28,500 --> 01:05:38,500
Sets basically, for those of you not super familiar with them, so sets are basically the keys of a dictionary.

651
01:05:38,500 --> 01:05:45,500
So they're guaranteed to be unique and they're hashable and thus they're searchable in very short amounts of time.

652
01:05:45,500 --> 01:05:50,500
That's guarantee uniqueness in their members.

653
01:05:50,500 --> 01:06:00,500
Searching is very fast and all elements are hashable.

654
01:06:00,500 --> 01:06:03,500
Just like dict keys.

655
01:06:03,500 --> 01:06:04,500
Right?

656
01:06:04,500 --> 01:06:08,500
You can think of a set really as a dictionary without values.

657
01:06:08,500 --> 01:06:09,500
Right?

658
01:06:09,500 --> 01:06:12,500
But okay, well, how does that help me here?

659
01:06:12,500 --> 01:06:16,500
Well, what I can do is I can go up here.

660
01:06:16,500 --> 01:06:26,500
I can take my list and as soon as I get it back, I can say here set of this thing.

661
01:06:26,500 --> 01:06:29,500
And so now what is the type of user names?

662
01:06:29,500 --> 01:06:32,500
It's a set.

663
01:06:32,500 --> 01:06:34,500
Well, we can do better than that.

664
01:06:34,500 --> 01:06:38,500
We can use a set comprehension.

665
01:06:38,500 --> 01:06:48,500
And a set comprehension, it looks almost exactly like a list comprehension.

666
01:06:48,500 --> 01:06:52,500
But it uses curly braces instead.

667
01:06:52,500 --> 01:06:55,500
And so basically, yes, it's true.

668
01:06:55,500 --> 01:06:56,500
I could do this.

669
01:06:56,500 --> 01:06:58,500
But think of what I'm doing in this example here.

670
01:06:58,500 --> 01:07:06,500
In this example, I'm first creating a list and then I'm passing that list to set and set is then creating the set form.

671
01:07:06,500 --> 01:07:11,500
And here if I just use the curly braces, it's a little neater and nicer.

672
01:07:11,500 --> 01:07:12,500
And I have to assume a little faster.

673
01:07:12,500 --> 01:07:17,500
Maybe we'll check that in just a moment.

674
01:07:17,500 --> 01:07:21,500
Oh, I should get rid of the square.

675
01:07:21,500 --> 01:07:25,500
And now the type of user names is set.

676
01:07:25,500 --> 01:07:29,500
And now if I search in here, root in user names, here.

677
01:07:29,500 --> 01:07:31,500
See how much faster that was?

678
01:07:31,500 --> 01:07:32,500
Right?

679
01:07:32,500 --> 01:07:34,500
See how much faster that was?

680
01:07:34,500 --> 01:07:35,500
Right?

681
01:07:35,500 --> 01:07:41,500
So basically, I can create a set really, really, really easily just by swapping the braces.

682
01:07:41,500 --> 01:07:42,500
Right?

683
01:07:42,500 --> 01:07:45,500
If I used to have square brackets, now I use curly braces.

684
01:07:45,500 --> 01:07:50,500
Now you have to remember, this is a set, which means the elements must be unique.

685
01:07:50,500 --> 01:07:56,500
If you had non-unique elements before, some of them might disappear on you.

686
01:07:56,500 --> 01:08:02,500
This can be surprising if you're not expecting it.

687
01:08:02,500 --> 01:08:05,500
So let's do a quick little exercise before the break.

688
01:08:05,500 --> 01:08:08,500
Let's do some unique numbers.

689
01:08:08,500 --> 01:08:16,500
So I want you to ask the user to enter numbers separated by whitespace and print their sum,

690
01:08:16,500 --> 01:08:21,500
but only count each number once.

691
01:08:21,500 --> 01:08:25,500
So as an example, if I say here, you know, enter numbers, I say 10, 20, 30, 10, 20, 30,

692
01:08:25,500 --> 01:08:30,500
they'll say total is 60, which is a little bit of a lie.

693
01:08:30,500 --> 01:08:35,500
It's actually 120, but we've only counted each number once.

694
01:08:35,500 --> 01:08:36,500
All right.

695
01:08:36,500 --> 01:08:38,500
So what am I going to do here?

696
01:08:38,500 --> 01:08:47,500
Well, I could say now, you know, s equals input, enter numbers, strip, and then I'll say here,

697
01:08:47,500 --> 01:08:52,500
now I want to do sum of, say, int one item for one item in s split.

698
01:08:52,500 --> 01:08:57,500
And this is going to be fine if I say 10, 20, 30, 10, 20, 30, but it's going to add up to 120,

699
01:08:57,500 --> 01:09:00,500
because here I've got a list.

700
01:09:00,500 --> 01:09:05,500
So I just do a little switcheroo with the parentheses, and now 10, 20, 30, 10, 20, 30.

701
01:09:05,500 --> 01:09:08,500
And because it got a set, it narrowed that down.

702
01:09:08,500 --> 01:09:13,500
It deduplicated them.

703
01:09:13,500 --> 01:09:18,500
Questions, comments so far?

704
01:09:18,500 --> 01:09:19,500
All right.

705
01:09:19,500 --> 01:09:21,500
So we're going to take a break now.

706
01:09:21,500 --> 01:09:24,500
I can tell you, so I live in Israel.

707
01:09:24,500 --> 01:09:27,500
People in Israel never let me talk so long without questions.

708
01:09:27,500 --> 01:09:30,500
So the good news is that if you have more questions, don't be embarrassed.

709
01:09:30,500 --> 01:09:32,500
You can keep asking them, ask even more.

710
01:09:32,500 --> 01:09:35,500
The other piece of good news is I will be able to throw in some extra stuff at the end,

711
01:09:35,500 --> 01:09:39,500
because we're clearly going to have more time, because you guys are not as loud as I am.

712
01:09:39,500 --> 01:09:42,500
So I'll be able to go deeper into some things, which should be a lot of fun.

713
01:09:42,500 --> 01:09:43,500
All right.

714
01:09:43,500 --> 01:09:47,500
So let's go to the break, and we'll be back here, I guess, 15 minutes?

715
01:09:47,500 --> 01:09:48,500
Sure.

716
01:09:48,500 --> 01:09:51,500
We'll find out what the official line is.

717
01:09:51,500 --> 01:09:56,500
Okay.

718
01:09:56,500 --> 01:10:00,500
By the way, you don't need it just yet.

719
01:10:00,500 --> 01:10:05,500
As part of, like, sort of time adjustments that I'm doing, cultural time adjustments,

720
01:10:05,500 --> 01:10:10,500
so I've added some files to the GitHub repo here so that we'll have some more things to play with later on the course.

721
01:10:12,500 --> 01:10:13,500
I'll also make that available to you.

722
01:10:13,500 --> 01:10:15,500
I'll tell you where you can get it from.

723
01:10:15,500 --> 01:10:16,500
So don't worry.

724
01:10:16,500 --> 01:10:19,500
None of the files are bigger than 10 gigs, so it should be downloadable pretty fast.

725
01:10:19,500 --> 01:10:20,500
No, no, no.

726
01:10:20,500 --> 01:10:21,500
It's really, really ridiculously small.

727
01:10:21,500 --> 01:10:22,500
Don't worry.

728
01:10:22,500 --> 01:10:23,500
Okay.

729
01:10:23,500 --> 01:10:28,500
So what we saw here just before the break was that we can do a quick little switch of the parentheses.

730
01:10:28,500 --> 01:10:31,500
So I'm going to go ahead and do that.

731
01:10:31,500 --> 01:10:48,500
So what we saw here is that we can do a quick little switch of the parentheses, and just as we can define lists with square brackets and we can define sets with curly braces, we can create list comprehensions with square brackets and set comprehensions with curly braces.

732
01:10:48,500 --> 01:10:53,500
And set comprehensions are really, really useful.

733
01:10:53,500 --> 01:11:00,500
And it's true that in this example I used it for unifying, for deduplicating the data.

734
01:11:00,500 --> 01:11:02,500
Definitely useful for that in a lot of different places.

735
01:11:02,500 --> 01:11:11,500
What I showed you before was when we loaded up the usernames, we can create a set based on that, and that's great not because it works faster, because it doesn't.

736
01:11:11,500 --> 01:11:16,500
There is that overhead associated with the hashing function that will take longer to set up the set.

737
01:11:16,500 --> 01:11:22,500
But once you've set it up, then searching it is much, much faster than searching in a list, which is fantastic.

738
01:11:22,500 --> 01:11:27,500
So if you're going to be searching in your usernames once, it is not worth creating a set comprehension.

739
01:11:27,500 --> 01:11:31,500
But if you're going to be searching in it a lot, 100% worth it.

740
01:11:31,500 --> 01:11:48,500
And so you can use this basically whenever you have sort of the question, how many unique blah, blah, blah, how many different blah, blah, blah, like whatever the thing is that you're looking for different unique values, you almost certainly will benefit from using a set.

741
01:11:48,500 --> 01:11:55,500
And if you're getting it from some sort of data source that's iterable, then using a set comprehension can also be really, really great.

742
01:11:55,500 --> 01:11:59,500
So let's let's do a slightly longer, more complex exercise.

743
01:11:59,500 --> 01:12:06,500
Now we're going to go back to our password file password.

744
01:12:06,500 --> 01:12:12,500
So again, those of you who don't know about Unix and so forth, that is not a requirement for this class or even for this exercise.

745
01:12:12,500 --> 01:12:18,500
But so far we have been concentrating on the left side of this file.

746
01:12:18,500 --> 01:12:20,500
We've been looking at the usernames.

747
01:12:20,500 --> 01:12:31,500
Well, the different fields that we have in each line, each valid line here in Etsy password are we have the username, the not password, the user ID, the group ID.

748
01:12:31,500 --> 01:12:34,500
Then we have the.

749
01:12:34,500 --> 01:12:36,500
Oh, it's username.

750
01:12:36,500 --> 01:12:38,500
Wait, anyway, user group group, I guess.

751
01:12:38,500 --> 01:12:39,500
Oh, no, it's just the name.

752
01:12:39,500 --> 01:12:40,500
It's just the name.

753
01:12:40,500 --> 01:12:42,500
It's like fooling me because these are the system things.

754
01:12:42,500 --> 01:12:49,500
And then basically we've got the home directory and then we have the shell and the shell is the command interpreter that's used in Unix.

755
01:12:49,500 --> 01:12:54,500
Right. So you might use bash or ZSH or heaven for fendt CSH or something.

756
01:12:54,500 --> 01:12:57,500
Right. But you can use one of those and you can also have the shell.

757
01:12:57,500 --> 01:13:04,500
The interpreter defined to be something as you can see here for no login, where when someone tries to log in with that, they can't right away.

758
01:13:04,500 --> 01:13:11,500
And so setting the command interpreter, setting the shell in the Unix system is not an unusual thing to want to do.

759
01:13:11,500 --> 01:13:15,500
So what I want to do now in an exercise is which shells.

760
01:13:15,500 --> 01:13:22,500
So I want you to read through Linux, Etsy password, oops, back, back.

761
01:13:22,500 --> 01:13:23,500
Let's see.

762
01:13:23,500 --> 01:13:25,500
Password TXT.

763
01:13:25,500 --> 01:13:29,500
And find the different.

764
01:13:29,500 --> 01:13:33,500
Shells that are used on the system.

765
01:13:33,500 --> 01:13:44,500
Now this is in some ways the opposite of what we did before looking at counter where counter expects to get a list where the items are not unique and then will tell us how many there are here.

766
01:13:44,500 --> 01:13:47,500
We want to get the unique list.

767
01:13:47,500 --> 01:13:49,500
Not a list, but we want to get the anyway.

768
01:13:49,500 --> 01:13:50,500
You know what I mean.

769
01:13:50,500 --> 01:13:51,500
All right.

770
01:13:51,500 --> 01:13:52,500
So we'll give this a few minutes.

771
01:13:52,500 --> 01:13:54,500
Then we'll look at it together.

772
01:13:54,500 --> 01:13:55,500
Okay.

773
01:13:55,500 --> 01:13:57,500
So let's look at this.

774
01:13:57,500 --> 01:13:59,500
So I'm going to.

775
01:13:59,500 --> 01:14:02,500
I'm going to start off actually with a list comprehension.

776
01:14:02,500 --> 01:14:06,500
Actually, let me let me not do that and then I'll show you why I do do that.

777
01:14:06,500 --> 01:14:10,500
So what we want to do then is go through Linux Etsy password TXT.

778
01:14:10,500 --> 01:14:13,500
So I'm going to start off with, you know, curly braces.

779
01:14:13,500 --> 01:14:18,500
I'm going to say here one line for one line in open.

780
01:14:18,500 --> 01:14:20,500
Linux Etsy password.

781
01:14:20,500 --> 01:14:21,500
Great.

782
01:14:21,500 --> 01:14:25,500
And I have a set of the lines from this file, which seems weird, right?

783
01:14:25,500 --> 01:14:27,500
Like, why would I want to read these in as a set?

784
01:14:27,500 --> 01:14:29,500
But actually, there are times when we might want to do that.

785
01:14:29,500 --> 01:14:33,500
And then I say, well, how am I going to want to get this data?

786
01:14:33,500 --> 01:14:34,500
Well, I know.

787
01:14:34,500 --> 01:14:37,500
First of all, I'm going to add an if statement here, like looking for a colon each line.

788
01:14:37,500 --> 01:14:40,500
So I'll say if colon in one line.

789
01:14:40,500 --> 01:14:43,500
And yes, you can have the condition there and a set comprehension as well.

790
01:14:43,500 --> 01:14:46,500
And then I'm going to say, well, I have to break it apart.

791
01:14:46,500 --> 01:14:49,500
So I'm going to say one line dot split on colon.

792
01:14:49,500 --> 01:14:52,500
And that's where it goes wrong.

793
01:14:52,500 --> 01:14:57,500
And it goes wrong because split always returns a list, a list of strings.

794
01:14:57,500 --> 01:15:01,500
And the set comprehension cannot have things that are not hashable.

795
01:15:01,500 --> 01:15:03,500
Not hashable is more or less immutable.

796
01:15:03,500 --> 01:15:06,500
Not really, but it's close enough for our purposes.

797
01:15:06,500 --> 01:15:09,500
You can't use a list as a dictionary key.

798
01:15:09,500 --> 01:15:12,500
And so you can't use a list as an element in a set.

799
01:15:12,500 --> 01:15:15,500
It's very nice that I'm just kind of trying to do this one step at a time,

800
01:15:15,500 --> 01:15:21,500
stepping through what I have to do in order to get the shell from each line.

801
01:15:21,500 --> 01:15:23,500
But Python doesn't know that.

802
01:15:23,500 --> 01:15:25,500
It doesn't know that I'm almost done having a list there.

803
01:15:25,500 --> 01:15:26,500
And so it blows up.

804
01:15:26,500 --> 01:15:30,500
And so that's why I will very often just use a list comprehension at first

805
01:15:30,500 --> 01:15:32,500
and then later on change the braces back.

806
01:15:32,500 --> 01:15:36,500
And now I can sort of inspect it and see what's going on.

807
01:15:36,500 --> 01:15:40,500
I should add that, yes, I use an IDE or an editor of some sort.

808
01:15:40,500 --> 01:15:44,500
And I use all sorts of fancier tools for developing.

809
01:15:44,500 --> 01:15:48,500
But very, very often I develop in Jupyter, especially with something small.

810
01:15:48,500 --> 01:15:50,500
I call Jupyter my laboratory for Python

811
01:15:50,500 --> 01:15:53,500
because I can do lots of little experiments quickly and easily.

812
01:15:53,500 --> 01:15:56,500
And so I'll sometimes go back and forth between my editor and Jupyter,

813
01:15:56,500 --> 01:15:57,500
sort of play with things.

814
01:15:57,500 --> 01:16:00,500
In any event, what we see here then is I have a list of lists, right?

815
01:16:00,500 --> 01:16:02,500
The list on the outside from the list comprehension

816
01:16:02,500 --> 01:16:04,500
and the list on the inside from split.

817
01:16:04,500 --> 01:16:07,500
And we can see that very similar to what we had before

818
01:16:07,500 --> 01:16:10,500
where we were getting the usernames at index 0,

819
01:16:10,500 --> 01:16:15,500
now I'm going to want to get the shell from index.

820
01:16:15,500 --> 01:16:18,500
I'm just going to call it index minus 1 because I can't count that high.

821
01:16:18,500 --> 01:16:19,500
Right?

822
01:16:19,500 --> 01:16:22,500
Now we'll also see that we have the backslash n

823
01:16:22,500 --> 01:16:24,500
because when we read from a file,

824
01:16:24,500 --> 01:16:28,500
each iteration gives us up to and including that newline character.

825
01:16:28,500 --> 01:16:30,500
So it will always include the newlines.

826
01:16:30,500 --> 01:16:32,500
We've got to get rid of that somehow.

827
01:16:32,500 --> 01:16:35,500
Well, that's okay. I can do like, you know, just strip here.

828
01:16:35,500 --> 01:16:40,500
And now I have a list of all the shells in that file.

829
01:16:40,500 --> 01:16:42,500
And now that I have the data that I want,

830
01:16:42,500 --> 01:16:46,500
I can unicify it by saying here curly braces.

831
01:16:46,500 --> 01:16:49,500
And now I have a set with all the different shells in that file.

832
01:16:49,500 --> 01:16:51,500
And the set did the hard work for me

833
01:16:51,500 --> 01:16:54,500
of making sure I don't have any duplicates here,

834
01:16:54,500 --> 01:16:56,500
which is pretty snazzy, I think.

835
01:16:56,500 --> 01:17:00,500
Right? So once again, we see that we have our three parts to comprehension.

836
01:17:00,500 --> 01:17:03,500
We have the expression, which here is getting somewhat complicated.

837
01:17:03,500 --> 01:17:05,500
We have the iteration, which is not that complicated.

838
01:17:05,500 --> 01:17:09,500
And then we have the condition where we can do all sorts of things.

839
01:17:09,500 --> 01:17:12,500
Questions, comments, thoughts about this?

840
01:17:12,500 --> 01:17:15,500
Why did I not start off with a set?

841
01:17:15,500 --> 01:17:18,500
Why did I not start off with a set?

842
01:17:18,500 --> 01:17:21,500
Why did I not start off with a set?

843
01:17:21,500 --> 01:17:24,500
Oh, I didn't start with... So why did I not start off with a set?

844
01:17:24,500 --> 01:17:28,500
Simply because I'm trying to step through a whole bunch of possibilities.

845
01:17:28,500 --> 01:17:31,500
Right? So if I know that I want to do split

846
01:17:31,500 --> 01:17:33,500
and then I know I want to do something with that split,

847
01:17:33,500 --> 01:17:37,500
but split is going to give me a list, and lists cannot be set elements.

848
01:17:37,500 --> 01:17:40,500
So basically, if at any point along the way,

849
01:17:40,500 --> 01:17:43,500
if I start off with a curly braces for doing a set comprehension,

850
01:17:43,500 --> 01:17:45,500
and at some point along the way,

851
01:17:45,500 --> 01:17:48,500
I end up with a list as the output for my expression,

852
01:17:48,500 --> 01:17:50,500
then it'll blow up.

853
01:17:50,500 --> 01:17:53,500
So starting with a list comprehension is just like a fail safe.

854
01:17:53,500 --> 01:17:57,500
I know that I'll get back something that I can view and inspect,

855
01:17:57,500 --> 01:17:59,500
and then if I go past that list,

856
01:17:59,500 --> 01:18:02,500
then I'll be able to change it back to be a set comprehension.

857
01:18:06,500 --> 01:18:08,500
Other questions?

858
01:18:11,500 --> 01:18:13,500
Okay.

859
01:18:13,500 --> 01:18:17,500
So we can run set comprehensions on all sorts of things,

860
01:18:17,500 --> 01:18:19,500
and really, I've done this quite a bit,

861
01:18:19,500 --> 01:18:22,500
and don't forget that sets have all sorts of great operators

862
01:18:22,500 --> 01:18:26,500
and methods that we can use to compare them with other sets.

863
01:18:26,500 --> 01:18:28,500
So, I mean, it's not unusual.

864
01:18:28,500 --> 01:18:30,500
I've definitely done this a few times

865
01:18:30,500 --> 01:18:32,500
where I've had collections of information

866
01:18:32,500 --> 01:18:34,500
and I had to move it from one place to another.

867
01:18:34,500 --> 01:18:36,500
I wasn't sure what had or had not moved,

868
01:18:36,500 --> 01:18:38,500
and so I would just like slurp up each file

869
01:18:38,500 --> 01:18:40,500
using a set comprehension,

870
01:18:40,500 --> 01:18:43,500
and then I could do, you know, subset and less than,

871
01:18:43,500 --> 01:18:45,500
and, you know, less than a subset,

872
01:18:45,500 --> 01:18:47,500
and subtraction, all that other good stuff

873
01:18:47,500 --> 01:18:49,500
to actually make it work.

874
01:18:49,500 --> 01:18:51,500
Okay.

875
01:18:51,500 --> 01:18:55,500
Well, let's get more complicated.

876
01:18:55,500 --> 01:19:00,500
So what if I have, you know, a string,

877
01:19:00,500 --> 01:19:05,500
and I want to create a string, you know, with some words,

878
01:19:05,500 --> 01:19:07,500
and I want to create a dictionary

879
01:19:07,500 --> 01:19:10,500
where each word is the key

880
01:19:10,500 --> 01:19:14,500
and the word length is the value.

881
01:19:14,500 --> 01:19:16,500
Okay.

882
01:19:16,500 --> 01:19:18,500
Sounds like a really exciting dictionary.

883
01:19:18,500 --> 01:19:20,500
Okay, maybe not.

884
01:19:20,500 --> 01:19:22,500
So basically, how would I do this?

885
01:19:22,500 --> 01:19:26,500
So if I say s equals, this is a bunch of words.

886
01:19:26,500 --> 01:19:28,500
Okay.

887
01:19:28,500 --> 01:19:30,500
So I can turn this into a dictionary

888
01:19:30,500 --> 01:19:32,500
with actually a list comprehension and some help, right?

889
01:19:32,500 --> 01:19:34,500
This is not going to be the best way to do it,

890
01:19:34,500 --> 01:19:36,500
but I'm sort of stepping through the logic here.

891
01:19:36,500 --> 01:19:38,500
So I can say here,

892
01:19:38,500 --> 01:19:40,500
let's just scroll this up a little bit,

893
01:19:40,500 --> 01:19:44,500
so I can say here, you know, one word for one word in s split.

894
01:19:44,500 --> 01:19:46,500
Okay, so far so good.

895
01:19:46,500 --> 01:19:50,500
And now, instead of returning one element as my expression,

896
01:19:50,500 --> 01:19:52,500
I'm going to return a tuple.

897
01:19:52,500 --> 01:19:55,500
I'm going to return one word, comma, len of one word.

898
01:19:55,500 --> 01:19:57,500
And what is that going to do?

899
01:19:57,500 --> 01:19:59,500
It's going to return a list of tuples.

900
01:19:59,500 --> 01:20:01,500
Well, as you might know, right,

901
01:20:01,500 --> 01:20:04,500
we can invoke dict on a list of tuples

902
01:20:04,500 --> 01:20:06,500
and get back a dictionary.

903
01:20:06,500 --> 01:20:09,500
So I can say dict of this whole thing.

904
01:20:09,500 --> 01:20:11,500
And there we go.

905
01:20:11,500 --> 01:20:13,500
I've created a dictionary based on it.

906
01:20:13,500 --> 01:20:15,500
So could I do this?

907
01:20:15,500 --> 01:20:17,500
Yes, absolutely, like we see that I can do it.

908
01:20:17,500 --> 01:20:19,500
But the cool kids, right,

909
01:20:19,500 --> 01:20:23,500
so we could use instead a dictionary comprehension.

910
01:20:23,500 --> 01:20:26,500
Now, I'll add dictionary comprehensions

911
01:20:26,500 --> 01:20:28,500
can look really, really messy,

912
01:20:28,500 --> 01:20:31,500
and you're going to see why in just a moment.

913
01:20:31,500 --> 01:20:33,500
So how do I translate this?

914
01:20:33,500 --> 01:20:35,500
Well, first of all, what kind of braces

915
01:20:35,500 --> 01:20:37,500
are we going to use on dictionary comprehensions?

916
01:20:37,500 --> 01:20:41,500
Curly braces, just like with set comprehensions.

917
01:20:41,500 --> 01:20:43,500
And at first, that seems really weird,

918
01:20:43,500 --> 01:20:45,500
but it's okay, because we use curly braces

919
01:20:45,500 --> 01:20:48,500
in general in Python for both dictionaries and sets.

920
01:20:48,500 --> 01:20:52,500
So how does Python distinguish between those use cases?

921
01:20:52,500 --> 01:20:54,500
Well, in a dictionary, we have colons

922
01:20:54,500 --> 01:20:56,500
between the keys and values,

923
01:20:56,500 --> 01:20:58,500
and in a set, we don't.

924
01:20:58,500 --> 01:21:01,500
So basically, Python looks for colons in there.

925
01:21:01,500 --> 01:21:03,500
If they're colons, dictionary.

926
01:21:03,500 --> 01:21:04,500
No colons, set.

927
01:21:04,500 --> 01:21:06,500
The same thing is going to be true here.

928
01:21:06,500 --> 01:21:13,500
So we use curly braces just as with a set comprehension.

929
01:21:13,500 --> 01:21:19,500
But we have two expressions in the first line

930
01:21:19,500 --> 01:21:22,500
separated by a colon,

931
01:21:22,500 --> 01:21:26,500
and that is weird, as you're about to see.

932
01:21:26,500 --> 01:21:29,500
So I'm going to say here, curly braces,

933
01:21:29,500 --> 01:21:32,500
and I'm going to purposely put in a lot of extra white space

934
01:21:32,500 --> 01:21:36,500
so it can be more obvious, colon, len of one word.

935
01:21:36,500 --> 01:21:39,500
So this is my key value expression,

936
01:21:39,500 --> 01:21:42,500
and then here I'm going to say for one word in ssplit.

937
01:21:42,500 --> 01:21:45,500
That doesn't change, and I'll have my closing thing there.

938
01:21:45,500 --> 01:21:48,500
And it works. It definitely does work.

939
01:21:48,500 --> 01:21:51,500
But, ugh, right?

940
01:21:51,500 --> 01:21:54,500
Like, you have this expression, and you have that expression,

941
01:21:54,500 --> 01:21:57,500
and they are independent of one another.

942
01:21:57,500 --> 01:22:00,500
And that is really annoying in a whole bunch of cases.

943
01:22:00,500 --> 01:22:03,500
Now, we will see how we can clean that up,

944
01:22:03,500 --> 01:22:05,500
but it's going to have consequences, folks.

945
01:22:05,500 --> 01:22:07,500
It's going to clean it in some ways

946
01:22:07,500 --> 01:22:09,500
and look ugly in other ways.

947
01:22:09,500 --> 01:22:11,500
That's the way it is.

948
01:22:11,500 --> 01:22:13,500
So basically, a dictionary comprehension

949
01:22:13,500 --> 01:22:17,500
is going to have two expressions separated by a colon.

950
01:22:17,500 --> 01:22:19,500
That also means, by the way,

951
01:22:19,500 --> 01:22:22,500
can you use a function with a dictionary comprehension?

952
01:22:22,500 --> 01:22:24,500
The answer is yes.

953
01:22:24,500 --> 01:22:26,500
But if you're using that function,

954
01:22:26,500 --> 01:22:28,500
it's going to return either a value for the key

955
01:22:28,500 --> 01:22:30,500
or a value for the value.

956
01:22:30,500 --> 01:22:32,500
It can't do both.

957
01:22:32,500 --> 01:22:34,500
Like, you could normally say,

958
01:22:34,500 --> 01:22:36,500
but, but, but, but, a function can return a tuple.

959
01:22:36,500 --> 01:22:39,500
Yeah, it can, but it can't return a colon.

960
01:22:39,500 --> 01:22:41,500
The colon is a syntactic element here

961
01:22:41,500 --> 01:22:43,500
that we just can't get around.

962
01:22:43,500 --> 01:22:45,500
And that's the sort of annoying thing

963
01:22:45,500 --> 01:22:47,500
with these sorts of things.

964
01:22:47,500 --> 01:22:49,500
Let me see if I have it here.

965
01:22:49,500 --> 01:22:51,500
If not, I'll just create it really quickly.

966
01:22:51,500 --> 01:22:53,500
Do I have? No. All right.

967
01:22:53,500 --> 01:22:58,500
So I'm going to create a really fast config file, right,

968
01:22:58,500 --> 01:23:01,500
with name equals value on each line.

969
01:23:01,500 --> 01:23:05,500
So I'm going to say with open my config.txt

970
01:23:05,500 --> 01:23:08,500
for writing as outfile.

971
01:23:08,500 --> 01:23:11,500
I'm going to say here for, you know, one key.

972
01:23:11,500 --> 01:23:13,500
Let's do this.

973
01:23:13,500 --> 01:23:15,500
I'll say here index one key.

974
01:23:15,500 --> 01:23:17,500
Let's do one character.

975
01:23:17,500 --> 01:23:23,500
In, we'll say here enumerate of, let's say, abcd.

976
01:23:23,500 --> 01:23:25,500
We'll start with one.

977
01:23:25,500 --> 01:23:27,500
Say here outfile right.

978
01:23:27,500 --> 01:23:29,500
And on each line I'm going to say here

979
01:23:29,500 --> 01:23:35,500
one character equals index new line.

980
01:23:35,500 --> 01:23:38,500
Okay, now if I look at my config.txt,

981
01:23:38,500 --> 01:23:40,500
look at that.

982
01:23:40,500 --> 01:23:42,500
Fantastic. I've got a configuration file

983
01:23:42,500 --> 01:23:44,500
written to perfection.

984
01:23:44,500 --> 01:23:46,500
It just doesn't really configure anything useful.

985
01:23:46,500 --> 01:23:48,500
And by the way, this, I love, love, love, love

986
01:23:48,500 --> 01:23:50,500
this kind of like code in Python

987
01:23:50,500 --> 01:23:52,500
where we're opening the file for writing within a width

988
01:23:52,500 --> 01:23:55,500
so we know that it's going to be flushed and closed.

989
01:23:55,500 --> 01:23:57,500
I give it an alias there outfile.

990
01:23:57,500 --> 01:24:01,500
And then I iterate over that string using enumerate.

991
01:24:01,500 --> 01:24:03,500
And enumerate, when we iterate over,

992
01:24:03,500 --> 01:24:06,500
it gives us two things, the index and the character.

993
01:24:06,500 --> 01:24:08,500
So it's going to go through abcd,

994
01:24:08,500 --> 01:24:10,500
but we're going to get actually, we're going to get

995
01:24:10,500 --> 01:24:12,500
1a, 2b, 3c, 4d.

996
01:24:12,500 --> 01:24:14,500
And the reason it starts with one and not with zero

997
01:24:14,500 --> 01:24:16,500
is because I'm told to do that.

998
01:24:16,500 --> 01:24:18,500
And I'm just going to write to the file

999
01:24:18,500 --> 01:24:20,500
these lines using an f string there.

1000
01:24:20,500 --> 01:24:22,500
So I've got my file.

1001
01:24:22,500 --> 01:24:24,500
So I can use a dict comprehension

1002
01:24:24,500 --> 01:24:28,500
to read this file into a dict.

1003
01:24:28,500 --> 01:24:31,500
I can say here, well, what am I going to do?

1004
01:24:31,500 --> 01:24:35,500
We're going to say for one line in open

1005
01:24:35,500 --> 01:24:38,500
what's it called, my config.txt.

1006
01:24:38,500 --> 01:24:40,500
And then what is going to be the key?

1007
01:24:40,500 --> 01:24:46,500
Yeah, it's going to be one line split on equals zero.

1008
01:24:46,500 --> 01:24:48,500
What's going to be the value?

1009
01:24:48,500 --> 01:24:51,500
One line split on equals one.

1010
01:24:51,500 --> 01:24:53,500
Oh, no, it's not.

1011
01:24:53,500 --> 01:24:55,500
We also have to have a strip in there.

1012
01:24:55,500 --> 01:24:57,500
Beautiful, right?

1013
01:24:57,500 --> 01:24:59,500
This is why people say Python code is always so elegant.

1014
01:24:59,500 --> 01:25:01,500
Okay, maybe not so much here.

1015
01:25:01,500 --> 01:25:03,500
But you can see that it worked,

1016
01:25:03,500 --> 01:25:05,500
that I was able to, with this dict comprehension,

1017
01:25:05,500 --> 01:25:07,500
read this configuration file into a dictionary

1018
01:25:07,500 --> 01:25:09,500
very, very easily.

1019
01:25:09,500 --> 01:25:11,500
And so we see here really, again,

1020
01:25:11,500 --> 01:25:15,500
the sort of power of these comprehensions.

1021
01:25:15,500 --> 01:25:17,500
Okay?

1022
01:25:17,500 --> 01:25:19,500
Questions, comments until here,

1023
01:25:19,500 --> 01:25:21,500
and then we'll practice this a little bit.

1024
01:25:21,500 --> 01:25:23,500
Yeah, please.

1025
01:25:23,500 --> 01:25:25,500
man speaking off mic

1026
01:25:30,500 --> 01:25:32,500
Oh, I flip a coin.

1027
01:25:32,500 --> 01:25:34,500
A virtual one.

1028
01:25:34,500 --> 01:25:36,500
A virtual one, right?

1029
01:25:36,500 --> 01:25:38,500
So here's the thing.

1030
01:25:38,500 --> 01:25:42,500
You can run strip on a string.

1031
01:25:42,500 --> 01:25:46,500
So you can either do it before you do the splitting up of stuff

1032
01:25:46,500 --> 01:25:48,500
or after you've got one element.

1033
01:25:48,500 --> 01:25:50,500
A very common mistake that I see people make

1034
01:25:50,500 --> 01:25:52,500
is they do split, and then they try to do strip,

1035
01:25:52,500 --> 01:25:56,500
and it blows up because strip is not a list method.

1036
01:25:56,500 --> 01:26:00,500
But I am extremely inconsistent in when I do it,

1037
01:26:00,500 --> 01:26:03,500
and probably at some point I should check to see which is faster,

1038
01:26:03,500 --> 01:26:07,500
and if there's any real difference, then I should make a decision.

1039
01:26:07,500 --> 01:26:11,500
But yeah, I probably should do that at some point.

1040
01:26:11,500 --> 01:26:13,500
Other questions?

1041
01:26:13,500 --> 01:26:15,500
Yeah, please.

1042
01:26:15,500 --> 01:26:17,500
man speaking off mic

1043
01:26:23,500 --> 01:26:27,500
So, probably sort of kind of.

1044
01:26:27,500 --> 01:26:30,500
So the way that it works is, so with explicitly,

1045
01:26:30,500 --> 01:26:32,500
I'll just scroll up back here.

1046
01:26:32,500 --> 01:26:34,500
Can I scroll there?

1047
01:26:34,500 --> 01:26:37,500
So with is what we call a context manager,

1048
01:26:37,500 --> 01:26:40,500
and it basically hides two method calls in here.

1049
01:26:40,500 --> 01:26:44,500
Here it calls outfile.enter,

1050
01:26:44,500 --> 01:26:49,500
and here it's calling outfile.exit.

1051
01:26:49,500 --> 01:26:53,500
And basically, like, these are hidden methods, magic methods,

1052
01:26:53,500 --> 01:26:56,500
and enter actually does nothing here, although it could directly do something,

1053
01:26:56,500 --> 01:26:58,500
and exit says I want to flush and close the file.

1054
01:26:58,500 --> 01:27:00,500
So this guarantees that by the end of the with block,

1055
01:27:00,500 --> 01:27:02,500
the file is definitely flushed and closed,

1056
01:27:02,500 --> 01:27:04,500
and when you're writing to a file, this is important,

1057
01:27:04,500 --> 01:27:08,500
because if you don't flush and close it, it might be a very long time.

1058
01:27:08,500 --> 01:27:11,500
It will eventually get closed, and it will eventually get flushed,

1059
01:27:11,500 --> 01:27:13,500
but it might be when Python shuts down,

1060
01:27:13,500 --> 01:27:16,500
which will be, like, for me at the end of this session, which is kind of sad.

1061
01:27:16,500 --> 01:27:19,500
So with is like, I know when I want it to happen.

1062
01:27:19,500 --> 01:27:24,500
I, first of all, don't get too worried about it when I read from a file.

1063
01:27:24,500 --> 01:27:27,500
Whatever, I'm opening a file for reading.

1064
01:27:27,500 --> 01:27:32,500
I know that makes me, like, you know, a bad guy in the Python world in some places.

1065
01:27:32,500 --> 01:27:33,500
I'll take him on.

1066
01:27:33,500 --> 01:27:35,500
Now, like, I mean, if you're working with lots and lots of files,

1067
01:27:35,500 --> 01:27:36,500
that can be a problem.

1068
01:27:36,500 --> 01:27:38,500
If you're working with Windows, I'm told that Windows doesn't like it

1069
01:27:38,500 --> 01:27:41,500
if two people try to read from the same file at the same time.

1070
01:27:41,500 --> 01:27:45,500
But, like, generally speaking, I don't care that much in these sorts of situations,

1071
01:27:45,500 --> 01:27:48,500
in part also because, and we are going to have time to look at this,

1072
01:27:48,500 --> 01:27:52,500
what I mentioned earlier, comprehension's open a new scope.

1073
01:27:52,500 --> 01:27:55,500
And so what's going to happen is when the comprehension returns,

1074
01:27:55,500 --> 01:28:00,500
that scope disappears, and so the odds of still having a reference

1075
01:28:00,500 --> 01:28:02,500
to that file object are very slim,

1076
01:28:02,500 --> 01:28:06,500
and so I think the file is going to be almost certainly closed right away.

1077
01:28:06,500 --> 01:28:09,500
It's not guaranteed, but it's so close that, like, who cares?

1078
01:28:09,500 --> 01:28:13,500
Also, you can't put width inside of a comprehension, so there.

1079
01:28:13,500 --> 01:28:15,500
Yeah, please.

1080
01:28:15,500 --> 01:28:37,500
So generally speaking, any variables that you are assigning to inside,

1081
01:28:37,500 --> 01:28:41,500
not modifying, but assignments to variables inside of a comprehension,

1082
01:28:41,500 --> 01:28:44,500
which really only occurs in one place,

1083
01:28:44,500 --> 01:28:47,500
it really only occurs here in the for loop, right?

1084
01:28:47,500 --> 01:28:50,500
So that variable is internal, local,

1085
01:28:50,500 --> 01:28:53,500
has nothing to do with anything outside of the comprehension,

1086
01:28:53,500 --> 01:28:55,500
which is, and again, we'll see this a little bit

1087
01:28:55,500 --> 01:28:57,500
because I'm excited that we'll have time to do this,

1088
01:28:57,500 --> 01:29:02,500
is in stark contrast to for loops, right?

1089
01:29:02,500 --> 01:29:05,500
And it was something new that they put in Python 3,

1090
01:29:05,500 --> 01:29:07,500
which is not so new anymore, but, like, I'm old.

1091
01:29:07,500 --> 01:29:10,500
But, like, basically, I remember it was very surprising,

1092
01:29:10,500 --> 01:29:12,500
and when I sort of dug into it,

1093
01:29:12,500 --> 01:29:16,500
it was kind of cool to see what they did there.

1094
01:29:16,500 --> 01:29:19,500
Other questions?

1095
01:29:19,500 --> 01:29:22,500
Okay.

1096
01:29:22,500 --> 01:29:24,500
So here's what I want to do.

1097
01:29:24,500 --> 01:29:30,500
Let's do a little exercise to play with dict comprehensions a little more.

1098
01:29:30,500 --> 01:29:33,500
Let's do this.

1099
01:29:33,500 --> 01:29:38,500
Let's do usernames and shells.

1100
01:29:38,500 --> 01:29:42,500
What I want you to do is use a dict comprehension

1101
01:29:42,500 --> 01:29:48,500
to create a dict in which the keys are usernames

1102
01:29:48,500 --> 01:29:55,500
and the values are the shells associated with those usernames

1103
01:29:55,500 --> 01:29:59,500
in Linux.xzpassword.txt.

1104
01:29:59,500 --> 01:30:02,500
I guess I don't need a number one here. That's it.

1105
01:30:02,500 --> 01:30:04,500
All right, so I'll give you a few minutes to work on that,

1106
01:30:04,500 --> 01:30:06,500
and then we'll look at it together.

1107
01:30:06,500 --> 01:30:11,500
All right, so I'm going to start off like with the set comprehension.

1108
01:30:11,500 --> 01:30:13,500
I'm going to start off with a list comprehension here.

1109
01:30:13,500 --> 01:30:15,500
Again, not because I have to,

1110
01:30:15,500 --> 01:30:17,500
but just so I can sort of get a feel for what's going on

1111
01:30:17,500 --> 01:30:19,500
and then rejigger things as necessary.

1112
01:30:19,500 --> 01:30:23,500
So I'm going to say here one line, for one line in open,

1113
01:30:23,500 --> 01:30:26,500
Linux, xzpassword, blah, blah, blah.

1114
01:30:26,500 --> 01:30:29,500
We'll say if colon in one line.

1115
01:30:29,500 --> 01:30:31,500
So we get our standard stuff.

1116
01:30:31,500 --> 01:30:33,500
And then what am I going to want from there?

1117
01:30:33,500 --> 01:30:37,500
Well, I'm going to say here one line split on colon.

1118
01:30:37,500 --> 01:30:39,500
I'm going to do it the tuple way first.

1119
01:30:39,500 --> 01:30:44,500
Split, zero, comma, one line split on colon.

1120
01:30:44,500 --> 01:30:47,500
Say here minus one, strip.

1121
01:30:47,500 --> 01:30:50,500
And so now I'll get my list of tuples.

1122
01:30:50,500 --> 01:30:53,500
Not exactly what I wanted, but pretty close.

1123
01:30:53,500 --> 01:30:55,500
And now at least I understand

1124
01:30:55,500 --> 01:30:57,500
what are the different components I'm going to need.

1125
01:30:57,500 --> 01:31:02,500
Okay, and so now I can rejigger it into an actual dict comprehension.

1126
01:31:02,500 --> 01:31:06,500
So here I'm going to copy this and this and this.

1127
01:31:06,500 --> 01:31:13,500
So now I'll start with a list-tuple combo.

1128
01:31:13,500 --> 01:31:18,500
And then here I'm going to say now curly braces, colon.

1129
01:31:18,500 --> 01:31:23,500
Again, I'm exaggerating the whitespace, colon.

1130
01:31:23,500 --> 01:31:25,500
And there we go. I get the same thing back.

1131
01:31:25,500 --> 01:31:29,500
So I can start off with one and get the other one.

1132
01:31:29,500 --> 01:31:31,500
And sure enough, I now have this dictionary

1133
01:31:31,500 --> 01:31:34,500
in which the usernames are keys and the shells are values,

1134
01:31:34,500 --> 01:31:37,500
and it's going to work great.

1135
01:31:37,500 --> 01:31:41,500
Okay? Questions? Yes, please.

1136
01:31:41,500 --> 01:31:44,500
For iterables with a large number of elements,

1137
01:31:44,500 --> 01:31:48,500
what's the implication of that being called split, like?

1138
01:31:48,500 --> 01:31:53,500
Yeah, great question.

1139
01:31:53,500 --> 01:31:55,500
Could be worse. Right?

1140
01:31:55,500 --> 01:31:58,500
Like, split is at least written in C,

1141
01:31:58,500 --> 01:32:00,500
part of the standard library. It's running on a string.

1142
01:32:00,500 --> 01:32:03,500
But your point is a good one.

1143
01:32:03,500 --> 01:32:06,500
And it does really, like, even someone like me,

1144
01:32:06,500 --> 01:32:09,500
I mean, I'm a dynamic language kind of guy.

1145
01:32:09,500 --> 01:32:12,500
There's a reason I'm in Python. I'm like, oh, please.

1146
01:32:12,500 --> 01:32:14,500
I'm paid by the hour. I'm a consultant.

1147
01:32:14,500 --> 01:32:16,500
If it takes longer, all the better.

1148
01:32:16,500 --> 01:32:20,500
But there are times when I actually do want things to run faster,

1149
01:32:20,500 --> 01:32:24,500
and this just sort of haunts me a little bit.

1150
01:32:24,500 --> 01:32:29,500
So maybe, maybe I could improve this a little bit.

1151
01:32:29,500 --> 01:32:31,500
And the question is how?

1152
01:32:31,500 --> 01:32:35,500
Like, it would be really nice if I could split it once

1153
01:32:35,500 --> 01:32:37,500
and then use it twice.

1154
01:32:37,500 --> 01:32:41,500
But as I said before, those two parts of the expression are distinct.

1155
01:32:41,500 --> 01:32:44,500
They can't, like, carry over.

1156
01:32:44,500 --> 01:32:51,500
But, but, what gets executed before the expression in the top line?

1157
01:32:51,500 --> 01:32:54,500
Well, the for loop and the if.

1158
01:32:54,500 --> 01:32:58,500
What if I could somehow take advantage of that

1159
01:32:58,500 --> 01:33:00,500
and have it carry over?

1160
01:33:00,500 --> 01:33:03,500
I'm glad you are all sitting down.

1161
01:33:06,500 --> 01:33:09,500
I hope you also brought Tylenol.

1162
01:33:09,500 --> 01:33:12,500
Okay, so here's the thing.

1163
01:33:12,500 --> 01:33:15,500
This if here at the bottom, this is a condition.

1164
01:33:15,500 --> 01:33:19,500
Right? What could I possibly do there?

1165
01:33:19,500 --> 01:33:23,500
Well, what if I made it a compound condition?

1166
01:33:23,500 --> 01:33:25,500
What if I said, like, and something?

1167
01:33:25,500 --> 01:33:27,500
Well, and what?

1168
01:33:27,500 --> 01:33:30,500
I could say, like, and true.

1169
01:33:30,500 --> 01:33:35,500
What if I were to say, like, and one line split on colon?

1170
01:33:35,500 --> 01:33:36,500
Well, it's not going to be bad.

1171
01:33:36,500 --> 01:33:37,500
I'm going to get the same thing.

1172
01:33:37,500 --> 01:33:38,500
It's kind of useless.

1173
01:33:38,500 --> 01:33:40,500
Like, now I'm using split three times.

1174
01:33:40,500 --> 01:33:41,500
Ka-ching!

1175
01:33:41,500 --> 01:33:42,500
No, no, no.

1176
01:33:42,500 --> 01:33:45,500
Like, basically, what if, though,

1177
01:33:45,500 --> 01:33:48,500
what if, though, I could somehow capture it there?

1178
01:33:48,500 --> 01:33:49,500
What if I could put it into a variable?

1179
01:33:49,500 --> 01:33:53,500
Like, what if I could say, like, fields equals that?

1180
01:33:53,500 --> 01:33:55,500
Well, now Python's going to say you can't do that.

1181
01:33:55,500 --> 01:33:58,500
You can't do that because assignment in Python

1182
01:33:58,500 --> 01:34:00,500
is not an expression.

1183
01:34:00,500 --> 01:34:02,500
Assignment is a statement.

1184
01:34:02,500 --> 01:34:04,500
Oh-ho-ho.

1185
01:34:04,500 --> 01:34:06,500
But you know what is an expression?

1186
01:34:06,500 --> 01:34:10,500
The walrus operator, friends.

1187
01:34:10,500 --> 01:34:12,500
And it works just great.

1188
01:34:12,500 --> 01:34:14,500
What the heck is going on here?

1189
01:34:14,500 --> 01:34:17,500
Well, what I said is I'm going to do a one line split.

1190
01:34:17,500 --> 01:34:21,500
We are going to assign it to the variable fields,

1191
01:34:21,500 --> 01:34:23,500
and then the value of fields

1192
01:34:23,500 --> 01:34:25,500
is going to be passed back to the if.

1193
01:34:25,500 --> 01:34:27,500
And it worked just fine.

1194
01:34:27,500 --> 01:34:30,500
And because it executed before our expression,

1195
01:34:30,500 --> 01:34:37,500
I can now say fields zero and fields minus one dot strip.

1196
01:34:37,500 --> 01:34:39,500
Voila, it works.

1197
01:34:39,500 --> 01:34:42,500
And now your colleagues will never talk to you again.

1198
01:34:45,500 --> 01:34:48,500
So, is this better?

1199
01:34:48,500 --> 01:34:50,500
I guess.

1200
01:34:50,500 --> 01:34:54,500
But it does have some downsides,

1201
01:34:54,500 --> 01:34:56,500
like you won't have any friends.

1202
01:34:58,500 --> 01:35:00,500
But more seriously,

1203
01:35:00,500 --> 01:35:07,500
when the walrus operator was sort of revealed to the world,

1204
01:35:07,500 --> 01:35:12,500
this was one of the places where people talked about using it.

1205
01:35:12,500 --> 01:35:15,500
This and while loops, where basically,

1206
01:35:15,500 --> 01:35:18,500
we don't just want to do while true and then check something inside,

1207
01:35:18,500 --> 01:35:20,500
but we want to maybe do something a little more active.

1208
01:35:20,500 --> 01:35:25,500
And I must say, I am consistently, I don't know,

1209
01:35:25,500 --> 01:35:27,500
ambivalent about this.

1210
01:35:27,500 --> 01:35:30,500
I really, like, I want to like it.

1211
01:35:30,500 --> 01:35:33,500
It's really kind of a cool use of things.

1212
01:35:33,500 --> 01:35:39,500
And yet, and yet, it seems more like an abuse rather than use.

1213
01:35:39,500 --> 01:35:43,500
But at least I'm not calling split multiple times, right?

1214
01:35:43,500 --> 01:35:45,500
Like, big win.

1215
01:35:45,500 --> 01:35:47,500
So, yeah, so there's that.

1216
01:35:50,500 --> 01:35:52,500
Any other questions to tempt fate?

1217
01:35:57,500 --> 01:36:00,500
Yes, so, right, so it's a colon before equal.

1218
01:36:00,500 --> 01:36:05,500
And one of the saving graces for the walrus operator

1219
01:36:05,500 --> 01:36:08,500
is that you cannot use it where you use a regular assignment.

1220
01:36:08,500 --> 01:36:10,500
So, if you just try to say like,

1221
01:36:10,500 --> 01:36:12,500
x colon equals five, it won't work for you.

1222
01:36:12,500 --> 01:36:16,500
Now, the walrus is introduced in, I want to say, 3.8.

1223
01:36:16,500 --> 01:36:20,500
So, if you're using a version of Python before that,

1224
01:36:20,500 --> 01:36:22,500
then it won't work at all.

1225
01:36:22,500 --> 01:36:25,500
If you're getting errors and you're after 3.8,

1226
01:36:25,500 --> 01:36:27,500
then it might just be like so.

1227
01:36:27,500 --> 01:36:29,500
I'll tell you the other thing I did is I put parentheses

1228
01:36:29,500 --> 01:36:31,500
around this assignment here.

1229
01:36:31,500 --> 01:36:33,500
Because if you don't do that, I think,

1230
01:36:33,500 --> 01:36:35,500
I think I just like do it instinctively now.

1231
01:36:35,500 --> 01:36:38,500
Yeah, yeah, yeah.

1232
01:36:38,500 --> 01:36:42,500
So, what happens is if you don't put the parentheses there

1233
01:36:42,500 --> 01:36:46,500
making that whole assignment split business one expression,

1234
01:36:46,500 --> 01:36:49,500
then it's like if colon in one line and fields.

1235
01:36:49,500 --> 01:36:52,500
Like, and this then like is hanging off the edge

1236
01:36:52,500 --> 01:36:54,500
and Python's parser isn't sure what to do with it.

1237
01:36:54,500 --> 01:36:56,500
So, you just have to put the parentheses in there.

1238
01:36:56,500 --> 01:36:58,500
Yeah, please.

1239
01:37:09,500 --> 01:37:12,500
So, right, if somehow fields were false,

1240
01:37:12,500 --> 01:37:14,500
then that's right.

1241
01:37:14,500 --> 01:37:16,500
Then the if would not, then we would not run

1242
01:37:16,500 --> 01:37:18,500
that top expression.

1243
01:37:18,500 --> 01:37:20,500
That's exactly right.

1244
01:37:20,500 --> 01:37:22,500
But fields is going to be a list.

1245
01:37:22,500 --> 01:37:24,500
And lists are only false when they're empty.

1246
01:37:24,500 --> 01:37:27,500
So, I'm basically betting here that there's a colon

1247
01:37:27,500 --> 01:37:29,500
in the string.

1248
01:37:29,500 --> 01:37:31,500
And so, when we do the split,

1249
01:37:31,500 --> 01:37:33,500
I'm going to get more than one thing.

1250
01:37:33,500 --> 01:37:35,500
But you're right, there might be some weirdo

1251
01:37:35,500 --> 01:37:37,500
there.

1252
01:37:37,500 --> 01:37:39,500
Yeah.

1253
01:37:45,500 --> 01:37:47,500
Oh, I'm sure.

1254
01:37:47,500 --> 01:37:49,500
I'm sure.

1255
01:37:49,500 --> 01:37:51,500
Oh, the question was could it backfire somehow?

1256
01:37:51,500 --> 01:37:53,500
And I'm sure there is.

1257
01:37:53,500 --> 01:37:55,500
I can't think of it offhand.

1258
01:37:55,500 --> 01:37:57,500
Like, I think the real backfiring,

1259
01:37:57,500 --> 01:37:59,500
like look, you might or might not know this,

1260
01:37:59,500 --> 01:38:01,500
but like when the walrus was approved,

1261
01:38:01,500 --> 01:38:04,500
there was like a firestorm in the Python community

1262
01:38:04,500 --> 01:38:06,500
of like what?

1263
01:38:06,500 --> 01:38:08,500
What craziness?

1264
01:38:08,500 --> 01:38:10,500
How could such a thing, like, and so,

1265
01:38:10,500 --> 01:38:12,500
like it was a really, really, really big deal.

1266
01:38:12,500 --> 01:38:14,500
Like, you think Python people are all nice

1267
01:38:14,500 --> 01:38:16,500
and calm and reasonable,

1268
01:38:16,500 --> 01:38:18,500
yet introduce a walrus into the language

1269
01:38:18,500 --> 01:38:20,500
and like the big teeth come out,

1270
01:38:20,500 --> 01:38:22,500
you know, all meanings aside.

1271
01:38:22,500 --> 01:38:24,500
So, I'm sure

1272
01:38:24,500 --> 01:38:26,500
that there's some like weirdness

1273
01:38:26,500 --> 01:38:28,500
backfiring problem that could

1274
01:38:28,500 --> 01:38:30,500
show up here. That said,

1275
01:38:30,500 --> 01:38:32,500
it is convenient in this

1276
01:38:32,500 --> 01:38:34,500
sort of situation. Like, there are times

1277
01:38:34,500 --> 01:38:36,500
when I'm going to want to do this.

1278
01:38:40,500 --> 01:38:42,500
Are there questions or thoughts about this?

1279
01:38:44,500 --> 01:38:46,500
Total revulsion.

1280
01:38:48,500 --> 01:38:50,500
Alright.

1281
01:38:50,500 --> 01:38:52,500
So, we've now seen

1282
01:38:52,500 --> 01:38:54,500
a whole bunch

1283
01:38:54,500 --> 01:38:56,500
of, we've seen now

1284
01:38:56,500 --> 01:38:58,500
mostly the whole gamut,

1285
01:38:58,500 --> 01:39:00,500
most of the gamut of the comprehensions

1286
01:39:00,500 --> 01:39:02,500
that exist. The normal comprehensions,

1287
01:39:02,500 --> 01:39:04,500
list, set, dict comprehensions.

1288
01:39:04,500 --> 01:39:06,500
And it's hard to

1289
01:39:06,500 --> 01:39:08,500
exaggerate how often we use these.

1290
01:39:08,500 --> 01:39:10,500
I would say list comprehensions are more common than

1291
01:39:10,500 --> 01:39:12,500
set, set are more common than dict,

1292
01:39:12,500 --> 01:39:14,500
but it probably like depends on your usage.

1293
01:39:14,500 --> 01:39:16,500
But very, very, very often,

1294
01:39:16,500 --> 01:39:18,500
if I have, like, and the rule of thumb

1295
01:39:18,500 --> 01:39:20,500
definitely has to be, I have an

1296
01:39:20,500 --> 01:39:22,500
iterable, I want an iterable

1297
01:39:22,500 --> 01:39:24,500
of some sort, I want a list or set or dict,

1298
01:39:24,500 --> 01:39:26,500
and I have some way of mapping between

1299
01:39:26,500 --> 01:39:28,500
the old one and the new one, if you can

1300
01:39:28,500 --> 01:39:30,500
fulfill those three requirements,

1301
01:39:30,500 --> 01:39:32,500
then a comprehension is probably going to be

1302
01:39:32,500 --> 01:39:34,500
faster, more compact,

1303
01:39:34,500 --> 01:39:36,500
and idiomatic in Python.

1304
01:39:36,500 --> 01:39:38,500
It doesn't mean that you should

1305
01:39:38,500 --> 01:39:40,500
not ever use a for loop,

1306
01:39:40,500 --> 01:39:42,500
but those are the situations in which you should

1307
01:39:42,500 --> 01:39:44,500
try to use it.

1308
01:39:44,500 --> 01:39:46,500
Okay.

1309
01:39:46,500 --> 01:39:48,500
But, we

1310
01:39:48,500 --> 01:39:50,500
can do even more than that.

1311
01:39:50,500 --> 01:39:52,500
Why stop there?

1312
01:39:52,500 --> 01:39:54,500
So, let's say I have

1313
01:39:54,500 --> 01:39:56,500
a list. My list equals

1314
01:39:56,500 --> 01:39:58,500
I'm going to create now a list of lists

1315
01:39:58,500 --> 01:40:00,500
where inner lists have,

1316
01:40:00,500 --> 01:40:02,500
you know, are contained

1317
01:40:02,500 --> 01:40:04,500
integers. So, I'm going to say

1318
01:40:04,500 --> 01:40:06,500
my list is, we're going to say here like

1319
01:40:06,500 --> 01:40:08,500
10, 20, 25.

1320
01:40:08,500 --> 01:40:10,500
This is going to be very

1321
01:40:10,500 --> 01:40:12,500
exciting, people. I'm going to say here like

1322
01:40:12,500 --> 01:40:14,500
30, 35, 40, 45, 50.

1323
01:40:14,500 --> 01:40:16,500
I'm going to say here,

1324
01:40:16,500 --> 01:40:18,500
you know, 60, 70,

1325
01:40:18,500 --> 01:40:20,500
80, 90, 100.

1326
01:40:20,500 --> 01:40:22,500
Let's just do one more.

1327
01:40:22,500 --> 01:40:24,500
110, 115,

1328
01:40:24,500 --> 01:40:26,500
120, 130,

1329
01:40:26,500 --> 01:40:28,500
140, 145.

1330
01:40:28,500 --> 01:40:30,500
Okay, I think that's good enough.

1331
01:40:30,500 --> 01:40:32,500
Okay. So, we have

1332
01:40:32,500 --> 01:40:34,500
here a list of lists.

1333
01:40:34,500 --> 01:40:36,500
How can I sum

1334
01:40:36,500 --> 01:40:38,500
the integers

1335
01:40:38,500 --> 01:40:40,500
in this nested list?

1336
01:40:40,500 --> 01:40:42,500
And the

1337
01:40:42,500 --> 01:40:44,500
first thing you might say, you know, first guess

1338
01:40:44,500 --> 01:40:46,500
is sum.

1339
01:40:46,500 --> 01:40:48,500
Bad guess.

1340
01:40:48,500 --> 01:40:50,500
So, I say sum of my list

1341
01:40:50,500 --> 01:40:52,500
and it completely falls apart

1342
01:40:52,500 --> 01:40:54,500
right out of the gate. Why?

1343
01:40:54,500 --> 01:40:56,500
Because once again, it starts

1344
01:40:56,500 --> 01:40:58,500
off with a total of zero and it goes

1345
01:40:58,500 --> 01:41:00,500
through my list. Well,

1346
01:41:00,500 --> 01:41:02,500
what is the first element of my list?

1347
01:41:02,500 --> 01:41:04,500
It's a list. So, it tries to add

1348
01:41:04,500 --> 01:41:06,500
zero plus 10,

1349
01:41:06,500 --> 01:41:08,500
20, 25.

1350
01:41:08,500 --> 01:41:10,500
Right? And it says then, I can't do that. I can't

1351
01:41:10,500 --> 01:41:12,500
add an int and a list together.

1352
01:41:12,500 --> 01:41:14,500
So, this is already not

1353
01:41:14,500 --> 01:41:16,500
doing so well.

1354
01:41:16,500 --> 01:41:18,500
But maybe I could

1355
01:41:18,500 --> 01:41:20,500
use a comprehension to do something

1356
01:41:20,500 --> 01:41:22,500
with this. Right? Maybe

1357
01:41:22,500 --> 01:41:24,500
because we are in a comprehension tutorial, right?

1358
01:41:24,500 --> 01:41:26,500
So, you know, guess two.

1359
01:41:26,500 --> 01:41:28,500
Use a comprehension.

1360
01:41:28,500 --> 01:41:30,500
So, what if I say like, one

1361
01:41:30,500 --> 01:41:32,500
sublist

1362
01:41:32,500 --> 01:41:34,500
for one sublist in my list

1363
01:41:34,500 --> 01:41:36,500
and I do like a sum on that?

1364
01:41:36,500 --> 01:41:38,500
Actually, that's going to be

1365
01:41:38,500 --> 01:41:40,500
just as bad because it is equivalent

1366
01:41:40,500 --> 01:41:42,500
because what is the result

1367
01:41:42,500 --> 01:41:44,500
of this list comprehension? It's

1368
01:41:44,500 --> 01:41:46,500
exactly the same thing as we had before.

1369
01:41:46,500 --> 01:41:48,500
I mean, look at it. I'm going through my list.

1370
01:41:48,500 --> 01:41:50,500
I'm getting one sublist and I'm

1371
01:41:50,500 --> 01:41:52,500
returning it. I've copied my

1372
01:41:52,500 --> 01:41:54,500
list basically.

1373
01:41:54,500 --> 01:41:56,500
And now we're sort of running into

1374
01:41:56,500 --> 01:41:58,500
that brick wall that I described earlier

1375
01:41:58,500 --> 01:42:00,500
that the number of elements

1376
01:42:00,500 --> 01:42:02,500
that we get back

1377
01:42:02,500 --> 01:42:04,500
is either the same as the input

1378
01:42:04,500 --> 01:42:06,500
or, thanks to if, it can be

1379
01:42:06,500 --> 01:42:08,500
lower. But how can I get

1380
01:42:08,500 --> 01:42:10,500
more things back?

1381
01:42:10,500 --> 01:42:12,500
Right? Because that's what I want to do here. I want to have an

1382
01:42:12,500 --> 01:42:14,500
input of four elements, but I want to

1383
01:42:14,500 --> 01:42:16,500
have output of, let's call it more than

1384
01:42:16,500 --> 01:42:18,500
four because I can't count that fast.

1385
01:42:18,500 --> 01:42:20,500
And now it's time for

1386
01:42:20,500 --> 01:42:22,500
nested list

1387
01:42:22,500 --> 01:42:24,500
comprehensions.

1388
01:42:24,500 --> 01:42:26,500
Where I'm going to say

1389
01:42:26,500 --> 01:42:28,500
one number

1390
01:42:28,500 --> 01:42:30,500
for one

1391
01:42:30,500 --> 01:42:32,500
sublist in my list

1392
01:42:32,500 --> 01:42:34,500
for one number

1393
01:42:34,500 --> 01:42:36,500
in one sublist.

1394
01:42:36,500 --> 01:42:38,500
Ta-da!

1395
01:42:38,500 --> 01:42:40,500
I've got them all out

1396
01:42:40,500 --> 01:42:42,500
one at a time. Now we're going to go over this.

1397
01:42:42,500 --> 01:42:44,500
Don't you worry. Or worry.

1398
01:42:44,500 --> 01:42:46,500
And it works.

1399
01:42:46,500 --> 01:42:48,500
So what the heck is going on here?

1400
01:42:48,500 --> 01:42:50,500
So

1401
01:42:50,500 --> 01:42:52,500
basically, as before,

1402
01:42:52,500 --> 01:42:54,500
we have our for loop.

1403
01:42:54,500 --> 01:42:56,500
For one sublist in my list.

1404
01:42:56,500 --> 01:42:58,500
But we don't yet

1405
01:42:58,500 --> 01:43:00,500
go up to the expression.

1406
01:43:00,500 --> 01:43:02,500
We then, after, in the middle of this

1407
01:43:02,500 --> 01:43:04,500
for loop, right, for iteration of this

1408
01:43:04,500 --> 01:43:06,500
for loop, we then do this for loop.

1409
01:43:06,500 --> 01:43:08,500
And any variables that we defined

1410
01:43:08,500 --> 01:43:10,500
here, for example, one sublist,

1411
01:43:10,500 --> 01:43:12,500
are available here.

1412
01:43:12,500 --> 01:43:14,500
And any variables from both of these

1413
01:43:14,500 --> 01:43:16,500
are available up here.

1414
01:43:16,500 --> 01:43:18,500
So basically,

1415
01:43:18,500 --> 01:43:20,500
I'm able to take a complex data

1416
01:43:20,500 --> 01:43:22,500
structure, in this case a list of

1417
01:43:22,500 --> 01:43:24,500
lists, and break it apart

1418
01:43:24,500 --> 01:43:26,500
into little pieces

1419
01:43:26,500 --> 01:43:28,500
so that I can then extract

1420
01:43:28,500 --> 01:43:30,500
one piece of it.

1421
01:43:30,500 --> 01:43:32,500
Now if I wanted to, right, because

1422
01:43:32,500 --> 01:43:34,500
everything is available everywhere, I could

1423
01:43:34,500 --> 01:43:36,500
do something like, you know, one sublist,

1424
01:43:36,500 --> 01:43:38,500
one number. Right? And now I have a

1425
01:43:38,500 --> 01:43:40,500
tuple in each element of the

1426
01:43:40,500 --> 01:43:42,500
sublist the number came from and the number itself.

1427
01:43:42,500 --> 01:43:44,500
A little weird, but like,

1428
01:43:44,500 --> 01:43:46,500
there's nothing technically wrong with it.

1429
01:43:46,500 --> 01:43:48,500
Oops.

1430
01:43:48,500 --> 01:43:50,500
Oh, come back, come back, come back.

1431
01:43:50,500 --> 01:43:52,500
There we go.

1432
01:43:52,500 --> 01:43:54,500
So how does this work?

1433
01:43:54,500 --> 01:43:56,500
Again, we have a

1434
01:43:56,500 --> 01:43:58,500
regular list comprehension with

1435
01:43:58,500 --> 01:44:00,500
our regular for loop.

1436
01:44:00,500 --> 01:44:02,500
We then said, but wait, the thing that

1437
01:44:02,500 --> 01:44:04,500
I got in each iteration,

1438
01:44:04,500 --> 01:44:06,500
it is also iterable.

1439
01:44:06,500 --> 01:44:08,500
So it has to be an iterable of iterables

1440
01:44:08,500 --> 01:44:10,500
for this to work.

1441
01:44:10,500 --> 01:44:12,500
And then I can iterate over

1442
01:44:12,500 --> 01:44:14,500
both and then I will get output

1443
01:44:14,500 --> 01:44:16,500
not for each main

1444
01:44:16,500 --> 01:44:18,500
item, but rather for each

1445
01:44:18,500 --> 01:44:20,500
sub item.

1446
01:44:20,500 --> 01:44:22,500
Now nested list

1447
01:44:22,500 --> 01:44:24,500
comprehensions, if you think list comprehensions

1448
01:44:24,500 --> 01:44:26,500
confuse people,

1449
01:44:26,500 --> 01:44:28,500
nested list comprehensions completely

1450
01:44:28,500 --> 01:44:30,500
and utterly bamboozle people.

1451
01:44:30,500 --> 01:44:32,500
And it's like, why?

1452
01:44:32,500 --> 01:44:34,500
I think a big part of it is how they're written.

1453
01:44:34,500 --> 01:44:36,500
Traditionally, they are written

1454
01:44:36,500 --> 01:44:38,500
like this.

1455
01:44:38,500 --> 01:44:40,500
Gee, that's

1456
01:44:40,500 --> 01:44:42,500
super understandable, right?

1457
01:44:42,500 --> 01:44:44,500
Like, I didn't understand these for years

1458
01:44:44,500 --> 01:44:46,500
because which for goes with

1459
01:44:46,500 --> 01:44:48,500
which in is evaluated when.

1460
01:44:48,500 --> 01:44:50,500
And the moment that I started

1461
01:44:50,500 --> 01:44:52,500
writing them, I mean, it worked.

1462
01:44:52,500 --> 01:44:54,500
But the moment I started writing

1463
01:44:54,500 --> 01:44:56,500
them on multiple lines, it

1464
01:44:56,500 --> 01:44:58,500
suddenly became like crystal clear to me.

1465
01:44:58,500 --> 01:45:00,500
Because it's also going in an order.

1466
01:45:00,500 --> 01:45:02,500
First the first for,

1467
01:45:02,500 --> 01:45:04,500
then the second for, and if you're daring,

1468
01:45:04,500 --> 01:45:06,500
the third for, and like you can go as many as you want.

1469
01:45:08,500 --> 01:45:10,500
Don't. But you can.

1470
01:45:14,500 --> 01:45:16,500
But wait a second. Oh yeah, please, please, please.

1471
01:45:22,500 --> 01:45:24,500
So, the

1472
01:45:24,500 --> 01:45:26,500
question is, can we use if statements there?

1473
01:45:26,500 --> 01:45:28,500
And the answer is,

1474
01:45:28,500 --> 01:45:30,500
absolutely we can. Let's do that.

1475
01:45:34,500 --> 01:45:36,500
So, I'm going to grab this.

1476
01:45:36,500 --> 01:45:38,500
So, I can put an if statement after

1477
01:45:38,500 --> 01:45:40,500
any of the fours that I want.

1478
01:45:40,500 --> 01:45:42,500
So, I can say here,

1479
01:45:42,500 --> 01:45:44,500
if len of one sublist

1480
01:45:44,500 --> 01:45:46,500
is greater than three.

1481
01:45:46,500 --> 01:45:48,500
And then it will only

1482
01:45:48,500 --> 01:45:50,500
drop down to the second for loop

1483
01:45:50,500 --> 01:45:52,500
if it is greater than three.

1484
01:45:52,500 --> 01:45:54,500
But I can also put

1485
01:45:54,500 --> 01:45:56,500
an if statement after the second four.

1486
01:45:56,500 --> 01:45:58,500
And that will

1487
01:45:58,500 --> 01:46:00,500
evaluate there. If one number,

1488
01:46:00,500 --> 01:46:02,500
say modulo two, meaning, you know,

1489
01:46:02,500 --> 01:46:04,500
only if it's odd.

1490
01:46:04,500 --> 01:46:06,500
So, this is going to give me

1491
01:46:06,500 --> 01:46:08,500
only long sublists.

1492
01:46:08,500 --> 01:46:10,500
So, this is going to give me

1493
01:46:10,500 --> 01:46:12,500
odd numbers from long

1494
01:46:12,500 --> 01:46:14,500
sublists.

1495
01:46:14,500 --> 01:46:16,500
And you can imagine that

1496
01:46:16,500 --> 01:46:18,500
this could be way, way, way more complex

1497
01:46:18,500 --> 01:46:20,500
than that.

1498
01:46:22,500 --> 01:46:24,500
Now, an interesting little outgrowth of this

1499
01:46:24,500 --> 01:46:26,500
is to just say

1500
01:46:28,500 --> 01:46:30,500
oh.

1501
01:46:32,500 --> 01:46:34,500
An interesting little outgrowth of this

1502
01:46:34,500 --> 01:46:36,500
is that you can always,

1503
01:46:36,500 --> 01:46:38,500
in all list comprehensions,

1504
01:46:38,500 --> 01:46:40,500
regardless of how many fours you have,

1505
01:46:40,500 --> 01:46:42,500
you can have multiple ifs.

1506
01:46:42,500 --> 01:46:44,500
You can have multiple if lines, and they are just

1507
01:46:44,500 --> 01:46:46,500
anded together.

1508
01:46:46,500 --> 01:46:48,500
So, I can say here, for example,

1509
01:46:48,500 --> 01:46:50,500
let's do this, like, you know, numbers equals

1510
01:46:50,500 --> 01:46:52,500
10, 20, 30,

1511
01:46:52,500 --> 01:46:54,500
40, 50, 60, 70.

1512
01:46:54,500 --> 01:46:56,500
I don't know. Let's do this actually. Let's do

1513
01:46:56,500 --> 01:46:58,500
35 and 55.

1514
01:46:58,500 --> 01:47:00,500
And then I'll say here,

1515
01:47:00,500 --> 01:47:02,500
one number,

1516
01:47:02,500 --> 01:47:04,500
no, no, no, number,

1517
01:47:04,500 --> 01:47:06,500
one number,

1518
01:47:06,500 --> 01:47:08,500
excuse me,

1519
01:47:08,500 --> 01:47:10,500
for one number, oh,

1520
01:47:10,500 --> 01:47:12,500
yeah, in numbers. And I can say

1521
01:47:12,500 --> 01:47:14,500
here, if one number is

1522
01:47:14,500 --> 01:47:16,500
greater than 40,

1523
01:47:16,500 --> 01:47:18,500
and if one

1524
01:47:18,500 --> 01:47:20,500
number, modulo two.

1525
01:47:20,500 --> 01:47:22,500
I don't have to say and,

1526
01:47:22,500 --> 01:47:24,500
because the structure of

1527
01:47:24,500 --> 01:47:26,500
these nested list comprehensions always

1528
01:47:26,500 --> 01:47:28,500
allows me to have multiple ifs. And if I

1529
01:47:28,500 --> 01:47:30,500
have more than one if and only one

1530
01:47:30,500 --> 01:47:32,500
four, that's okay. That actually

1531
01:47:32,500 --> 01:47:34,500
will work. And so I

1532
01:47:34,500 --> 01:47:36,500
think I figured this out like a few years ago. I mean, when I

1533
01:47:36,500 --> 01:47:38,500
said I figured it out, like, I'm sure other people had

1534
01:47:38,500 --> 01:47:40,500
figured this out before me, but I

1535
01:47:40,500 --> 01:47:42,500
like had this revelation. I was like, oh, wow,

1536
01:47:42,500 --> 01:47:44,500
this is really useful. Instead of having a

1537
01:47:44,500 --> 01:47:46,500
really long line of if, this,

1538
01:47:46,500 --> 01:47:48,500
and this, and this, I can just have

1539
01:47:48,500 --> 01:47:50,500
multiple ifs and it will work the same way, and I think

1540
01:47:50,500 --> 01:47:52,500
it's just cleaner.

1541
01:47:54,500 --> 01:47:56,500
So, I'm not going to tell you

1542
01:47:56,500 --> 01:47:58,500
that nested list comprehensions are

1543
01:47:58,500 --> 01:48:00,500
something you're going to do every week.

1544
01:48:00,500 --> 01:48:02,500
Probably not.

1545
01:48:02,500 --> 01:48:04,500
I hope not. But when you

1546
01:48:04,500 --> 01:48:06,500
have a complex data structure,

1547
01:48:06,500 --> 01:48:08,500
it can be really, really

1548
01:48:08,500 --> 01:48:10,500
helpful to unpack

1549
01:48:10,500 --> 01:48:12,500
it using this sort of nested

1550
01:48:12,500 --> 01:48:14,500
list comprehension.

1551
01:48:14,500 --> 01:48:16,500
It really comes in handy. Again,

1552
01:48:16,500 --> 01:48:18,500
not always, but often.

1553
01:48:20,500 --> 01:48:22,500
Okay. And by the way,

1554
01:48:22,500 --> 01:48:24,500
you can, you

1555
01:48:24,500 --> 01:48:26,500
can use nested set comprehensions

1556
01:48:26,500 --> 01:48:28,500
and nested dict comprehensions as

1557
01:48:28,500 --> 01:48:30,500
well, but

1558
01:48:30,500 --> 01:48:32,500
I will let you do crazy

1559
01:48:32,500 --> 01:48:34,500
things like that on your own time.

1560
01:48:34,500 --> 01:48:36,500
That said, I do want

1561
01:48:36,500 --> 01:48:38,500
to practice this a little

1562
01:48:38,500 --> 01:48:40,500
bit, play with it a little bit.

1563
01:48:40,500 --> 01:48:42,500
There's a file that I

1564
01:48:42,500 --> 01:48:44,500
use for this kind of exercise, which I did not

1565
01:48:44,500 --> 01:48:46,500
include in the download.

1566
01:48:46,500 --> 01:48:48,500
I put it on the GitHub

1567
01:48:48,500 --> 01:48:50,500
repo here,

1568
01:48:50,500 --> 01:48:52,500
so you can download from there if you want.

1569
01:48:52,500 --> 01:48:54,500
Also, if you go to

1570
01:48:54,500 --> 01:48:56,500
files.learner.co.il,

1571
01:48:56,500 --> 01:48:58,500
it's under advanced python.

1572
01:48:58,500 --> 01:49:00,500
It's that zip file, and there is some overlap between the two.

1573
01:49:02,500 --> 01:49:04,500
So I'm just going to stick this here.

1574
01:49:04,500 --> 01:49:06,500
And so,

1575
01:49:06,500 --> 01:49:08,500
download the,

1576
01:49:08,500 --> 01:49:10,500
which file is it? Oh yeah,

1577
01:49:10,500 --> 01:49:12,500
it's movies.dat file

1578
01:49:12,500 --> 01:49:14,500
from here.

1579
01:49:14,500 --> 01:49:16,500
And so movies.dat,

1580
01:49:16,500 --> 01:49:18,500
it's just a CSV file,

1581
01:49:18,500 --> 01:49:20,500
with colon, colon between the elements.

1582
01:49:20,500 --> 01:49:22,500
This is like a long list of movies from a

1583
01:49:22,500 --> 01:49:24,500
movie rating system from years ago.

1584
01:49:24,500 --> 01:49:26,500
That's like not at all the important

1585
01:49:26,500 --> 01:49:28,500
thing. And what you see here is,

1586
01:49:28,500 --> 01:49:30,500
we see that each line in this file

1587
01:49:30,500 --> 01:49:32,500
contains a record

1588
01:49:32,500 --> 01:49:34,500
describing one movie.

1589
01:49:34,500 --> 01:49:36,500
And the fields are separated with

1590
01:49:36,500 --> 01:49:38,500
double colons. The first field

1591
01:49:38,500 --> 01:49:40,500
is the ID number.

1592
01:49:40,500 --> 01:49:42,500
The second field is

1593
01:49:42,500 --> 01:49:44,500
the movie name and its year.

1594
01:49:44,500 --> 01:49:46,500
We're going to ignore both of those. The third

1595
01:49:46,500 --> 01:49:48,500
field is a set

1596
01:49:48,500 --> 01:49:50,500
of, or a vertical bar set,

1597
01:49:50,500 --> 01:49:52,500
a separated set of genres,

1598
01:49:52,500 --> 01:49:54,500
like movie genres.

1599
01:49:54,500 --> 01:49:56,500
And so basically,

1600
01:49:56,500 --> 01:49:58,500
here's what I want you to do

1601
01:49:58,500 --> 01:50:00,500
for an exercise.

1602
01:50:02,500 --> 01:50:04,500
An exercise like movie

1603
01:50:04,500 --> 01:50:06,500
genres. So I want you to

1604
01:50:06,500 --> 01:50:08,500
use a, well,

1605
01:50:08,500 --> 01:50:10,500
let's just do this.

1606
01:50:10,500 --> 01:50:12,500
The goal is, find

1607
01:50:12,500 --> 01:50:14,500
out what the five

1608
01:50:14,500 --> 01:50:16,500
most popular

1609
01:50:16,500 --> 01:50:18,500
movie genres are

1610
01:50:18,500 --> 01:50:20,500
in movies.dat.

1611
01:50:26,500 --> 01:50:28,500
Okay, and so what I want you to do

1612
01:50:28,500 --> 01:50:30,500
is use,

1613
01:50:30,500 --> 01:50:32,500
you know, a nested comprehension

1614
01:50:32,500 --> 01:50:34,500
to read through the file,

1615
01:50:34,500 --> 01:50:36,500
find the,

1616
01:50:36,500 --> 01:50:38,500
you know, the appropriate

1617
01:50:38,500 --> 01:50:40,500
fields and lines,

1618
01:50:40,500 --> 01:50:42,500
and then use counter

1619
01:50:42,500 --> 01:50:44,500
to find

1620
01:50:44,500 --> 01:50:46,500
the most common

1621
01:50:46,500 --> 01:50:48,500
genres. And so if

1622
01:50:48,500 --> 01:50:50,500
a movie has more than one genre,

1623
01:50:50,500 --> 01:50:52,500
right, each

1624
01:50:52,500 --> 01:50:54,500
should be counted once.

1625
01:50:56,500 --> 01:50:58,500
Okay? So you're

1626
01:50:58,500 --> 01:51:00,500
basically, you know, here's a big

1627
01:51:00,500 --> 01:51:02,500
hint. You'll want to hand

1628
01:51:02,500 --> 01:51:04,500
counter

1629
01:51:04,500 --> 01:51:06,500
a list of genres

1630
01:51:06,500 --> 01:51:08,500
from the file.

1631
01:51:08,500 --> 01:51:10,500
There we go. I've

1632
01:51:10,500 --> 01:51:12,500
given away the store now. All right?

1633
01:51:12,500 --> 01:51:14,500
So I'll give you a few minutes to work on this,

1634
01:51:14,500 --> 01:51:16,500
and then we'll look at this together.

1635
01:51:20,500 --> 01:51:22,500
Okay. Let's

1636
01:51:22,500 --> 01:51:24,500
look at this and see what we can do with it.

1637
01:51:24,500 --> 01:51:26,500
So this is,

1638
01:51:26,500 --> 01:51:28,500
by the way, complicated, right?

1639
01:51:28,500 --> 01:51:30,500
So if you didn't get it, or you're scratching your head,

1640
01:51:30,500 --> 01:51:32,500
or like, you know,

1641
01:51:32,500 --> 01:51:34,500
scratching your eyes out, like, this is

1642
01:51:34,500 --> 01:51:36,500
complex, especially since we just started

1643
01:51:36,500 --> 01:51:38,500
with comprehensions today.

1644
01:51:38,500 --> 01:51:40,500
But let's start off with like

1645
01:51:40,500 --> 01:51:42,500
a simple thing. One line for one line

1646
01:51:42,500 --> 01:51:44,500
in open, movies.dat.

1647
01:51:44,500 --> 01:51:46,500
And sure enough, I get the lines there.

1648
01:51:46,500 --> 01:51:48,500
Okay. So far so good.

1649
01:51:48,500 --> 01:51:50,500
Well, I don't really want those lines,

1650
01:51:50,500 --> 01:51:52,500
right? What I'm really going to want is in the end

1651
01:51:52,500 --> 01:51:54,500
like one genre.

1652
01:51:54,500 --> 01:51:56,500
Okay? Or if you want to be

1653
01:51:56,500 --> 01:51:58,500
like, you know, one category, if you want to be

1654
01:51:58,500 --> 01:52:00,500
less fancy about it.

1655
01:52:00,500 --> 01:52:02,500
But okay, so one line, that's good.

1656
01:52:02,500 --> 01:52:04,500
But now what? I've got

1657
01:52:04,500 --> 01:52:06,500
that line. But what I want

1658
01:52:06,500 --> 01:52:08,500
to do is break that line apart.

1659
01:52:08,500 --> 01:52:10,500
So what I can say is like for one

1660
01:52:10,500 --> 01:52:12,500
genre in

1661
01:52:12,500 --> 01:52:14,500
one line, then

1662
01:52:14,500 --> 01:52:16,500
what? Well, I can split it on double colon.

1663
01:52:16,500 --> 01:52:18,500
What is that going to give me?

1664
01:52:18,500 --> 01:52:20,500
That's going to give me a list, a list of strings.

1665
01:52:20,500 --> 01:52:22,500
And I know that

1666
01:52:22,500 --> 01:52:24,500
I want the thing at

1667
01:52:24,500 --> 01:52:26,500
index minus one, or if you prefer

1668
01:52:26,500 --> 01:52:28,500
index two.

1669
01:52:28,500 --> 01:52:30,500
What if I just do that?

1670
01:52:30,500 --> 01:52:32,500
Ugh.

1671
01:52:32,500 --> 01:52:34,500
What happened there?

1672
01:52:34,500 --> 01:52:36,500
Well, as someone said to me

1673
01:52:36,500 --> 01:52:38,500
so many years ago, computers don't do what you want.

1674
01:52:38,500 --> 01:52:40,500
They do what you tell them.

1675
01:52:40,500 --> 01:52:42,500
And what I did here was I iterated over

1676
01:52:42,500 --> 01:52:44,500
each character in each of the

1677
01:52:44,500 --> 01:52:46,500
genres. So

1678
01:52:46,500 --> 01:52:48,500
a little premature maybe

1679
01:52:48,500 --> 01:52:50,500
to be producing some results here.

1680
01:52:50,500 --> 01:52:52,500
But what I can do is I can

1681
01:52:52,500 --> 01:52:54,500
say, okay, one line split

1682
01:52:54,500 --> 01:52:56,500
two, and then I can do then a split

1683
01:52:56,500 --> 01:52:58,500
on vertical bar.

1684
01:52:58,500 --> 01:53:00,500
Look at that.

1685
01:53:00,500 --> 01:53:02,500
Now what I've done is I've said

1686
01:53:02,500 --> 01:53:04,500
throw out the first two fields

1687
01:53:04,500 --> 01:53:06,500
on each line. Take the third field

1688
01:53:06,500 --> 01:53:08,500
on that line and split that

1689
01:53:08,500 --> 01:53:10,500
giving me a list of strings.

1690
01:53:10,500 --> 01:53:12,500
And then one genre is going to go over each of those.

1691
01:53:12,500 --> 01:53:14,500
Now it is true that I have now

1692
01:53:14,500 --> 01:53:16,500
this backslash end there. So I'm going to

1693
01:53:16,500 --> 01:53:18,500
say one line strip split.

1694
01:53:18,500 --> 01:53:20,500
And then we get rid of that.

1695
01:53:20,500 --> 01:53:22,500
I now have a list

1696
01:53:22,500 --> 01:53:24,500
of all the genres

1697
01:53:24,500 --> 01:53:26,500
that are in this file. And now

1698
01:53:26,500 --> 01:53:28,500
I can just count them up.

1699
01:53:28,500 --> 01:53:30,500
I can say here

1700
01:53:30,500 --> 01:53:32,500
C equals a counter of

1701
01:53:32,500 --> 01:53:34,500
this thing. And then I can

1702
01:53:34,500 --> 01:53:36,500
say C dot

1703
01:53:36,500 --> 01:53:38,500
most common

1704
01:53:38,500 --> 01:53:40,500
five. And now we have the

1705
01:53:40,500 --> 01:53:42,500
most common genres

1706
01:53:42,500 --> 01:53:44,500
in this whole file.

1707
01:53:46,500 --> 01:53:48,500
Now I'm not

1708
01:53:48,500 --> 01:53:50,500
saying it's necessarily easy or

1709
01:53:50,500 --> 01:53:52,500
intuitive to come up with this.

1710
01:53:52,500 --> 01:53:54,500
And I'm not saying it's easy or intuitive to read it

1711
01:53:54,500 --> 01:53:56,500
either until you've

1712
01:53:56,500 --> 01:53:58,500
gotten some practice with it. But it is definitely

1713
01:53:58,500 --> 01:54:00,500
definitely possible.

1714
01:54:00,500 --> 01:54:02,500
And after a while you start to think in this way.

1715
01:54:02,500 --> 01:54:04,500
I don't know

1716
01:54:04,500 --> 01:54:06,500
if that's good. But you can

1717
01:54:06,500 --> 01:54:08,500
start to really think in this way and then

1718
01:54:08,500 --> 01:54:10,500
really play with it. And suddenly

1719
01:54:10,500 --> 01:54:12,500
all these file formats

1720
01:54:12,500 --> 01:54:14,500
and files and data

1721
01:54:14,500 --> 01:54:16,500
structures are infinitely

1722
01:54:16,500 --> 01:54:18,500
malleable using

1723
01:54:18,500 --> 01:54:20,500
comprehensions.

1724
01:54:22,500 --> 01:54:24,500
Questions, comments, thoughts about this?

1725
01:54:26,500 --> 01:54:28,500
Other than why me?

1726
01:54:30,500 --> 01:54:32,500
Oh yeah, please, please, sorry.

1727
01:54:34,500 --> 01:54:36,500
Oh, I think it's just like hiding off to the side

1728
01:54:36,500 --> 01:54:38,500
there. Hold on, I'll

1729
01:54:38,500 --> 01:54:40,500
see if I can get a little closer.

1730
01:54:40,500 --> 01:54:42,500
Yeah, here we go.

1731
01:54:42,500 --> 01:54:44,500
Oops, that was bad. There we go.

1732
01:54:44,500 --> 01:54:46,500
Okay, sure.

1733
01:54:46,500 --> 01:54:48,500
Oh, that's

1734
01:54:48,500 --> 01:54:50,500
a new feature in Python. You don't need to close

1735
01:54:50,500 --> 01:54:52,500
parentheses. It just like intuits from

1736
01:54:52,500 --> 01:54:54,500
what you want.

1737
01:54:56,500 --> 01:54:58,500
It's part of the all new. Implicit is better

1738
01:54:58,500 --> 01:55:00,500
than explicit approach to Python.

1739
01:55:02,500 --> 01:55:04,500
All right. I want to show you

1740
01:55:04,500 --> 01:55:06,500
one more kind

1741
01:55:06,500 --> 01:55:08,500
of comprehension, which is

1742
01:55:08,500 --> 01:55:10,500
sort of kind of comprehension. And then I think

1743
01:55:10,500 --> 01:55:12,500
we'll have a few minutes to be able to go into the innards of things

1744
01:55:12,500 --> 01:55:14,500
as well, which should be fun.

1745
01:55:16,500 --> 01:55:18,500
So,

1746
01:55:18,500 --> 01:55:20,500
everything we've done so far

1747
01:55:20,500 --> 01:55:22,500
is fine and good and really,

1748
01:55:22,500 --> 01:55:24,500
like, it's, it's, it's

1749
01:55:24,500 --> 01:55:26,500
really is good, but

1750
01:55:26,500 --> 01:55:28,500
one of the

1751
01:55:28,500 --> 01:55:30,500
problems you can end up with, I

1752
01:55:30,500 --> 01:55:32,500
mentioned this a little bit earlier when we were talking about reading from

1753
01:55:32,500 --> 01:55:34,500
files. Let's say

1754
01:55:34,500 --> 01:55:36,500
I want to use a list comprehension

1755
01:55:36,500 --> 01:55:38,500
to read from a file, and

1756
01:55:38,500 --> 01:55:40,500
I want to get user names,

1757
01:55:40,500 --> 01:55:42,500
error information, IP addresses, you name

1758
01:55:42,500 --> 01:55:44,500
it. And it's a really, really big

1759
01:55:44,500 --> 01:55:46,500
file. Well, what's going to happen

1760
01:55:46,500 --> 01:55:48,500
then is that the comprehension is going to return

1761
01:55:48,500 --> 01:55:50,500
a really, really, really big

1762
01:55:50,500 --> 01:55:52,500
list. It could be,

1763
01:55:52,500 --> 01:55:54,500
right, because we're iterating over the file

1764
01:55:54,500 --> 01:55:56,500
one line at a time. The size

1765
01:55:56,500 --> 01:55:58,500
of the file is not going to be a problem,

1766
01:55:58,500 --> 01:56:00,500
because we're only reading one line

1767
01:56:00,500 --> 01:56:02,500
at a time. But

1768
01:56:02,500 --> 01:56:04,500
the total list that we're

1769
01:56:04,500 --> 01:56:06,500
going to create will be too big, or

1770
01:56:06,500 --> 01:56:08,500
just will be enormous.

1771
01:56:08,500 --> 01:56:10,500
And so what if we want to

1772
01:56:10,500 --> 01:56:12,500
avoid that? So

1773
01:56:12,500 --> 01:56:14,500
we can use what's called a generator

1774
01:56:14,500 --> 01:56:16,500
expression,

1775
01:56:16,500 --> 01:56:18,500
or sometimes people call it generator comprehension,

1776
01:56:18,500 --> 01:56:20,500
because, like, why not?

1777
01:56:20,500 --> 01:56:22,500
And so

1778
01:56:22,500 --> 01:56:24,500
let me reiterate sort of what

1779
01:56:24,500 --> 01:56:26,500
we've done. Or actually I don't have to. I don't have to.

1780
01:56:26,500 --> 01:56:28,500
So people often try this.

1781
01:56:28,500 --> 01:56:30,500
They're like, well, if

1782
01:56:30,500 --> 01:56:32,500
I have

1783
01:56:32,500 --> 01:56:34,500
regular square brackets,

1784
01:56:34,500 --> 01:56:36,500
and I get a list comprehension,

1785
01:56:36,500 --> 01:56:38,500
which produces a list, and I have

1786
01:56:38,500 --> 01:56:40,500
curly braces, which is a set

1787
01:56:40,500 --> 01:56:42,500
comprehension, which produces a set,

1788
01:56:42,500 --> 01:56:44,500
and I have curly braces in colon,

1789
01:56:44,500 --> 01:56:46,500
which is a dictionary,

1790
01:56:46,500 --> 01:56:48,500
what if I use regular round

1791
01:56:48,500 --> 01:56:50,500
parentheses?

1792
01:56:50,500 --> 01:56:52,500
What if I say here, like,

1793
01:56:52,500 --> 01:56:54,500
x to the second power,

1794
01:56:54,500 --> 01:56:56,500
for one number

1795
01:56:56,500 --> 01:56:58,500
in, let's call it range 10,

1796
01:56:58,500 --> 01:57:00,500
will I get a tuple?

1797
01:57:00,500 --> 01:57:02,500
And the answer is,

1798
01:57:02,500 --> 01:57:04,500
of course, no. This is a generator.

1799
01:57:04,500 --> 01:57:06,500
And that

1800
01:57:06,500 --> 01:57:08,500
is surprising

1801
01:57:08,500 --> 01:57:10,500
to people.

1802
01:57:10,500 --> 01:57:12,500
So first of all, what's a generator?

1803
01:57:12,500 --> 01:57:14,500
And basically

1804
01:57:14,500 --> 01:57:16,500
a generator

1805
01:57:16,500 --> 01:57:18,500
is an object in Python

1806
01:57:18,500 --> 01:57:20,500
that

1807
01:57:20,500 --> 01:57:22,500
knows how to behave

1808
01:57:22,500 --> 01:57:24,500
inside of a for loop

1809
01:57:24,500 --> 01:57:26,500
because

1810
01:57:26,500 --> 01:57:28,500
it is iterable.

1811
01:57:28,500 --> 01:57:30,500
Okay. And so

1812
01:57:30,500 --> 01:57:32,500
what? The point of a generator

1813
01:57:32,500 --> 01:57:34,500
is that it doesn't return

1814
01:57:34,500 --> 01:57:36,500
all of

1815
01:57:36,500 --> 01:57:38,500
the elements, all of its elements,

1816
01:57:38,500 --> 01:57:40,500
at once.

1817
01:57:40,500 --> 01:57:42,500
Rather, it only returns

1818
01:57:42,500 --> 01:57:44,500
one at a time.

1819
01:57:44,500 --> 01:57:46,500
And this is key

1820
01:57:46,500 --> 01:57:48,500
to understanding a lot of things in Python.

1821
01:57:48,500 --> 01:57:50,500
Again, when I iterate over a file,

1822
01:57:50,500 --> 01:57:52,500
I'm not getting the entire file

1823
01:57:52,500 --> 01:57:54,500
into memory at once, because that

1824
01:57:54,500 --> 01:57:56,500
could be catastrophically bad.

1825
01:57:56,500 --> 01:57:58,500
Rather, I'm getting one line, and the next

1826
01:57:58,500 --> 01:58:00,500
line, and the next line, and the next line, so the

1827
01:58:00,500 --> 01:58:02,500
maximum memory I'm using is only one

1828
01:58:02,500 --> 01:58:04,500
line's worth of memory.

1829
01:58:04,500 --> 01:58:06,500
And so I can read a 10 terabyte file

1830
01:58:06,500 --> 01:58:08,500
without any trouble, even in a tiny little

1831
01:58:08,500 --> 01:58:10,500
computer, because I'm only using one

1832
01:58:10,500 --> 01:58:12,500
line of memory at a time.

1833
01:58:12,500 --> 01:58:14,500
And that's because file objects are

1834
01:58:14,500 --> 01:58:16,500
iterable, and they act sort of kind of

1835
01:58:16,500 --> 01:58:18,500
like generators. So we can do that ourselves

1836
01:58:18,500 --> 01:58:20,500
with generators, and there are multiple ways

1837
01:58:20,500 --> 01:58:22,500
for us to create generators in Python.

1838
01:58:22,500 --> 01:58:24,500
We can use generator functions,

1839
01:58:24,500 --> 01:58:26,500
for example. But if you want something

1840
01:58:26,500 --> 01:58:28,500
quick and dirty, you can use a

1841
01:58:28,500 --> 01:58:30,500
generator expression, which looks

1842
01:58:30,500 --> 01:58:32,500
like a comprehension,

1843
01:58:32,500 --> 01:58:34,500
and acts like a comprehension, except

1844
01:58:34,500 --> 01:58:36,500
that it doesn't return everything at

1845
01:58:36,500 --> 01:58:38,500
once.

1846
01:58:38,500 --> 01:58:40,500
Right? So

1847
01:58:40,500 --> 01:58:42,500
a generator

1848
01:58:42,500 --> 01:58:44,500
expression

1849
01:58:44,500 --> 01:58:46,500
works just like

1850
01:58:46,500 --> 01:58:48,500
a list comprehension,

1851
01:58:48,500 --> 01:58:50,500
except that

1852
01:58:50,500 --> 01:58:52,500
instead of returning a list

1853
01:58:52,500 --> 01:58:54,500
with all of its elements,

1854
01:58:54,500 --> 01:58:56,500
it returns a generator object.

1855
01:58:56,500 --> 01:58:58,500
And that object

1856
01:58:58,500 --> 01:59:00,500
can be put into a for loop,

1857
01:59:00,500 --> 01:59:02,500
or any other

1858
01:59:02,500 --> 01:59:04,500
iterable context,

1859
01:59:04,500 --> 01:59:06,500
and it will only run

1860
01:59:06,500 --> 01:59:08,500
the expression

1861
01:59:08,500 --> 01:59:10,500
once,

1862
01:59:10,500 --> 01:59:12,500
sort of like

1863
01:59:12,500 --> 01:59:14,500
when it is asked to.

1864
01:59:14,500 --> 01:59:16,500
Typically, once per iteration.

1865
01:59:18,500 --> 01:59:20,500
So what if I were to do this here?

1866
01:59:20,500 --> 01:59:22,500
What if I say here, let's just grab this thing.

1867
01:59:24,500 --> 01:59:26,500
So if I say here,

1868
01:59:26,500 --> 01:59:28,500
like, G is this.

1869
01:59:28,500 --> 01:59:30,500
And so now

1870
01:59:30,500 --> 01:59:32,500
I can say for one item in G,

1871
01:59:32,500 --> 01:59:34,500
print one item.

1872
01:59:34,500 --> 01:59:36,500
And what's going to happen? The first

1873
01:59:36,500 --> 01:59:38,500
loop is going to say to G, are you

1874
01:59:38,500 --> 01:59:40,500
iterable? The answer is yes.

1875
01:59:40,500 --> 01:59:42,500
It's going to say, okay, give me your next thing.

1876
01:59:42,500 --> 01:59:44,500
G is like, okay.

1877
01:59:44,500 --> 01:59:46,500
And it then runs

1878
01:59:46,500 --> 01:59:48,500
one iteration here.

1879
01:59:48,500 --> 01:59:50,500
It returns one number.

1880
01:59:50,500 --> 01:59:52,500
And then it goes to sleep.

1881
01:59:52,500 --> 01:59:54,500
It stops. And it waits

1882
01:59:54,500 --> 01:59:56,500
for the for loop, that sort of whoever is on top

1883
01:59:56,500 --> 01:59:58,500
of it, to ask for the next thing.

1884
01:59:58,500 --> 02:00:00,500
Now typically we do this

1885
02:00:00,500 --> 02:00:02,500
in a for loop. Behind the scenes, there's a whole

1886
02:00:02,500 --> 02:00:04,500
mechanism where Python is saying,

1887
02:00:04,500 --> 02:00:06,500
give me your next thing, give me your next thing, give me your next thing.

1888
02:00:06,500 --> 02:00:08,500
And it's lazy evaluating.

1889
02:00:08,500 --> 02:00:10,500
It's not doing everything at once.

1890
02:00:10,500 --> 02:00:12,500
And that's terrific in all

1891
02:00:12,500 --> 02:00:14,500
sorts of contexts. I don't want

1892
02:00:14,500 --> 02:00:16,500
to get everything at once a lot of times.

1893
02:00:16,500 --> 02:00:18,500
One of the big changes, again, talking like

1894
02:00:18,500 --> 02:00:20,500
ancient history, I guess, one of the big changes

1895
02:00:20,500 --> 02:00:22,500
between Python 2 and Python 3

1896
02:00:22,500 --> 02:00:24,500
is that Python 2 would return lists for just about

1897
02:00:24,500 --> 02:00:26,500
everything. And in Python 3, they're like,

1898
02:00:26,500 --> 02:00:28,500
wait, actually, that's not a good

1899
02:00:28,500 --> 02:00:30,500
idea. Because for small things,

1900
02:00:30,500 --> 02:00:32,500
who cares? But for big things, everyone

1901
02:00:32,500 --> 02:00:34,500
cares. And so now, in Python,

1902
02:00:34,500 --> 02:00:36,500
virtually anything that returns

1903
02:00:36,500 --> 02:00:38,500
a bunch of values is going to return

1904
02:00:38,500 --> 02:00:40,500
an iterable, a generator object,

1905
02:00:40,500 --> 02:00:42,500
something like that, so that it doesn't

1906
02:00:42,500 --> 02:00:44,500
potentially overwhelm our memory.

1907
02:00:44,500 --> 02:00:46,500
And so we can do that too now.

1908
02:00:46,500 --> 02:00:48,500
So where would I

1909
02:00:48,500 --> 02:00:50,500
use this sort of thing?

1910
02:00:50,500 --> 02:00:52,500
Well, let's see. Oh, fine.

1911
02:00:52,500 --> 02:00:54,500
Why did I say that?

1912
02:00:54,500 --> 02:00:56,500
Oh, because I didn't take it.

1913
02:00:56,500 --> 02:00:58,500
Oh, I didn't want to.

1914
02:00:58,500 --> 02:01:00,500
Oh, thank you.

1915
02:01:00,500 --> 02:01:02,500
Oh, thank you. That would do it.

1916
02:01:04,500 --> 02:01:06,500
Oh, instead of X, I get it.

1917
02:01:06,500 --> 02:01:08,500
Yeah, there we go.

1918
02:01:08,500 --> 02:01:10,500
I was like, what's the complaint about one item?

1919
02:01:10,500 --> 02:01:12,500
It looks so good to me.

1920
02:01:12,500 --> 02:01:14,500
There's a pro tip for you. Look at

1921
02:01:14,500 --> 02:01:16,500
the code that has the problem, not the code that works.

1922
02:01:16,500 --> 02:01:18,500
All right.

1923
02:01:18,500 --> 02:01:20,500
So what if I do this sort of thing?

1924
02:01:20,500 --> 02:01:22,500
What if I say here, and by the way, you can do like

1925
02:01:22,500 --> 02:01:24,500
nested for loops and

1926
02:01:24,500 --> 02:01:26,500
generators and so forth.

1927
02:01:26,500 --> 02:01:28,500
Yeah, what if I do something like this?

1928
02:01:30,500 --> 02:01:32,500
Well, I could even do something infinitely large.

1929
02:01:32,500 --> 02:01:34,500
Well,

1930
02:01:34,500 --> 02:01:36,500
let's not go crazy here.

1931
02:01:36,500 --> 02:01:38,500
So let's even do something super simple.

1932
02:01:38,500 --> 02:01:40,500
So if I say like my list equals,

1933
02:01:40,500 --> 02:01:42,500
we did this before, 10, 20, 30.

1934
02:01:42,500 --> 02:01:44,500
And then I say here,

1935
02:01:44,500 --> 02:01:46,500
star join

1936
02:01:46,500 --> 02:01:48,500
of, and then I can say a list comprehension

1937
02:01:48,500 --> 02:01:50,500
stir of one item

1938
02:01:50,500 --> 02:01:52,500
for one item

1939
02:01:52,500 --> 02:01:54,500
in my list. This works.

1940
02:01:54,500 --> 02:01:56,500
And I can also instead

1941
02:01:56,500 --> 02:01:58,500
use

1942
02:01:58,500 --> 02:02:00,500
regular round parentheses here.

1943
02:02:00,500 --> 02:02:02,500
So here I'm going to use a list comprehension.

1944
02:02:04,500 --> 02:02:06,500
And here I'm going to

1945
02:02:06,500 --> 02:02:08,500
use a generator expression.

1946
02:02:14,500 --> 02:02:16,500
Now, we don't see much of a difference

1947
02:02:16,500 --> 02:02:18,500
here. I mean, there is no difference. And the whole

1948
02:02:18,500 --> 02:02:20,500
point is that you will get exactly the same

1949
02:02:20,500 --> 02:02:22,500
results back. However, in

1950
02:02:22,500 --> 02:02:24,500
many, many cases, not here by the way,

1951
02:02:24,500 --> 02:02:26,500
but in many cases, it will use much less memory

1952
02:02:26,500 --> 02:02:28,500
because it's only using one element at a time.

1953
02:02:32,500 --> 02:02:34,500
Okay, that's nice,

1954
02:02:34,500 --> 02:02:36,500
but it gets even better.

1955
02:02:36,500 --> 02:02:38,500
What if I do this?

1956
02:02:38,500 --> 02:02:40,500
What if I say here, generator expression

1957
02:02:40,500 --> 02:02:42,500
with only

1958
02:02:42,500 --> 02:02:44,500
one set of parentheses?

1959
02:02:46,500 --> 02:02:48,500
And it's the same thing.

1960
02:02:48,500 --> 02:02:50,500
Basically, you

1961
02:02:50,500 --> 02:02:52,500
can put what looks like

1962
02:02:52,500 --> 02:02:54,500
a list comprehension, what is a generator

1963
02:02:54,500 --> 02:02:56,500
expression, inside of parentheses, inside

1964
02:02:56,500 --> 02:02:58,500
of a function call, and Python knows

1965
02:02:58,500 --> 02:03:00,500
that it's a generator expression. It's totally okay

1966
02:03:00,500 --> 02:03:02,500
with that. And this,

1967
02:03:02,500 --> 02:03:04,500
by the way, when I finally figured this out,

1968
02:03:04,500 --> 02:03:06,500
a whole lot of code that I'd seen started to make sense.

1969
02:03:06,500 --> 02:03:08,500
I was like, I don't understand. Why are people

1970
02:03:08,500 --> 02:03:10,500
like passing something that looks like a comprehension?

1971
02:03:10,500 --> 02:03:12,500
Oh, it's just because the extra parentheses look

1972
02:03:12,500 --> 02:03:14,500
kind of dumb. And so if you

1973
02:03:14,500 --> 02:03:16,500
only have one set there, you sort of get away with

1974
02:03:16,500 --> 02:03:18,500
them doing double duty.

1975
02:03:18,500 --> 02:03:20,500
But yeah, yeah, it works. It works really,

1976
02:03:20,500 --> 02:03:22,500
really well. So if you're reading data

1977
02:03:22,500 --> 02:03:24,500
from a file, right? So let's say I want to do

1978
02:03:24,500 --> 02:03:26,500
something a little more

1979
02:03:26,500 --> 02:03:28,500
interesting. So let's read

1980
02:03:28,500 --> 02:03:30,500
words from a file.

1981
02:03:30,500 --> 02:03:32,500
So do I have a file here?

1982
02:03:34,500 --> 02:03:36,500
I don't have anything super

1983
02:03:36,500 --> 02:03:38,500
exciting. Fine, I'll just

1984
02:03:38,500 --> 02:03:40,500
read from, I don't know,

1985
02:03:40,500 --> 02:03:42,500
I'll read from WC

1986
02:03:42,500 --> 02:03:44,500
file.txt. I use it for another exercise, but

1987
02:03:44,500 --> 02:03:46,500
who cares? So if I'm going to say

1988
02:03:46,500 --> 02:03:48,500
now,

1989
02:03:48,500 --> 02:03:50,500
one word for one

1990
02:03:50,500 --> 02:03:52,500
line in open,

1991
02:03:52,500 --> 02:03:54,500
what did I say? WC file

1992
02:03:54,500 --> 02:03:56,500
txt. And then for one

1993
02:03:56,500 --> 02:03:58,500
word in one line split. So you see

1994
02:03:58,500 --> 02:04:00,500
I'm even using here a nested comprehension.

1995
02:04:00,500 --> 02:04:02,500
So this is going to return all the words

1996
02:04:02,500 --> 02:04:04,500
in the file. But if that file is really,

1997
02:04:04,500 --> 02:04:06,500
really big, if I don't want to flood my memory with

1998
02:04:06,500 --> 02:04:08,500
everything, then instead I can use a

1999
02:04:08,500 --> 02:04:10,500
generator expression.

2000
02:04:10,500 --> 02:04:12,500
And now if I iterate over this,

2001
02:04:12,500 --> 02:04:14,500
if I say like, you know, for, let's just say here

2002
02:04:14,500 --> 02:04:16,500
g equals this. Say, you know, for

2003
02:04:16,500 --> 02:04:18,500
w in g

2004
02:04:18,500 --> 02:04:20,500
print, what we can say here like,

2005
02:04:20,500 --> 02:04:22,500
you know, total equals zero.

2006
02:04:22,500 --> 02:04:24,500
And we'll say here total plus equal len

2007
02:04:24,500 --> 02:04:26,500
of w.

2008
02:04:26,500 --> 02:04:28,500
Right, so total, the length

2009
02:04:28,500 --> 02:04:30,500
of all words.

2010
02:04:30,500 --> 02:04:32,500
No spaces.

2011
02:04:32,500 --> 02:04:34,500
And so that'll work fine.

2012
02:04:34,500 --> 02:04:36,500
But the real magic here is that

2013
02:04:36,500 --> 02:04:38,500
every time this for loop asks

2014
02:04:38,500 --> 02:04:40,500
g for next thing, only then

2015
02:04:40,500 --> 02:04:42,500
is it going to advance its for loops

2016
02:04:42,500 --> 02:04:44,500
inside of here. It's not going to run them

2017
02:04:44,500 --> 02:04:46,500
all at once. It can give me that whole list all at once.

2018
02:04:46,500 --> 02:04:48,500
It's going to save me memory.

2019
02:04:48,500 --> 02:04:50,500
And so generator expressions

2020
02:04:50,500 --> 02:04:52,500
have become really, really

2021
02:04:52,500 --> 02:04:54,500
popular in Python over the last few years.

2022
02:04:54,500 --> 02:04:56,500
I would say in the last decade, they

2023
02:04:56,500 --> 02:04:58,500
move from being something sort of,

2024
02:04:58,500 --> 02:05:00,500
you know, interesting, a little less

2025
02:05:00,500 --> 02:05:02,500
esoteric for the people who are really worried about performance

2026
02:05:02,500 --> 02:05:04,500
to in some cases, it's just like

2027
02:05:04,500 --> 02:05:06,500
the default. Like why would

2028
02:05:06,500 --> 02:05:08,500
you use a list comprehension if in most cases,

2029
02:05:08,500 --> 02:05:10,500
not all, in most cases, the generator expression will give you

2030
02:05:10,500 --> 02:05:12,500
the same results and will probably

2031
02:05:12,500 --> 02:05:14,500
save you some memory.

2032
02:05:14,500 --> 02:05:16,500
And so I just see people sort of moving

2033
02:05:16,500 --> 02:05:18,500
in the direction of always using them.

2034
02:05:18,500 --> 02:05:20,500
You can't always use them in place because there are places

2035
02:05:20,500 --> 02:05:22,500
where it's actually expecting to get a list.

2036
02:05:22,500 --> 02:05:24,500
But if you're

2037
02:05:24,500 --> 02:05:26,500
passing something to a function or

2038
02:05:26,500 --> 02:05:28,500
some other sort of iterable, yeah,

2039
02:05:28,500 --> 02:05:30,500
it works really well.

2040
02:05:32,500 --> 02:05:34,500
The other thing that you can do with a generator

2041
02:05:34,500 --> 02:05:36,500
expression is this.

2042
02:05:36,500 --> 02:05:38,500
So I just mentioned you can

2043
02:05:38,500 --> 02:05:40,500
define, you know, you can define

2044
02:05:40,500 --> 02:05:42,500
a generator with a generator function.

2045
02:05:42,500 --> 02:05:44,500
And in such a function,

2046
02:05:46,500 --> 02:05:48,500
you use yield

2047
02:05:48,500 --> 02:05:50,500
to, you know, return

2048
02:05:50,500 --> 02:05:52,500
a value without

2049
02:05:52,500 --> 02:05:54,500
exiting the function.

2050
02:05:54,500 --> 02:05:56,500
I'm not going to go into like detail,

2051
02:05:56,500 --> 02:05:58,500
well, maybe I will, but no, probably not.

2052
02:05:58,500 --> 02:06:00,500
So if I say like, you know, def,

2053
02:06:00,500 --> 02:06:02,500
my, you know, mygen,

2054
02:06:02,500 --> 02:06:04,500
I'll say here like yield 10,

2055
02:06:04,500 --> 02:06:06,500
yield 20, and yield 30.

2056
02:06:06,500 --> 02:06:08,500
Very exciting.

2057
02:06:08,500 --> 02:06:10,500
Okay, and so now,

2058
02:06:10,500 --> 02:06:12,500
if I say g equals mygen,

2059
02:06:12,500 --> 02:06:14,500
g is the generator.

2060
02:06:14,500 --> 02:06:16,500
And if I say like list of g,

2061
02:06:16,500 --> 02:06:18,500
I'm going to get each of those. I'm going to create a list.

2062
02:06:18,500 --> 02:06:20,500
Because what happens? List goes to g, and it runs

2063
02:06:20,500 --> 02:06:22,500
a for loop on it, it gets it one by one by one.

2064
02:06:22,500 --> 02:06:24,500
So many people, if they

2065
02:06:24,500 --> 02:06:26,500
want to have functions that return

2066
02:06:26,500 --> 02:06:28,500
things in pieces, will write

2067
02:06:28,500 --> 02:06:30,500
a generator function like this.

2068
02:06:30,500 --> 02:06:32,500
Here's the

2069
02:06:32,500 --> 02:06:34,500
cool thing. You can do

2070
02:06:34,500 --> 02:06:36,500
exactly

2071
02:06:36,500 --> 02:06:38,500
the same thing

2072
02:06:38,500 --> 02:06:40,500
by writing a function

2073
02:06:40,500 --> 02:06:42,500
that returns a

2074
02:06:42,500 --> 02:06:44,500
generator expression.

2075
02:06:44,500 --> 02:06:46,500
In other words, if I say def, mygen,

2076
02:06:46,500 --> 02:06:48,500
and I just say,

2077
02:06:48,500 --> 02:06:50,500
oops, let's go down here a little bit,

2078
02:06:50,500 --> 02:06:52,500
and I say then,

2079
02:06:52,500 --> 02:06:54,500
return, you know, one

2080
02:06:54,500 --> 02:06:56,500
number for one number

2081
02:06:56,500 --> 02:06:58,500
in, this is kind of stupid, I know, 10, 20, 30.

2082
02:06:58,500 --> 02:07:00,500
If I call

2083
02:07:00,500 --> 02:07:02,500
mygen, what am I going to get back?

2084
02:07:02,500 --> 02:07:04,500
Well, it's a regular function that's returning

2085
02:07:04,500 --> 02:07:06,500
a generator object.

2086
02:07:06,500 --> 02:07:08,500
And so, sure enough, it works exactly

2087
02:07:08,500 --> 02:07:10,500
the same way. So there are just

2088
02:07:10,500 --> 02:07:12,500
some cases when I found that

2089
02:07:12,500 --> 02:07:14,500
as easy as it can be to write

2090
02:07:14,500 --> 02:07:16,500
a generator function, it's even easier

2091
02:07:16,500 --> 02:07:18,500
for me to express it as a generator

2092
02:07:18,500 --> 02:07:20,500
expression, just return that from my function or method.

2093
02:07:26,500 --> 02:07:28,500
Okay.

2094
02:07:28,500 --> 02:07:30,500
Questions, comments,

2095
02:07:30,500 --> 02:07:32,500
thoughts until here.

2096
02:07:32,500 --> 02:07:34,500
I want to stress, by the way,

2097
02:07:34,500 --> 02:07:36,500
like in the last, I don't know,

2098
02:07:36,500 --> 02:07:38,500
half hour, 45 minutes, we've been going into

2099
02:07:38,500 --> 02:07:40,500
some more advanced stuff.

2100
02:07:40,500 --> 02:07:42,500
Most people,

2101
02:07:42,500 --> 02:07:44,500
most of the time, don't need that.

2102
02:07:44,500 --> 02:07:46,500
If you came in here saying, oh,

2103
02:07:46,500 --> 02:07:48,500
I've heard comprehensions are interesting, but I'm a little

2104
02:07:48,500 --> 02:07:50,500
afraid without them, you're like, oh, my God,

2105
02:07:50,500 --> 02:07:52,500
all my fears have been realized.

2106
02:07:52,500 --> 02:07:54,500
You don't need this

2107
02:07:54,500 --> 02:07:56,500
most days.

2108
02:07:56,500 --> 02:07:58,500
Most people,

2109
02:07:58,500 --> 02:08:00,500
most of the time, when they're doing comprehensions,

2110
02:08:00,500 --> 02:08:02,500
just like little list, little set,

2111
02:08:02,500 --> 02:08:04,500
little bit, and you're done.

2112
02:08:04,500 --> 02:08:06,500
But,

2113
02:08:06,500 --> 02:08:08,500
but, for the

2114
02:08:08,500 --> 02:08:10,500
ambitious among us, no,

2115
02:08:10,500 --> 02:08:12,500
masochistic among us.

2116
02:08:12,500 --> 02:08:14,500
So I just want to, I mentioned this a little bit earlier

2117
02:08:14,500 --> 02:08:16,500
and we have a few minutes, so I want to

2118
02:08:16,500 --> 02:08:18,500
sort of show you

2119
02:08:18,500 --> 02:08:20,500
like behind the scenes

2120
02:08:20,500 --> 02:08:22,500
a little more in terms of comprehensions.

2121
02:08:22,500 --> 02:08:24,500
And if what I just, like if we just

2122
02:08:24,500 --> 02:08:26,500
saw over the last 45 minutes or so was advanced,

2123
02:08:26,500 --> 02:08:28,500
this is like, you know, sort of

2124
02:08:28,500 --> 02:08:30,500
super cool brain melting advanced.

2125
02:08:30,500 --> 02:08:32,500
So like,

2126
02:08:32,500 --> 02:08:34,500
it's on you if you don't have towels.

2127
02:08:34,500 --> 02:08:36,500
All right.

2128
02:08:36,500 --> 02:08:38,500
So here's the thing, and again,

2129
02:08:38,500 --> 02:08:40,500
I mentioned this a little bit earlier, I just want to sort of

2130
02:08:40,500 --> 02:08:42,500
make it clear. So if I say here

2131
02:08:42,500 --> 02:08:44,500
x equals 100, and then I say

2132
02:08:44,500 --> 02:08:46,500
four, one

2133
02:08:46,500 --> 02:08:48,500
number in, let's say, range five.

2134
02:08:48,500 --> 02:08:50,500
And I say x equals

2135
02:08:50,500 --> 02:08:52,500
one number times

2136
02:08:52,500 --> 02:08:54,500
three.

2137
02:08:54,500 --> 02:08:56,500
What

2138
02:08:56,500 --> 02:08:58,500
will, what is x here?

2139
02:08:58,500 --> 02:09:00,500
And a whole

2140
02:09:00,500 --> 02:09:02,500
lot of people, including people

2141
02:09:02,500 --> 02:09:04,500
who have experience with Python for many

2142
02:09:04,500 --> 02:09:06,500
years, are like, well, clearly, x will

2143
02:09:06,500 --> 02:09:08,500
be 100. Because I mean,

2144
02:09:08,500 --> 02:09:10,500
the for loop couldn't possibly

2145
02:09:10,500 --> 02:09:12,500
change what's in the, you know, outside of

2146
02:09:12,500 --> 02:09:14,500
it. I mean, I've got indentation. Indentation

2147
02:09:14,500 --> 02:09:16,500
is a new scope, right?

2148
02:09:16,500 --> 02:09:18,500
Wrong.

2149
02:09:18,500 --> 02:09:20,500
Actually, we did

2150
02:09:20,500 --> 02:09:22,500
not go into a function here.

2151
02:09:22,500 --> 02:09:24,500
No function definition, no

2152
02:09:24,500 --> 02:09:26,500
new scope. It's as simple

2153
02:09:26,500 --> 02:09:28,500
as that. All of these variables

2154
02:09:28,500 --> 02:09:30,500
here, x and one number,

2155
02:09:30,500 --> 02:09:32,500
are all in the global scope.

2156
02:09:34,500 --> 02:09:36,500
Okay. So far so good.

2157
02:09:36,500 --> 02:09:38,500
So now I say x equals

2158
02:09:38,500 --> 02:09:40,500
100, and then I say

2159
02:09:40,500 --> 02:09:42,500
one number times three

2160
02:09:42,500 --> 02:09:44,500
for one

2161
02:09:44,500 --> 02:09:46,500
number in range

2162
02:09:46,500 --> 02:09:48,500
five. Oh, I guess I need to have

2163
02:09:48,500 --> 02:09:50,500
the x here, so fine, I'm going to say x.

2164
02:09:50,500 --> 02:09:52,500
Well, I'll say

2165
02:09:52,500 --> 02:09:54,500
one number, I'll say x here.

2166
02:09:54,500 --> 02:09:56,500
Whatever.

2167
02:09:56,500 --> 02:09:58,500
So you can see that x is like,

2168
02:09:58,500 --> 02:10:00,500
and we'll even say print this thing, so we'll

2169
02:10:00,500 --> 02:10:02,500
see the result of the list comprehension.

2170
02:10:04,500 --> 02:10:06,500
So when I first discovered

2171
02:10:06,500 --> 02:10:08,500
this, I was like, wait.

2172
02:10:08,500 --> 02:10:10,500
What's wrong

2173
02:10:10,500 --> 02:10:12,500
with this picture? How can

2174
02:10:12,500 --> 02:10:14,500
it possibly be

2175
02:10:14,500 --> 02:10:16,500
that comprehensions don't

2176
02:10:16,500 --> 02:10:18,500
modify the outer scope?

2177
02:10:18,500 --> 02:10:20,500
Who's been lying to whom? And I sure

2178
02:10:20,500 --> 02:10:22,500
hope it has not been me lying to all of my students.

2179
02:10:24,500 --> 02:10:26,500
So for a little while, I would tell people,

2180
02:10:26,500 --> 02:10:28,500
oh yeah, in

2181
02:10:28,500 --> 02:10:30,500
Python 3, they introduced this

2182
02:10:30,500 --> 02:10:32,500
new half scope for

2183
02:10:32,500 --> 02:10:34,500
comprehensions. That has got to be

2184
02:10:34,500 --> 02:10:36,500
one of the hand waviest things I've ever

2185
02:10:36,500 --> 02:10:38,500
told people in my courses.

2186
02:10:38,500 --> 02:10:40,500
Because it was the only way that I could

2187
02:10:40,500 --> 02:10:42,500
understand it, because we have the very

2188
02:10:42,500 --> 02:10:44,500
strict rule of what's known as LEGB

2189
02:10:44,500 --> 02:10:46,500
in Python. Local and closing

2190
02:10:46,500 --> 02:10:48,500
global built-ins. There are four

2191
02:10:48,500 --> 02:10:50,500
scopes, only four places

2192
02:10:50,500 --> 02:10:52,500
where your variables can reside.

2193
02:10:52,500 --> 02:10:54,500
And if you're not in a function,

2194
02:10:54,500 --> 02:10:56,500
then the first two don't exist.

2195
02:10:56,500 --> 02:10:58,500
Right? There's no function

2196
02:10:58,500 --> 02:11:00,500
here. So if there's

2197
02:11:00,500 --> 02:11:02,500
no function, then I must be at the global

2198
02:11:02,500 --> 02:11:04,500
scope or at the built-in scope. And I

2199
02:11:04,500 --> 02:11:06,500
sure as heck hope that we're not modifying

2200
02:11:06,500 --> 02:11:08,500
built-ins, although I did once get

2201
02:11:08,500 --> 02:11:10,500
email from someone saying, we're having some problems

2202
02:11:10,500 --> 02:11:12,500
at my company keeping track of a variable

2203
02:11:12,500 --> 02:11:14,500
scoping, but we found a solution. We just

2204
02:11:14,500 --> 02:11:16,500
say built-ins.x and built-ins.y

2205
02:11:16,500 --> 02:11:18,500
and everything works great. I was like,

2206
02:11:18,500 --> 02:11:20,500
oh my god, please don't do that.

2207
02:11:20,500 --> 02:11:22,500
Anyway, I

2208
02:11:22,500 --> 02:11:24,500
finally decided maybe

2209
02:11:24,500 --> 02:11:26,500
I should look into this a little more closely.

2210
02:11:26,500 --> 02:11:28,500
Maybe I should try to figure out really what's

2211
02:11:28,500 --> 02:11:30,500
going on here. So

2212
02:11:30,500 --> 02:11:32,500
let's do that. I'm going

2213
02:11:32,500 --> 02:11:34,500
to define some functions here. I'm going

2214
02:11:34,500 --> 02:11:36,500
to say def, you know,

2215
02:11:36,500 --> 02:11:38,500
regular loop.

2216
02:11:38,500 --> 02:11:40,500
And then I'm just going to copy

2217
02:11:40,500 --> 02:11:42,500
in the code that I had before.

2218
02:11:46,500 --> 02:11:48,500
Okay.

2219
02:11:48,500 --> 02:11:50,500
It would help if I actually indented it.

2220
02:11:50,500 --> 02:11:52,500
Sure. Be that way.

2221
02:11:52,500 --> 02:11:54,500
I'm not going to run this. I don't care about

2222
02:11:54,500 --> 02:11:56,500
running it. I care about, remember that

2223
02:11:56,500 --> 02:11:58,500
Python is a compiled language.

2224
02:11:58,500 --> 02:12:00,500
So when I define this function,

2225
02:12:00,500 --> 02:12:02,500
it's compiling this into bytecodes. If I

2226
02:12:02,500 --> 02:12:04,500
can look behind the scenes, we

2227
02:12:04,500 --> 02:12:06,500
will see what's going on. And so I'm going to import

2228
02:12:06,500 --> 02:12:08,500
dis. This is the disassembler

2229
02:12:08,500 --> 02:12:10,500
for Python.

2230
02:12:10,500 --> 02:12:12,500
And I'm going to say dis.dis

2231
02:12:12,500 --> 02:12:14,500
of regular loop.

2232
02:12:14,500 --> 02:12:16,500
Regular lop.

2233
02:12:18,500 --> 02:12:20,500
And what do we see here?

2234
02:12:20,500 --> 02:12:22,500
This is what Python is actually executing

2235
02:12:22,500 --> 02:12:24,500
behind the scenes. And what we see

2236
02:12:24,500 --> 02:12:26,500
is it's loading the constant 100.

2237
02:12:26,500 --> 02:12:28,500
It's store and store fast.

2238
02:12:28,500 --> 02:12:30,500
Store fast is the important thing.

2239
02:12:30,500 --> 02:12:32,500
That means local variable. So

2240
02:12:32,500 --> 02:12:34,500
x is a local variable here.

2241
02:12:34,500 --> 02:12:36,500
But like, so we're

2242
02:12:36,500 --> 02:12:38,500
setting x to be 100. So that's local.

2243
02:12:38,500 --> 02:12:40,500
And then we're setting other things here. It's all local.

2244
02:12:40,500 --> 02:12:42,500
One number, store fast.

2245
02:12:42,500 --> 02:12:44,500
One number, load fast.

2246
02:12:44,500 --> 02:12:46,500
X, store fast. So this x

2247
02:12:46,500 --> 02:12:48,500
and this x are exactly the same x.

2248
02:12:48,500 --> 02:12:50,500
If before I said, we're

2249
02:12:50,500 --> 02:12:52,500
not in a function and thus everything's global,

2250
02:12:52,500 --> 02:12:54,500
now we are in a function and everything is local.

2251
02:12:56,500 --> 02:12:58,500
Okay, so what?

2252
02:12:58,500 --> 02:13:00,500
Well, let's compare this with

2253
02:13:00,500 --> 02:13:02,500
the comprehension version.

2254
02:13:04,500 --> 02:13:06,500
So I'm going to say here, you know,

2255
02:13:06,500 --> 02:13:08,500
comprehension.

2256
02:13:08,500 --> 02:13:10,500
I'm going to say here, I said 100,

2257
02:13:10,500 --> 02:13:12,500
I'm going to say here, print. I'll say like, you know,

2258
02:13:12,500 --> 02:13:14,500
x times 3. I know it's not exactly

2259
02:13:14,500 --> 02:13:16,500
the same, but it's close enough for our purposes

2260
02:13:16,500 --> 02:13:18,500
for x in range 3, 5,

2261
02:13:18,500 --> 02:13:20,500
whatever. Who cares?

2262
02:13:20,500 --> 02:13:22,500
And now I'm going to say, dist.dist of

2263
02:13:22,500 --> 02:13:24,500
comp loop.

2264
02:13:26,500 --> 02:13:28,500
And my mind was blown when I saw

2265
02:13:28,500 --> 02:13:30,500
this. Okay.

2266
02:13:30,500 --> 02:13:32,500
We're loading

2267
02:13:32,500 --> 02:13:34,500
constant 100,

2268
02:13:34,500 --> 02:13:36,500
storing it in x, and then

2269
02:13:36,500 --> 02:13:38,500
what the heck is this?

2270
02:13:38,500 --> 02:13:40,500
We're loading the constant,

2271
02:13:40,500 --> 02:13:42,500
code object list comp,

2272
02:13:42,500 --> 02:13:44,500
what the heck?

2273
02:13:44,500 --> 02:13:46,500
So it turns out that when you

2274
02:13:46,500 --> 02:13:48,500
define a list comprehension,

2275
02:13:48,500 --> 02:13:50,500
you are creating a secret function

2276
02:13:50,500 --> 02:13:52,500
behind the scenes.

2277
02:13:52,500 --> 02:13:54,500
And that secret function

2278
02:13:54,500 --> 02:13:56,500
has, like all functions,

2279
02:13:56,500 --> 02:13:58,500
its own local variables.

2280
02:13:58,500 --> 02:14:00,500
And they don't leak out.

2281
02:14:00,500 --> 02:14:02,500
So if we set something

2282
02:14:02,500 --> 02:14:04,500
in the comprehension, which we do,

2283
02:14:04,500 --> 02:14:06,500
it won't be seen

2284
02:14:06,500 --> 02:14:08,500
outside. It can't be seen outside.

2285
02:14:08,500 --> 02:14:10,500
Now the cool thing about this, one of the

2286
02:14:10,500 --> 02:14:12,500
main cool things, is load const.

2287
02:14:12,500 --> 02:14:14,500
So load const, so whenever you define a function,

2288
02:14:14,500 --> 02:14:16,500
all the strings,

2289
02:14:16,500 --> 02:14:18,500
all the integers, they are stored on the

2290
02:14:18,500 --> 02:14:20,500
function object as constants.

2291
02:14:20,500 --> 02:14:22,500
So like if you say x equals 5,

2292
02:14:22,500 --> 02:14:24,500
it stores 5 to the

2293
02:14:24,500 --> 02:14:26,500
constant on the function object that pulls it up.

2294
02:14:26,500 --> 02:14:28,500
So it turns out that when you have a

2295
02:14:28,500 --> 02:14:30,500
function that has a comprehension in it,

2296
02:14:30,500 --> 02:14:32,500
Python's like, oh, I'm going to turn this

2297
02:14:32,500 --> 02:14:34,500
function into, I'm going to turn this comprehension

2298
02:14:34,500 --> 02:14:36,500
into a secret function, and then stick that

2299
02:14:36,500 --> 02:14:38,500
as a constant on the function.

2300
02:14:38,500 --> 02:14:40,500
And indeed then,

2301
02:14:40,500 --> 02:14:42,500
where do I see that? Oh yeah, down here,

2302
02:14:42,500 --> 02:14:44,500
it says, oh yeah, here's the disassembly of your

2303
02:14:44,500 --> 02:14:46,500
code object. So if

2304
02:14:46,500 --> 02:14:48,500
this is the secret function here,

2305
02:14:48,500 --> 02:14:50,500
and it's going to build a list, why is it going to build

2306
02:14:50,500 --> 02:14:52,500
a list? Because it's a list comprehension.

2307
02:14:52,500 --> 02:14:54,500
And it's going to load fast,

2308
02:14:54,500 --> 02:14:56,500
it's going to load a variable, it's going

2309
02:14:56,500 --> 02:14:58,500
to iterate, it's going to store

2310
02:14:58,500 --> 02:15:00,500
fast into x. But this

2311
02:15:00,500 --> 02:15:02,500
x is local to our comprehension.

2312
02:15:02,500 --> 02:15:04,500
It has nothing to do with the x that was

2313
02:15:04,500 --> 02:15:06,500
in the outer function. And that's

2314
02:15:06,500 --> 02:15:08,500
then why variable

2315
02:15:08,500 --> 02:15:10,500
set and comprehensions don't leak out.

2316
02:15:10,500 --> 02:15:12,500
Because basically they are functions

2317
02:15:12,500 --> 02:15:14,500
in disguise.

2318
02:15:18,500 --> 02:15:20,500
Okay.

2319
02:15:20,500 --> 02:15:22,500
So now, like,

2320
02:15:22,500 --> 02:15:24,500
stunned silence, everyone's like, can I go home now?

2321
02:15:26,500 --> 02:15:28,500
I'm very happy to answer

2322
02:15:28,500 --> 02:15:30,500
further questions if you have any.

2323
02:15:32,500 --> 02:15:34,500
Okay.

2324
02:15:34,500 --> 02:15:36,500
Oh yeah, please, please.

2325
02:15:36,500 --> 02:15:38,500
So yes, yes, so in Python 2,

2326
02:15:38,500 --> 02:15:40,500
comprehensions were just in the normal

2327
02:15:40,500 --> 02:15:42,500
plain old scope. They didn't do this

2328
02:15:42,500 --> 02:15:44,500
wacky thing at all.

2329
02:15:44,500 --> 02:15:46,500
That's why I was like,

2330
02:15:46,500 --> 02:15:48,500
how does, what's going on here?

2331
02:15:48,500 --> 02:15:50,500
And that's also why, like,

2332
02:15:50,500 --> 02:15:52,500
anyway, you can really, like,

2333
02:15:52,500 --> 02:15:54,500
spend way too much time with this, as I know.

2334
02:15:54,500 --> 02:15:56,500
But I'm not going to go into that.

2335
02:15:56,500 --> 02:15:58,500
I'm just going to go into the

2336
02:15:58,500 --> 02:16:00,500
code.

2337
02:16:00,500 --> 02:16:02,500
So I'm going to spend way too much time with this, as I know.

2338
02:16:04,500 --> 02:16:06,500
Alright.

2339
02:16:06,500 --> 02:16:08,500
So, a few closing things.

2340
02:16:08,500 --> 02:16:10,500
First of all, I hope

2341
02:16:10,500 --> 02:16:12,500
that this was helpful, useful,

2342
02:16:12,500 --> 02:16:14,500
interesting, and helps to

2343
02:16:14,500 --> 02:16:16,500
put in perspective a whole lot of comprehension stuff.

2344
02:16:16,500 --> 02:16:18,500
That you'll be less intimidated

2345
02:16:18,500 --> 02:16:20,500
by them. You can do the intimidating now.

2346
02:16:20,500 --> 02:16:22,500
Not the comprehensions. That you'll maybe start

2347
02:16:22,500 --> 02:16:24,500
to use them in your work, show off to your

2348
02:16:24,500 --> 02:16:26,500
friends, and so forth.

2349
02:16:26,500 --> 02:16:28,500
Second of all, this repo on GitHub will stick around

2350
02:16:28,500 --> 02:16:30,500
forever, basically.

2351
02:16:30,500 --> 02:16:32,500
So, if you want to go over it,

2352
02:16:32,500 --> 02:16:34,500
look at it, the Jupyter Notebook is there.

2353
02:16:34,500 --> 02:16:36,500
I'll also put it into HTML format.

2354
02:16:36,500 --> 02:16:38,500
So that if you just want to view it

2355
02:16:38,500 --> 02:16:40,500
on your own computer or elsewhere, like, that's an easy thing to do.

2356
02:16:40,500 --> 02:16:42,500
The third thing is,

2357
02:16:42,500 --> 02:16:44,500
I love being in touch with people about

2358
02:16:44,500 --> 02:16:46,500
this sort of stuff. I mean, that's what I do,

2359
02:16:46,500 --> 02:16:48,500
right? So, you know,

2360
02:16:48,500 --> 02:16:50,500
A, the self-serving part,

2361
02:16:50,500 --> 02:16:52,500
if you want me to come and do training at your company,

2362
02:16:52,500 --> 02:16:54,500
I'm very happy to come do that. If you want to talk to you about other stuff,

2363
02:16:54,500 --> 02:16:56,500
happy to do that as well.

2364
02:16:56,500 --> 02:16:58,500
I have a lot of fun stuff on Twitter, YouTube,

2365
02:16:58,500 --> 02:17:00,500
I have a mailing list.

2366
02:17:00,500 --> 02:17:02,500
I also put that on the GitHub repo as well.

2367
02:17:02,500 --> 02:17:04,500
And also, I'm giving some more talks here

2368
02:17:04,500 --> 02:17:06,500
at PyCon, and I've got a booth

2369
02:17:06,500 --> 02:17:08,500
giving out t-shirts, giving out swag,

2370
02:17:08,500 --> 02:17:10,500
assuming it all arrives on time.

2371
02:17:10,500 --> 02:17:12,500
So I'll be very happy to talk to you about that.

2372
02:17:12,500 --> 02:17:14,500
And anyway, this has been super fun for me.

2373
02:17:14,500 --> 02:17:16,500
And it's a great way to kick off PyCon.

2374
02:17:16,500 --> 02:17:18,500
And I'm now regretting

2375
02:17:18,500 --> 02:17:20,500
even more that last year it took me

2376
02:17:20,500 --> 02:17:22,500
42 hours to get to PyCon, and I missed

2377
02:17:22,500 --> 02:17:24,500
the tutorial I was supposed to do, because this was so much fun.

2378
02:17:24,500 --> 02:17:26,500
So, anyway, thanks so much, folks,

2379
02:17:26,500 --> 02:17:28,500
and I'll see you around the rest of the conference.

2380
02:17:28,500 --> 02:17:30,500
Applause

