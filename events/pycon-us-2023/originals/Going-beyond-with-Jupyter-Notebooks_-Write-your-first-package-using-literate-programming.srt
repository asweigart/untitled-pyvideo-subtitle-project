1
00:00:00,000 --> 00:00:12,680
Hi. Hello, everyone. I'm just waiting for everyone's got set up, and we're going to

2
00:00:12,680 --> 00:00:27,520
start in a few minutes, okay? So my name is Italo. I'm a software engineer from Brazil.

3
00:00:27,520 --> 00:00:33,160
It's nice to meet you all. I'm going to be your host today for this tutorial, going beyond

4
00:00:33,160 --> 00:00:39,840
with two Python notebooks. I'm going to present to you the NBdev library. I'm pretty nervous

5
00:00:39,840 --> 00:00:45,240
and excited because it's my first PyCon, and it's my first tutorial as well, presenting

6
00:00:45,240 --> 00:00:53,120
here. NBdev is the library we're going to discuss today, and it got in the GitHub program,

7
00:00:53,960 --> 00:01:04,600
it will be accelerated, so its development, it will get way better. So I'm a software

8
00:01:04,600 --> 00:01:10,640
engineer from Brazil. This is where I live. This city is called Natal. It was a big shift

9
00:01:10,640 --> 00:01:16,760
of weather. I'm a computer scientist, almost there, because I'm working on my tests right

10
00:01:17,240 --> 00:01:23,760
now. I work as a researcher in development using Python, and I'm also an open source

11
00:01:23,760 --> 00:01:31,640
maintainer. I'm also a contributor for the Python community in my city. And today we're

12
00:01:31,640 --> 00:01:36,120
going to discuss a lot of things. So we're going to introduce the concepts to publish

13
00:01:36,120 --> 00:01:43,000
a package and why we're going to need to publish a package, discuss Python packaging system

14
00:01:43,160 --> 00:01:48,440
and distribution, explain the concept of literate programming, show how two Python notebooks

15
00:01:48,440 --> 00:01:55,160
works, introduce the NBdev library and how we can use to program using this programming

16
00:01:55,160 --> 00:02:01,800
paradigm called literate programming, explain good practices, and develop a mini game with

17
00:02:01,800 --> 00:02:08,800
a French deck library. I'm going to display how to use the quality assurance on two Python

18
00:02:08,880 --> 00:02:14,400
notebooks, discuss how we're going to test our software, show how to publish a Python

19
00:02:14,400 --> 00:02:21,400
package, introduce GitHub action to use CI, CD, talk about a little bit about Python packaging

20
00:02:21,560 --> 00:02:28,560
past and future, introduce how to build UIs for two Python notebooks, show why Squarto,

21
00:02:29,920 --> 00:02:35,520
what Squarto and how to customize it, and demonstrate how to use chat GPT in two Python

22
00:02:35,520 --> 00:02:42,440
notebooks. So if you have any questions, you can just raise your hand or we're going

23
00:02:42,440 --> 00:02:48,840
to run some exercises during this tutorial. If you're having trouble with the exercises,

24
00:02:48,840 --> 00:02:55,840
just raise your hand. I'm going to be at your desk. So let's introduce some core concepts

25
00:02:55,840 --> 00:03:03,840
of Python packaging. There are two main concepts that are modules and packaging. Modules are

26
00:03:03,880 --> 00:03:10,880
files that contain Python code, Python definitions, statements. Any Python file can be considered

27
00:03:11,480 --> 00:03:18,480
a module. So in this code right here, we have this module.py, this write file, it's a magic

28
00:03:18,480 --> 00:03:25,000
cell that writes a file into Python notebooks. And we have just a simple function called

29
00:03:25,000 --> 00:03:32,000
hello that will print a hello. Yeah, so going beyond, modules can be as simple as this.

30
00:03:33,840 --> 00:03:40,840
Executed as Python scripts, as a regular Python script. If you're running in your interpreter,

31
00:03:41,080 --> 00:03:48,080
this module.py, and you have this conditional name equals main, you're going to see that

32
00:03:49,280 --> 00:03:56,280
it will run the main code that's inside this conditional. And how Python interpreter looks

33
00:03:56,560 --> 00:04:03,560
for the modules when you open your interpreter. So let me show you here. When you open your

34
00:04:07,840 --> 00:04:14,840
interpreter, you can import this module and you can get these modules.names right here.

35
00:04:17,960 --> 00:04:24,960
This is all Python building modules. So Python first loads all these modules. And then you

36
00:04:26,920 --> 00:04:33,920
can call and use them. Or it will look at the sys.path. So here are my files where Python

37
00:04:36,280 --> 00:04:43,280
is looking at my modules. So that's how Python search for modules when you're loading things

38
00:04:45,800 --> 00:04:52,800
on your packaging on your Python structure. The main concept here is packages. That's

39
00:04:53,280 --> 00:05:00,120
a collection of modules, right? So it uses dot modules name. For example, when you're

40
00:05:00,120 --> 00:05:07,120
using this from my package, some module, import some function. This is what they call dot

41
00:05:11,560 --> 00:05:18,560
module names. So now we're going to start our first exercise. This folder structure

42
00:05:19,560 --> 00:05:26,000
here, you can create on your computer this subfolder structure. With this username, you

43
00:05:26,000 --> 00:05:33,000
can switch your username by your GitHub username, underlying package, and write these files.

44
00:05:33,680 --> 00:05:40,680
You don't need to write code now. Just open your terminal and create this folder structure,

45
00:05:40,680 --> 00:05:48,680
and then you can start your own. Can you see this folder structure? Okay, let me show you.

46
00:06:10,680 --> 00:06:17,680
Okay, I'm just going to exclude some things here, and you're going to be able to show

47
00:06:17,680 --> 00:06:24,680
to see the folder structure. Okay, so this is the folder structure. So this is the folder

48
00:06:47,680 --> 00:06:54,680
structure. Okay, so this is the folder structure. So this is the folder structure. So this

49
00:07:17,680 --> 00:07:24,680
is the folder structure. Okay, you can still see, right? Yeah.

50
00:07:47,680 --> 00:07:54,680
Okay, so this is the folder structure. So this is the folder structure. So this is the

51
00:08:17,680 --> 00:08:24,680
folder structure. I'm not sure if this helps. This one? Okay, so you create a folder. You

52
00:08:24,680 --> 00:08:31,680
can call whatever you want, and you're going to add this image module in here, and the

53
00:08:31,680 --> 00:08:38,680
module.py is the main folders and files that you need. Okay, so this is the folder structure.

54
00:08:46,240 --> 00:08:53,240
Okay, so this is the folder structure. So this is the folder structure. So this is the

55
00:09:01,680 --> 00:09:08,680
folder structure. Okay, so this is the folder structure. So this is the folder structure.

56
00:09:31,680 --> 00:09:38,680
Yeah, you're going to create the folder and these two files. You can ignore the remaining.

57
00:09:53,400 --> 00:10:00,400
Everyone all set up? All right. Okay. We're going to first publish this small package

58
00:10:01,160 --> 00:10:05,680
just to understand how to publish packages and distribute it, and later we're going to

59
00:10:05,680 --> 00:10:12,680
use NB dev and Jupyter Notebooks to distribute a more fancy package. I suggest you use this.

60
00:10:17,280 --> 00:10:22,240
Inside the folder that you created, you need to create, this is something that I should

61
00:10:22,240 --> 00:10:29,240
explain before. You should create a folder with your GitHub name underline package because

62
00:10:30,440 --> 00:10:37,440
we're going to publish this package on your test.py.py account. Okay? So create your user

63
00:10:37,920 --> 00:10:44,920
name package inside of your folder with these two files right here. Let me show you.

64
00:11:00,400 --> 00:11:07,400
Okay, so this is the folder structure. So this is the folder structure. So this is the

65
00:11:30,400 --> 00:11:37,400
folder structure. Okay, so you're going to access a folder like examples right here,

66
00:11:40,120 --> 00:11:46,040
and you're going to create another folder with your GitHub user name underline package,

67
00:11:46,040 --> 00:11:53,040
and then you're going to create these two files, empty files, .init.py and module1.py.

68
00:11:53,040 --> 00:12:00,040
No, it's the main thing, it's the exercise. Yeah. With examples, sure. Like you have this,

69
00:12:14,640 --> 00:12:21,640
okay. Like you create your user name package, and then you're going to create a folder with

70
00:12:23,040 --> 00:12:30,040
your GitHub user name underline package. No, no. Yeah, you're going to put some wire

71
00:12:30,840 --> 00:12:37,840
in your computer, so it's some folder you can name in whatever you want. Okay. Everyone

72
00:12:42,400 --> 00:12:47,360
was able to create a package with your GitHub user name underline package and these two

73
00:12:47,760 --> 00:12:54,760
files inside that package. Okay, let's move on. So you can open your terminal, your Python

74
00:12:58,040 --> 00:13:05,040
terminal, and you can import those files like from your user name, your user name package.

75
00:13:09,720 --> 00:13:16,720
Fix here. So you're going to be able to see that you're going to be able to see that you're

76
00:13:17,920 --> 00:13:24,920
the Python interpreter is searching for your Python files that is loaded in the current

77
00:13:26,760 --> 00:13:33,600
folder. I'm here using examples. You're probably put somewhere in your computer, so you're

78
00:13:33,600 --> 00:13:40,600
going to be at this file and run your interpreter there. And you're going to be able to import

79
00:13:41,480 --> 00:13:48,480
your package. Everyone was able to import your packages? Okay. So if you go to a different

80
00:13:53,360 --> 00:14:00,360
folder and try to load your Python interpreter and load your package, you're going to see

81
00:14:01,480 --> 00:14:08,480
an error. Mine is not throwing an error because I installed this package before, but it probably

82
00:14:08,480 --> 00:14:15,480
shows a package error. It can find that package. But if you're using import sys and append

83
00:14:21,360 --> 00:14:28,360
your folder, your some folder on your computer, you're going to be able to import your package.

84
00:14:31,160 --> 00:14:38,160
So have you be able to see the error when you're through? So import sys append your

85
00:14:38,800 --> 00:14:44,600
folder name right here, and you're going to be able to import your package. This is an

86
00:14:44,600 --> 00:14:51,600
oracle that some people use. You can see? Okay. So everyone is already completed the

87
00:14:51,600 --> 00:14:58,600
task? Great. I'm sorry about that. I thought that this folder structure would be easier

88
00:14:58,600 --> 00:15:05,600
to read. So with this exercise, we understand how Python can import things and how they

89
00:15:05,600 --> 00:15:12,600
load our modules and understand our packages, right? Python is a very simple and easy to

90
00:15:13,280 --> 00:15:20,280
use application. It's a very simple application. It's a very simple application. It's a very

91
00:15:21,600 --> 00:15:26,960
simple application. Python packaging searches like the Python modules. It uses the sys.path

92
00:15:26,960 --> 00:15:33,960
as well. When you're appending something to that path, you're adding a path that's not

93
00:15:34,120 --> 00:15:41,120
usually add to your Python. This is a workaround. It's not recommended to use this append right

94
00:15:42,320 --> 00:15:49,000
here, but something that you can see in some code and some Python packages. So be aware

95
00:15:49,000 --> 00:15:56,000
it's not a good practice, but it's to understand how Python loads its modules, okay? So why

96
00:15:58,120 --> 00:16:05,120
packaging? Why do we need to share a piece of code with others and publish that Python

97
00:16:06,240 --> 00:16:13,240
packaging? I like this example. I'm not sure if you can see down there. This is we have

98
00:16:13,240 --> 00:16:20,240
this Avenger, this Avenger movie, Avenger 1 and Avenger 2, where the Avenger 1, we

99
00:16:22,000 --> 00:16:29,000
have a full application called Avengers with three heroes right here, Hulk, Black Widow,

100
00:16:30,240 --> 00:16:36,160
and Thor. And okay, we run our application. We run the Avenger 1 application, and it's

101
00:16:36,160 --> 00:16:43,160
like a model if everything is there. But then we need to build Avenger 2 and then we need

102
00:16:43,400 --> 00:16:49,240
to share that multiple heroes in different timelines for other movies. So a good way

103
00:16:49,240 --> 00:16:56,240
to do that is create a package for every superhero. So this is an example for modular architecture

104
00:16:58,720 --> 00:17:05,720
in Python packaging, a talk from Python Brazil in 2022. I found a great example to show how

105
00:17:06,720 --> 00:17:13,720
we normally use Python packaging in a Python code. So the pros of using Python packages

106
00:17:16,520 --> 00:17:23,520
increases the code reuse. You're going to be able to import that Hulk, that Black Widow

107
00:17:24,000 --> 00:17:29,280
packages. It reduces the coupling because the superheroes, it will not talk with each

108
00:17:29,280 --> 00:17:36,280
other, so the coupling between those files, it will not exist. It will be easier to maintain,

109
00:17:36,640 --> 00:17:42,760
easier to author developers to use. It will split the responsibility across teams. If

110
00:17:42,760 --> 00:17:48,080
you're having a big team that's working on one application, you can split in multiple

111
00:17:48,080 --> 00:17:55,080
Python packages and make it easier to run faster. But there's some problems as well.

112
00:17:55,880 --> 00:18:01,960
So when you're writing Python packages, you have the version of your package and managing

113
00:18:01,960 --> 00:18:08,960
multiple packages on an application can be difficult. If you're not developing the Python

114
00:18:09,080 --> 00:18:15,320
packages you're installing, you can't guarantee your security. And packages sometimes have

115
00:18:15,320 --> 00:18:22,320
more features than is needed for your Python application. So we now, we have a minimal

116
00:18:22,320 --> 00:18:29,320
example of a Python package on your computer, how we can build that package and distribute

117
00:18:29,880 --> 00:18:36,880
that package so anyone can download that package. We need to create, okay.

118
00:18:52,320 --> 00:18:59,320
Yeah, it's related. Because for example, sometimes there's a concept called dependency hell.

119
00:19:10,320 --> 00:19:17,320
That's where you have like this Hulk application runs Python 3.0. It's called dependency hell.

120
00:19:17,320 --> 00:19:24,320
It's when you have, yeah, when you have conflicts between the versions of your software. Like

121
00:19:29,920 --> 00:19:36,920
Hulk requires a version of Python and Thor needs a different version of Python. So it

122
00:19:37,000 --> 00:19:43,200
conflicts. You can't move your application forward because there's a conflict between

123
00:19:43,280 --> 00:19:50,280
those two packages. This is a dumb example, but okay. So when we're going to distribute

124
00:19:53,320 --> 00:20:00,320
our package we need to add the name of the package and the version. We use usually a

125
00:20:00,800 --> 00:20:07,800
setup.py or a more new approach using pyproject.tom. We build our project using a source distribution

126
00:20:08,800 --> 00:20:15,800
Python packages or a binary Python packages, okay. We're going to discuss this later. And

127
00:20:16,800 --> 00:20:23,800
using this back end it will produce an artifact. It's a file that is Thor or this weird format

128
00:20:26,480 --> 00:20:33,480
wheel. And after building our package we're going to upload that to someplace that can

129
00:20:34,480 --> 00:20:41,480
distribute our package. So we usually use PyPI or test PyPI. That's more common in the

130
00:20:42,480 --> 00:20:49,480
Python community to use them. But I will show you some other packages where you can publish

131
00:20:49,920 --> 00:20:56,920
and distribute your package. So what is PyPI? It's the Python package index. It's where

132
00:20:57,920 --> 00:21:04,920
most of the Python packages you install and use on your computer is hosted. So when you're

133
00:21:05,520 --> 00:21:12,520
using pip it's downloading the package from the PyPI index, okay. And the PyPI contains

134
00:21:15,000 --> 00:21:22,000
a lot of Python packages and has multiple problems of like it's a big repository and

135
00:21:23,000 --> 00:21:29,000
scale that is very difficult. So they have this test PyPI that's a separate index for

136
00:21:29,840 --> 00:21:36,840
learning. And we're going to use the test PyPI for publish or minimal package that we

137
00:21:37,480 --> 00:21:44,480
just created now. So I will ask you to create a count on test PyPI right now. If you don't

138
00:21:45,480 --> 00:21:52,480
already have one. Yeah, so it's on my GitHub. You can access. Like my GitHub is IT Epiphanium

139
00:22:07,920 --> 00:22:12,280
and the name of the application is going beyond which Python notebooks. Maybe searching you're

140
00:22:12,280 --> 00:22:19,280
going to find. Let me. You will stay here. You will all fork this repository later on

141
00:22:35,120 --> 00:22:42,120
this tutorial. So you're going to have a version on your own. So you're going to have a version

142
00:22:42,280 --> 00:22:49,280
on your own. So test PyPI. I'm sorry. You can see. But test PyPI is this. So you can

143
00:23:12,280 --> 00:23:19,280
is this site right here. You can register or log in if you already have an account.

144
00:23:34,080 --> 00:23:41,080
I'll give you about five minutes to create your account, okay. After you created. Okay.

145
00:23:42,040 --> 00:23:47,840
After you created your Python packages, you may need to activate your account. Okay. So

146
00:23:47,840 --> 00:23:54,840
go to your email and activate your account as well. So is everyone okay with your account?

147
00:24:00,200 --> 00:24:07,200
Okay. Let's move on. Now that we already have our test PyPI account, we're going to publish

148
00:24:07,200 --> 00:24:14,200
those files that we created before. So go to the some folder that you create on your

149
00:24:15,120 --> 00:24:22,120
computer and create a setup.py file with this content right here that you may not be able

150
00:24:22,960 --> 00:24:29,960
to see. We're going to add here. Okay. So you can see that we have a test PyPI account

151
00:24:37,600 --> 00:24:44,600
Can you see you guys? Okay. So you're going to create a setup.py on the root of some folder

152
00:24:47,240 --> 00:24:54,240
you create on your computer and add this to your setup.py. Okay. Instead of the username,

153
00:24:54,240 --> 00:25:01,240
you're going to use your GitHub username, the package you created right here, the name.

154
00:25:13,240 --> 00:25:20,240
Okay. Like, okay. So you can see that we have a setup.py file. Okay. So you can see that

155
00:25:24,240 --> 00:25:31,240
you can see that we have a setup.py file. Okay. Everyone just, okay. So your folder

156
00:25:32,360 --> 00:25:39,360
should look like this. Now you have your package, right? And you have your setup.py with that

157
00:25:42,280 --> 00:25:49,280
content we just write. Now we can create a virtual AMP. You're going to choose your

158
00:25:54,480 --> 00:26:01,480
you're going to enter your, your folder and type Python. Let's AMP the virtual environment

159
00:26:03,800 --> 00:26:10,800
module you're going to load and create a virtual environment name. I'm going to, I'm going

160
00:26:11,840 --> 00:26:18,840
to name example right here. After you create this, you're going to create a virtual environment

161
00:26:24,240 --> 00:26:31,240
name. You're going to be able to load using this command.

162
00:26:54,240 --> 00:27:01,240
Have you, everyone, be able to create your virtual environment? You may need to install

163
00:27:04,600 --> 00:27:11,600
virtual environment if you don't have it installed on your computer. Okay. After that, activate

164
00:27:11,680 --> 00:27:18,680
using the source, the name of your virtual environment and activate. You can press enter

165
00:27:19,680 --> 00:27:26,680
and it will activate your virtual environment. Has everyone been able to activate your virtual

166
00:27:34,800 --> 00:27:41,800
environment? No? Okay. So you can see that you can see that

167
00:27:49,680 --> 00:27:56,680
it's working. Okay. With your virtual environment activated,

168
00:28:02,760 --> 00:28:08,480
you can start line. It's a package that will help us to distribute our package. It's going

169
00:28:08,480 --> 00:28:15,480
to publish our package on TestPyPI. Okay. So you can see that you can see that your

170
00:28:18,680 --> 00:28:25,680
package is working. Okay. So if you're using Windows instead of using source, you're going

171
00:28:26,280 --> 00:28:33,280
to go to your, to the file that you created. It's going to create an activate script somewhere

172
00:28:36,000 --> 00:28:43,000
in your computer and you can just type enter if you're using Windows. It's activated, right?

173
00:28:43,000 --> 00:28:50,000
Okay. We're using virtual environments to avoid to mess up with our global environment,

174
00:29:01,880 --> 00:29:08,880
right? It's a way to isolate our environments. Okay.

175
00:29:13,960 --> 00:29:20,960
Has everyone been able to install Twine? Okay. So now that we already have Twine install

176
00:29:27,960 --> 00:29:34,960
or package set up, we can execute this to build our Python package. It will create a

177
00:29:34,960 --> 00:29:41,960
source distribution of Python like Python regular code and binary distribution using

178
00:29:44,880 --> 00:29:51,000
wheels. That's another format we're going to distribute our packages in these two ways.

179
00:29:51,000 --> 00:29:58,000
There are the ways of your distribution, your packages. So you can run this. You're going

180
00:29:59,000 --> 00:30:06,000
to see that it will create a dist environment with two files there. Now, you can do that

181
00:30:13,920 --> 00:30:20,920
too. You can do the two of us, the two of them together. So if you're using Windows,

182
00:30:20,920 --> 00:30:27,920
you can just ignore the wheel part and build this. Okay? So has everyone been able to build

183
00:30:32,120 --> 00:30:39,120
your package? Now we're going to upload our package on testpipi. It's the final step.

184
00:30:40,880 --> 00:30:47,880
We're almost there, okay? So we're going to use Twine to upload on testpipi. So we're

185
00:30:51,000 --> 00:30:58,000
going to use testpipi using this common. We're going to be able to type your email and password

186
00:30:58,440 --> 00:31:05,440
and upload your package to testpipi. Yeah, it should work on both. Okay, so if you already

187
00:31:05,440 --> 00:31:12,440
uploaded your Twine package to your testpipi account, you can check your testpipi account

188
00:31:21,320 --> 00:31:26,280
and see the package there. You'll be able to install and everyone in the room will be

189
00:31:26,280 --> 00:31:33,280
able to install your package as well. It's your username from your testpipi account.

190
00:31:33,600 --> 00:31:40,600
Guys, we're running out of time, so I will need to move on with the tutorial without

191
00:31:41,080 --> 00:31:48,080
this exercise. Outside of the tutorial, we can talk and see the errors, okay? Sorry about

192
00:31:50,000 --> 00:31:57,000
that. I thought it would be easier to upload those packages and understand how Python

193
00:31:57,800 --> 00:32:04,800
understands these core concepts, okay? So we should. We uploaded to pipi or should have

194
00:32:05,640 --> 00:32:11,880
uploaded to pipi, but there's other servers where we can upload our packages. Like pipi

195
00:32:11,880 --> 00:32:18,880
server, you can run locally or self-hosted. JFrog, AWS, called artifacts, Google artifacts,

196
00:32:18,880 --> 00:32:25,880
register, GitLab also has a registration of Python packages, and GitHub, I searched,

197
00:32:27,320 --> 00:32:33,320
I didn't find a way to upload Python packages to GitHub, but they also have a package registration

198
00:32:33,320 --> 00:32:40,320
for Ruby and for Node, okay? Let's introduce now the concept of literative programming.

199
00:32:41,760 --> 00:32:48,280
That's a way to tell a story with your code. It was introduced in 1984 by Donald Knuth.

200
00:32:48,280 --> 00:32:55,280
If you're in computer science, you already know Donald Knuth. He's published a lot of

201
00:32:56,560 --> 00:33:02,000
important papers in computer science. In these papers, he said, let us change our traditional

202
00:33:02,000 --> 00:33:06,720
attitudes to the construction of programs. Instead of imagining that our main task is

203
00:33:06,720 --> 00:33:12,280
to instruct a computer what to do, let us concentrate rather on explaining to humans

204
00:33:12,360 --> 00:33:19,360
being what we want a computer to do. So this concept makes its code and markdown or code

205
00:33:19,520 --> 00:33:26,520
and human literature into computer programs. Haskell is one of the languages that brought

206
00:33:28,600 --> 00:33:35,600
this into its core development. So if you're writing a Haskell program, you're using this

207
00:33:36,600 --> 00:33:43,600
.8s, and if you're using literate programming with Haskell, you're using L8s, and you're

208
00:33:45,680 --> 00:33:52,680
able to write code and write human language like Spanish, like English. You can write

209
00:33:52,800 --> 00:33:59,800
and tell a story with your code. Its literate programming usage increases in the last years,

210
00:34:00,480 --> 00:34:07,480
so data science has grew a lot in the past years, and the literate programming grew with

211
00:34:07,960 --> 00:34:14,960
the data science field. The most used tools are Jupyter Notebooks and RStudio for literate

212
00:34:17,720 --> 00:34:24,720
programming. Introducing, you may not be able to see the image. So this is how Donald Knuth

213
00:34:24,720 --> 00:34:31,720
thinks of literate programming. He created a language, a script called Web, where you

214
00:34:36,320 --> 00:34:43,320
can mix code and mix text, and it generates a text file or a Pascal binary file. This

215
00:34:46,000 --> 00:34:53,000
was in 1984, okay? So using Jupyter Notebooks, we write a Jupyter Notebook and we use code

216
00:34:54,920 --> 00:35:01,920
for R2, that's a software to write markdown files and use them as PDF, HTML, like publish

217
00:35:02,080 --> 00:35:09,080
our documentation, and we use this library called NBDEV to generate Python codes. So

218
00:35:10,320 --> 00:35:16,360
from the Jupyter Notebook code you wrote, you generate your documentation and your Python

219
00:35:16,360 --> 00:35:23,360
scripts that's going to be used for publishing Python packages, okay? So I will introduce

220
00:35:24,120 --> 00:35:31,120
very quickly Jupyter Notebooks. If you can type pip install notebook to install Jupyter

221
00:35:31,360 --> 00:35:38,360
Notebook and type Jupyter Notebooks on your terminal. I'm not going to wait for you guys

222
00:35:45,640 --> 00:35:52,640
because we're very late, so I'm going to show you the page. This is the page that I'm going

223
00:35:53,360 --> 00:36:00,360
to show you. This is the UI that Jupyter Notebook runs when you open it. I'm going

224
00:36:00,880 --> 00:36:07,880
to create a simple new Jupyter Notebook. When you're creating a Jupyter Notebook, you give

225
00:36:11,000 --> 00:36:18,000
to the file a name. Later you can mix this field right here is called cell. You can change

226
00:36:18,560 --> 00:36:25,560
a cell to code or markdown. So we usually start our Jupyter Notebooks writing a title

227
00:36:25,560 --> 00:36:32,560
to the Jupyter Notebook and a simple description of what your Jupyter Notebook is doing. Then

228
00:36:33,560 --> 00:36:40,560
we can write Python code and we can mix the two of the text and the Python code in a Jupyter

229
00:36:40,560 --> 00:36:47,560
Notebook. We can test it's not a linear thing. It's not sequential. You can have a counter

230
00:36:56,480 --> 00:37:03,480
right here and increase the counter. Counter now is one because it's done. You can run

231
00:37:03,480 --> 00:37:10,480
this multiple times and have the answer. You can experiment a lot with Python code in Jupyter

232
00:37:15,680 --> 00:37:22,680
Notebooks. When you're creating a Jupyter Notebook, you expect that the Jupyter Notebook

233
00:37:22,760 --> 00:37:29,760
will run smoothly to the end in a sequential way. You can experiment as well as the way

234
00:37:30,160 --> 00:37:37,160
you want, but you need to run everything sequentially at the end. So to run a cell, you can use this

235
00:37:40,360 --> 00:37:47,360
run right here. Are you able to see? So you have this button here to run. You have like

236
00:37:48,200 --> 00:37:55,200
you can move the cells. You can change the type of your cell. Code markdown is more used,

237
00:37:56,200 --> 00:38:03,200
but you also have other different types that we're going to discuss later. If you like

238
00:38:04,400 --> 00:38:11,400
to use shortcuts, all shortcuts of Jupyter Notebooks are listed here. This would be an

239
00:38:11,680 --> 00:38:16,360
exercise to create a Jupyter Notebook. Do you want to have about five minutes to try

240
00:38:16,360 --> 00:38:23,360
Jupyter Notebooks and its interface? Okay, let's move on. So there's a difference. This

241
00:38:24,360 --> 00:38:31,360
is the traditional UI for Jupyter Notebooks. It's called Notebook Classic, but the most

242
00:38:32,720 --> 00:38:39,720
popular one is JupyterLab. We're not going to use it for this tutorial because JupyterLab

243
00:38:39,720 --> 00:38:46,720
has more features that we want to use today. When you create a Jupyter Notebook file, it

244
00:38:46,720 --> 00:38:53,720
will create a file with this format, ipynb. ipynb stores like you can see very well, but

245
00:39:05,760 --> 00:39:12,760
it's a JSON file. IPy Notebooks are JSON files. They are stored like that. And as you can

246
00:39:13,760 --> 00:39:20,760
see, the code is here and the output of that code is also added here to the Jupyter Notebook.

247
00:39:22,920 --> 00:39:29,920
So once you run your notebook, it will keep the history of your running. After the Jupyter

248
00:39:30,720 --> 00:39:37,400
Notebook introduction, let's get to the main concept of this tutorial. That's NBDEV. It's

249
00:39:37,400 --> 00:39:44,000
a library that allows you to publish Python packaging, just like the publishments that

250
00:39:44,000 --> 00:39:51,000
we made previously. Jupyter Notebooks using NBDEV allows you to use GitHub actions to

251
00:39:52,120 --> 00:39:58,720
publish and to run your Jupyter Notebooks. You're going to have a documentation from

252
00:39:58,720 --> 00:40:05,720
your Jupyter Notebook using this Quarto software. You'll be able to upload your deck on PyPI

253
00:40:06,480 --> 00:40:13,480
or test PyPI, and you'll also be able to upload your package to the Anaconda repository. That's

254
00:40:13,720 --> 00:40:20,720
another repository where you can store your packages. So this is the part that you will

255
00:40:26,480 --> 00:40:33,480
fork my repository. Let me add to the terminal. So this is the part that you can fork my repository.

256
00:40:36,720 --> 00:40:43,720
You can fork this repository just to have on your machine, and you'll be able to use

257
00:40:46,600 --> 00:40:53,600
as a consultant a material later. We're not going to run this exercise, but it will help

258
00:40:54,800 --> 00:41:01,800
you to have this material later. So please go to this URL and fork the repository, please.

259
00:41:05,720 --> 00:41:12,720
It's outside in some other place than you created the previous. We will ignore the previously

260
00:41:25,560 --> 00:41:32,560
created tutorial, the previously created project. So you're going to access this repository

261
00:41:36,080 --> 00:41:43,080
right here, and you're going to click on fork right here. We're forking because later we're

262
00:41:43,400 --> 00:41:49,080
going to publish these packages using GitHub actions.

263
00:41:49,080 --> 00:41:56,080
So okay, after forking the repository, we're going to do some exercise later if we have

264
00:41:57,840 --> 00:42:04,840
time, but I want to show you how NBDEV distributes its packages. So this is the part that you

265
00:42:05,860 --> 00:42:12,860
want to focus on how it works. How it processes its folder and its structure and how it works.

266
00:42:16,840 --> 00:42:23,840
So when you create an NBDEV project, it will create this NBS folder where you start all

267
00:42:24,000 --> 00:42:31,000
of your pattern notebooks and will also create some metadata files like NBDEV, IMOML. The

268
00:42:35,720 --> 00:42:37,840
It will be created.

269
00:42:37,840 --> 00:42:46,280
It will create as well a GitHub workflow with the workflows that you need to use with GitHub

270
00:42:46,280 --> 00:42:48,600
actions, okay?

271
00:42:48,600 --> 00:42:51,560
And we'll create this settings.ini.

272
00:42:51,560 --> 00:42:57,500
If you upload your package to testpipel, you're going to see that it's missing a lot of information.

273
00:42:57,500 --> 00:43:00,560
That's because it was a minimal example.

274
00:43:00,560 --> 00:43:10,040
But when you're using NBDEV, all metadata is available here in settings.ini.

275
00:43:10,040 --> 00:43:15,160
So then your name, the description of the package, the version, everything's there.

276
00:43:15,160 --> 00:43:18,080
And it also creates this setup.py.

277
00:43:18,080 --> 00:43:20,280
That's a more fancy setup.py.

278
00:43:20,280 --> 00:43:25,680
It's licensing and everything and requirements.

279
00:43:25,680 --> 00:43:32,320
So here on my settings.ini, I created a package, a French DAQ package that doesn't have any

280
00:43:32,320 --> 00:43:38,240
requirement like you're going to install only the French DAQ package, but it has a lot of

281
00:43:38,240 --> 00:43:39,680
dev requirements.

282
00:43:39,680 --> 00:43:53,740
So it has some keyway tools, some test tools, some things that I'm going to explain later.

283
00:43:53,740 --> 00:44:02,860
So this is what NBDEV creates on your machine when you created an NBDEV package.

284
00:44:02,860 --> 00:44:08,100
Let me show here how to execute.

285
00:44:08,100 --> 00:44:12,060
Like when you install NBDEV, it's a CLI tool.

286
00:44:12,060 --> 00:44:19,680
So it has a lot of features.

287
00:44:19,780 --> 00:44:24,780
The main features of NBDEV, it's cleaning your Jupyter notebooks because when you run

288
00:44:24,780 --> 00:44:29,380
your Jupyter notebooks, all metadata is stored there.

289
00:44:29,380 --> 00:44:35,160
And when you're uploading your Jupyter notebooks to GitHub, you want them clean.

290
00:44:35,160 --> 00:44:39,180
And we felt that those outputs.

291
00:44:39,180 --> 00:44:44,780
You also have the NBDEV docs that create your documentation from your Jupyter notebooks.

292
00:44:45,180 --> 00:44:52,680
NBDEV export that export your Python packages from the Jupyter notebooks.

293
00:44:52,680 --> 00:44:57,780
NBDEV install hooks for a Githy-friendly usage of NBDEV.

294
00:44:57,780 --> 00:45:03,780
Like if you have git conflicts with your Jupyter notebooks, NBDEV will handle that for you.

295
00:45:03,780 --> 00:45:05,860
NBDEV install quarto.

296
00:45:05,860 --> 00:45:11,780
If you don't have quarto on your computer, you can still use their CLI.

297
00:45:12,580 --> 00:45:14,780
NBDEV PyPI to upload to PyPI.

298
00:45:14,780 --> 00:45:17,080
NBDEV Conda to upload to Conda.

299
00:45:17,080 --> 00:45:21,980
And NBDEV prepare both.

300
00:45:21,980 --> 00:45:23,980
That's somewhere here.

301
00:45:23,980 --> 00:45:25,780
That will upload on Conda.

302
00:45:25,780 --> 00:45:27,580
Yeah, NBDEV release both.

303
00:45:27,580 --> 00:45:32,580
That will upload on Conda and PyPI.

304
00:45:32,580 --> 00:45:34,980
So NBDEV is a CLI tool.

305
00:45:34,980 --> 00:45:41,580
When you have your Jupyter notebooks, it will be able to export as a code and a Python.

306
00:45:42,780 --> 00:45:44,680
A Python package.

307
00:45:44,680 --> 00:45:52,880
So when you have a Jupyter notebooks, you're using NBDEV magic comments to create your

308
00:45:52,880 --> 00:45:54,580
Python packaging.

309
00:45:54,580 --> 00:45:55,580
For example.

310
00:46:01,880 --> 00:46:06,480
This is a Jupyter notebook that uses NBDEV.

311
00:46:06,480 --> 00:46:10,780
This default exp, it says the name of my file.

312
00:46:10,780 --> 00:46:12,580
That's core.

313
00:46:12,580 --> 00:46:15,980
I'm describing the module that I'm developing here.

314
00:46:15,980 --> 00:46:23,280
It's a deck, a French deck module inspired by fluent Python book.

315
00:46:23,280 --> 00:46:27,080
You're exporting your imports.

316
00:46:27,080 --> 00:46:30,480
This will be added to the core file.

317
00:46:30,480 --> 00:46:33,380
You're hiding this from the documentation.

318
00:46:33,480 --> 00:46:40,680
So the hide is used like if you don't need to export your imports to the documentation,

319
00:46:40,680 --> 00:46:42,880
you can hide them.

320
00:46:42,880 --> 00:46:47,680
So I'm explaining some features from the core.

321
00:46:47,680 --> 00:46:51,380
It's a module.

322
00:46:51,380 --> 00:46:53,280
Let me run here.

323
00:46:53,280 --> 00:46:56,080
So I'm creating a core file.

324
00:46:56,080 --> 00:46:58,580
I'm exporting this to my file.

325
00:46:58,580 --> 00:47:02,280
I'm hiding this from the documentation.

326
00:47:02,380 --> 00:47:06,380
I'm exporting the card definition.

327
00:47:06,380 --> 00:47:12,180
It's a card that contains a rank and a suite property.

328
00:47:12,180 --> 00:47:17,680
I'm executing this example on my documentation.

329
00:47:17,680 --> 00:47:22,980
So this output right here will be added to my documentation.

330
00:47:22,980 --> 00:47:26,580
I'm explaining the French deck and how it works right here.

331
00:47:32,280 --> 00:47:40,780
Yeah, so export i.

332
00:47:40,780 --> 00:47:47,380
The difference is because it will export without the API.

333
00:47:47,380 --> 00:47:48,880
Let me show you.

334
00:47:54,380 --> 00:47:57,880
I will show the exported code.

335
00:47:57,880 --> 00:48:04,180
So this is the core file that will be exported from the Jupyter Notebook.

336
00:48:04,180 --> 00:48:09,980
So you will be able to see the exports right here.

337
00:48:09,980 --> 00:48:19,980
But if I run my documentation, it will not be able to see there.

338
00:48:19,980 --> 00:48:21,780
Like this is my deck.

339
00:48:21,780 --> 00:48:25,580
This is the documentation generated from the Jupyter Notebook.

340
00:48:25,680 --> 00:48:29,280
So it has the title, the description.

341
00:48:29,280 --> 00:48:36,680
I'm exporting the imports, but it's not in the documentation.

342
00:48:36,680 --> 00:48:41,480
And like from this example, this is something I'm running on the Jupyter Notebooks, but

343
00:48:41,480 --> 00:48:43,380
it's not necessarily on my package.

344
00:48:43,380 --> 00:48:48,080
So I'm hiding from the documentation as well.

345
00:48:48,080 --> 00:48:54,680
So this is executing this code on the documentation because it's not executed by default because

346
00:48:55,180 --> 00:48:58,980
we don't want to see these outputs on the documentation.

347
00:49:02,180 --> 00:49:06,980
There's a lot of explanations about what is the French deck, how it works.

348
00:49:06,980 --> 00:49:10,880
It's a 52 cards split in four suits.

349
00:49:10,880 --> 00:49:14,980
It's the most common deck card you know.

350
00:49:14,980 --> 00:49:20,980
So this example is almost the same used by the Python fluent code.

351
00:49:20,980 --> 00:49:25,680
I only changed the G key K.

352
00:49:25,680 --> 00:49:27,780
It used strings before.

353
00:49:27,780 --> 00:49:29,980
It's using only integers now.

354
00:49:31,980 --> 00:49:36,780
And I'm using, I'm exporting and I'm hiding this code on the documentation right here.

355
00:49:39,280 --> 00:49:43,580
So you can see the code, but it's collapsed.

356
00:49:43,580 --> 00:49:53,980
This right here is a callout node from the quarto.

357
00:49:53,980 --> 00:50:01,280
So we are able to see incremental documentation using some quarto features.

358
00:50:01,280 --> 00:50:06,580
I'm going to talk about quarto later.

359
00:50:06,580 --> 00:50:09,680
So this is executed on the documentation.

360
00:50:09,680 --> 00:50:10,780
I'm hiding them.

361
00:50:10,880 --> 00:50:12,980
I'm executing the documentation.

362
00:50:14,380 --> 00:50:21,280
So these are the most important NBDEF calls when you're writing a Jupyter Notebook.

363
00:50:21,280 --> 00:50:24,180
You're using hide to hide from the documentation.

364
00:50:24,180 --> 00:50:30,780
Export to export your Jupyter Notebook code to your Python packages.

365
00:50:30,780 --> 00:50:38,080
Using export I to hide from the documentation but export the code to your Python package.

366
00:50:38,080 --> 00:50:42,380
Exec.doc for execution of the documentation, code fold.

367
00:50:42,380 --> 00:50:49,980
The default exp to export the NBDEF file to Python files.

368
00:50:49,980 --> 00:50:57,780
And evolve false because sometimes we are running tests on our Jupyter Notebooks and

369
00:50:57,780 --> 00:51:01,180
we don't want to evaluate all the tests.

370
00:51:01,280 --> 00:51:12,080
So we can ignore some tests like this is a test that NBDEF runs and you can evaluate false.

371
00:51:12,080 --> 00:51:16,480
We're going to discuss NBDEF tests later in this tutorial.

372
00:51:16,480 --> 00:51:27,780
But using the keyword and some dummy tests you can run simple tests on your cells.

373
00:51:27,880 --> 00:51:37,180
And some projects that are used by NBDEF that build their packages using the NBDEF CLI tool.

374
00:51:37,180 --> 00:51:40,280
The most well-known is Fast.ai.

375
00:51:40,280 --> 00:51:45,480
It's the project that builds the NBDEF tool.

376
00:51:45,480 --> 00:51:52,680
Ipy annotator is the package I developed with PyLimon.

377
00:51:52,680 --> 00:51:56,880
We work with NBDEF since its first version.

378
00:51:56,880 --> 00:52:05,180
This was the documentation, the interface that it was used by NBDEF in the first version.

379
00:52:05,180 --> 00:52:08,780
And this is the last version of NBDEF UI.

380
00:52:08,780 --> 00:52:15,880
Ipy annotator is a very visual framework for annotation.

381
00:52:15,880 --> 00:52:19,180
So you can annotate your data.

382
00:52:19,180 --> 00:52:21,780
Let me just show some example here.

383
00:52:21,880 --> 00:52:26,780
NBDEF is awesome when you have this visual.

384
00:52:26,780 --> 00:52:28,580
You need to show something.

385
00:52:28,580 --> 00:52:30,980
Okay, this tutorial is better.

386
00:52:30,980 --> 00:52:36,480
We need to show rich elements on your documentation.

387
00:52:36,480 --> 00:52:42,080
So you can annotate things using Ipy annotator.

388
00:52:42,080 --> 00:52:46,480
And we're using NBDEF to build our package.

389
00:52:46,580 --> 00:52:53,480
And this package was only able to be developed by NBDEF

390
00:52:53,480 --> 00:52:56,380
because it runs over Jupyter notebooks.

391
00:52:56,380 --> 00:53:00,980
Like, it's an UI that works only on Jupyter notebooks.

392
00:53:00,980 --> 00:53:06,080
So NBDEF allows us to develop a Ipy annotator.

393
00:53:06,080 --> 00:53:12,280
These are other awesome projects that you can search later.

394
00:53:12,280 --> 00:53:19,080
So what are the good practices when developing Jupyter notebooks and using NBDEF?

395
00:53:20,880 --> 00:53:26,480
So it's not showing the image right here.

396
00:53:26,480 --> 00:53:29,080
Let me show you very quickly.

397
00:53:30,580 --> 00:53:35,380
When you're developing documentation for your software,

398
00:53:35,380 --> 00:53:42,880
there's a lot of methodologies that you can use.

399
00:53:46,480 --> 00:53:52,180
And the one that's recommended by NBDEF is the DATX system.

400
00:53:52,180 --> 00:53:54,680
So when you're developing your documentation,

401
00:53:54,680 --> 00:53:58,580
you can choose what type of documentation you're developing.

402
00:53:58,680 --> 00:54:03,280
If it's a tutorial that's learning-orientated,

403
00:54:03,280 --> 00:54:05,480
or if you're explaining a concept,

404
00:54:05,480 --> 00:54:11,380
you're going to create your Jupyter notebook only to explain a concept.

405
00:54:11,380 --> 00:54:16,180
A reference, like you have your API, your Jupyter note, your package.

406
00:54:16,180 --> 00:54:19,180
And like my package, shuffle cards.

407
00:54:19,180 --> 00:54:23,780
I have a card, I have a deck, and I want to shuffle the deck.

408
00:54:23,780 --> 00:54:27,380
So I put this information as a reference.

409
00:54:27,380 --> 00:54:30,680
Like you can use this function shuffle to shuffle the deck.

410
00:54:30,680 --> 00:54:33,480
So it's a reference to Jupyter notebook.

411
00:54:33,480 --> 00:54:38,480
And how to guide that problem-oriented Jupyter notebooks.

412
00:54:38,480 --> 00:54:44,380
This is the way that NBDEF suggests you to use the DATX system.

413
00:54:44,380 --> 00:54:48,780
So when you're starting a Jupyter notebook, the best practice is...

414
00:54:48,780 --> 00:54:49,680
Okay.

415
00:54:50,280 --> 00:54:51,280
What?

416
00:54:55,780 --> 00:55:01,780
Yeah, you have multiple methodologies to build your documentation.

417
00:55:01,780 --> 00:55:06,980
And this DATX system is a way to develop your documentation.

418
00:55:06,980 --> 00:55:12,380
It's not the only way, but it's recommended by NBDEF to use this approach.

419
00:55:19,680 --> 00:55:34,080
No, it's like the DATX system is a way to develop your documentation.

420
00:55:34,080 --> 00:55:42,880
Like it's not developed through NBDEF or NBDEF only works with this methodology.

421
00:55:42,880 --> 00:55:47,780
But it's a methodology to you write your documentation.

422
00:55:47,780 --> 00:55:48,780
Okay?

423
00:55:50,380 --> 00:55:55,580
So this is something I already show you to you guys.

424
00:55:55,580 --> 00:56:01,580
When you're creating Jupyter notebooks, you want to have a good title and a good description.

425
00:56:01,580 --> 00:56:03,980
You can use quarto as well.

426
00:56:03,980 --> 00:56:10,180
Remember I show you the cell types on Jupyter notebooks.

427
00:56:11,180 --> 00:56:21,180
Like you have markdown and you have code, but you also have raw NBDE convert.

428
00:56:21,180 --> 00:56:27,180
This is a metadata that you can use to increment your documentation using quarto features.

429
00:56:27,180 --> 00:56:37,180
So if you want to use quarto, you can just change your cell type to raw and run quarto commands on here.

430
00:56:38,180 --> 00:56:40,180
Okay.

431
00:56:45,180 --> 00:56:49,180
So change the text of your Jupyter notebook according to the DATX system.

432
00:56:49,180 --> 00:56:55,180
So if you're writing a reference, you start with a small description and use symbolic symbols

433
00:56:55,180 --> 00:57:04,180
because everyone is assessing your documentation to see which features from your package are going to be used.

434
00:57:04,180 --> 00:57:12,180
You can write tutorials and guides and use Jupyter notebooks to describe what the reader will learn and be objective.

435
00:57:12,180 --> 00:57:20,180
And you can write explanations to Jupyter notebooks to introduce some concept for the readers.

436
00:57:20,180 --> 00:57:28,180
And Jupyter notebooks are awesome because they have a very interactive and fancy way to use images, videos,

437
00:57:28,180 --> 00:57:36,180
audio and use multiple visualizations. So this is awesome if you're publishing a Python package that uses visualizations.

438
00:57:36,180 --> 00:57:44,180
Another thing, when you're using Jupyter notebooks, you want to keep your cells very small.

439
00:57:44,180 --> 00:57:50,180
So this is a cell and you don't want to have a huge cell.

440
00:57:50,180 --> 00:58:06,180
And to avoid big cells, NBDEV has this feature called Patches where you can add in runtime patches to your code.

441
00:58:06,180 --> 00:58:10,180
For example, here I have the French Jack definition.

442
00:58:10,180 --> 00:58:22,180
It has a lot of Python Dundermats for Unity to have a size of your French Jack to get a card from your French Jack.

443
00:58:22,180 --> 00:58:32,180
But you have some additional functions like shuffle and you can use this to avoid writing a big cell.

444
00:58:32,180 --> 00:58:40,180
Because previously this class would be huge with some additional functions.

445
00:58:40,180 --> 00:58:48,180
And using Patches, you can describe and use better your Jupyter notebooks and keep it readable.

446
00:58:48,180 --> 00:59:00,180
So when you're using Jupyter notebooks, you want to import your code at the top of your Jupyter notebook.

447
00:59:00,180 --> 00:59:06,180
You don't want to import and execute Python code on the same cell like this.

448
00:59:06,180 --> 00:59:14,180
Because you're loading everything and also running Python code is not a good practice.

449
00:59:14,180 --> 00:59:23,180
Avoid ambiguous execution order. So sometimes, as I said before, you can run this cell here and run this cell above.

450
00:59:23,180 --> 00:59:31,180
But at the end, you want a sequentially executable Jupyter notebook.

451
00:59:31,180 --> 00:59:42,180
Use code cells for experiments. For example, when I show this output right here,

452
00:59:42,180 --> 00:59:50,180
sometimes you're running experiments on Jupyter notebooks and you want everyone to know what the output is.

453
00:59:50,180 --> 01:00:02,180
So you can execute this experimentation and show other developers, okay, this outputs this and other stuff on Jupyter notebooks.

454
01:00:02,180 --> 01:00:08,180
So don't avoid code execution and output if you need it.

455
01:00:08,180 --> 01:00:20,180
So documentation of parameters. When you're using the data access system, sometimes you're developing the reference

456
01:00:20,180 --> 01:00:26,180
and you want to have documentation of the parameters you're using.

457
01:00:26,180 --> 01:00:32,180
So NBDef supports the two types of documentation of parameters.

458
01:00:32,180 --> 01:00:38,180
The first one is NumPy style. This is the classic one we're using in Python.

459
01:00:38,180 --> 01:00:46,180
So you have the comment of your function, the parameters, the type of the parameters, and the description of the parameters.

460
01:00:46,180 --> 01:00:55,180
And when you're executing your code, you output something like this, where you have, okay, I have this function, addNP.

461
01:00:55,180 --> 01:01:01,180
That's some still numbers. But NBDef also allows what they call documents.

462
01:01:01,180 --> 01:01:08,180
That's a way to have a very direct comment on your documentation.

463
01:01:08,180 --> 01:01:16,180
So it outputs the same thing, but using less code, and it's very readable.

464
01:01:16,180 --> 01:01:22,180
And another good practice when you're developing Jupyter notebooks, it's adding tests.

465
01:01:22,180 --> 01:01:31,180
So we keep the cells small so we can run tests very specific for our features on Jupyter notebooks.

466
01:01:31,180 --> 01:01:45,180
So using assert and running NBDef tests, you're able to execute the code from your Jupyter notebook and execute the tests.

467
01:01:45,180 --> 01:02:02,180
So everything's passing here right now, but if I add a keyword like NBDef is through the error.

468
01:02:02,180 --> 01:02:11,180
So this is used by CI and used by your day-to-day development to run tests.

469
01:02:11,180 --> 01:02:21,180
And this is another exercise where we're going to create a Jupyter notebook on this structure that you forked.

470
01:02:21,180 --> 01:02:32,180
But we're going to move on right now, and we're going to get back to this exercise later.

471
01:02:32,180 --> 01:02:42,180
So here I show you the deck definition. We have a French deck definition and we have the card definition.

472
01:02:42,180 --> 01:02:56,180
And the way this exercise would create a Jupyter notebook card called card-utils, it would export a card-utils to our package.

473
01:02:56,180 --> 01:02:59,180
Yeah, but we're going to ignore this for now.

474
01:02:59,180 --> 01:03:04,180
Let's talk about dependency hell that we were talking before.

475
01:03:04,180 --> 01:03:16,180
So dependency, when you're developing a Python package, you want to avoid conflicts between the dependencies of the packages.

476
01:03:16,180 --> 01:03:21,180
So when a software grows, they tend to add more Python packages, and they are awesome.

477
01:03:21,180 --> 01:03:27,180
They can add features, they can avoid and fix errors and provide more security.

478
01:03:27,180 --> 01:03:32,180
But keeping them updated and moving forward with our software is tricky.

479
01:03:32,180 --> 01:03:43,180
So sometimes one dependency expects a certain requirement and another dependency requires a different requirement like this.

480
01:03:43,180 --> 01:03:50,180
Dependency one expects Python 3.7 and dependency one expects Python 3.9.

481
01:03:50,180 --> 01:04:00,180
So it will have a conflict and sometimes you need to update your package, but you can't because a package you're using doesn't allow that update.

482
01:04:00,180 --> 01:04:05,180
So to avoid this, you're going to specify your dependencies.

483
01:04:05,180 --> 01:04:15,180
So nbdev has that setting.ini that I showed you previously.

484
01:04:15,180 --> 01:04:27,180
I hope you can see.

485
01:04:27,180 --> 01:04:29,180
Can you see?

486
01:04:29,180 --> 01:04:30,180
Okay.

487
01:04:30,180 --> 01:04:34,180
So you can add your requirements here.

488
01:04:34,180 --> 01:04:42,180
So these requirements would be installed by everyone that installs your packages, and the dev requirements is only for developers.

489
01:04:42,180 --> 01:04:52,180
So when you're specifying equals equals, you're fixing a certain version of the requirement you're installing.

490
01:04:52,180 --> 01:04:59,180
But when you're using this, you're specifying some release of the software.

491
01:04:59,180 --> 01:05:01,180
This you're excluding a version.

492
01:05:01,180 --> 01:05:04,180
This you're including a range of versions.

493
01:05:04,180 --> 01:05:06,180
This is the most recommended way.

494
01:05:06,180 --> 01:05:08,180
This is true.

495
01:05:08,180 --> 01:05:20,180
So anyone with the black requirement from 23.1 to the next releases can execute my code.

496
01:05:20,180 --> 01:05:23,180
This is a way to avoid dependency hell.

497
01:05:23,180 --> 01:05:27,180
So when you're creating a Python package, you're creating releases.

498
01:05:27,180 --> 01:05:34,180
Remember the version that we add to our software to the minimal package we publish.

499
01:05:34,180 --> 01:05:39,180
So the version has a standard way to be added.

500
01:05:39,180 --> 01:05:41,180
It's called semantic version.

501
01:05:41,180 --> 01:05:45,180
It's a set of rules that help us to avoid dependency hell.

502
01:05:45,180 --> 01:05:51,180
So you must declare a public API like you are having some features on your Python packages.

503
01:05:51,180 --> 01:05:57,180
You need this API so everyone can work with your Python package.

504
01:05:57,180 --> 01:06:05,180
The version should use this format XAZ and should use non-negative numbers.

505
01:06:05,180 --> 01:06:09,180
And you're using usually this major minor path.

506
01:06:09,180 --> 01:06:17,180
So our version, our first version of the Python packages, we're using 001, right?

507
01:06:17,180 --> 01:06:21,180
So we don't have a stable Python package yet.

508
01:06:21,180 --> 01:06:25,180
We don't have minor update on your Python packages.

509
01:06:25,180 --> 01:06:28,180
And we only have a simple addition of code.

510
01:06:28,180 --> 01:06:36,180
So this is what we call semantic version to release packages in Python.

511
01:06:36,180 --> 01:06:43,180
But only releasing the Python packages is not enough so humans can understand what was released.

512
01:06:43,180 --> 01:06:53,180
So always keep a file called changelog that is a semantic version, didactic way for humans to read and understand.

513
01:06:53,180 --> 01:07:01,180
For example, we have that first version but we released version 002.

514
01:07:01,180 --> 01:07:11,180
So we're going to add to the changelog what we did on the package and what we want to do in the future if you want to do something.

515
01:07:11,180 --> 01:07:14,180
So let me show you.

516
01:07:14,180 --> 01:07:18,180
Change log.

517
01:07:18,180 --> 01:07:21,180
So it uses this structure.

518
01:07:21,180 --> 01:07:25,180
It has a documentation site, this one.

519
01:07:25,180 --> 01:07:40,180
It uses the semantic version standard and uses this markdown style where you can put unreleased features of your package.

520
01:07:40,180 --> 01:07:47,180
For example, you want to add a new feature like draw a card from the deck.

521
01:07:47,180 --> 01:07:54,180
So you add here that next release will add this feature.

522
01:07:54,180 --> 01:08:05,180
And when you're releasing a new version, you're adding a date and what you did in topics usually.

523
01:08:05,180 --> 01:08:06,180
Okay.

524
01:08:06,180 --> 01:08:21,180
So we already discussed how to publish, how to load Python packages, how NBDEV exports the Python code and the HTML to the documentation.

525
01:08:21,180 --> 01:08:26,180
We also discussed how to create semantic version releases.

526
01:08:26,180 --> 01:08:33,180
Now let's talk about tools that can improve our Python package code.

527
01:08:33,180 --> 01:08:39,180
So Python has a lot of tools that help us to develop better Python projects.

528
01:08:39,180 --> 01:08:44,180
And most of them don't run over Jupyter notebooks.

529
01:08:44,180 --> 01:08:54,180
But we have this package called NBQA where you can use the most popular tools on Jupyter notebooks.

530
01:08:54,180 --> 01:09:05,180
So the most popular tools used on NBQA are AutoPep8, Black, Flake8, MyPy, and iSort.

531
01:09:05,180 --> 01:09:12,180
And all of them can be executed using NBQA.

532
01:09:12,180 --> 01:09:24,180
MyPy is the tool that will analyze our Python code and check if it has type issues.

533
01:09:24,180 --> 01:09:30,180
For example, previously we usually had the NumPy style documentation.

534
01:09:30,180 --> 01:09:36,180
And nothing guarantees that this X and this Y would be integers.

535
01:09:36,180 --> 01:09:43,180
But MyPy does that if you're adding these type annotations to your code.

536
01:09:43,180 --> 01:09:52,180
So to run MyPy over Jupyter notebooks, you can specify the tool using NBQA,

537
01:09:52,180 --> 01:10:00,180
execute it on Jupyter notebooks, and ignore missing parts from external packages.

538
01:10:00,180 --> 01:10:05,180
Another popular tool for quality assurance in Jupyter notebooks is Flake8.

539
01:10:05,180 --> 01:10:11,180
So sometimes you're arguing with your team about some code style on pull requests,

540
01:10:11,180 --> 01:10:19,180
and Flake8 can help you to define a way to code a code style.

541
01:10:19,180 --> 01:10:31,180
And this discussion will be not done on pull requests again because it's specified on AutoPep file.

542
01:10:31,180 --> 01:10:39,180
So Flake8 also can check some errors.

543
01:10:39,180 --> 01:10:45,180
Like if you import something that is not used or some typo, Flake8 can help you with that.

544
01:10:45,180 --> 01:10:51,180
So it guarantees our quality assurance of the Python package we're writing.

545
01:10:51,180 --> 01:11:00,180
So Python has a PEP called PEP8 that defines the code style of your Python packages, of your Python code actually.

546
01:11:00,180 --> 01:11:05,180
And you can run using NBQA keyway as well.

547
01:11:05,180 --> 01:11:13,180
Flake is a more flexible way to run PEP8 on Jupyter notebooks or Python code in general.

548
01:11:13,180 --> 01:11:21,180
And advanced testing. Okay. So these are the most well-known quality assurance tools.

549
01:11:21,180 --> 01:11:28,180
And we're going to discuss how to use advanced testing in Jupyter notebooks.

550
01:11:28,180 --> 01:11:33,180
Let me show you here.

551
01:11:33,180 --> 01:11:48,180
When we are using only the assert, like when we are using the assert, we don't have the isolation the test requires.

552
01:11:48,180 --> 01:12:00,180
So if I change the size of the deck here, like if I draw a card, it will be 51, but this test will fail.

553
01:12:00,180 --> 01:12:07,180
And we want to isolate this test in the way that we do that is using IPyTest.

554
01:12:07,180 --> 01:12:19,180
It's a library that allows us to run tests, PyTest, that's the most popular framework.

555
01:12:19,180 --> 01:12:27,180
It's the most popular framework for Python code, but it doesn't run on Jupyter notebooks.

556
01:12:27,180 --> 01:12:35,180
So we can import IPyTest and run tests on our Jupyter notebooks.

557
01:12:35,180 --> 01:12:45,180
So here is that example where we can run, like we have this counter.

558
01:12:45,180 --> 01:12:54,180
It has an assertion and it works, but if we change here, this assertion will broke.

559
01:12:54,180 --> 01:13:03,180
But when we're using IPyTest, we use the magic cell IPyTest and we can execute the code.

560
01:13:03,180 --> 01:13:12,180
We can guarantee that the test will be isolated from the scope of your Jupyter notebook.

561
01:13:12,180 --> 01:13:27,180
So it's a great feature to have and a great way to name what you are testing.

562
01:13:27,180 --> 01:13:43,180
Okay.

563
01:13:43,180 --> 01:13:49,180
Okay. So we discussed quality assurance tools for our Python packages.

564
01:13:49,180 --> 01:13:53,180
We discussed testing for our Python packages.

565
01:13:53,180 --> 01:14:12,180
And now, okay.

566
01:14:12,180 --> 01:14:17,180
Yeah, so this is a discussion from software engineers, software engineering.

567
01:14:17,180 --> 01:14:23,180
Some people like to have the test folder separated, write tests outside of your code.

568
01:14:23,180 --> 01:14:30,180
But when you're using Jupyter notebooks, you want to integrate your tests on the Jupyter notebooks.

569
01:14:30,180 --> 01:14:38,180
So you keep your cells small so you can test a very specific code of your Python package.

570
01:14:38,180 --> 01:14:48,180
So mixing code, tests, and documentation keeps your file readable to any developers to understand what is happening.

571
01:14:48,180 --> 01:14:57,180
So it's also a good practice to, if you're testing something visual, output that test to the documentation.

572
01:14:57,180 --> 01:15:00,180
Okay.

573
01:15:00,180 --> 01:15:08,180
So now I think we can do one of the exercises.

574
01:15:08,180 --> 01:15:11,180
Okay.

575
01:15:11,180 --> 01:15:14,180
Let me just see. Yeah.

576
01:15:14,180 --> 01:15:21,180
I'm going to introduce some concepts before we do another exercise because the idea was publish the minimal package

577
01:15:21,180 --> 01:15:26,180
and then publish the package that you forked from my repository.

578
01:15:26,180 --> 01:15:35,180
So I'm going to introduce some concepts of CI-CD before we do that exercise.

579
01:15:35,180 --> 01:15:48,180
So CI-CD is a way that we integrate, like we're developing our package on our machine, on our local machine.

580
01:15:48,180 --> 01:15:52,180
But we want to guarantee the delivery of the software.

581
01:15:52,180 --> 01:16:02,180
So we increase the version and change their code, but we want to guarantee that the tests are executed and the code style is being followed.

582
01:16:02,180 --> 01:16:05,180
So CI-CD is a way to do that.

583
01:16:05,180 --> 01:16:09,180
It's called continuous integration, continuous delivery.

584
01:16:09,180 --> 01:16:18,180
So it's a well-known concept in DevOps, but it became more accessible to developers thanks to GitHub actions and other tools.

585
01:16:18,180 --> 01:16:22,180
So it automates some stages of the app development.

586
01:16:22,180 --> 01:16:28,180
It enforces security when we're delivering new versions of the Python packages.

587
01:16:28,180 --> 01:16:34,180
So you may not be able to see the image, but you have the CI and the CD.

588
01:16:34,180 --> 01:16:38,180
You're building your package on the CI.

589
01:16:38,180 --> 01:16:48,180
You're testing your code on the CI and you're merging your version, like you're merging the release on your main branch.

590
01:16:48,180 --> 01:17:00,180
This will automatically release, and a release for Python packages is creating a new release on PyPI or test PyPI that will be automatically deployed.

591
01:17:00,180 --> 01:17:10,180
Like it will upload our documentation to GitHub pages or some other place.

592
01:17:10,180 --> 01:17:18,180
Some tools that we can run CI-CD are GitHub actions, GitLab CI-CD, Jenkins, CircuCI.

593
01:17:18,180 --> 01:17:21,180
And we're using GitHub actions because it's easy to use.

594
01:17:21,180 --> 01:17:24,180
It's free until 22,000 minutes.

595
01:17:24,180 --> 01:17:27,180
And it's very easy to use.

596
01:17:27,180 --> 01:17:35,180
Most tools have some integration with it, and BDEV also have integrations with GitHub actions.

597
01:17:35,180 --> 01:17:43,180
The core concepts of GitHub actions is these four events, jobs, actions, and runner.

598
01:17:43,180 --> 01:17:50,180
So when you're creating a commit to your GitHub account, it's dispatching an event.

599
01:17:50,180 --> 01:17:53,180
It's triggering an event.

600
01:17:53,180 --> 01:18:00,180
So this event can be listed and executed by a sequence of steps that's called jobs.

601
01:18:00,180 --> 01:18:10,180
So, for example, we're releasing our packages to the second version, and it will be listed as an event.

602
01:18:10,180 --> 01:18:20,180
It will execute the jobs that we run, the tests, the quality assurance tools, and it will publish our package on test PyPI.

603
01:18:20,180 --> 01:18:24,180
And it will publish our documentation.

604
01:18:24,180 --> 01:18:29,180
Another concept from GitHub actions are the actions itself.

605
01:18:29,180 --> 01:18:36,180
It's a way to avoid developing lots of code in GitHub action files.

606
01:18:36,180 --> 01:18:41,180
Let me show you real quickly here.

607
01:18:41,180 --> 01:18:50,180
So you develop GitHub actions in this GitHub file, in this workflow subfolder.

608
01:18:50,180 --> 01:19:01,180
And, for example, you have this publish file.

609
01:19:01,180 --> 01:19:06,180
So we have the name. It will list into releases.

610
01:19:06,180 --> 01:19:10,180
So every time I release a package, it will be published at the test PyPI.

611
01:19:10,180 --> 01:19:19,180
This is something that we did manually, but now it can run automatically every time we release on GitHub.

612
01:19:19,180 --> 01:19:27,180
So it will run all these steps, and it uses this action to set up Python.

613
01:19:27,180 --> 01:19:36,180
So install Python on your GitHub actions is a very common feature that we need.

614
01:19:36,180 --> 01:19:43,180
So the Python organization can create an action, and you can just use the code.

615
01:19:43,180 --> 01:19:45,180
This is what actions is.

616
01:19:45,180 --> 01:19:52,180
And runner is the server, is the GitHub server that executed the workflows.

617
01:19:52,180 --> 01:19:58,180
So here in this project, I created four workflows, one for publishing in test PyPI,

618
01:19:58,180 --> 01:20:10,180
another for checking the quality assurance of our Python packages, running, I think it was mypy, Flick 8 on the Jupyter Notebooks.

619
01:20:10,180 --> 01:20:20,180
It will deploy the pages to GitHub pages, and it will also run.

620
01:20:20,180 --> 01:20:32,180
So it listens. Every time I made a commit or pull request or push anything to GitHub, the test will be executed.

621
01:20:32,180 --> 01:20:40,180
So I think before advancing, it will be nice to...

622
01:20:40,180 --> 01:20:49,180
This is why we forked the project. It's to publish that code on our test PyPI account.

623
01:20:49,180 --> 01:20:54,180
So let's back to the exercise.

624
01:20:54,180 --> 01:21:03,180
I think we have... maybe we have time. It needs to be quickly.

625
01:21:03,180 --> 01:21:24,180
So in the forked folder that you made, you can access there and create a new virtual environment for that using Python,

626
01:21:24,180 --> 01:21:33,180
Python, less mvm, the tutorial name. Can you see you guys?

627
01:21:33,180 --> 01:21:43,180
So you can access the fork. You can clone the fork you made and create a virtual environment there.

628
01:21:43,180 --> 01:22:00,180
So you can come here and clone your fork, right? Like go to someplace else and clone your fork.

629
01:22:00,180 --> 01:22:25,180
To clone your fork, you can access here the fork that you made and just copy the 880p or SSH and clone on your terminal.

630
01:22:25,180 --> 01:22:39,180
Yeah, you already cloned your fork on your machine. So now you create a virtual environment, a new virtual environment, and activate it.

631
01:22:39,180 --> 01:22:45,180
So this is the sequential steps that we need to make to install the dependencies.

632
01:22:45,180 --> 01:22:54,180
So you can use pip install dot and this command right here to install the development tools.

633
01:22:54,180 --> 01:23:06,180
But if you're on a Windows machine, the readme also has all packages listed as pip install.

634
01:23:06,180 --> 01:23:15,180
So you can also run this instead of this.

635
01:23:15,180 --> 01:23:24,180
Guys, so when you're naming your package on Windows machines, you're running on some issues.

636
01:23:24,180 --> 01:23:32,180
I'm not sure why. On Linux, it works well, but it may be the different file.

637
01:23:32,180 --> 01:23:41,180
I don't know because I wrote on a Linux file, but Microsoft's not reading the file.

638
01:23:41,180 --> 01:23:56,180
I create this script because it's like very painful to change the name of the package because you need to change all imports on every Jupyter Notebook.

639
01:23:56,180 --> 01:24:06,180
For example, I'm using here like the name of my package is it-apiphone-deck and you need to change everything here.

640
01:24:06,180 --> 01:24:19,180
But if you're not able to accomplish that, we're going to move on from this exercise because you need to change everything with your username,

641
01:24:19,180 --> 01:24:36,180
and if you're using the same deck on every Jupyter Notebook, you need to change this folder for your username as well.

642
01:24:36,180 --> 01:24:50,180
So I think we're going to move on from the exercise and get back to the theory of NBDAV.

643
01:24:50,180 --> 01:24:57,180
I was not expecting this problem. Sorry.

644
01:24:57,180 --> 01:25:07,180
So the idea was to rename your NBDAV project and upload using GitHub Actions.

645
01:25:07,180 --> 01:25:14,180
You can see GitHub Actions being executed on your repository.

646
01:25:14,180 --> 01:25:26,180
When you have it set up, you can go here to Actions and you're going to be able to see that every time I commit or merge something on my code,

647
01:25:26,180 --> 01:25:37,180
it will run a pages-build deployment, a linked execution, deploy to GitHub pages, and tests.

648
01:25:37,180 --> 01:25:43,180
I'm going to update my script later to fix this bug so everyone can do this exercise.

649
01:25:43,180 --> 01:25:53,180
The idea was to publish this documentation on your GitHub account.

650
01:25:53,180 --> 01:26:00,180
That's why we forked the repository. Sorry about that.

651
01:26:00,180 --> 01:26:10,180
Let's move on with the theory behind NBDAV.

652
01:26:10,180 --> 01:26:22,180
What?

653
01:26:22,180 --> 01:26:30,180
So let's move on from the exercise since it has some problems with the Windows machines.

654
01:26:30,180 --> 01:26:43,180
To upload anything to the PyPI using NBDAV, you can use NBDAV PyPI and NBDAV Conda, and NBDAV Reliefs both to publish on Conda on PyPI.

655
01:26:43,180 --> 01:26:55,180
If you're using test PyPI like we are, you can just add the repository to upload this code to your test PyPI account.

656
01:26:55,180 --> 01:27:08,180
If you don't like to put your password and username every time you're uploading something to test PyPI or PyPI,

657
01:27:08,180 --> 01:27:17,180
you can write your password to PyPI RC. It's a file that Python reads globally.

658
01:27:17,180 --> 01:27:23,180
But it's not recommended to add your username and password to that file.

659
01:27:23,180 --> 01:27:35,180
Usually we first upload the package manually like we did before, and then we go to test PyPI UI and create a token for our project.

660
01:27:35,180 --> 01:27:41,180
And then we rename the PyPI RC file.

661
01:27:41,180 --> 01:27:57,180
And if you're using other repositories than PyPI or test PyPI, you can create this private repository on the PyRC file and put the URL of the repository there.

662
01:27:57,180 --> 01:28:18,180
Remember, you can use GitLab or you can use AWS. AWS has a private repository, so you can use one of them.

663
01:28:18,180 --> 01:28:28,180
So I already showed you the workflows.

664
01:28:28,180 --> 01:28:41,180
So if you have your NB dev installed and running on your machine, you're going to be able to go to change.

665
01:28:41,180 --> 01:28:54,180
If you already uploaded your forked repository to your test PyPI, you will be able to create a token for your test PyPI package.

666
01:28:54,180 --> 01:28:59,180
But since we were not able to do that, I will move on.

667
01:28:59,180 --> 01:29:09,180
But GitHub has a way to keep the tokens from hiding the tokens from other people.

668
01:29:09,180 --> 01:29:12,180
It's called GitHub Secrets.

669
01:29:12,180 --> 01:29:34,180
So when you go into the interface of GitHub, you can go to Settings.

670
01:29:42,180 --> 01:30:11,180
So there's an option here in GitHub that you can add.

671
01:30:11,180 --> 01:30:15,180
I think it changes the interface.

672
01:30:15,180 --> 01:30:20,180
I'm a beta user from GitHub, so it may change the interface.

673
01:30:20,180 --> 01:30:25,180
Like here is beta. Maybe they changed something.

674
01:30:25,180 --> 01:30:37,180
But when you're going to your GitHub repository, you can go to Settings, Actions, and add a GitHub secret that's called test PyPI API token.

675
01:30:37,180 --> 01:30:45,180
So you can upload your project using CI CD in your GitHub project.

676
01:30:45,180 --> 01:30:55,180
And to publish, you will create the version on your settings.ini, update your changelog, commit and push your change to GitHub,

677
01:30:55,180 --> 01:31:07,180
check if the tests and links are passing, and then create a release using semantic version, the semantic version standard.

678
01:31:07,180 --> 01:31:17,180
And we will be able to upload your package with those automations that we talked about before.

679
01:31:17,180 --> 01:31:26,180
So going back to the end of the presentation, I'm going to talk about Python packaging history.

680
01:31:26,180 --> 01:31:32,180
So the first version of Python, you were not able to install Python packages.

681
01:31:32,180 --> 01:31:35,180
It didn't have a package manager.

682
01:31:35,180 --> 01:31:42,180
But in Python 1.6, Python introduced the setup.py.

683
01:31:42,180 --> 01:31:50,180
So it's a very old approach of installing and using Python packages writing setup.py files.

684
01:31:50,180 --> 01:31:57,180
It was added in this package manager was added to the language as well.

685
01:31:57,180 --> 01:32:01,180
But it didn't install the requirements of that package.

686
01:32:01,180 --> 01:32:09,180
So people created a package and said on the documentation, install those packages to use my package.

687
01:32:09,180 --> 01:32:14,180
So setup tools was introduced to fix this problem in 2003.

688
01:32:14,180 --> 01:32:22,180
In 2004, easy install was added to be used alongside setup tools.

689
01:32:22,180 --> 01:32:33,180
In 2008, Python packaging authority was founded because everyone says that Python has a problem with Python packaging.

690
01:32:33,180 --> 01:32:38,180
It's like other languages have better package management.

691
01:32:38,180 --> 01:32:46,180
So to fix that, Python created in 2008 this authority to regulate the packaging.

692
01:32:46,180 --> 01:32:52,180
And in 2011, it became the default manager. That's the one we use today.

693
01:32:52,180 --> 01:32:59,180
The wheel package was introduced as a way to distribute binary Python files.

694
01:32:59,180 --> 01:33:02,180
It's very, very fast to install.

695
01:33:02,180 --> 01:33:07,180
But when you generate a wheel package, it's generated for architecture.

696
01:33:07,180 --> 01:33:14,180
So if you're running on Mac, it will work only for Mac files or Mac computers.

697
01:33:14,180 --> 01:33:21,180
If you're generating on Linux, it will work only for Linux machines.

698
01:33:21,180 --> 01:33:27,180
In 2017, the fleet package was developed and introduced the PyProject.com.

699
01:33:27,180 --> 01:33:30,180
That's the modern way to write metadata.

700
01:33:30,180 --> 01:33:40,180
So all those metadata, name, version, description, your author, your license are now added to PyProject.com.

701
01:33:40,180 --> 01:33:44,180
This change was made in 2020.

702
01:33:44,180 --> 01:33:53,180
It's the modern way to do it, but NBDEV still didn't add to its core.

703
01:33:53,180 --> 01:34:01,180
There's an issue and there's a pull request there, but it still doesn't work with PyProject.

704
01:34:01,180 --> 01:34:08,180
So what is Quarto and how to install our documentation using Quarto?

705
01:34:08,180 --> 01:34:11,180
Let me show here Quarto.

706
01:34:11,180 --> 01:34:17,180
So Quarto.org, as we were discussing, is not a Python project.

707
01:34:17,180 --> 01:34:24,180
You're not installing a Python project, you're installing an R project.

708
01:34:24,180 --> 01:34:35,180
It's from RStudio and it's a way to write technical stuff using Markdown or Jupyter Notebooks.

709
01:34:35,180 --> 01:34:45,180
So you can write Python or Julia and this JavaScript language, JavaScript plugin called Observable

710
01:34:45,180 --> 01:34:51,180
to create websites, to create blogs, HTML, PDF documents.

711
01:34:51,180 --> 01:35:00,180
It's a great way if you have a research and like to publish that to other people, you can use Quarto.

712
01:35:00,180 --> 01:35:02,180
And that's why NBDEV is using Quarto.

713
01:35:02,180 --> 01:35:05,180
It was introduced in the second version of NBDEV.

714
01:35:05,180 --> 01:35:14,180
The first version was not using Quarto and it had a lot of issues with the generation of the documentation before.

715
01:35:14,180 --> 01:35:20,180
So Quarto helped a lot with different tools and different customizations.

716
01:35:20,180 --> 01:35:26,180
Like if when you generate a Quarto, like you're running Quarto preview,

717
01:35:26,180 --> 01:35:32,180
your documentation will be executed in a random port and will open a browse.

718
01:35:32,180 --> 01:35:38,180
So I always change the way that Quarto will open the NBDEV documentation.

719
01:35:38,180 --> 01:35:44,180
You can change the navigation of your GitHub pages.

720
01:35:44,180 --> 01:35:49,180
So I can change, I can put pages here or pages here.

721
01:35:49,180 --> 01:35:54,180
I can change the navigation of my documentation using Quarto.

722
01:35:54,180 --> 01:36:00,180
You can add Google Analytics to your GitHub pages if you're publishing NBDEV.

723
01:36:00,180 --> 01:36:06,180
So there's multiple features like dark mode, page navigation.

724
01:36:06,180 --> 01:36:10,180
For example, in my project I'm not using page navigation.

725
01:36:10,180 --> 01:36:14,180
So you can't navigate from deck to hand.

726
01:36:14,180 --> 01:36:17,180
Like there's no next page here.

727
01:36:17,180 --> 01:36:22,180
But if you're activating, you can add this feature to your documentation.

728
01:36:22,180 --> 01:36:27,180
There's reader mode as well.

729
01:36:27,180 --> 01:36:30,180
And this is a part of the tutorial.

730
01:36:30,180 --> 01:36:38,180
I want to show some cool features of Jupyter Notebooks that are further than Python packaging.

731
01:36:38,180 --> 01:36:41,180
The first one is using Voila.

732
01:36:41,180 --> 01:36:51,180
Voila is a package, a Python package that allows us to use our Jupyter Notebook as a dashboard.

733
01:36:51,180 --> 01:37:05,180
So I publish a mini game using the, I create a mini game using the French deck.

734
01:37:05,180 --> 01:37:11,180
The French deck that I showed you before, that French deck definition.

735
01:37:11,180 --> 01:37:17,180
And Voila allows us to execute the Jupyter Notebook as an application.

736
01:37:17,180 --> 01:37:23,180
It's a Jupyter Notebook execution, so it renders all markdown.

737
01:37:23,180 --> 01:37:25,180
And this is the UI I developed.

738
01:37:25,180 --> 01:37:29,180
So the cards are represented by buttons.

739
01:37:29,180 --> 01:37:31,180
So this is a button.

740
01:37:31,180 --> 01:37:39,180
And in the Jupyter Notebook you're going to be able to see the code, but this is only the UI that we created.

741
01:37:39,180 --> 01:37:41,180
And this is the game.

742
01:37:41,180 --> 01:37:45,180
So you can push the cards.

743
01:37:45,180 --> 01:37:49,180
And if you reach 21, you win.

744
01:37:49,180 --> 01:37:53,180
Otherwise, you're game over.

745
01:37:53,180 --> 01:37:59,180
So this is a simple application of Jupyter Notebooks for using Voila.

746
01:37:59,180 --> 01:38:05,180
But most people use Voila to create dashboards.

747
01:38:05,180 --> 01:38:13,180
So if you're a data scientist, you can create fancy dashboards and show to people it has data, it has access control.

748
01:38:13,180 --> 01:38:21,180
And if you need to create users for your clients, you can create them and share with them.

749
01:38:21,180 --> 01:38:29,180
So it's a very clever way to share Jupyter Notebooks and data science applications.

750
01:38:29,180 --> 01:38:31,180
And...

751
01:38:31,180 --> 01:38:33,180
Okay.

752
01:38:33,180 --> 01:38:45,180
Okay.

753
01:38:45,180 --> 01:38:47,180
Good question.

754
01:38:47,180 --> 01:38:49,180
This was running Python code.

755
01:38:49,180 --> 01:38:59,180
So there's a trend on Python ecosystem that, like, you already have a lot of knowledge in Python and data science.

756
01:38:59,180 --> 01:39:03,180
You don't need to understand JavaScript.

757
01:39:03,180 --> 01:39:07,180
So first they create PyScript, right?

758
01:39:07,180 --> 01:39:13,180
So it was a huge creation and the whole community was talking about.

759
01:39:13,180 --> 01:39:17,180
But there's some other tools.

760
01:39:17,180 --> 01:39:27,180
And here I'm using IPyWidget that we can create interface using only Python.

761
01:39:27,180 --> 01:39:33,180
So I can show you the code right here.

762
01:39:33,180 --> 01:39:41,180
IPyWidgets are the most basic library that creates UI for Jupyter Notebooks.

763
01:39:41,180 --> 01:39:45,180
There are other UIs that create fancy interfaces for you.

764
01:39:45,180 --> 01:39:47,180
So this is very simple.

765
01:39:47,180 --> 01:39:49,180
This is the most basic tool.

766
01:39:49,180 --> 01:39:56,180
But with that, you can create, for example, here's the button that I was talking about, like the test button.

767
01:39:56,180 --> 01:40:01,180
I'm just calling a Widgets button, say that it will be disabled.

768
01:40:01,180 --> 01:40:05,180
And it will have a description and a layout.

769
01:40:05,180 --> 01:40:11,180
So it will be increased by its name.

770
01:40:11,180 --> 01:40:20,180
So it's that library that I showed you before called IPyAnnotator is all developed using IPyWidgets.

771
01:40:20,180 --> 01:40:25,180
We develop annotation for machine learning data using IPyWidgets.

772
01:40:25,180 --> 01:40:32,180
And we use Voila for our annotators to use the interface.

773
01:40:32,180 --> 01:40:37,180
So yeah, you don't need to understand JavaScript to build interfaces.

774
01:40:37,180 --> 01:40:41,180
And you can create them on Jupyter Notebooks.

775
01:40:41,180 --> 01:40:45,180
That's the cool part of working with this.

776
01:40:45,180 --> 01:40:49,180
And the last part is new, too.

777
01:40:49,180 --> 01:40:53,180
There's multiple ways now, I think.

778
01:40:53,180 --> 01:41:01,180
When I create this presentation, there's a way to use ChatGPT on your Jupyter Notebook that I'm going to show you.

779
01:41:01,180 --> 01:41:05,180
But now there's more fancy plugins that you can install and use.

780
01:41:05,180 --> 01:41:13,180
So Jupyter Notebook doesn't have like GitHub Copilot, right, that can help you.

781
01:41:13,180 --> 01:41:18,180
But you can install this package called AskAI.

782
01:41:18,180 --> 01:41:28,180
And you can ask ChatGPT to help you with your tasks using Jupyter Notebook.

783
01:41:28,180 --> 01:41:32,180
So I'm going to show you right here how it works.

784
01:41:32,180 --> 01:41:35,180
This command will install the package.

785
01:41:35,180 --> 01:41:39,180
This will load your OpenAI key.

786
01:41:39,180 --> 01:41:45,180
You can open your OpenAI account and get a key from there.

787
01:41:45,180 --> 01:41:49,180
This is going to load the package on your Jupyter Notebook.

788
01:41:49,180 --> 01:41:51,180
And this is how you use it.

789
01:41:51,180 --> 01:41:57,180
You can ask something to your ChatGPT.

790
01:41:57,180 --> 01:42:02,180
It will take a time, but it will answer.

791
01:42:02,180 --> 01:42:08,180
So here I asked for a French deck definition, that class that I showed you before.

792
01:42:08,180 --> 01:42:13,180
This code is the code from the Fluent Python.

793
01:42:13,180 --> 01:42:21,180
It uses unit code here instead of strings and uses the strings.

794
01:42:21,180 --> 01:42:29,180
I only changed two integers because it was easier to my example of that game.

795
01:42:29,180 --> 01:42:33,180
It was easier to use.

796
01:42:33,180 --> 01:42:37,180
So that's all I prepared.

797
01:42:37,180 --> 01:42:39,180
I'm sorry for the exercises.

798
01:42:39,180 --> 01:42:47,180
I'm going to share the PDF with you guys on the repository.

799
01:42:47,180 --> 01:42:52,180
Right now you already have the presentation on your fork.

800
01:42:52,180 --> 01:42:58,180
Let me show you here.

801
01:42:58,180 --> 01:43:00,180
Sure.

802
01:43:00,180 --> 01:43:16,180
I'm not sure if I understand your question.

803
01:43:16,180 --> 01:43:21,180
In the ChatGPT?

804
01:43:21,180 --> 01:43:24,180
The patch.

805
01:43:24,180 --> 01:43:28,180
In these lies in the Jupyter Notebook?

806
01:43:28,180 --> 01:43:30,180
Where?

807
01:43:30,180 --> 01:43:32,180
In the Notebook?

808
01:43:32,180 --> 01:43:34,180
Which one?

809
01:43:34,180 --> 01:43:59,180
This is?

810
01:43:59,180 --> 01:44:18,180
So remember I said that you use the sys.path.

811
01:44:18,180 --> 01:44:23,180
So when you're using the Python interpreter, he will search on the sys.path.

812
01:44:23,180 --> 01:44:44,180
And when you're opening?

813
01:44:44,180 --> 01:44:56,180
Let me show.

814
01:44:56,180 --> 01:45:06,180
So when I have the decorator patch, what's your question?

815
01:45:06,180 --> 01:45:13,180
So when you're writing here the self, you can mention the class that will be patched.

816
01:45:13,180 --> 01:45:21,180
So it will patch using this.

817
01:45:21,180 --> 01:45:26,180
You have a question as well?

818
01:45:26,180 --> 01:45:30,180
So where is that?

819
01:45:30,180 --> 01:45:32,180
So okay.

820
01:45:32,180 --> 01:45:34,180
This is the repository.

821
01:45:34,180 --> 01:45:37,180
So this is the presentation right here.

822
01:45:37,180 --> 01:45:41,180
I developed the presentation using quarto.

823
01:45:41,180 --> 01:45:43,180
So it's a QMD file.

824
01:45:43,180 --> 01:45:46,180
Like it's our application.

825
01:45:46,180 --> 01:45:49,180
So it uses this format.

826
01:45:49,180 --> 01:45:52,180
It's quarto markdown.

827
01:45:52,180 --> 01:46:00,180
To develop presentations with quarto, you just need to add a title to your presentation.

828
01:46:00,180 --> 01:46:04,180
And then you can add a title which will be a new slide.

829
01:46:04,180 --> 01:46:16,180
So to run this, you only have to run quarto preview presentation index.

830
01:46:16,180 --> 01:46:24,180
But I will also add the PDF to the GitHub so you can access later.

831
01:46:24,180 --> 01:46:29,180
The problem with the script, renaming script, I will fix it.

832
01:46:29,180 --> 01:46:41,180
And I will probably upload a video to finish the exercise that we should have done in this tutorial.

833
01:46:41,180 --> 01:46:46,180
You guys have any questions?

834
01:46:46,180 --> 01:46:47,180
Okay.

835
01:46:47,180 --> 01:46:50,180
So I'm going to conclude here.

836
01:46:50,180 --> 01:46:52,180
Okay.

837
01:46:52,180 --> 01:47:09,180
This is a good question.

838
01:47:09,180 --> 01:47:21,180
I don't know how to do that because unless you're calling a lot of subprocesses using Python code to call your C++ code,

839
01:47:21,180 --> 01:47:23,180
I'm not sure how you would do that.

840
01:47:23,180 --> 01:47:27,180
At least with RStudio or Jupyter Notebooks.

841
01:47:27,180 --> 01:47:34,180
Only if I think C++ has something similar to Jupyter Notebooks.

842
01:47:34,180 --> 01:47:37,180
Yeah, I think I read something about it.

843
01:47:37,180 --> 01:47:40,180
But it's very alpha release.

844
01:47:40,180 --> 01:47:47,180
It's not used.

845
01:47:47,180 --> 01:48:00,180
So I'm going to run my presentation here and conclude.

846
01:48:00,180 --> 01:48:06,180
So quarto presentation also allows you to run Python code and other stuff.

847
01:48:06,180 --> 01:48:11,180
That's why I developed using quarto presentation.

848
01:48:11,180 --> 01:48:15,180
Jupyter Notebooks is awesome for quick prototyping.

849
01:48:15,180 --> 01:48:24,180
Code, docs, and tests can be used to tell a story of your code and improve the documentation.

850
01:48:24,180 --> 01:48:28,180
This is something that I always iterate with my team.

851
01:48:28,180 --> 01:48:36,180
For example, if I have a code that the team didn't understand on my pull request, I go back to my documentation and update there.

852
01:48:36,180 --> 01:48:41,180
I always tell a story of that package.

853
01:48:41,180 --> 01:48:52,180
For example, there's a workaround or I install a specific version of the software I'm always telling and iterating over the Jupyter Notebooks.

854
01:48:52,180 --> 01:48:59,180
Jupyter Notebooks itself doesn't allow you to write literate programming because it doesn't write the documentation and the code.

855
01:48:59,180 --> 01:49:01,180
It doesn't split both.

856
01:49:01,180 --> 01:49:06,180
But with NBDEV, it allows us to use this paradigm.

857
01:49:06,180 --> 01:49:11,180
Publishing a package with NBDEV is easier, faster, and efficient.

858
01:49:11,180 --> 01:49:14,180
And visual libraries benefit a lot from NBDEV.

859
01:49:14,180 --> 01:49:17,180
So I'm from Brazil and I work for Pileimon.

860
01:49:17,180 --> 01:49:19,180
That's a company for Germany.

861
01:49:19,180 --> 01:49:22,180
And we have a four-hour time difference.

862
01:49:22,180 --> 01:49:25,180
So we work completely asynchronously.

863
01:49:25,180 --> 01:49:30,180
And the tool that allows us to work asynchronously is NBDEV.

864
01:49:30,180 --> 01:49:36,180
Because I'm always iterating and documenting everything that we discuss over text.

865
01:49:36,180 --> 01:49:39,180
So that's the way we work.

866
01:49:39,180 --> 01:49:42,180
And that's why NBDEV is so important for us.

867
01:49:42,180 --> 01:49:52,180
And as I said before in the introduction of the presentation, NBDEV got into a GitHub program that will accelerate its development.

868
01:49:52,180 --> 01:49:54,180
So it will get huge.

869
01:49:54,180 --> 01:49:59,180
And I hope you will be soon using NBDEV.

870
01:49:59,180 --> 01:50:01,180
So that's the presentation.

871
01:50:01,180 --> 01:50:04,180
Sorry for the problems we have.

872
01:50:04,180 --> 01:50:06,180
But I will fix it.

873
01:50:06,180 --> 01:50:13,180
I will send an email for everyone with the link and the fix it for Windows machines.

874
01:50:13,180 --> 01:50:14,180
Okay.

875
01:50:14,180 --> 01:50:16,180
So thank you.

876
01:50:16,180 --> 01:50:18,180
Thank you.

