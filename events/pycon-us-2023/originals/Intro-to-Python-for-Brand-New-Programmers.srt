1
00:00:00,000 --> 00:00:09,040
All right. Welcome to PyCon. This is your first tutorial. It must be because this is

2
00:00:09,040 --> 00:00:16,000
the first tutorial at PyCon. So I got to chat with some of you before we got started here.

3
00:00:16,000 --> 00:00:20,440
We have some very mixed backgrounds today, which is always the case with a tutorial like

4
00:00:20,440 --> 00:00:24,880
this. Some of you have done Python before. Some of you have written code before, but

5
00:00:24,880 --> 00:00:31,920
never done Python. Some of you have not written code at all. Now, this tutorial was originally

6
00:00:31,920 --> 00:00:36,800
intended for folks who have never written a line of code, never even seen a line of

7
00:00:36,800 --> 00:00:43,480
code. For many of you, that means it's going to be a little bit slow at times. Also, for

8
00:00:43,480 --> 00:00:48,240
those of you who are brand new to coding, you are in the right place. This will be a

9
00:00:48,240 --> 00:00:53,600
little fast sometimes, partly because many people in this room have written some code

10
00:00:53,640 --> 00:01:00,640
before. So there's no way we can please everyone at all moments. If you're a little intimidated,

11
00:01:00,640 --> 00:01:05,400
if it's a little slow, it's just going to be the way things are sometimes this morning.

12
00:01:05,400 --> 00:01:09,600
So this place that I'm in, does anyone know what this is called? I'm actually typing code

13
00:01:09,600 --> 00:01:19,280
right here. Yeah. Yep. Python interpreter. That is a name for it. Anyone ever heard another

14
00:01:19,280 --> 00:01:26,400
name for this? The REPL. That is another name for it. Anyone heard another name? Terminal.

15
00:01:26,400 --> 00:01:33,520
That, ooh, yes. I am in a terminal in the Python REPL and in the Python interpreter,

16
00:01:33,520 --> 00:01:37,680
which is sometimes also called the Python interactive interpreter. Anyone heard another

17
00:01:37,680 --> 00:01:45,600
name? IDE. This one isn't technically an IDE, though I like that one, because it is something

18
00:01:45,600 --> 00:01:50,480
you see embedded in IDEs. And in fact, later on, you might wonder whether I'm using an

19
00:01:50,480 --> 00:01:59,720
IDE. Python prompt is another one I sometimes hear. Python shell. Code editor. Ooh, this

20
00:01:59,720 --> 00:02:04,000
isn't a code editor yet, but we will see a code editor. I like that one. And the reason

21
00:02:04,000 --> 00:02:10,800
is it's funny because we're not at our system prompt. I'm going to exit Python here. I'm

22
00:02:10,800 --> 00:02:16,200
now at my system prompt. My system prompt, if I open up terminal on Linux or Mac, if

23
00:02:16,200 --> 00:02:19,960
I open up command prompt on Windows, this is my system command prompt. I can do things

24
00:02:19,960 --> 00:02:25,920
like change directories, go up one directory, change into this directory. Apparently, I

25
00:02:25,920 --> 00:02:29,960
have something from PyCon last year. I can list this directory. There's nothing in this

26
00:02:29,960 --> 00:02:34,560
directory, so it's empty here. This is my system command prompt. When I type Python

27
00:02:34,560 --> 00:02:38,600
or Python 3, either one works on my machine. On Windows, sometimes you have to type just

28
00:02:39,280 --> 00:02:43,520
different things on different machines. I'm now in the Python repel, Python interactive

29
00:02:43,520 --> 00:02:48,760
interpreter, the Python prompt, the Python shell. There are far too many names for this

30
00:02:48,760 --> 00:02:53,960
place that I am at. Melanie in the back of the room there at some point said that these

31
00:02:53,960 --> 00:03:01,520
three little greater than signs look kind of like the back of an alligator, I think,

32
00:03:01,520 --> 00:03:06,760
which is a reptile. I think alligators are reptiles. Yes, they are reptiles. Alligators

33
00:03:06,760 --> 00:03:19,360
are reptiles. This is the Python rep tile. There you go. The Python repel. The Python

34
00:03:19,360 --> 00:03:22,360
repel, that's the way you can remember those three little greater than signs. If you see

35
00:03:22,360 --> 00:03:26,840
those, that's where you're typing code. This is basically an interactive sandbox. We're

36
00:03:26,840 --> 00:03:33,800
able to type Python code, immediately see results. It's not a code editor only because

37
00:03:33,920 --> 00:03:38,280
it does more than, well, it actually doesn't edit code. It allows you to write code. You

38
00:03:38,280 --> 00:03:44,960
can't really change it. I can hit the up arrow and I can run code again, but I can't change

39
00:03:44,960 --> 00:03:48,720
code I've already written. It's very, very interactive. It's a little sandbox. We're

40
00:03:48,720 --> 00:03:53,360
writing our code, seeing results. Anyone want to guess or maybe you think you know what

41
00:03:53,360 --> 00:04:03,480
R-E-P-L stands for? Ripple. Yes. People either tend to know all four of the letters or they

42
00:04:03,480 --> 00:04:06,920
know none of them because most of us, we don't need to know what repel means. You just know

43
00:04:06,920 --> 00:04:13,400
it's called the repel. It actually describes what it does. Python is currently reading.

44
00:04:13,400 --> 00:04:18,920
It's reading what I type here. It's evaluating or executing what I've written. I'll say

45
00:04:18,920 --> 00:04:24,200
either one was fine, though. And then it'll print whatever the result of that thing is,

46
00:04:24,200 --> 00:04:28,360
that line of code I've typed, and then it loops, meaning it just does the same thing

47
00:04:28,360 --> 00:04:34,080
over and over. Go back to step one, in a sense, there. Step one, read, evaluate, print, and

48
00:04:34,080 --> 00:04:40,760
then loop. All right. This is going to be very interactive today. Who thinks they know

49
00:04:40,760 --> 00:04:46,760
the answer to this when I hit enter? Error. Great guess. There are no wrong guesses, by

50
00:04:46,760 --> 00:04:53,760
the way. We don't know what we're doing. Error is a perfectly good one. Two. Two, two. Ooh,

51
00:04:53,760 --> 00:05:02,000
that's a good guess. Four. That's the correct answer in this case. I wasn't tricking you

52
00:05:02,000 --> 00:05:07,080
this time, though. I like those ideas. I am going to be tricking you. Two plus two equals

53
00:05:07,080 --> 00:05:12,040
four. Python, you know, it obviously can do math. It is a programming language. It can

54
00:05:13,040 --> 00:05:18,440
As we type here, it's reading. When I hit enter, that's what makes it finally evaluate

55
00:05:18,440 --> 00:05:24,360
what I've written there. It prints out a result, and then it loops, meaning it waits for more.

56
00:05:24,360 --> 00:05:32,640
Anyone know or want to take a guess what this thing does? What might it do? Yep. Yeah, this

57
00:05:32,640 --> 00:05:37,440
is exponentiation. It's raising something to a power different from this. What's this?

58
00:05:38,440 --> 00:05:42,520
Yeah, for those of you who've done maybe Matlab or you've used a calculator on your computer

59
00:05:42,520 --> 00:05:47,600
or, you know, graphing calculator maybe, it's just multiplying. Star, star, raising something

60
00:05:47,600 --> 00:05:53,440
to a power, multiplying two by itself ten times. What about this? What's your guess?

61
00:05:53,440 --> 00:06:03,000
What might we see when I hit enter? What are the options? Possibilities. Could be a valuer.

62
00:06:03,000 --> 00:06:09,640
That's going to be a very big number, right? Two by two by two. I mean, we all learned,

63
00:06:09,640 --> 00:06:15,000
if we hadn't before, what exponential growth is like during the pandemic. This is exponential.

64
00:06:15,000 --> 00:06:22,760
This is a very, very, very big number. So it could be an error. It isn't. Python can

65
00:06:22,760 --> 00:06:27,720
represent a number as large as we'd like. It has something called big integers. This

66
00:06:27,720 --> 00:06:31,280
is two to the 10,000th power. I don't know how big this number actually is, but it's

67
00:06:31,280 --> 00:06:37,080
scrolled off my screen as you can see. They get bigger and bigger as they need to get

68
00:06:37,080 --> 00:06:42,040
bigger, which is interesting. They just take up more memory as needed. So we're in the

69
00:06:42,040 --> 00:06:46,640
Python REPL here. I'd like you to play with the REPL. We're going to take a very quick

70
00:06:46,640 --> 00:06:53,160
break now. I know we're only a few minutes in, but I want you to get practice with this.

71
00:06:53,160 --> 00:06:58,640
The reason I want you to write code yourself right now is you do not learn by putting information

72
00:06:58,880 --> 00:07:06,880
into your head. Anyone know how you learn? Yeah, there's a phrase everyone says, you

73
00:07:06,880 --> 00:07:12,240
learn by doing, right? The reason doing is important, it's not actually the doing that's

74
00:07:12,240 --> 00:07:16,280
the important part. It's the memory retrieval. Active retrieval is the important part. The

75
00:07:16,280 --> 00:07:19,720
fact that we're trying to take something that might be in our head and take it out of our

76
00:07:19,720 --> 00:07:25,680
head. So it's important that we actually write some code to learn some things. So I'd like

77
00:07:25,720 --> 00:07:32,720
you to bring up the Python REPL on your machine. The way you can do that is open up Terminal

78
00:07:33,400 --> 00:07:40,400
or Command Prompt and type Python 3. And after you've done that, I'd like you to try out

79
00:07:40,880 --> 00:07:47,880
some exercises. These exercises are on a website that we're working on today. I am not on the

80
00:07:49,040 --> 00:07:52,600
Wi-Fi, even though I put up the Wi-Fi password. I'm just going to type the URL for the website

81
00:07:52,600 --> 00:07:59,600
and hope it works. So that URL there, you can go to the website, click on the very first

82
00:08:14,000 --> 00:08:21,000
one, pycon2023.pym.dev, and then click on the REPL over in that section. And then you

83
00:08:22,600 --> 00:08:27,600
can see the sidebar there. Click on the REPL. And that website will stay up online afterwards,

84
00:08:27,600 --> 00:08:32,680
so if you're watching the recording later, it should still hopefully exist on the internet.

85
00:08:32,680 --> 00:08:37,200
I am now going to wander around the room along with Melanie, who's in the back of the room.

86
00:08:37,200 --> 00:08:42,700
And oh, what I'd like you to do, I'm going to give you a few minutes here. Just a few

87
00:08:42,700 --> 00:08:49,700
minutes to play around in the REPL. I want you to try to type 4 plus 7 in the REPL, see

88
00:08:50,700 --> 00:08:53,980
what it does. And then try to do the other things that are at the very bottom of that

89
00:08:53,980 --> 00:09:00,980
page, just a couple ideas for playing in the REPL. If you get done with all the things

90
00:09:02,180 --> 00:09:06,460
in this first section here, actually no, if you manage to even open up the REPL, type

91
00:09:06,460 --> 00:09:11,380
something and see a result, please put a green sticky, a green sticky note on the top of

92
00:09:11,380 --> 00:09:15,620
your computer. Excellent. Some of you have already done that. If you're having trouble,

93
00:09:15,620 --> 00:09:18,500
please put up a red sticky. All right, I'll be wandering around here.

94
00:09:19,700 --> 00:09:26,700
All right. For the folks on the recording, I want to note a problem that multiple folks

95
00:09:28,380 --> 00:09:33,780
are having here that I forgot to mention. I'm also going to increase my font size here.

96
00:09:33,780 --> 00:09:40,780
That didn't quite work. Increase the font size over here. There we go. If you were on

97
00:09:40,780 --> 00:09:47,780
Windows and you say, I know I installed Python, but when I type Python or Python 3, it opens

98
00:09:51,740 --> 00:09:56,340
up the Microsoft store. What's going on? When you install Python, there is a checkbox that

99
00:09:56,340 --> 00:10:00,300
says do you want to add Python or Python 3 to your path? This is on Windows when you

100
00:10:00,300 --> 00:10:05,020
install Python from Python.org. You probably didn't check the checkbox. That's okay. I

101
00:10:05,020 --> 00:10:11,340
didn't tell you to. What you can do instead of typing Python or Python 3 is on Windows,

102
00:10:11,340 --> 00:10:16,700
you can type py. It's short. It doesn't work on Mac or Linux, although it does for me because

103
00:10:16,700 --> 00:10:22,300
I have a special alias installed there. Type py and it will launch Python. Every time I

104
00:10:22,300 --> 00:10:27,740
type Python or Python 3 today, if you're on Windows, type py instead. If Python or Python

105
00:10:27,740 --> 00:10:32,460
3 works even though you're on Windows, excellent. That's great too. The reason is the Microsoft

106
00:10:32,460 --> 00:10:37,620
store has their own Python that you can install. It competes with the Python.org. Sometimes

107
00:10:37,620 --> 00:10:43,220
the two don't realize the other one's installed. All right. I see a lot of green stickies,

108
00:10:43,220 --> 00:10:49,140
which is excellent. I want to ask you why are we using the red stickies? You want to

109
00:10:49,140 --> 00:10:53,420
take a guess. I'll ask a different question, actually. When you have a question you need

110
00:10:53,420 --> 00:10:57,780
help, what do you usually do? Yeah, what you were just doing. You raise your hand. What

111
00:10:57,780 --> 00:11:03,380
is it difficult to do while you're raising your hand? Type. Right. I want you to be able

112
00:11:03,380 --> 00:11:07,580
to type even if you have a question and no one's able to answer it at the moment. The

113
00:11:07,580 --> 00:11:13,020
red stickies are to passively indicate I have a question. No rush, but come help me when

114
00:11:13,020 --> 00:11:18,020
you have a moment. I'll be wandering back around. For those of you who have red stickies

115
00:11:18,020 --> 00:11:22,740
up, I'll get to you in just a second. We'll get back to talking about the REPL and playing

116
00:11:22,740 --> 00:11:29,740
with Python in just a moment. All right. So I would like to move on here. I want to ask

117
00:11:34,540 --> 00:11:40,780
you oh, you can put down your green stickies, by the way, and your red stickies. When I'm

118
00:11:40,780 --> 00:11:43,900
up here, I'm talking to you, feel free you don't need to stick up a stickie to ask a

119
00:11:43,900 --> 00:11:47,180
question, by the way. Feel free to raise your hand or even just shout something out maybe

120
00:11:47,820 --> 00:11:54,820
when it seems appropriate. What do you think will happen when I hit enter? Error. Yeah,

121
00:11:58,820 --> 00:12:01,780
maybe unless it's a variable. So that's something we're going to talk about in just a moment

122
00:12:01,780 --> 00:12:06,740
here. By the way, my name's Trey. It's nice to meet you. I'll be typing my name a lot

123
00:12:06,740 --> 00:12:11,580
because it's fun to use your own name when you were learning coding. Yeah, we get an

124
00:12:11,580 --> 00:12:16,260
error, a name error. There is not a variable called Trey. We're going to work in variables

125
00:12:16,300 --> 00:12:21,300
with just in just a moment. But the thing I'm trying to do is represent characters.

126
00:12:21,300 --> 00:12:26,660
Anyone know how I can do that if you've done programming before? There's a type of thing

127
00:12:26,660 --> 00:12:31,180
that we often use. There's numbers. And there's the other thing, the two most common things

128
00:12:31,180 --> 00:12:37,920
you see in programming. Strings, yeah. We need a string. So you can put double quotes

129
00:12:37,920 --> 00:12:44,920
around something to make a string. Do you think I could put single quotes? What's your

130
00:12:46,740 --> 00:12:53,340
answer? Do you think there's a difference between double quotes and single quotes? Maybe.

131
00:12:53,340 --> 00:12:57,020
In some programming languages there aren't and some there are. I'll just tell you the

132
00:12:57,020 --> 00:13:03,180
short answer in Python is there isn't. There isn't, except if you want to represent single

133
00:13:03,180 --> 00:13:08,020
quotes inside your string. So if I wanted to say I don't know, what do you think will

134
00:13:08,020 --> 00:13:15,020
happen here? Yeah, Python might not know where's the end of the string. We get an error in

135
00:13:16,340 --> 00:13:21,340
invalid syntax. I could fix it by using double quotes. Anyone know another way to fix it?

136
00:13:21,340 --> 00:13:27,980
Yeah, you can use a backslash before a quote to say I'm escaping this. Typically though,

137
00:13:27,980 --> 00:13:31,260
since we have both single quotes and double quotes, it's pretty rare to have strings that

138
00:13:31,260 --> 00:13:35,060
have both of them. So you just switch the quote you're using. If you prefer one, you

139
00:13:35,060 --> 00:13:40,060
need a single quote or a double quote, you switch to the other. Another question I want

140
00:13:40,060 --> 00:13:47,060
to ask is what are the possibilities? What might happen when I hit enter here? What are

141
00:13:47,420 --> 00:13:52,420
the options? We might see an error, always an option, always a possible option we hit

142
00:13:52,420 --> 00:13:59,420
enter. We might see an error. What else might happen? Yeah, we smoosh the stuff together

143
00:13:59,740 --> 00:14:04,900
somehow. Maybe we'll get PyCon and 2023. So we get back a string of PyCon 2023. What other

144
00:14:04,900 --> 00:14:11,900
type of thing could we get back? A number. We could get back 2023 or zero or something

145
00:14:12,020 --> 00:14:15,020
else. We could get a number. We could get a string. We've seen numbers and strings at

146
00:14:15,020 --> 00:14:21,220
this point. We could also get an error. In Python, in most programming languages, you

147
00:14:21,220 --> 00:14:24,540
get this concatenation thing. You're taking two strings, adding them together. You smoosh

148
00:14:24,540 --> 00:14:29,860
them together. In Python, you actually do get an error, which is unusual. It's one of

149
00:14:29,860 --> 00:14:35,380
the few programming languages where a string plus a number is an error. You have to explicitly

150
00:14:35,380 --> 00:14:41,860
convert that number to a string. There's a str function. We'll talk about functions later.

151
00:14:41,860 --> 00:14:47,100
Or if you're just writing it out yourself, you do this. Now, this is a little bit silly

152
00:14:47,100 --> 00:14:50,900
because we could also just write the string out ourselves. Notice there's no space here.

153
00:14:50,900 --> 00:14:56,140
We'd have to put the space in ourselves if we wanted a space to be there. So we're going

154
00:14:56,140 --> 00:14:59,380
to play with strings just a little bit at the REPL again, just a few minutes here. This

155
00:14:59,380 --> 00:15:01,980
will actually be just a few minutes this time. I know it took us a little while to

156
00:15:01,980 --> 00:15:08,060
get up the REPL before. Play with strings. So on the website, we are under strings. At

157
00:15:08,060 --> 00:15:13,740
the very bottom of the page, string exercises. Try strings out in the REPL for just a few

158
00:15:13,740 --> 00:15:17,140
minutes here. I'll be wandering around. If you have a question on anything, stick up

159
00:15:17,140 --> 00:15:28,140
a red sticky. Oh, and once you've tried anything with strings in the REPL, put up a green sticky.

160
00:15:28,140 --> 00:15:34,380
All right. So a couple folks asked about the timer that I'm using here. Yes, this is written

161
00:15:34,380 --> 00:15:40,640
in Python. Countdown. If you have ever installed a Python package, I'm guessing most of you

162
00:15:40,640 --> 00:15:48,380
haven't since you're brand new to Python. Python 3-M pip install countdown CLI. It'll

163
00:15:48,380 --> 00:15:51,580
be on the recording. You can write it down if you'd like. You don't need to do that right

164
00:15:51,580 --> 00:15:56,300
now. It will globally install on your machine that little countdown script if you ever need

165
00:15:56,300 --> 00:16:01,860
a countdown timer for some reason. It's great for teaching. Who found something interesting

166
00:16:01,860 --> 00:16:04,860
out? Yeah, what did you discover?

167
00:16:34,860 --> 00:16:39,020
Yeah, I wonder if there was a typo involved there because it shouldn't be an error. So

168
00:16:39,020 --> 00:16:45,180
you said double quote plus double quote. Comes out as 23. Yeah, so it might have been a typo

169
00:16:45,180 --> 00:16:48,700
there. But this is interesting on its own, the fact that there's no numbers involved

170
00:16:48,700 --> 00:16:53,540
here. We're just concatenating strings. Anyone else find another interesting thing? Yep.

171
00:16:53,540 --> 00:17:09,420
Right. Yeah, a couple folks found this one. What does this do? What do we get? Right.

172
00:17:09,420 --> 00:17:16,820
This is called self-concatenation. So in Python, you can multiply a string by a number. You

173
00:17:16,820 --> 00:17:21,100
get that string that many times. Now, it doesn't have to be a single digit. Anyone try something

174
00:17:21,100 --> 00:17:33,740
bigger? Or maybe you can take any string you'd like and concatenate it to itself lots of

175
00:17:33,740 --> 00:17:37,420
times. Now, this seems really silly, right? But it is actually sometimes useful. When

176
00:17:37,420 --> 00:17:46,700
might this come in handy? Sometimes you want one character in a string over and over, for

177
00:17:46,700 --> 00:17:52,660
example. You want a string that has, for example, something I've done often when teaching,

178
00:17:52,660 --> 00:17:58,060
I want 80 zeros on my screen to see whether my font size is big enough. It's an easy way

179
00:17:58,060 --> 00:18:15,300
to check if the projector's in the right mode. Yep? Right. This is a great question. So some

180
00:18:15,300 --> 00:18:21,300
programming languages, Perl is one example. Concatenation and adding numbers are two totally

181
00:18:21,300 --> 00:18:24,900
different things. Because in Python, we've seen plus. What does plus do? There's two

182
00:18:24,900 --> 00:18:28,260
different things we've seen it do. What does it do with numbers? Adds them. What does it

183
00:18:28,260 --> 00:18:33,180
do with strings? It smushes them together. It concatenates them is the fancy word for

184
00:18:33,180 --> 00:18:40,580
that. It's really just a fancy word for smushes together or gluing things together, I guess.

185
00:18:40,580 --> 00:18:43,700
Plus does both, depending on what objects it works. Now, this is something you'll see

186
00:18:43,740 --> 00:18:48,420
a lot, not just in Python, but other languages, that plus often does both things. Perl, you

187
00:18:48,420 --> 00:18:53,140
need to use a period to concatenate. You need to use a plus to add. Two totally different

188
00:18:53,140 --> 00:18:58,740
things. So they've actually decided those shouldn't be the same symbol. In Python in

189
00:18:58,740 --> 00:19:03,740
particular, it's actually pretty common to see one symbol overloaded for multiple different

190
00:19:03,740 --> 00:19:08,260
purposes. For example, multiplication. We've seen multiplication for two different things.

191
00:19:08,260 --> 00:19:15,260
You can multiply numbers. Can you multiply strings? Anyone try this? What's your guess?

192
00:19:16,660 --> 00:19:23,660
When I hit enter, what do you think we'll see? What could we see? Could always be an

193
00:19:24,180 --> 00:19:29,300
error, right? Could be an error. Could be two 10 times. Could be something else. Turns

194
00:19:29,300 --> 00:19:34,320
out it's an error. But you can multiply a string by a number, right? We just saw that.

195
00:19:34,320 --> 00:19:37,500
So string times a number, that does a different thing than number times a number. So it's

196
00:19:37,500 --> 00:19:41,500
very common in Python to have one symbol do different things depending on the types

197
00:19:41,500 --> 00:19:47,660
of those objects. And those objects can usually control what happens there. So when I typed

198
00:19:47,660 --> 00:19:52,660
tray before and we said it didn't work, somebody said, but if it was a variable, it might work.

199
00:19:52,660 --> 00:19:56,160
How do you think you make a variable? If I wanted to say I have a variable X and its

200
00:19:56,160 --> 00:20:03,160
value is four. X equals four. So who's done algebra before? Who liked algebra? A different

201
00:20:04,160 --> 00:20:10,920
set of hands. I actually liked algebra. It was one of my favorite mathy things. And I

202
00:20:10,920 --> 00:20:14,720
think it's because I got exposure to programming around the time I got exposure to algebra,

203
00:20:14,720 --> 00:20:19,000
just a little bit of programming. And I liked the fact that they felt similar. But felt

204
00:20:19,000 --> 00:20:22,920
similar in ways I couldn't quite say how are they different, how are they similar. I just

205
00:20:22,920 --> 00:20:27,380
knew they were similar in some way. One very big way is they both have variables. So X

206
00:20:27,380 --> 00:20:32,000
equals four. We're assigning the value of X to four. Now this is different from in math

207
00:20:32,040 --> 00:20:36,920
where we say, well, we have some expression we need to solve for X. X equals X plus three.

208
00:20:36,920 --> 00:20:42,360
This doesn't solve. There's no solving for X here. What does this do? Yeah, this assigns

209
00:20:42,360 --> 00:20:49,360
X again to what value do you think? Whatever X was, which was four, plus three. So it should

210
00:20:50,320 --> 00:20:56,920
be seven. So because I'm in the REPL here, I type an expression, I hit enter, I get the

211
00:20:56,920 --> 00:21:01,120
result of that expression. Notice when there's an equal sign there, I'm doing an assignment,

212
00:21:01,120 --> 00:21:06,200
there isn't a result. It's just empty. That's one of the expressions in Python where Python

213
00:21:06,200 --> 00:21:13,200
doesn't see this as having a result. So if I'm maybe packing for PyCon, I've got two

214
00:21:13,200 --> 00:21:17,240
pairs of socks isn't quite enough at PyCon. I mean, the sponsors are generous at their

215
00:21:17,240 --> 00:21:22,760
booths. Socks are not so readily available. Shirts, you could come to Python. PyCon with

216
00:21:22,760 --> 00:21:29,760
one shirt. There are lots of shirts here. You probably do not want shorts this year.

217
00:21:30,760 --> 00:21:38,240
Something to wear. This here, socks equals, there's nothing after it. The REPL's not printing

218
00:21:38,240 --> 00:21:43,960
anything out. There's no result of this. But if I say socks plus shirts plus pants and

219
00:21:43,960 --> 00:21:50,480
I hit enter here, what am I going to see? Yeah, add two plus one plus three, we get

220
00:21:50,480 --> 00:21:56,360
six. So assignment from the REPL's perspective doesn't have a result. Pretty much any other

221
00:21:56,360 --> 00:22:01,160
expression you see it printed out there. All right. Again, we're just going to take

222
00:22:01,160 --> 00:22:04,880
a couple minutes here. We're going to try out some variables in the REPL. So just two

223
00:22:04,880 --> 00:22:09,360
minutes this time. And then we will finally be making a Python program after this. I promise

224
00:22:09,360 --> 00:22:14,440
we'll actually make a working Python script. Got questions during these couple minutes

225
00:22:14,440 --> 00:22:19,080
here? Stick up a red sticky. If you create a variable from the REPL, stick up a green

226
00:22:19,080 --> 00:22:26,080
sticky on your machine. All right. I know that was very quick. Some interesting

227
00:22:26,160 --> 00:22:33,160
things that we found. So if you make a variable, let's say it's x is two. I hit enter here.

228
00:22:36,880 --> 00:22:43,880
We see that x is two. If I say x plus two and I hit enter, I see four. What is x? Yeah,

229
00:22:50,640 --> 00:22:55,800
it's not a trick question. There will be trick questions. It's still two. How do I change

230
00:22:56,120 --> 00:23:03,120
x if I want it to become the result of that? Yeah, I need to say x equals. So this is a

231
00:23:04,040 --> 00:23:07,720
very common thing you'll see in Python, not just with plus, but with lots of operations.

232
00:23:07,720 --> 00:23:12,580
Lots of operations in Python give you a new thing back, but they don't change the object.

233
00:23:12,580 --> 00:23:16,660
We have two types of change in Python. There's changing a variable and then changing the

234
00:23:16,660 --> 00:23:21,560
value that variable happens to be pointing to. We're not going to get into the fact that

235
00:23:21,560 --> 00:23:26,920
in Python variables and objects are two distinct things, but they are. I'll link you to an

236
00:23:26,920 --> 00:23:31,760
article on that later. It's a big and scary topic. You mostly don't have to know about

237
00:23:31,760 --> 00:23:35,360
your first couple years of using Python because Python typically pushes you in the right direction

238
00:23:35,360 --> 00:23:42,360
of reassigning variables when you need to reassign them. All right. We're going to be

239
00:23:42,400 --> 00:23:47,820
making our own Python programs here. So what I'm going to do here, by the way, what you're

240
00:23:47,860 --> 00:23:51,460
seeing with this split screen situation I have going on, which you probably don't have

241
00:23:51,460 --> 00:23:58,220
on your machine, I'm using something called TMUX, Terminal Multiplexer. It allows me to

242
00:23:58,220 --> 00:24:04,380
have up one terminal and in the same window, physical window on my machine, another terminal.

243
00:24:04,380 --> 00:24:09,880
I happen to use a text editor. It is a very confusing text editor. Anyone want to guess

244
00:24:09,880 --> 00:24:16,880
what it's called? Vim, Emacs. I like these confusing text. There are multiple confusing

245
00:24:17,400 --> 00:24:24,400
text editors. The one I'm using is Vim. So I'm using Vim. I do not want you to use Vim.

246
00:24:26,040 --> 00:24:29,120
Something nice about Vim, though, is that I can show it on the screen easily at the

247
00:24:29,120 --> 00:24:36,120
same time as my code editor. So when you see something that looks like this, where it says

248
00:24:37,120 --> 00:24:40,800
greetings.py, it may be complaining about something, there's some line numbers, this

249
00:24:40,800 --> 00:24:45,760
is my text editor. You might have Visual Studio Code, you might have Notepad++, you might

250
00:24:45,760 --> 00:24:52,760
have Sublime Text. Who has a different editor installed? Edit? Oh, G-Edit, yep, or B-Edit,

251
00:24:55,440 --> 00:25:01,840
or there's a lot of them with that name, yep. Emacs. It's also PyCharm is another one. That's

252
00:25:01,840 --> 00:25:06,240
kind of an ID, that's a bigger one. So I'm using Vim here. It doesn't matter where you

253
00:25:06,240 --> 00:25:11,200
write this code, though. You're going to make a file called, ooh, I misspelled that. There

254
00:25:11,600 --> 00:25:18,600
will be a lot of misspellings today. Greetings.py is how I'm going to make this. And I'm going

255
00:25:18,600 --> 00:25:24,160
to type in here a string, hello world, and I'm going to save this file. Now, right now,

256
00:25:24,160 --> 00:25:30,520
from the Python REPL, if I type Python 3 greetings.py, anyone want to guess what might happen?

257
00:25:30,520 --> 00:25:37,520
We haven't tried this before. We get hello world, that's one option. What's another option?

258
00:25:38,360 --> 00:25:44,880
We get an error, always an option. What's another option? Nothing. We see nothing. Any

259
00:25:44,880 --> 00:25:51,880
other options? So when I hit enter, I get an error. It says invalid syntax. Why? Anyone

260
00:25:54,400 --> 00:26:01,400
want to take a guess? That's a good guess. In the wrong directory, yep. Yeah. So this

261
00:26:01,400 --> 00:26:08,400
is a very common problem. The answer here is that there are two places you can run code.

262
00:26:10,840 --> 00:26:15,240
There's the Python REPL. There's your system terminal, your system command prompt, your

263
00:26:15,240 --> 00:26:18,640
system shell, your system prompt, whatever you want to call that thing. I'm in the Python

264
00:26:18,640 --> 00:26:23,640
REPL. I can tell that within those three greater than signs here. I can exit the Python REPL.

265
00:26:23,640 --> 00:26:27,600
There's a function called exit. You put two parentheses after it. Hit enter. I'm back

266
00:26:27,600 --> 00:26:32,320
at my system command prompt. Depending on how you launch Python, you might exit my...

267
00:26:32,320 --> 00:26:38,000
It might close the window. If you bring up on Windows your command prompt or on Mac and

268
00:26:38,000 --> 00:26:44,080
Linux your terminal, this is where I want to be. Now, I see a dollar sign. That means

269
00:26:44,080 --> 00:26:48,160
I'm in my system command prompt. But I'm on Linux. Mac, you see a dollar sign typically

270
00:26:48,160 --> 00:26:53,000
as well. Windows, you typically see C colon backslash greater than. Some kind of greater

271
00:26:53,000 --> 00:26:57,200
than sign with something before it. This is my directory name. So greater than sign, dollar

272
00:26:57,200 --> 00:27:02,560
sign, whatever it is, it's at the beginning there. I can type Python3 greetings.py. Now,

273
00:27:02,560 --> 00:27:08,160
I want you to guess now. This is actually how you run a Python program or Python script.

274
00:27:08,160 --> 00:27:12,720
It's Python file name. We have to do it from our system command prompt, not from within

275
00:27:12,720 --> 00:27:20,200
the Python REPL. What do you think might happen now when I hit enter? It's your guess. Nothing

276
00:27:20,200 --> 00:27:27,200
again. Always an option. Could also be an error. Could print hello world. Yeah. Nothing.

277
00:27:33,960 --> 00:27:40,960
Why did nothing happen? Yeah, we didn't print anything, but I wasn't printing before. I

278
00:27:42,280 --> 00:27:46,920
mean, if I type... Let's go into the Python REPL and I type hello world. Why do I see

279
00:27:46,920 --> 00:27:53,920
hello world? Yep. Nothing's being outputted. Yes, it's not the full answer there, but you're

280
00:28:00,280 --> 00:28:05,120
absolutely right. Up here, nothing's being outputted to standard out. Something is here.

281
00:28:05,120 --> 00:28:12,120
Why? I didn't ask it to do that.

282
00:28:16,920 --> 00:28:23,240
Yeah, so the REPL, read, evaluate, print, and loop, it is printing out the result of

283
00:28:23,240 --> 00:28:28,400
this expression. Now, it's printing out the programmer readable representation. If I use

284
00:28:28,400 --> 00:28:32,560
the print function, it's built in the Python. We'll talk about functions in just a moment.

285
00:28:32,560 --> 00:28:37,880
Print open parenthesis, something, close parenthesis. There's no quotes. So, this is showing the

286
00:28:37,880 --> 00:28:42,560
user readable, the human readable representation. Not that programmers aren't humans, but we

287
00:28:42,560 --> 00:28:46,960
want to see things that other humans might not want to see, like those quotes there.

288
00:28:46,960 --> 00:28:52,200
We need to do that in our program. So, at the Python REPL, there's P in the name. It's

289
00:28:52,200 --> 00:28:58,100
printing the result of every single evaluation. In a Python program, nothing gets printed

290
00:28:58,100 --> 00:29:02,600
unless you ask it to print explicitly, or unless you run a function that's going to

291
00:29:02,600 --> 00:29:09,600
ask it to print. So, we need to tell it or ask it here to print out hello world. All

292
00:29:09,760 --> 00:29:16,760
right. So, we're in our Python program. Now, when we run it, got to run it with Python

293
00:29:18,080 --> 00:29:25,000
3 greetings.py, hit enter, it prints hello world. So, it took us a little while, but

294
00:29:25,000 --> 00:29:29,920
we finally made hello world. It's just one line of code in Python, but we've got our

295
00:29:29,920 --> 00:29:35,720
first Python program here. So, I would like you now to try to make your first Python program.

296
00:29:35,720 --> 00:29:40,040
It can be hello world. I actually have two other recommendations on the website. Each

297
00:29:40,040 --> 00:29:47,040
of them involves downloading a file called rand.py. I'll show you what rand.py has in

298
00:29:52,440 --> 00:29:56,800
it real quick here as you download it on the website there. I'll put up here where we are

299
00:29:56,800 --> 00:30:03,800
on the website. Again, that's pycon2023.py.dev under scripts. And we'll go ahead and download

300
00:30:05,720 --> 00:30:12,720
it. We are at script exercises, very bottom of the page there. So, that rand.py file,

301
00:30:15,480 --> 00:30:20,240
it looks like this. It's got in there import random. We haven't talked about import yet.

302
00:30:20,240 --> 00:30:27,240
Random.randint, 1 in 100. What could I do if I wanted to see the value of x here? That's

303
00:30:28,200 --> 00:30:35,200
your guess. Yeah, print x. Let's see what x is. So, we'll run python3 rand.py. And we

304
00:30:41,160 --> 00:30:47,160
see x printed out. It's 60. Who thinks it's going to be 60 again? Yeah, it seems like

305
00:30:47,160 --> 00:30:52,360
there's randomness going on. So, you can play with this, see if you can figure out what

306
00:30:52,360 --> 00:30:56,140
it does, and see if you can figure out how to make a six-sided die roll. So, make your

307
00:30:56,140 --> 00:31:00,060
own program called die or dice, whatever you'd like to call it. On the website there

308
00:31:00,060 --> 00:31:07,060
are some instructions. There's another exercise after that for a meditative breathing exercise

309
00:31:07,060 --> 00:31:11,300
that involves figuring out how to stop doing something for a couple seconds and start doing

310
00:31:11,300 --> 00:31:16,620
it again. When you work through the first exercise, you make a random roll of a dice,

311
00:31:16,620 --> 00:31:22,100
put up a green sticky. If you need some help, put up a red sticky if you have a question

312
00:31:22,100 --> 00:31:29,100
or anything at all. So, not done quite yet, but a couple notes for folks at home, some

313
00:31:30,020 --> 00:31:36,580
of the issues we're having here. When you were running your code, you're trying to launch

314
00:31:36,580 --> 00:31:40,820
your program. If you're in the Python REPL, to get back to your system command prompt,

315
00:31:40,820 --> 00:31:46,080
you can usually type exit, exit, open, close parenthesis. Also, you might sometimes be

316
00:31:46,080 --> 00:31:51,620
in a different directory or folder. So, wherever you saved that file, you need to get into

317
00:31:51,620 --> 00:31:56,340
that directory. So, you can use the CD command to change directories. There's also a shortcut

318
00:31:56,340 --> 00:32:00,980
on Windows, which unfortunately I can't demonstrate here because I'm not on Windows. In Windows

319
00:32:00,980 --> 00:32:06,100
Explorer, you can go up to the top location or URL bar, click on it and type cmd and hit

320
00:32:06,100 --> 00:32:13,100
enter. It launches the command prompt in that directory there. What did you learn? Anyone

321
00:32:13,100 --> 00:32:20,100
find anything unexpected? I know there were some glitches and unexpected things, in particular,

322
00:32:23,820 --> 00:32:30,820
editors or IDEs or some folks who were in the browser found interesting things. Yep?

323
00:32:32,340 --> 00:32:39,340
Yeah, this is an interesting one. So, what was said there was instead of Python 3 rand,

324
00:32:43,460 --> 00:32:49,060
that didn't work. You have to put rand.py to actually get it to run, which is interesting

325
00:32:49,060 --> 00:32:55,900
because on Windows, sometimes you can also just type rand or rand.py and it will run.

326
00:32:55,900 --> 00:33:00,060
But if you put the Python 3 before it, it doesn't. So, depends on your operating system,

327
00:33:00,060 --> 00:33:07,060
but whenever you're typing it this way, you've got to put the full file name. That's a good

328
00:33:07,620 --> 00:33:13,380
thing. So, let's do this first one together. The meditative breathing one I know is a little

329
00:33:13,380 --> 00:33:20,380
bit bigger. We may take a look at that one together later. This first one here, rolling

330
00:33:20,580 --> 00:33:27,580
a die, what did you do to modify this to make it like a dice roll? Yeah, change the number.

331
00:33:30,100 --> 00:33:36,940
So this first number 1 is a good one. Yeah, change 100 to 6 there. So, I called this rand.py

332
00:33:36,940 --> 00:33:43,940
here. Let me rename this file to, actually I'll copy this file I guess to die.py because

333
00:33:46,940 --> 00:33:53,940
we're rolling a single die. So, if we need a dice roll, we've got a dice roll. Rolls

334
00:33:54,140 --> 00:34:01,140
a random number from 1 to 6 there. So, this is a nice one. So, this is a nice one. So,

335
00:34:07,100 --> 00:34:11,060
so far when we've been using Python here, we've been doing things entirely within the

336
00:34:11,060 --> 00:34:17,500
Python process. We haven't looked at any files. We haven't asked the user any questions. We've

337
00:34:17,500 --> 00:34:22,100
only been outputting things. For those of you, I know at least a couple of you have

338
00:34:22,100 --> 00:34:29,100
taken a Python tutorial at some point before. How can you prompt a user to ask them a question?

339
00:34:29,580 --> 00:34:32,380
Anyone know? There's a function in Python that's built in. I know a couple of you have

340
00:34:32,380 --> 00:34:39,380
probably seen. Yeah, so this function, it's not called prompt, though that would be a

341
00:34:39,860 --> 00:34:46,860
nice name for it, to prompt the user. Instead, we're asking the user for input. And actually

342
00:34:49,860 --> 00:34:54,220
before I talk about that, I want to talk about what functions are real briefly here. I'm

343
00:34:54,220 --> 00:35:00,740
going to start up a new Python rebel. So, we've already used a function. What function

344
00:35:00,740 --> 00:35:06,620
have we used besides input? Yeah, print. We've been printing things. So, print takes one

345
00:35:06,620 --> 00:35:11,700
argument or you can even give it multiple arguments. An argument is these things that

346
00:35:11,700 --> 00:35:17,540
go in the parentheses. So, a function has a name. After it, you put parentheses. What

347
00:35:17,540 --> 00:35:23,580
happens if you don't put parentheses? Anyone ever tried this before? What's your guess?

348
00:35:23,580 --> 00:35:30,580
What might happen? Yeah, we could get an error. Always a possibility. What else might happen?

349
00:35:30,740 --> 00:35:37,740
See nothing at all. Maybe it'll print nothing. Yep. Get a description of the print function.

350
00:35:39,940 --> 00:35:45,700
That's an odd guess. I feel like maybe you've done this before. We do. We get a description

351
00:35:45,700 --> 00:35:52,220
of the print function. The reason is in Python, everything is an object. We've got a name.

352
00:35:52,220 --> 00:35:56,740
That's a variable. Functions aren't any different from variables we make. Now, they're different

353
00:35:56,740 --> 00:36:01,900
in the sense that there's a function object. Functions do a thing. A string doesn't do

354
00:36:01,900 --> 00:36:07,900
a thing. It stores things. It's got some characters. Function does a thing. The way we use this,

355
00:36:07,900 --> 00:36:11,140
the way we use a number, maybe we add the number, maybe we multiply the number, lots

356
00:36:11,140 --> 00:36:15,060
of ways to use it. There's one way to use a function. What's the way to use a function?

357
00:36:15,060 --> 00:36:21,180
There was a verb I used a moment ago. What was the verb? Call. You call a function. Now,

358
00:36:21,180 --> 00:36:25,180
it's not the only verb, but it's just one thing you can do. You can call a function,

359
00:36:25,180 --> 00:36:31,860
evaluate a function, execute a function. We call it with parentheses. Put print, parentheses.

360
00:36:31,860 --> 00:36:36,420
You give it whatever you'd like to give it. Now, if I put nothing in those parentheses,

361
00:36:36,420 --> 00:36:42,780
your guess is right. It does nothing. Well, sort of. It prints out a new line, because

362
00:36:42,780 --> 00:36:48,380
print always puts a new line at the end. There's also a function called help. We can pass print

363
00:36:48,380 --> 00:36:54,420
to help to ask for help on the print function, which is a little weird. So help in parentheses

364
00:36:54,740 --> 00:36:59,740
print. We're giving it the print function. And it tells us print takes any number of

365
00:36:59,740 --> 00:37:04,060
arguments. That's what that little star thing means there, which we haven't explained and

366
00:37:04,060 --> 00:37:09,980
I won't explain. That's just a special syntax in Python. There's an optional sep, an end,

367
00:37:09,980 --> 00:37:14,580
and file, and flush. We mostly don't care about these. But we could actually make it

368
00:37:14,580 --> 00:37:21,140
not print a new line if we wanted to. Then it really does nothing. So arguments in Python,

369
00:37:21,140 --> 00:37:24,820
there's two types of arguments. We'll mostly be working with one type. There's positional

370
00:37:24,820 --> 00:37:28,420
arguments and keyword arguments, or named arguments. That's where you've got something

371
00:37:28,420 --> 00:37:37,420
equals. We've been using positional arguments. Print name. Or print, we give it two arguments,

372
00:37:37,420 --> 00:37:43,260
hello, comma name. It prints out hello, puts a space in between, which we can also customize

373
00:37:43,260 --> 00:37:50,260
if we wanted, and then my name. What other functions have you seen in Python? I know

374
00:37:52,620 --> 00:37:59,620
I've seen a couple of you call functions in your terminal there, your REPL.

375
00:38:02,820 --> 00:38:08,940
The comma, yeah, well actually comma doesn't make the position argument. Comma makes an

376
00:38:08,940 --> 00:38:13,820
argument. You've got argument, another argument. If it's just a comma, positional arguments.

377
00:38:13,820 --> 00:38:18,860
But if it's a keyword argument, what do we put? What's the symbol you see with a keyword

378
00:38:18,860 --> 00:38:24,700
or named argument? An equal sign. If I wanted to change the separator between these, instead

379
00:38:24,700 --> 00:38:31,300
of being space, hello, space tray, it's dash. You make it a dash. Or maybe comma space.

380
00:38:31,580 --> 00:38:38,580
We're going to put a bunch of things here. You put comma space between each of them.

381
00:38:40,140 --> 00:38:43,580
You can also change the end there. Instead of new line, maybe we can make it two new

382
00:38:43,580 --> 00:38:48,600
lines. That backslash in represents a new line character. The reason is, what happens

383
00:38:48,600 --> 00:38:53,220
if I make a new line? What's the key I hit on my keyboard to make a new line character?

384
00:38:53,220 --> 00:39:00,220
Yeah, enter. What does enter do? It runs the code. So we need something to represent in

385
00:39:01,300 --> 00:39:07,220
a new line character. Backslash in. That was a weird one that I just did there. Let's type

386
00:39:07,220 --> 00:39:12,980
that again. So if I do hello name, I change end. Its default is backslash in. If I make

387
00:39:12,980 --> 00:39:19,980
it nothing, what happened? Yeah, it stuck three greater than signs after my name. Sort

388
00:39:23,700 --> 00:39:27,540
of. It didn't stick those there. It always puts three greater than signs. There was no

389
00:39:27,540 --> 00:39:31,140
new line. And so two lines are just kind of smooshed on top of each other. So now I'm

390
00:39:31,140 --> 00:39:36,260
typing Python code right after the end of what kind of looks like a prompt. Because

391
00:39:36,260 --> 00:39:40,580
it just didn't print a new line. We asked it not to. So other functions that I know

392
00:39:40,580 --> 00:39:47,580
a couple of you have seen, how can you take a string and turn it into a number? Yeah,

393
00:39:50,580 --> 00:39:54,260
turn it into an integer like this. There's two kinds of numbers in Python, though. What's

394
00:39:54,260 --> 00:40:00,820
the other kind of number? Yeah, I haven't talked about this. If you have a decimal point

395
00:40:00,820 --> 00:40:04,780
in a number, it's a floating point number. It actually works in a different way than

396
00:40:04,780 --> 00:40:11,060
an integer does. So two types of numbers. So there's also a built-in float function

397
00:40:11,060 --> 00:40:15,700
for turning into a floating point number. What if I have a number and I wanted to turn

398
00:40:15,700 --> 00:40:22,700
it into a string? Yeah, maybe there's a string function. Right, some of you have done a Python

399
00:40:22,700 --> 00:40:29,700
tutorial before. STR is how we spell string in Python. We like it short for some reason.

400
00:40:31,700 --> 00:40:37,420
It turns it into a string. So lots of built-in functions. There are I think 72, 71, somewhere

401
00:40:37,420 --> 00:40:40,660
in there are built-in functions. There's only a dozen or a couple dozen that are probably

402
00:40:40,660 --> 00:40:45,660
going to be practically useful for you in day-to-day coding. There's stir, there's

403
00:40:45,660 --> 00:40:50,820
int, there's float. There's a number of these things. We've also got print. We also have

404
00:40:51,060 --> 00:40:54,520
other functions that can live in other places. We can define our own functions, but there's

405
00:40:54,520 --> 00:41:01,340
also functions that can live in modules. So math is a module that's included with Python.

406
00:41:01,340 --> 00:41:08,340
This is called the Python standard library. It has a function in it called squirt. Square

407
00:41:08,340 --> 00:41:12,860
root. Yeah, that's what it's actually called, but it's spelled squirt. So if I give it a

408
00:41:12,860 --> 00:41:19,860
number, it gives us the square root of that number. So there's lots of modules in the

409
00:41:19,860 --> 00:41:23,900
Python standard library. There's third-party libraries as well. I have their own modules.

410
00:41:23,900 --> 00:41:28,960
There's functions in them, and we can call those functions the same way we use any function.

411
00:41:28,960 --> 00:41:33,220
What if I don't put parentheses after it and I hit enter? What do you think it might do?

412
00:41:33,220 --> 00:41:38,740
Yeah, kind of something similar to what print did. It doesn't do anything useful. It tells

413
00:41:38,740 --> 00:41:42,500
us this is a function object you're working with here. Same if you type a variable, you

414
00:41:42,500 --> 00:41:49,500
hit enter. It shows you what's in that variable. There's another type of function in Python.

415
00:41:49,860 --> 00:42:01,220
If I have a string, and I want to make that string lowercase, we don't have a lower function.

416
00:42:01,220 --> 00:42:05,780
There is a way to do this, though. I'm sure a couple of you might have seen this. Anyone

417
00:42:05,780 --> 00:42:10,500
remember, for those of you who've taken an intro to Python class before, what that is?

418
00:42:10,500 --> 00:42:19,500
Yep. It's a dot, right? Yeah, not lower.name, name.lower. So we're still calling a function

419
00:42:20,180 --> 00:42:26,420
here. We're still calling a function, but it's a function that lives on the name object.

420
00:42:26,420 --> 00:42:31,420
Name is a string, and every string has this lower thing on it, this lower function. Anyone

421
00:42:31,420 --> 00:42:36,820
know the name that a lot of programming languages really like this name, this distinction between

422
00:42:36,820 --> 00:42:40,020
this type of function and the other type of function? In Python, we do have this distinction,

423
00:42:40,020 --> 00:42:46,580
though we don't care about it as much. There's a word for this. Yep. Methods. Yeah. Something

424
00:42:46,580 --> 00:42:53,260
dot something. If there's parentheses after that second something, it's a method. So lower

425
00:42:53,260 --> 00:42:57,500
is a method that lives on the string type or the string class. You really don't need

426
00:42:57,500 --> 00:43:00,780
to care about that all that much. You can think of it as a function that lives on all

427
00:43:00,780 --> 00:43:07,220
strings. So it's just four strings. If I have x equals four and I say x.lower, what's your

428
00:43:07,220 --> 00:43:14,220
guess that might happen? So it worked on name. It might work on x. What type is x? Yeah,

429
00:43:23,860 --> 00:43:27,180
there's actually a built-in type function in Python. You can pass to it name, see that

430
00:43:27,180 --> 00:43:32,420
it's class str. You can pass to it x, see it's an integer. Pass 3.5 to it, see that

431
00:43:32,420 --> 00:43:39,420
it's a float. I said strings have a lower method. So you can say name.lower. X isn't

432
00:43:39,900 --> 00:43:45,900
currently a string. It's an integer. So if I call lower on it, we do get an error. There's

433
00:43:45,900 --> 00:43:51,700
no lower method on integers. So each type of object has its own methods. Eventually

434
00:43:51,700 --> 00:43:55,260
we talk about lists. You'll see there's an append method on lists. If you have your own

435
00:43:55,260 --> 00:43:59,820
custom class, you can have methods that are just for that class. It's a function that's

436
00:43:59,820 --> 00:44:06,820
attached to that type of object, only works on objects of that type. Yep? I like this

437
00:44:12,380 --> 00:44:16,760
question. There isn't, though anyone want to guess how we could get the first letter

438
00:44:16,760 --> 00:44:23,760
of a string? Yeah, does it start with something? There is actually a starts with method. So

439
00:44:24,780 --> 00:44:28,880
we can say does it start with p? Oh, it doesn't give us the first letter. We have to guess

440
00:44:28,960 --> 00:44:35,520
the first letter at that point. What else can we try to do? I like that name.fl. Doesn't

441
00:44:35,520 --> 00:44:41,440
work though. It's a good guess. Ooh, index. We haven't talked about that. Yeah. What does

442
00:44:41,440 --> 00:44:46,200
the index look like? What's the syntax for this? Yeah, a lot of programming languages

443
00:44:46,200 --> 00:44:51,280
have this. Not all of them. Name, open square bracket, zero, close square bracket, gives

444
00:44:51,280 --> 00:44:58,280
us p. Now strings aren't the only thing you can index. You can also index lists and anything

445
00:44:58,280 --> 00:45:03,840
that is a sequence, which is a fancy word for something you can index basically in Python.

446
00:45:03,840 --> 00:45:08,600
It has a length you can loop over. We'll talk about loops later and it can be indexed. So

447
00:45:08,600 --> 00:45:12,400
I haven't shown you all the things you can do with even strings, which are one of the

448
00:45:12,400 --> 00:45:19,400
most basic data types. But you absolutely can do things besides call methods. Indexing,

449
00:45:19,560 --> 00:45:26,560
concatenating, looping over them are mostly the things we haven't seen. Questions? Yep?

450
00:45:28,400 --> 00:45:35,400
Maybe. It depends on the function. So what type does the print function... This is a

451
00:45:35,400 --> 00:45:39,720
great question. So the question is a general function, not a method, a function that maybe

452
00:45:39,720 --> 00:45:43,800
lives at the top level of our code, not something dot something, just the function. Does it

453
00:45:43,800 --> 00:45:49,840
work with any type of object? We've been passing into print strings. Could I pass in a number

454
00:45:49,840 --> 00:45:56,840
to print? What's your guess? Maybe. It seems to work. Could I pass a print into print?

455
00:45:58,920 --> 00:46:05,920
No, this feels wrong, right? It seems like this shouldn't work. It works. It says built-in

456
00:46:10,120 --> 00:46:15,940
print function print. That's what happens when we type print and hit enter. So every

457
00:46:15,940 --> 00:46:23,060
object in Python can be converted to a string, even a function. Now, string representation

458
00:46:23,060 --> 00:46:26,840
is funny. It's not actually very useful. Every object can be converted to a string. So to

459
00:46:26,840 --> 00:46:33,320
answer your question, some functions accept any type of object. Stir is one of them. Print

460
00:46:33,320 --> 00:46:40,320
is also one of them, but not all of them. If I ask int to convert three, the string

461
00:46:40,360 --> 00:46:45,360
three to an integer, it says three. If I ask it to convert tray to an integer, what do

462
00:46:45,360 --> 00:46:52,360
you think it'll do? Could give us zero. Could give us the number of letters, maybe four.

463
00:46:52,360 --> 00:46:59,360
What else could it do? Yes, every letter in programming land is represented by a number.

464
00:47:06,480 --> 00:47:12,360
It's numeric. Called ASCII, or it was called ASCII. Now it's called Unicode because we

465
00:47:12,360 --> 00:47:18,440
have things besides just English characters, emoji and all foreign language characters,

466
00:47:18,440 --> 00:47:25,440
and many characters that are not languages of any sort in Unicode. So there might be

467
00:47:25,740 --> 00:47:30,040
some kind of adding up or using of those numbers that are under the hood that represent each

468
00:47:30,040 --> 00:47:36,240
of these. We get an error. So strings that aren't anything numeric, we actually get an

469
00:47:36,240 --> 00:47:42,640
error. So it's not even just the type. You can pass strings to int, but not all strings.

470
00:47:42,640 --> 00:47:47,560
But you can also pass some other things to int. You can pass 3.5 to turn it into an integer.

471
00:47:47,560 --> 00:47:54,560
It just lops off the .5. What about, could I pass int to int? I could pass print to print.

472
00:47:56,040 --> 00:48:01,800
It doesn't seem like you could convert a function to an integer, so no you can't. So to answer

473
00:48:01,800 --> 00:48:06,400
your question, sometimes yes, sometimes no. Some functions accept any type of object.

474
00:48:06,400 --> 00:48:10,200
Most of them don't. In fact, some of them don't even accept all objects of the same

475
00:48:10,200 --> 00:48:16,440
type. You can't always pass a string to int. Some of them just give you an error. Great

476
00:48:16,520 --> 00:48:17,520
questions. Other questions?

477
00:48:17,520 --> 00:48:24,520
What was that?

478
00:48:24,520 --> 00:48:35,520
Good question. So if I say 3 plus 2.5. 5.5 is what we hope for. Who thinks 5.5? That's

479
00:48:36,160 --> 00:48:40,360
your guess that Python's going to give us. Who thinks an error? Who thinks something

480
00:48:40,360 --> 00:48:43,360
else? I want to know what you think.

481
00:48:43,360 --> 00:48:50,360
5 or 6. It'll round it for us. Maybe it'll give us an integer. Maybe because the integer

482
00:48:50,480 --> 00:48:54,560
was first. If we flip them around, maybe it'll give us a float. I'm glad that Python doesn't

483
00:48:54,560 --> 00:48:59,800
work that way. We get 5.5. So yes, integer and float, you can always add together. It

484
00:48:59,800 --> 00:49:03,760
doesn't matter the order of them. You can always add them together. So the Python core

485
00:49:03,760 --> 00:49:07,940
developers actually had to do something special, some special magic to say, integers actually

486
00:49:07,940 --> 00:49:12,080
do not know how to add themselves to floats. Floats know how to add themselves to integers.

487
00:49:12,080 --> 00:49:16,000
However, an integer knows how to say, I don't know how to add myself to a float. Then Python

488
00:49:16,000 --> 00:49:19,840
goes over to the float and asks it if it knows how to add itself to the integer. It says,

489
00:49:19,840 --> 00:49:24,980
yes. All this happens under the hood and we can be grateful that it works. You can take

490
00:49:24,980 --> 00:49:30,560
a look at this yourself if you really wanted to. All objects have these things called Dunder

491
00:49:30,560 --> 00:49:36,760
methods, double underscore methods. This says not implemented. Integers do not know how

492
00:49:36,760 --> 00:49:42,480
to add themselves to floats. But there is a right-hand addition, which is the same as

493
00:49:42,480 --> 00:49:47,480
left-hand addition. You can do it in either direction, does the same thing. Floats know

494
00:49:47,480 --> 00:49:50,600
how to add themselves to integers. That's actually what's going on under the hood whenever

495
00:49:50,600 --> 00:49:54,680
you use the plus symbol in Python. Now, I'm showing you this not because you need to know

496
00:49:54,680 --> 00:49:59,160
it, but because we can be grateful that we don't have to know this. These are the nitty-gritty

497
00:49:59,160 --> 00:50:02,680
details of what's going on under the hood. In fact, you might see those sometimes. If

498
00:50:02,680 --> 00:50:07,240
you ask for help on an integer and you scroll down, if you go to the Python documentation,

499
00:50:07,240 --> 00:50:12,800
you'll see these same things. All these scary-looking double underscore methods, these are all implementing

500
00:50:12,800 --> 00:50:19,380
all the various operators in Python. Plus, equals, equals, equals to ask if two things

501
00:50:19,380 --> 00:50:24,680
are equal, which we haven't really talked about or seen yet there. All those are implemented

502
00:50:24,680 --> 00:50:29,360
and you can actually see them and control them on your own objects in Python.

503
00:50:29,360 --> 00:50:34,120
So back to the input function, the input function in Python. We can prompt a user for input,

504
00:50:34,120 --> 00:50:47,080
which I didn't actually show you. Someone shout out, what's your favorite color? I heard

505
00:50:47,080 --> 00:50:56,080
three. Green, okay. I was going to say three is an odd favorite color. Green. Although

506
00:50:56,160 --> 00:51:02,960
we could have typed three, Python wouldn't have cared. Color is a variable. We said color

507
00:51:02,960 --> 00:51:08,960
equals input and then it printed out what's your favorite color. I then typed green. What

508
00:51:08,960 --> 00:51:15,960
do you think color is right now? What type do you think it is? Yeah, it's a string. What's

509
00:51:17,840 --> 00:51:24,840
your favorite number? I don't have one. Anyone have one? 42. It's a classic favorite number

510
00:51:24,840 --> 00:51:31,840
there. 42, we hit enter. What type do you think number is? Right. We're torn here. Is

511
00:51:32,760 --> 00:51:39,080
it an integer or a string? We typed in an integer, it seems like. It's a string. The

512
00:51:39,080 --> 00:51:46,080
reason is input, it doesn't make any assumption about what we're typing. Everything you get

513
00:51:46,440 --> 00:51:50,720
from user input starts as a string. Now, what could we do if we wanted to turn it into an

514
00:51:50,720 --> 00:51:57,720
integer? Yeah, we pass it to the int function. What is number now? I tricked you. It's a

515
00:52:00,200 --> 00:52:06,840
string still. Why is it still a string? Right, we're at the Python REPL. Tricky things are

516
00:52:06,840 --> 00:52:11,440
going on here. Int, the int function, we pass number to it, it gave us back an integer.

517
00:52:11,440 --> 00:52:16,640
What did I not do with that thing it gave us? I didn't store it anywhere. We see the

518
00:52:16,640 --> 00:52:23,640
result printed out. If I wanted to save, what could I do? Yeah, assignment. Number equals

519
00:52:24,120 --> 00:52:27,440
if I want to use the same variable or make a new variable if I wanted to. It doesn't

520
00:52:27,440 --> 00:52:31,920
really matter. It's up to us how we want to do this. Now it's actually an integer. You'll

521
00:52:31,920 --> 00:52:38,920
sometimes see people do this. We use input. You can actually take the result of input

522
00:52:39,680 --> 00:52:46,680
and pass that to a function. I'll show you what I mean by that. Int and then in parentheses

523
00:52:47,840 --> 00:52:53,720
input. How does Python run this? What do you think it does first? Does it run int first

524
00:52:53,720 --> 00:53:00,720
or input? It has to run input first. It actually has to go from the inside out here. Because

525
00:53:02,520 --> 00:53:07,400
in order for us to know what to even turn into an integer, input has to run. So first

526
00:53:07,400 --> 00:53:14,040
we'll prompt the user for input. Then they'll type in a number and then it turns it into

527
00:53:14,040 --> 00:53:18,760
an integer. So you can nest function calls, but it does run them from the inside out as

528
00:53:18,760 --> 00:53:24,920
it would have to if you're taking the result and passing it to another function. Questions

529
00:53:24,920 --> 00:53:31,920
or thoughts? Yep?

530
00:53:37,400 --> 00:53:44,400
Yeah, so I'll try to repeat the question here. So there's a thing called type coercion

531
00:53:56,400 --> 00:54:00,440
that some programming languages have. The notion where you've got an operation. It happens

532
00:54:00,440 --> 00:54:05,780
on different types. Then the programming language magically figures out how to convert one type

533
00:54:05,780 --> 00:54:10,260
to another for the purpose of the operation actually working. It's automatic type conversion

534
00:54:10,260 --> 00:54:15,760
or type coercion. We don't really have that in Python, but this still seemed to work.

535
00:54:15,760 --> 00:54:19,740
So it is true we don't have this automatic type conversion in Python. You know, when

536
00:54:19,740 --> 00:54:26,740
we said three, a string plus a number, what happened? Yeah, it loudly failed. It didn't

537
00:54:29,140 --> 00:54:33,460
work because we don't have this thing, this automatic type coercion that other languages

538
00:54:33,460 --> 00:54:40,460
have. Now, how could we have fixed this if we have n equals two? That doesn't work. What

539
00:54:42,220 --> 00:54:49,220
could I do here though? How could I? Because I can add two strings together. How could

540
00:54:49,540 --> 00:54:56,540
I turn n into a string? Yeah, pass it to the str function. So you're right that we do have

541
00:54:57,220 --> 00:55:04,220
to go out of our way quite frequently to explicitly convert from one type to another, but not

542
00:55:04,220 --> 00:55:11,220
always. And the reason is some types know, like floats, for example. Floats, it's very,

543
00:55:11,980 --> 00:55:16,980
very common to add an integer to a float. So common that the float type in Python has

544
00:55:16,980 --> 00:55:22,100
decided, if you give me an integer, I know how to work with it. And so it's possible

545
00:55:22,100 --> 00:55:28,000
for a type of object to take it upon itself to not do automatic type coercion so much

546
00:55:28,000 --> 00:55:33,280
as say, I know how to work with objects besides just myself. In fact, we've seen this. A number

547
00:55:33,280 --> 00:55:38,900
multiplied by what? What was the thing? It wasn't a string. It was a string multiplied

548
00:55:38,900 --> 00:55:44,820
by not a floating point number. It had to be an integer. So in this case, strings know

549
00:55:44,820 --> 00:55:50,620
how to work with an integer with multiplication, but not with even strings. So it's sometimes

550
00:55:50,620 --> 00:55:54,180
the case they know how to work with multiple types, sometimes only the same type, sometimes

551
00:55:54,180 --> 00:55:57,820
only a different type. It's up to the object, though. So you're right, it does seem like

552
00:55:57,820 --> 00:56:01,940
it kind of goes against that idea of we don't have automatic type conversion, but it doesn't

553
00:56:01,940 --> 00:56:06,740
fully go against the idea. Yeah, good question. A little bit of an in the weeds question,

554
00:56:06,740 --> 00:56:10,620
but it's something you'll see happen often in Python is that idea of we've got to convert

555
00:56:10,620 --> 00:56:17,620
between types quite a bit. So I'm going to make a program here called add.pos. And I'm

556
00:56:20,660 --> 00:56:29,660
going to add the...the graded funding to this program, so there goes this gaura number in

557
00:56:33,220 --> 00:56:40,220
our example. i AND IP FUCKING NONE. Not even a faulty exact number. And here in the

558
00:56:40,300 --> 00:56:47,380
terrible idea of we start to, like, look at an example of an index, and as people see,

559
00:56:47,380 --> 00:56:48,980
a series of actual numbers appears.

560
00:56:48,980 --> 00:56:55,360
strings. So this is another problem in Python, plus works on multiple types of things. If

561
00:56:55,360 --> 00:56:58,900
they both happen to be strings, Python's happy. It's not going to complain. If they both have

562
00:56:58,900 --> 00:57:03,720
any numbers, Python's happy. If one's a number and one's a string, it's unhappy. How do we

563
00:57:03,720 --> 00:57:10,940
fix this in our case? Yeah, we can convert them. Ooh, I like that. We could put it up

564
00:57:10,940 --> 00:57:18,460
here or we could put it down here. Which is the right way to do it? It's a true question.

565
00:57:18,460 --> 00:57:22,900
There isn't a right way to do it. We can do it either way. So let's do it down here. Just

566
00:57:22,900 --> 00:57:27,420
because we did do it at the top before, doesn't really matter where we do it. As long as at

567
00:57:27,420 --> 00:57:33,860
the point where that plus operation is happening, we end up with two numbers. We'll do 7 and

568
00:57:33,860 --> 00:57:41,340
13 again. And it works this time. We get 20. All right. I would like you to try to make

569
00:57:41,340 --> 00:57:48,380
another Python program here. I'm going to give you too long for this one. And does anyone

570
00:57:48,380 --> 00:57:56,820
know when the break is? 1230. No, not that break. I will figure out when the break is

571
00:57:56,820 --> 00:58:02,580
during this break here. Because what happened in a past year, we decided to take a break

572
00:58:02,580 --> 00:58:07,160
a little bit later and all the food was gone. I would rather take a break on time because

573
00:58:07,160 --> 00:58:14,000
we want food. Yeah, food or drinks there. All right. So I'll give you seven minutes

574
00:58:14,000 --> 00:58:22,920
to try this out. On the website where we're at is input. We're on input doing input exercises

575
00:58:22,920 --> 00:58:31,160
at PyCon 2023.pym.dev there. So any questions at all? Put up a red sticky. If you get through

576
00:58:31,160 --> 00:58:36,240
the first exercise, which is printing out the number of things you need for a party

577
00:58:36,240 --> 00:58:40,880
based on the number of guests that you have and different numbers of things in packages,

578
00:58:40,880 --> 00:58:49,680
if you get through that first exercise, put up a green sticky on your machine. We have

579
00:58:49,680 --> 00:58:55,320
two minutes left. But I'm going to change things up here. I want you to stop what you're

580
00:58:55,320 --> 00:59:00,800
doing entirely. You're in the middle of something. I'm forcing you to stop whatever you're doing.

581
00:59:00,800 --> 00:59:06,480
And we're instead going to take a break to go eat because there is food and drink out

582
00:59:06,480 --> 00:59:11,440
there right now. And then afterward we will come back and you'll continue what we're doing.

583
00:59:11,440 --> 00:59:19,600
How long is the break meant to be? I like how everyone who thinks that everyone who

584
00:59:19,600 --> 00:59:24,000
should know how long the break is, we don't know how long the break is. Last year. I thought

585
00:59:24,000 --> 00:59:27,960
it was 15 minutes. I couldn't remember if it was 15 or 30. 30 felt too long. We're going

586
00:59:27,960 --> 00:59:32,960
to do a 15 minute break. This is not an exercise break though. I actually do want you to get

587
00:59:32,960 --> 00:59:36,160
up away from your machine. Even if you're not getting food and drink, walk around to

588
00:59:36,160 --> 00:59:41,120
the room. Take a stretch. You need to let your brain not think about Python for a minute

589
00:59:41,120 --> 00:59:48,120
or so maybe. So we've got a 15 minute stretch break. And then we will get back to it with

590
00:59:48,120 --> 00:59:55,120
a few minutes writing some code. If you've got questions in the meantime, feel free to

591
00:59:55,120 --> 00:59:55,960
ask.

592
01:00:02,960 --> 01:00:11,600
So we're done with our break break, but we're still in an exercise break. So I'm going to

593
01:00:11,600 --> 01:00:17,280
give you a few more minutes here to keep working with input, keep working with the programs

594
01:00:17,280 --> 01:00:22,120
you're working on there. I did want to note there are more exercises in each section than

595
01:00:22,120 --> 01:00:26,520
I expect you to possibly get through. So don't feel like you need to get through every exercise.

596
01:00:26,520 --> 01:00:31,440
Try out the first one. If you get done with it, try out the next one. As many as you can

597
01:00:31,480 --> 01:00:36,960
get through there. But you're always welcome to try them again later. If you have questions,

598
01:00:36,960 --> 01:00:40,960
stick up a red sticky. If you get done with the first exercise, you end up prompting the

599
01:00:40,960 --> 01:00:47,960
user for input, put up a green sticky. We'll get back to it in a few minutes here.

600
01:00:52,600 --> 01:00:57,400
All right. We are going to get back to it. We're doing pretty well on time here. A little

601
01:00:57,400 --> 01:01:03,880
bit more behind than I expected, but that's all right. Always the case. So I want to mention

602
01:01:03,880 --> 01:01:07,880
real quick, there will be resources linked on the website. They are not linked now, so

603
01:01:07,880 --> 01:01:12,000
as not to distract you. And also because I keep thinking of more resources I want to

604
01:01:12,000 --> 01:01:17,240
link as you are asking great questions on Python. One I want to link you to right now,

605
01:01:17,240 --> 01:01:23,160
though, because it might actually be helpful for some of the exercises. Tray.io slash built-ins,

606
01:01:23,160 --> 01:01:29,680
all one word. That will redirect you to a blog post I wrote a long time ago. Well, actually

607
01:01:29,680 --> 01:01:33,440
not so long ago. I've updated it recently. On the built-in functions in Python, which

608
01:01:33,440 --> 01:01:39,120
ones to learn first, which ones to learn next. It's about 25 I recommend committing to memory

609
01:01:39,120 --> 01:01:43,560
at the point where you actually write in Python code frequently. Or don't commit them to memory,

610
01:01:43,560 --> 01:01:48,720
just open up that blog post every time you need to use Python. And again, there are about

611
01:01:48,720 --> 01:01:52,200
70 built-in functions in Python. You don't need to memorize them. You don't need to know

612
01:01:52,200 --> 01:01:58,000
most of them. Most working Python programmers only know two or three dozen of them. It will

613
01:01:58,000 --> 01:02:04,560
get you many years of happy Python programming just knowing a couple dozen Python built-ins.

614
01:02:04,560 --> 01:02:09,720
So we've got some input from the user so far. We've printed things out to the screen. What

615
01:02:09,720 --> 01:02:16,680
if we had not done that would be an interesting thing to do with a program? The possibilities

616
01:02:16,680 --> 01:02:21,840
we might take our coding skills to next. We haven't done number crunching really outside

617
01:02:21,840 --> 01:02:27,920
of just basic math. We haven't talked about any data structures yet. But what about things

618
01:02:27,920 --> 01:02:34,000
getting stuff from outside of our program or putting things outside of our program?

619
01:02:34,000 --> 01:02:38,080
Passing arguments to our program, that might be something we could do to control it. What

620
01:02:38,080 --> 01:02:47,120
about if we have lots of data? How could we get the data into our program? Yeah. Right,

621
01:02:47,640 --> 01:02:53,640
a database. Yeah. Or we could go to the Internet, do an HTTP request and say I want to go to

622
01:02:53,640 --> 01:02:59,940
this website and download this thing. So we're going to talk about files. Now usually when

623
01:02:59,940 --> 01:03:03,700
people talk about files in Python, I want to note that there is a function that's built-in

624
01:03:03,700 --> 01:03:08,600
called open. We're not going to talk about that. The reason we're not going to talk about

625
01:03:08,600 --> 01:03:13,040
that is open involves opening a file. Then you have to worry about do I need to close

626
01:03:13,040 --> 01:03:16,800
the file? How do I get things into the file or out of the file? Do I want to read it?

627
01:03:16,800 --> 01:03:20,960
Do I want to write it? Instead, I'm going to show you a few lines of code that will

628
01:03:20,960 --> 01:03:25,200
seem a little bit magical but they're a little bit easier to get started with. The first

629
01:03:25,200 --> 01:03:31,560
one we're importing a type of object called path. Like a string, like an integer, like

630
01:03:31,560 --> 01:03:36,120
a float. It's a type of object, a class is what it's called, called path with a capital

631
01:03:36,120 --> 01:03:43,120
P from Python's path lib module. So this line we type first, that's our magical incantation

632
01:03:43,200 --> 01:03:50,200
to get access to path. Now I have a file, well I don't actually have it, I'm going to

633
01:03:50,200 --> 01:03:57,200
download it right now, called declaration of independence.txt, which has the declaration

634
01:03:59,920 --> 01:04:04,480
of independence in it. It has the text of this document in this file. Now it's a TXT

635
01:04:04,480 --> 01:04:09,240
file, it's not a Word document. If I wanted to open up a Word document, I'm going to have

636
01:04:09,240 --> 01:04:13,280
a little bit of trouble because Word documents have, they're actually binary files, it's

637
01:04:13,280 --> 01:04:20,280
not just plain text. Each type of file needs a separate mechanism for handling that file

638
01:04:20,680 --> 01:04:27,680
type. An Excel file, a docx file, a TXT file, a CSV file, a JSON file, whatever that file

639
01:04:27,800 --> 01:04:32,380
type is, you need to handle it in a different way, it's a different format. Text files are

640
01:04:32,380 --> 01:04:39,180
by far the easiest, it's kind of the non-format format file, kind of like the non-copyrighted

641
01:04:39,180 --> 01:04:44,260
copyright. You can take a work and say my license is it doesn't have a license. This

642
01:04:44,260 --> 01:04:48,460
is saying I don't even have a type to this file, it's just raw text. So we're going to

643
01:04:48,460 --> 01:04:54,780
open up this file here by using not the built-in open function, which is what you'll usually

644
01:04:54,780 --> 01:05:00,420
see in Python tutorials, but we're going to make instead a path object. So this object

645
01:05:00,420 --> 01:05:07,420
here, it's a POSIX path, anyone know what POSIX means? Anyone who's done some system

646
01:05:08,420 --> 01:05:13,940
administration stuff in the past might have seen POSIX before. There's NT path and POSIX

647
01:05:13,940 --> 01:05:19,300
path. NT path you'll see on Windows, Windows NT, which no one talks about anymore, but

648
01:05:19,300 --> 01:05:25,220
we still have that verbiage. POSIX path is anything but Windows basically, Linux path,

649
01:05:25,220 --> 01:05:31,100
Mac path, it's Unix, Unix or Linux. So I see a POSIX path on Windows, it'll just say NT

650
01:05:31,100 --> 01:05:36,580
path, same thing, that would say path object. So to get stuff out of this, to get the entire

651
01:05:36,660 --> 01:05:42,980
file as a string, I can say dot, read text, what is that called again when I say something

652
01:05:42,980 --> 01:05:48,620
dot and then there's parentheses? Yeah, method, which is just a function that lives on that

653
01:05:48,620 --> 01:05:53,340
path object. Since it's a function, I have to call it. If I don't have the parentheses,

654
01:05:53,340 --> 01:05:57,580
I instead see this bound method thing. I don't want that, I want those parentheses. So I've

655
01:05:57,580 --> 01:06:04,580
got our path object dot read text. Now what I get back, its type is str. It's actually

656
01:06:09,340 --> 01:06:14,420
a string that represents everything in this file. If I were to print it, I see the entire

657
01:06:14,420 --> 01:06:20,780
file printed out there. So I'm going to type all that again, show you what I did there.

658
01:06:20,780 --> 01:06:27,260
Three lines. The first line you only have to do once. So I already did it, doesn't need

659
01:06:27,260 --> 01:06:32,100
to be done again. Second line is getting a reference to that path and then the third

660
01:06:32,100 --> 01:06:38,180
line is taking that path, storing it as a string. The entire file is now a string. Now

661
01:06:38,180 --> 01:06:41,540
we don't know how to work with files or we haven't up to now, but we know how to work

662
01:06:41,540 --> 01:06:46,900
with strings. We've used them a little bit. Now that we have a string, we can work with

663
01:06:46,900 --> 01:06:52,040
that string just like we've been working with them before. What if I wanted to write some

664
01:06:52,080 --> 01:06:59,080
text to a file? So I'm going to say let's make a file called PyCon 2023.txt. Call this

665
01:07:03,600 --> 01:07:10,600
our PyCon path. And I want to say this file here, it should have the text, yay PyCon in

666
01:07:11,480 --> 01:07:18,480
it. How can I do that, do you think? What's your guess?

667
01:07:22,480 --> 01:07:27,360
Maybe the write text method? Yeah, so this doesn't work. There's lots of aspirational

668
01:07:27,360 --> 01:07:31,400
thinking I could do here. I could say maybe plus works, maybe there's another symbol that

669
01:07:31,400 --> 01:07:37,360
works. Read text worked before, let's try write text. PyCon path dot, instead of read

670
01:07:37,360 --> 01:07:44,360
text, we'll say write text and we'll give it this string here. Yay PyCon. Nine. And

671
01:07:52,360 --> 01:07:59,360
why did we get nine? Yeah, there's nine characters in this string. So Python thought it would

672
01:08:00,360 --> 01:08:06,920
helpfully tell us nine. Sometimes you get really weird results from functions. This

673
01:08:06,920 --> 01:08:11,560
is sometimes useful if you want to know how many things you wrote to a file. This is pretty

674
01:08:11,560 --> 01:08:16,960
much there for historical reasons. The notion of writing back in the C world often, how

675
01:08:16,960 --> 01:08:20,000
many bytes did I write out to this file is a thing you sometimes want to know. We're

676
01:08:20,000 --> 01:08:24,080
just going to ignore that nine, we don't care about it. The thing we care about is

677
01:08:24,080 --> 01:08:31,080
in my text editor, I can now see this file. If I list my directory, my folder here, I'll

678
01:08:32,320 --> 01:08:37,320
see this PyCon2023.txt file. So we just wrote it out. So the two things you can do with

679
01:08:37,320 --> 01:08:43,120
pathlib there, read files and write files. There was a question earlier. Or anyone have

680
01:08:43,120 --> 01:08:48,120
a question, maybe I answered it already.

681
01:08:50,920 --> 01:08:57,120
So two things. Here's reading from the file. And then if we wanted to write something different

682
01:08:57,120 --> 01:09:04,120
to the file. Yep.

683
01:09:09,600 --> 01:09:14,600
Great question. Yeah, this is implicitly in our current working directory. So that means

684
01:09:14,600 --> 01:09:18,640
when you run any program on your computer, doesn't matter if it's Python or another program,

685
01:09:18,640 --> 01:09:24,280
there's a directory or a folder that it thinks it's inside of. You can change that directory

686
01:09:24,280 --> 01:09:28,680
it thinks it's inside of. Sometimes you do, sometimes you don't. But if we had a file

687
01:09:28,680 --> 01:09:34,720
that was in a different directory, what could we do, do you think? We've got to tell it

688
01:09:34,720 --> 01:09:38,960
where it is. Yeah, we could give it an absolute path. I could say, for example, well, actually

689
01:09:38,960 --> 01:09:45,960
this is in home tray. It's in a different directory. Or maybe it's in the root directory

690
01:09:45,960 --> 01:09:50,640
on my computer or something. So I could give it a different directory there and instead

691
01:09:50,640 --> 01:09:55,280
write to that directory in that path. Or I could use dot dot, which means the directory

692
01:09:55,280 --> 01:10:01,800
above me, or some A slash B that would be the A directory, the file B below me. So yes,

693
01:10:01,800 --> 01:10:08,800
implicitly it's the current directory. Other questions?

694
01:10:12,280 --> 01:10:15,120
All right, well, you're going to play with pathlib a little bit here with reading and

695
01:10:15,120 --> 01:10:20,280
writing from files and working with strings that are stored in files. Where's our read

696
01:10:20,280 --> 01:10:27,280
text here? By the way, what do you think will happen when we write text to a file that already

697
01:10:30,920 --> 01:10:37,160
exists? It's your guess, it might happen. It could overwrite it entirely, it could add

698
01:10:37,160 --> 01:10:42,680
to the end, let's see. So right now, this file has yay PyCon in it. If I write PyCon

699
01:10:42,680 --> 01:10:46,760
exclamation exclamation, and I go and I refresh it, that's what we see. So yes, it did and

700
01:10:46,760 --> 01:10:53,480
completely overwrite it. If you wanted to add to the end, there isn't an append text.

701
01:10:53,480 --> 01:10:56,120
There could be, but they haven't made one. What could you do if you wanted to add to

702
01:10:56,120 --> 01:11:03,120
the end of a file? Right, read the file, concatenate something to that string to make a new string

703
01:11:07,360 --> 01:11:10,980
that's got the stuff at the end, write it back out to the file. You can always manually

704
01:11:11,260 --> 01:11:15,060
add stuff to the end of a file that way. And in fact, that's what you will want to do for

705
01:11:15,060 --> 01:11:22,060
the very first exercise in this section. It's called jot. So under files, file exercises,

706
01:11:22,980 --> 01:11:28,220
this is, as you'd expect, the most challenging exercise we've done so far. There is a little

707
01:11:28,220 --> 01:11:33,900
bit of a helper you can copy paste there. It involves taking the current date, printing

708
01:11:33,900 --> 01:11:38,940
that to a file. We're also prompting the user and asking them, it's basically like a daily

709
01:11:38,940 --> 01:11:43,700
journal. You type out a thought that you have and it sticks to the end of the file, the

710
01:11:43,700 --> 01:11:48,580
current date, and the thought that you have there. And I'm going to give you at least

711
01:11:48,580 --> 01:11:52,300
ten minutes on these exercises here to try this first one out. There are a couple other

712
01:11:52,300 --> 01:11:56,240
exercises after it, but I'm guessing jot will probably take you a little while. If you get

713
01:11:56,240 --> 01:12:01,700
through jot, if you get most of the way through it, stick up a green sticky on your machine.

714
01:12:01,700 --> 01:12:05,500
So take down those green stickies because I know you haven't got through it yet. If

715
01:12:05,700 --> 01:12:09,980
you need some help, you find yourself stuck, put up a red sticky. We'll come by and help

716
01:12:09,980 --> 01:12:14,060
you out. And I'm guessing more of you than before will need help on this one, so please

717
01:12:14,060 --> 01:12:21,060
don't hesitate to put up a red sticky if you get yourself stuck for 30 seconds or so.

718
01:12:23,380 --> 01:12:27,540
So I know the website's a little confusing the way it explains this. I gave you a starting

719
01:12:27,540 --> 01:12:33,100
script that doesn't do what you want yet. It prints out the current date. It does prompt

720
01:12:33,100 --> 01:12:37,780
the user. It doesn't write to a file. Not only that, it doesn't print anything useful

721
01:12:37,780 --> 01:12:40,820
yet. It doesn't print anything out that's useful yet. It doesn't write to the end of

722
01:12:40,820 --> 01:12:45,260
a file, certainly. You now need to figure out how can you take that working code that

723
01:12:45,260 --> 01:12:50,020
does kind of the wrong thing but something in the right direction and make it read from

724
01:12:50,020 --> 01:12:54,860
a file, write to a file, stick the current date in there. So again, when you find yourself

725
01:12:54,860 --> 01:12:58,100
stuck, which is probably going to happen at some point here, put up a red sticky. And

726
01:12:58,100 --> 01:13:02,100
I'm going to give you a few more minutes as well. When you finish this, stick up a green

727
01:13:02,100 --> 01:13:09,100
sticky. All right. I know I didn't give you a lot of time, but we're going to do this

728
01:13:15,420 --> 01:13:20,540
together. So very few green stickies up. That means most of us are still working on this,

729
01:13:20,540 --> 01:13:26,740
and that is okay. We're going to use our collective knowledge to see what we've learned so far.

730
01:13:26,740 --> 01:13:30,580
For those of you who have green stickies up or you're most of the way through or you finished

731
01:13:30,580 --> 01:13:34,580
it and forgot to put the green sticky up, maybe don't answer my questions right now

732
01:13:34,580 --> 01:13:38,460
because you already know some of the answers. Those of you who haven't quite got all the

733
01:13:38,460 --> 01:13:43,460
way through it, maybe you'll have some complementary knowledge. Some of you figured out different

734
01:13:43,460 --> 01:13:47,780
things probably here. I know some of you did as I was wandering around. So we're going

735
01:13:47,780 --> 01:13:53,620
to make a new file, jot.py. We're going to copy paste into it these three lines that

736
01:13:53,620 --> 01:13:57,780
were on the website. Now, they don't do what we want yet. We know they don't do what we

737
01:13:57,820 --> 01:14:02,220
want, but it's a starting point. It does prompt us. Now, it's a funny prompt. It just shows

738
01:14:02,220 --> 01:14:09,220
greater than we're expected to know now that this is a prompt. You can type, it's the first

739
01:14:09,420 --> 01:14:16,420
day of PyCon, and I'm teaching. If I hit enter, just like when we used input before, the result

740
01:14:20,300 --> 01:14:27,300
of input, where does that go? Yeah, it actually goes in that variable user message. What are

741
01:14:27,340 --> 01:14:34,340
we doing with user message? Nothing right now, so let's print it out. We are printing

742
01:14:34,380 --> 01:14:39,380
something though. It happens to be today's date, so let's do that again. I'll say at

743
01:14:39,380 --> 01:14:46,180
PyCon. Ah, so now we see at PyCon and today's date. We've got a variable. The variable does

744
01:14:46,180 --> 01:14:53,180
seem to work. It got the input from the user, and we got the current date. How do we make

745
01:14:53,780 --> 01:15:00,780
a string that has the date colon the message? We're not working with a file yet, but we're

746
01:15:00,860 --> 01:15:07,860
supposed to stick that at the end of a file. How can I make a string like that? I'll call

747
01:15:07,900 --> 01:15:14,900
this the line, the line that we stick in the file. Well, we're not going to work with a

748
01:15:14,900 --> 01:15:21,900
path yet, but how could I get the current date in here, do you think? We're printing

749
01:15:25,060 --> 01:15:30,060
the current date. What do I need to do to this line to make it useful for storing in

750
01:15:30,060 --> 01:15:37,060
a variable? Yeah, so could I say line equals this thing? What's your guess? Yeah, maybe

751
01:15:37,060 --> 01:15:44,060
remove the print. Do you think it'll work with the print? Maybe. So it's prompting us.

752
01:15:51,020 --> 01:15:58,020
I'll type A. That's interesting. It printed, the first thing we printed, we asked it to

753
01:15:58,860 --> 01:16:04,900
print the current date in the same line as this line thing here. Then we got none. We

754
01:16:04,900 --> 01:16:10,460
haven't talked about none yet. There's a default return value for every function in Python.

755
01:16:10,460 --> 01:16:16,380
Typically functions return something useful. Print doesn't return anything. It does something.

756
01:16:16,380 --> 01:16:21,140
Functions tend to either do a thing or return a thing. Print does a thing. It shows something

757
01:16:21,140 --> 01:16:25,560
to the screen. So it doesn't return anything. So we get none, and then it shows A. So let's

758
01:16:25,560 --> 01:16:31,860
remove that print as was suggested there. Try that again. Type B. So we see the date

759
01:16:31,980 --> 01:16:38,980
and B. B is our user message. Let's remove that. So we do see the date. Okay, so we want

760
01:16:41,100 --> 01:16:48,100
it to look like this though. Date, colon, and then our message. So how do we do that?

761
01:16:48,100 --> 01:16:55,100
What are we going to type on this line here? Plus, we want to concatenate. What do we want

762
01:16:55,100 --> 01:17:02,100
to do with? Colon, space, and then user input. Oh yeah, what's missing? Right. So if we run

763
01:17:05,940 --> 01:17:10,940
this right now, we get a syntax error. We need quotes there to make this into a string.

764
01:17:10,940 --> 01:17:17,940
Does that work? It didn't do anything because I didn't print anything. Let's try it again.

765
01:17:18,940 --> 01:17:25,940
Ah, user message. Right, wait. And also it said user input. Why didn't it actually show

766
01:17:26,020 --> 01:17:33,020
what I typed? If I type tray or I type type, it says user message instead. Right, user

767
01:17:34,380 --> 01:17:41,380
message is inside the quote. Okay, so we got colon, space in our quote. Concatenate again.

768
01:17:41,860 --> 01:17:45,580
So you can concatenate just like if you say two plus three plus four, you can add three

769
01:17:45,580 --> 01:17:52,580
numbers together. You can concatenate three strings together. There is a way to do it.

770
01:17:58,300 --> 01:18:03,380
I'm going to show you how to do it. I'm not expecting you to memorize it, but it is called

771
01:18:03,380 --> 01:18:10,380
an F string. It looks like this. An F string is basically flipping string concatenation

772
01:18:10,380 --> 01:18:17,380
on its head. So string concatenation, I described, what did I describe it as? String concatenation.

773
01:18:18,340 --> 01:18:25,340
Right, this. It's this. It's smushing things together. This is called string interpolation.

774
01:18:26,380 --> 01:18:31,580
It's not smushing together. It's more of sticking inside of. We're saying we've got a big string

775
01:18:31,580 --> 01:18:36,180
we're building up. We want to inject into it a couple things. Those things in the curly

776
01:18:36,180 --> 01:18:40,400
braces are the little bits of code that give us the thing to stick in there. You notice

777
01:18:40,400 --> 01:18:45,540
we don't have to convert these things to a string. That's optional. It will convert them

778
01:18:45,540 --> 01:18:49,300
to a string for us. So we'll do it this way. That's for the fun of it just because we've

779
01:18:49,300 --> 01:18:55,740
seen this. All right, we've got our line in the right format. How do we get it in our

780
01:18:55,740 --> 01:19:02,740
file? Yeah, we need to write to the file. We need to write to the file. So we need to

781
01:19:06,180 --> 01:19:13,180
import. So can I say jot dot txt dot write text line? Read pathlib from pathlib import

782
01:19:17,740 --> 01:19:21,900
path. We'll put that line. So this is called an import. You tend to see these at the very

783
01:19:21,900 --> 01:19:26,500
top of a file. All the things you're importing come first. Kind of like you're declaring,

784
01:19:26,500 --> 01:19:30,440
here are all the things I need. Okay, now let's use those things. So we've got this

785
01:19:30,560 --> 01:19:36,460
path thing we can use just as we have this date thing that we're using. So if I say path

786
01:19:36,460 --> 01:19:43,460
jot dot txt, will this work here? Path equals this thing. We'll call this a jot path. What

787
01:19:46,220 --> 01:19:53,220
method did we have on these path objects for writing to them? Yeah, write text. So let's

788
01:19:53,820 --> 01:20:00,820
try to give it our line. So instead of printing it out, we'll try to write to the file. Oh,

789
01:20:05,180 --> 01:20:09,940
do we not need quotes? Well, what's your guess? When I hit enter, what do you think might

790
01:20:09,940 --> 01:20:16,940
happen? Sounds like your guess is you think it'll be an error. It wasn't an error. Oh,

791
01:20:16,940 --> 01:20:23,940
it was an error. So a problem in Python, or in Python, I guess in Python as well, sometimes

792
01:20:28,500 --> 01:20:33,300
Python's running your code and it's fine, and then suddenly it's not fine, and the error

793
01:20:33,300 --> 01:20:38,940
blows up later. You can't always tell if your program starts that it is in fact correct.

794
01:20:38,940 --> 01:20:45,000
Now it didn't loudly complain here until we got to jot dot txt. This is actually valid

795
01:20:45,000 --> 01:20:51,360
Python syntax. What is it interpreting this as? Yeah, variable. It thinks, oh, jot's a

796
01:20:51,360 --> 01:20:56,440
variable. It must have an attribute called txt. An attribute is something dot something.

797
01:20:56,440 --> 01:21:00,000
If there's parentheses, it's a method. It's a function attached to something. We haven't

798
01:21:00,000 --> 01:21:04,960
talked about attributes, but they do exist in Python. Something dot something. So we

799
01:21:04,960 --> 01:21:09,080
need to put quotes around here for Python to see that as a string. It's not supposed

800
01:21:09,080 --> 01:21:16,080
to be a variable lookup. It did something. What should it have done? How do we know whether

801
01:21:16,280 --> 01:21:23,280
it worked? Right. Do we have a file called jot dot txt? We do. Let's open it up, see

802
01:21:28,600 --> 01:21:35,600
what's in it. It says we're a PyCon. When we run it again, what is it supposed to do?

803
01:21:36,000 --> 01:21:43,000
What is it meant to do again? Yeah, it's supposed to add to the end. So if I say we're at PyCon,

804
01:21:45,160 --> 01:21:52,160
we're going to eat lunch. It didn't add to the end. It completely overwrote the file.

805
01:21:52,160 --> 01:21:59,160
How can I get it to add to the end? What could we try to do here maybe? Yep?

806
01:22:05,600 --> 01:22:12,520
Right. So read the file. We're not giving anything to it. It will get back, though,

807
01:22:12,520 --> 01:22:19,520
the contents of the file. Say contents, and you're saying concatenate here the contents

808
01:22:19,520 --> 01:22:26,520
with our line and then write it out. Maybe like that. See if it works. At PyCon still.

809
01:22:35,600 --> 01:22:42,600
And then we'll look at our jot dot txt file. Well, that was weird. What happened there?

810
01:22:47,320 --> 01:22:52,360
It didn't put it on a new line. What else happened? It's the same message twice. At

811
01:22:52,360 --> 01:22:59,360
PyCon still, at PyCon still. Okay. So let's look at our code here. We've got our path.

812
01:23:00,000 --> 01:23:07,000
We're writing to the file. We read from it, but we just wrote to it. So we overwrote our

813
01:23:08,120 --> 01:23:11,960
file. So that might be where our problem is here. Instead of making guesses, though, I

814
01:23:11,960 --> 01:23:18,960
want to show you a function called breakpoint. Usually folks don't show new programmers breakpoint.

815
01:23:19,200 --> 01:23:22,920
I think new programmers should probably know about breakpoint, even though a warning here,

816
01:23:22,920 --> 01:23:27,720
this is going to be scary, because we're going to enter the Python debugger. So you've got

817
01:23:27,720 --> 01:23:31,280
your code editor, the Python repel, your system command prompt, and now there's a fourth

818
01:23:31,280 --> 01:23:36,080
thing we have to worry about, the Python debugger. The Python debugger, it acts kind of like

819
01:23:36,080 --> 01:23:43,080
the Python repel, though it's not quite the same. We're going to type at PyCon. What seems

820
01:23:44,540 --> 01:23:51,540
to happen here? What do we see? It's different than before. We see a path here. Home tray

821
01:23:52,540 --> 01:23:59,540
PyCon 2023, jot.py. What else? There's a number nine. Jot path equals, this looks like Python

822
01:24:04,980 --> 01:24:11,980
code. Yeah, this is the next line in the file after breakpoint. We're actually stepping

823
01:24:12,680 --> 01:24:19,680
through our Python program here. So in the Python debugger, you can do things like this.

824
01:24:21,540 --> 01:24:26,900
Kind of like at the repel, for example, I can say jot path. Just like at the repel,

825
01:24:26,900 --> 01:24:31,060
it shows me, it would show me what's in that variable, except I don't have a jot path variable

826
01:24:31,060 --> 01:24:36,100
yet, because that's defined on the next line of code. It's defined right here. It hasn't

827
01:24:36,100 --> 01:24:40,900
been defined yet. However, I do have a line variable. That's the line. To go to the next

828
01:24:40,900 --> 01:24:47,900
line of code, we can type n. We just ran this line of code, which means we should have a

829
01:24:48,380 --> 01:24:55,380
jot path variable, and we do. So we're actually interactively running our program. Kind of

830
01:24:55,380 --> 01:24:59,860
like how at the Python repel, we're interactively working with Python, typing lines of code

831
01:24:59,860 --> 01:25:05,460
and seeing results. We've basically injected ourselves into this program. We put the program

832
01:25:05,460 --> 01:25:11,380
on pause and said we want to run the next line of code. We're going to poke around.

833
01:25:11,380 --> 01:25:16,620
Don't run the next line of code yet until we ask you to. So right now, our path, we've

834
01:25:16,620 --> 01:25:23,500
got our path defined. If we say read text, this is what's in that file. This is what

835
01:25:23,500 --> 01:25:30,500
was there before. If I run the next line of code, the line that ran was this write text

836
01:25:32,540 --> 01:25:37,180
line. We're now just about to run the read text line. So we've now written to the file.

837
01:25:37,180 --> 01:25:44,180
If we read text, this is what's now in the file. We just overwrote the whole file. So

838
01:25:44,180 --> 01:25:47,300
we're going to run the next line of code. So I want to mention the Python debugger break

839
01:25:47,300 --> 01:25:52,340
point, even though it is scary, because at some point, you may find that using print

840
01:25:52,340 --> 01:25:56,380
to debug your code isn't quite enough. It's kind of confusing sometimes to figure out

841
01:25:56,380 --> 01:26:00,900
what you even need to print. Sometimes you just wish you could drop into a Python repel.

842
01:26:00,900 --> 01:26:07,900
And in fact, this scary land here, we can make it slightly less scary by typing interact.

843
01:26:09,100 --> 01:26:12,860
Where are we now, do you think? What does this usually symbolize? Yeah, we're in the

844
01:26:12,860 --> 01:26:17,900
Python repel. Those three greater than signs mean we're actually in a real Python repel.

845
01:26:17,900 --> 01:26:22,860
In fact, there's a function called dir, tells you all your currently defined variables,

846
01:26:22,860 --> 01:26:27,300
all these ones that have underscores we just ignore. There's line, there's jot path, there's

847
01:26:27,300 --> 01:26:34,140
user message, there's date. So we can poke around and see those. If I type exit, it does

848
01:26:34,140 --> 01:26:38,580
actually, in fact, exit my whole program, which is unfortunate. I thought I was going

849
01:26:38,580 --> 01:26:43,140
to go back to the Python debugger, but we'll just ignore that fact. Anyways, break point

850
01:26:43,140 --> 01:26:47,500
is the way to start the Python debugger. The way to fix this program, has anyone seen it

851
01:26:47,500 --> 01:26:54,500
yet, the way we can fix this? We do need to read the file, we do need to write from it.

852
01:26:57,240 --> 01:27:02,840
We're writing twice, though. We're overwriting the file first. We need to read from it and

853
01:27:02,840 --> 01:27:07,780
then stick on the end and then write. Someone noted we're sticking a line of code on the

854
01:27:07,780 --> 01:27:14,780
same line as another line. How do we fix that? Yeah, we need a new line. So we need a little

855
01:27:15,900 --> 01:27:22,900
bit extra concatenation. What's the symbol we use for a new line? Backslash n. So the

856
01:27:23,420 --> 01:27:27,780
current contents of the file, let's stick a line at the end and then we'll put another

857
01:27:27,780 --> 01:27:34,780
line there. Oops. Let's run this code again. I'm going to remove break point.

858
01:27:37,780 --> 01:27:44,780
We have a problem. Leading zero in decimal. Not permitted. Oh, it's because I tried to

859
01:27:46,300 --> 01:27:53,300
run jot.txt, which is not a Python program. You can give files that are not py files to

860
01:27:53,420 --> 01:28:00,420
Python, it'll just try to run them as programs. Maybe it worked. Let's go look at jot.txt.

861
01:28:00,420 --> 01:28:07,420
At PyCon. At PyCon. All right, let's try it again. At lunch at PyCon. It worked. Now

862
01:28:13,900 --> 01:28:20,900
there is a possible problem in this program. If the file doesn't exist yet, what do you

863
01:28:21,140 --> 01:28:28,140
think might happen? Yeah, when we try to read from it, we could get an empty string back.

864
01:28:35,300 --> 01:28:42,300
It might also give us an error. Let's try it out. So we don't have an error yet. We

865
01:28:43,140 --> 01:28:48,400
do get an error. So I didn't show you how to fix this, but also the way to fix this

866
01:28:48,400 --> 01:28:52,320
is to make the file exist. And then your program magically works. Sometimes a workaround

867
01:28:52,320 --> 01:28:58,000
is a decent solution. One thing you could do, though, is you could look up on path objects

868
01:28:58,000 --> 01:29:03,160
in Python. How do you ask whether a path exists? There is actually a way to do that. So if

869
01:29:03,160 --> 01:29:10,160
jot path dot exists, there's also an is file. Is file versus is directory. Either one is

870
01:29:10,560 --> 01:29:17,560
a perfectly good way to do this. If it doesn't exist, set the contents to an empty string.

871
01:29:18,040 --> 01:29:23,280
I just used something we've never seen before. What is that? If else. Yeah. Let's talk about

872
01:29:23,280 --> 01:29:30,280
if else before we do, though. Any questions? Yep. Yep. Uh-huh. Good question. So the question

873
01:29:47,880 --> 01:29:53,200
is os.path is a thing you'll see on stack overflow results. You'll see it if you're

874
01:29:53,200 --> 01:29:58,400
looking at Python code that works with file paths. Pathlib is this newer thing. That's

875
01:29:58,400 --> 01:30:02,940
what you've heard. Is os.path going away? Is it being replaced by pathlib? What's going

876
01:30:02,940 --> 01:30:09,940
on there? The answer is os.path will probably never go away because lots of code uses it.

877
01:30:10,600 --> 01:30:15,120
It's just a lot of old code floating around. And there's no reason to make it suddenly

878
01:30:15,120 --> 01:30:20,400
disappear because it would just break things for no particularly good reason. Pathlib is

879
01:30:20,400 --> 01:30:24,120
very well supported by everything at this point, though. It's newer in the sense that

880
01:30:24,120 --> 01:30:29,600
it is much newer than os.path. It's not actually very new at this point, though. It's just

881
01:30:29,600 --> 01:30:36,600
not 20 years old. Well, os.path's even older than that, in fact. Also, pathlib is slower.

882
01:30:37,800 --> 01:30:43,240
If you are traversing your file tree and you're looking at thousands of files on your system,

883
01:30:43,240 --> 01:30:46,480
you'll notice that it's in different paths. Pathlib takes a little bit more time to make

884
01:30:46,480 --> 01:30:51,520
the path object because it's got some fancy methods attached. Os.path is all strings.

885
01:30:51,520 --> 01:30:55,760
Strings are fast, even though strings can be messy. So I would recommend pathlib over

886
01:30:55,760 --> 01:31:02,760
that os.path thing when you see it. They both work, though. A little bit of an in the weeds

887
01:31:03,560 --> 01:31:07,160
question, but I like those. You see stuff online, you want to know what the answer is.

888
01:31:07,160 --> 01:31:11,900
So I want to note here something I don't think I mentioned at the beginning. We're not going

889
01:31:11,900 --> 01:31:18,260
to learn all of Python today. You probably guessed this, but in three hours you can't

890
01:31:18,260 --> 01:31:22,540
possibly learn all of Python. Doesn't matter how advanced you are already in programming

891
01:31:22,540 --> 01:31:29,100
or in Python. We're only getting a taste for Python, which means we will see if and else

892
01:31:29,100 --> 01:31:34,620
in a moment. We'll see loops. We'll see lists. That's about where we'll end. Beyond that,

893
01:31:34,620 --> 01:31:38,700
there's functions, there's the standard library, there's modules, there's list comprehension,

894
01:31:38,700 --> 01:31:42,620
there's tuple unpacking, there's indexing, there's slicing. There are so many other

895
01:31:42,620 --> 01:31:48,940
features that exist in Python. They're all built pretty much on these features we're

896
01:31:48,940 --> 01:31:54,620
talking about today, though, for the most part. So we're going to talk now about if

897
01:31:54,620 --> 01:32:01,620
else. We're going to do it by using if else. So I just used if else to ask does a file

898
01:32:01,900 --> 01:32:06,980
exist. Before I talk about if else, I want to ask you, some of you have done some programming

899
01:32:06,980 --> 01:32:13,980
before, what do you think will happen when I hit enter? False. It's a funny guess if

900
01:32:15,500 --> 01:32:21,260
you've never done programming before. Zero equals equals one, false. But it is false

901
01:32:21,260 --> 01:32:26,860
with a capital F. We have in Python a variable false and a variable true. It's capital F

902
01:32:26,860 --> 01:32:33,860
false, capital T true. We don't have the lowercase ones. This is asking is zero equal to one?

903
01:32:34,860 --> 01:32:39,180
So, for those of you who knew this syntax, the answer is obvious. Zero is not equal to

904
01:32:39,180 --> 01:32:46,180
one. Equals equals is the way we say this. Why not equals? Yeah, this assigns something.

905
01:32:47,860 --> 01:32:52,460
Now, we can't assign to zero. So, in fact, in this case, it wouldn't be ambiguous. But

906
01:32:52,460 --> 01:32:57,100
if I said name equals tray and I wanted to ask, well, is name equal to tray? I can't

907
01:32:57,100 --> 01:33:01,900
do it this way. That's an assignment. Got to use equals equals. So you can use equals

908
01:33:02,180 --> 01:33:06,920
to ask is a string equal to another string? Is a number equal to a number? Could I ask

909
01:33:06,920 --> 01:33:11,820
is a string equal to a number? What's your guess? So you think the answer will be true

910
01:33:11,820 --> 01:33:18,820
or false? False. Yeah, it's not an error. In fact, equals equals shouldn't ever give

911
01:33:19,840 --> 01:33:24,980
you an error. Objects in general, just as all of them are supposed to have a good string

912
01:33:24,980 --> 01:33:29,980
representation of some sort, all of them should give you an answer with equality. Question?

913
01:33:29,980 --> 01:33:36,980
Ah, good question. So the reason there's quotes around my name, not around the number,

914
01:33:37,820 --> 01:33:42,660
there are two types of things. So I'm going to do it a different way. X equals zero, Y

915
01:33:42,660 --> 01:33:49,660
equals zero. Both of those worked. What's the type of Y? It's a number, specifically

916
01:33:50,220 --> 01:33:57,220
an integer. This is kind of the weird one. What's the type of X? Str, string. So this

917
01:34:01,620 --> 01:34:05,500
in Python, this is a problem you will run into a lot. Even after you've been doing

918
01:34:05,500 --> 01:34:10,340
Python for a while, it's hard to internalize the fact that there's really three things.

919
01:34:10,340 --> 01:34:15,900
There's variables, which are when we have something like X, right? X is a variable.

920
01:34:15,900 --> 01:34:19,620
It doesn't have quotes around it, but it has some characters in it. It represents a

921
01:34:19,620 --> 01:34:25,020
pointer to something. And then there's a string that's got quotes around it. You can think

922
01:34:25,020 --> 01:34:29,260
of it as literal characters. It's like the things you'd write on a piece of paper. When

923
01:34:29,260 --> 01:34:36,260
we don't have quotes around it, that's something special. It's either a number, or it's a variable,

924
01:34:37,340 --> 01:34:43,980
or it is a special syntax. This here, this is a string. This is not a string. It's called

925
01:34:43,980 --> 01:34:49,140
a list. The square brackets mean something. So whenever something's in quotes, you're

926
01:34:49,140 --> 01:34:54,180
making a string object, just literal characters. If it's not in quotes, something else special

927
01:34:54,180 --> 01:34:59,820
is going on. In our case, we're working with a number. Yeah, great question, which means

928
01:34:59,820 --> 01:35:06,820
X is zero, Y is zero. Is X equal to Y, do you think? False. They're both zero, but one

929
01:35:07,820 --> 01:35:14,820
is zero the string, one zero the number. Now, int of X, is that equal to Y? It is, and X

930
01:35:17,780 --> 01:35:22,980
equals equals str of Y, and it's also true. Converting them to the same type, then they're

931
01:35:22,980 --> 01:35:27,860
actually equal. So we don't just have equality in Python, we also have inequality. Anyone

932
01:35:27,860 --> 01:35:33,300
want to guess what inequality looks like? Yeah, so there's a few different ways that

933
01:35:33,580 --> 01:35:38,380
languages do this. Python doesn't do it this way. This is something different. This is

934
01:35:38,380 --> 01:35:43,460
division, actually. Division and assignment at the same time. That's confusing. Some languages

935
01:35:43,460 --> 01:35:48,100
also do this. In fact, Python 2 used to support this. It's kind of a SQL way of doing things.

936
01:35:48,100 --> 01:35:55,100
This is the way we do it in Python. Exclamation mark equals. It doesn't equal. We also have,

937
01:35:55,700 --> 01:36:01,300
as you'd hope, greater than is one greater than zero. We have greater than or equal to,

938
01:36:01,300 --> 01:36:06,780
less than or equal to. What about this? What's your guess? Could we ask is a string less

939
01:36:06,780 --> 01:36:13,780
than a string? Lots of yeses. What do you think it's going to do? Alphabetical, maybe?

940
01:36:14,580 --> 01:36:21,580
So you think it'll be true here? The size of the string, maybe. I don't know. It's true.

941
01:36:22,020 --> 01:36:29,020
So A comes before B in the alphabet. Okay, let's try it this way. We'll say A less than

942
01:36:30,020 --> 01:36:37,020
B. True or false or error? False. It is false. What about A less than lowercase b? Now we're

943
01:36:50,660 --> 01:36:57,660
confused. It's true. So it's true for a strange reason. All the capital A's in the alphabet

944
01:36:59,100 --> 01:37:06,100
capital letters come before all the lowercase letters. So if you're comparing two strings,

945
01:37:06,300 --> 01:37:10,340
you want to make sure that you're comparing them with the same case. Now I'm talking about

946
01:37:10,340 --> 01:37:15,700
strings. We're using just characters here. What about a string with multiple characters?

947
01:37:15,700 --> 01:37:22,700
Is this possible, do you think? What do you think it does? It kind of seems like it'd

948
01:37:23,940 --> 01:37:27,900
be like when you went through these old books we used to have. You'd flip through them.

949
01:37:27,900 --> 01:37:32,820
They had words and then they were called dictionaries. Now we go to dictionary.com, right? We don't

950
01:37:32,820 --> 01:37:37,500
care about alphabetical ordering on dictionary.com. You care about them in a dictionary. In alphabetical

951
01:37:37,500 --> 01:37:44,500
order, Apple doesn't come before animal. L-M-N-O-P. Animal comes before Apple. But case does matter.

952
01:37:49,980 --> 01:37:53,660
So even though the A is the same, it goes to the next letter and sees which one is less

953
01:37:53,660 --> 01:38:00,660
than the other one. What about special characters? Yeah, what about the number zero? Is that

954
01:38:02,020 --> 01:38:08,940
less than the letter A? We should probably ask ourselves, why are we asking this question?

955
01:38:08,940 --> 01:38:12,420
We're going to get a weird answer, right? It is going to be either true or false. Turns

956
01:38:12,420 --> 01:38:19,420
out it's true. That one's true as well. I believe zero is 48 on the ASCII table. It

957
01:38:20,220 --> 01:38:24,980
really comes, where does it come in the ASCII table? If it's an emoji character, it's usually

958
01:38:24,980 --> 01:38:30,300
at the end. If it's a digit, it's at the beginning. If it's a linguistic character, it's a non-English

959
01:38:30,300 --> 01:38:34,980
linguistic character. It's somewhere in the middle. So you want to be careful about what

960
01:38:34,980 --> 01:38:38,660
it is you're comparing when you're ordering your strings.

961
01:38:38,660 --> 01:38:43,500
All right. We're about to get to if statements. One more operator I'd like to show you. We

962
01:38:43,500 --> 01:38:48,020
talked about equals equals, not equals, comparing things with less than and greater than. If

963
01:38:48,060 --> 01:38:54,420
I want to ask whether my name has a Y in it, whether it contains a Y, what's your guess

964
01:38:54,420 --> 01:39:01,420
that I could do? Now, I want you to just guess, complete guess of what I could type in here.

965
01:39:01,420 --> 01:39:08,420
For those who don't know the answer, there could be a method, name dot, what would the

966
01:39:08,500 --> 01:39:15,500
method maybe be called? Contains? That's a good guess. Does it contain the string Y?

967
01:39:18,580 --> 01:39:25,580
There is no contains method. That's a good guess, though. Name dot in. Invalid syntax,

968
01:39:26,860 --> 01:39:32,900
that should signify something. There is a find method, which is interesting. It gives

969
01:39:32,900 --> 01:39:38,340
us an index. There's actually an operator in Python for doing this. What's the operator?

970
01:39:38,340 --> 01:39:44,340
I know some of you know this. Yeah, in. Most programming languages don't have this. Y in

971
01:39:44,340 --> 01:39:50,620
the name. Is Y in the name? It is in the name. Is Z in the name? That's false. This

972
01:39:50,620 --> 01:39:55,620
is case sensitive. Is T in the name? That's false because it's a lowercase t. Capital

973
01:39:55,620 --> 01:40:02,620
T is in there. We have in. What's the opposite of in? Out. Yeah. T out name. That didn't

974
01:40:07,100 --> 01:40:14,100
work. Yeah, not in. Wait, is there an operator with a space inside? Is that valid? Yeah,

975
01:40:14,500 --> 01:40:21,500
it is. Python core developers decided not space in is a valid operator. They went out

976
01:40:21,500 --> 01:40:25,700
of their way to make that work. All right. So let's finally use if statements. So we

977
01:40:25,700 --> 01:40:30,180
have the answer to a question. We get true or false. These are yes, no questions. In

978
01:40:30,180 --> 01:40:35,540
Python, it's very, very common to ask a question that has a yes or a no, and based on the result

979
01:40:35,540 --> 01:40:42,540
of that, you do something or you don't do something. So we can say the year is 1999.

980
01:40:42,540 --> 01:40:49,540
If the year is equal to 1999, is there syntax for an if statement in Python, colon, and

981
01:40:51,980 --> 01:40:58,980
then I hit enter, something weird happens. What happened that's kind of unusual? Yeah,

982
01:41:00,260 --> 01:41:06,900
we see three dots. We don't see three greater than signs. Python knows that there is more

983
01:41:06,900 --> 01:41:13,900
to come. That means there is a block of code. So who knows that Python indentation is somehow

984
01:41:14,540 --> 01:41:18,340
important in some way? This is something that people often complain about. Even if you've

985
01:41:18,340 --> 01:41:22,300
never used Python, you might hear people complain about the fact that indentation matters in

986
01:41:22,300 --> 01:41:26,940
Python. This is where we finally see that indentation matters. At the Python repl here,

987
01:41:26,940 --> 01:41:32,580
we could hit tab, space a few times, typically four spaces, although the tab key in your

988
01:41:32,580 --> 01:41:37,580
text editor will insert four spaces. We now can write some code. It could be one line

989
01:41:37,580 --> 01:41:44,580
or multiple lines. Let's write it's 1999. That's a bigger year. So we should party quite

990
01:41:46,200 --> 01:41:53,200
a bit. And then if we hit enter again, we still see three dots. What do we do? I mean,

991
01:41:53,200 --> 01:42:00,200
we could type more code, but what if we actually wanted to end? What's your guess? Yeah, for

992
01:42:05,480 --> 01:42:09,960
the few of you who've used the Python repl with multiple lines of code already, you have

993
01:42:09,960 --> 01:42:16,960
to hit enter again. So the reason for this, it's something specific to the Python repl.

994
01:42:17,460 --> 01:42:21,480
It doesn't know when we're done. What if some other programming language is used to say,

995
01:42:21,480 --> 01:42:28,480
here's a block of code and here's a start and the end? Yeah, a curly brace. So C, Java,

996
01:42:28,480 --> 01:42:32,520
JavaScript, some of these languages say if curly brace, then you're going. And then finally

997
01:42:32,520 --> 01:42:36,240
there's a closed curly brace. We don't have those in Python. It's all about indentation.

998
01:42:36,240 --> 01:42:41,440
The problem is with indentation, we don't know if our indentation is done until we've

999
01:42:41,440 --> 01:42:46,520
out dented our line of code. There is no out dent at the Python repl. So you've got to

1000
01:42:46,520 --> 01:42:50,560
hit enter twice. So this is specific to the Python repl. You've got to hit enter twice

1001
01:42:50,600 --> 01:42:54,920
to end your block of code when you're writing an if statement. So we don't just have if

1002
01:42:54,920 --> 01:43:00,920
in Python. This is if something's true, we run some code. If it's not true, if it's 2000

1003
01:43:00,920 --> 01:43:06,380
and we run this same bit of code again, it's not going to print anything because it's not

1004
01:43:06,380 --> 01:43:13,380
true. What do we do if we want it to do a different thing if it's not true? Else, yeah.

1005
01:43:13,460 --> 01:43:20,460
So we can say if the year is 1999, we do those same things as before. Right after that, else

1006
01:43:20,560 --> 01:43:25,560
and then a colon. There's no condition with an else. There is actually a way to add a

1007
01:43:25,560 --> 01:43:29,380
condition though optionally. You don't want to guess what the way to add an optional to

1008
01:43:29,380 --> 01:43:36,380
chain conditions is. Elif. Some languages call this else if or else if. None of them

1009
01:43:37,540 --> 01:43:43,700
call it elf for some strange reason. Some language should call it elf. We call it elif

1010
01:43:43,820 --> 01:43:50,820
for characters just like else. Elif, the year is less than 1999. I don't know what we type

1011
01:43:54,020 --> 01:44:01,020
here. It's still the 90s. Not quite time to party right. Otherwise, the party's over.

1012
01:44:01,020 --> 01:44:08,020
So it says the party's over because year right now is 2000. So this is pretty much

1013
01:44:15,460 --> 01:44:22,460
the, not the biggest elf, elf, the biggest if statement you'll see, but this is the biggest

1014
01:44:23,420 --> 01:44:26,860
style. This is all the things you can possibly throw in. There's if, there's elif, there's

1015
01:44:26,860 --> 01:44:33,860
else. If has to, or else has to have if before it. How many else's do you think you can have

1016
01:44:34,740 --> 01:44:41,340
on an if? Just one. How many elifs do you think you can have? Yeah, zero worked. You

1017
01:44:41,340 --> 01:44:45,100
don't have to have an elif just like you don't have to have an else. You can have lots of

1018
01:44:45,100 --> 01:44:49,180
them though. Elif, elif, elif. It has to come before the else though and in between the

1019
01:44:49,180 --> 01:44:54,700
if. So you always start with the if, end with the else if there is one, and you sandwich

1020
01:44:54,780 --> 01:45:01,380
elif in the middle if there are any elifs there. It does not, only elif. There is no

1021
01:45:01,380 --> 01:45:08,380
else if in Python. Now you could say else, indent, do another if, and indent further.

1022
01:45:08,380 --> 01:45:11,380
But you're going to have to indent even more if you did that. So technically yeah, you

1023
01:45:11,380 --> 01:45:14,620
could get something like else if. You can't do it on one line though. Like you couldn't

1024
01:45:14,620 --> 01:45:21,620
say C or Java or some other languages. Yep, I've been hitting four spaces here, but yeah,

1025
01:45:21,620 --> 01:45:28,620
you typically hit tab. Basically every text editor knows if you have a file open and ends

1026
01:45:28,660 --> 01:45:32,740
with .py, it should use four spaces. Four spaces is typically what we use in Python

1027
01:45:32,740 --> 01:45:36,660
to indent. You can technically use anything. If you really want to upset people, use three

1028
01:45:36,660 --> 01:45:43,660
spaces. Not quite right, but not wrong enough to notice easily. But four spaces is what

1029
01:45:44,500 --> 01:45:51,500
typically happens when you hit the tab key. Five spaces is also equally bad. So if you

1030
01:45:51,620 --> 01:45:54,820
want to do that, you can use the if statement. So we're now going to write some if statements.

1031
01:45:54,820 --> 01:45:58,420
I'd like you to, even if you don't write it at the REPL, you can write it in a text editor

1032
01:45:58,420 --> 01:46:03,620
and copy paste it in. I do want you to try copy pasting it into the REPL because it's

1033
01:46:03,620 --> 01:46:08,220
going to be frustrating. I don't want you to be frustrated, but I do want you to understand

1034
01:46:08,220 --> 01:46:13,860
that the REPL works a little differently than your text editor does. It's a little pickier

1035
01:46:13,860 --> 01:46:19,060
about whether there's, you've hit enter twice for example. Your indentation is going to

1036
01:46:19,060 --> 01:46:25,660
matter in both your text editor and the REPL. But when you find yourself making a mistake,

1037
01:46:25,660 --> 01:46:28,580
it's frustrating in the REPL because you have to start over. You have to type all the code

1038
01:46:28,580 --> 01:46:33,300
again. So type it in your text editor. Maybe copy paste it into the REPL so you don't get

1039
01:46:33,300 --> 01:46:38,060
too frustrated there. But try running it from the Python REPL. So try out some if statements.

1040
01:46:38,060 --> 01:46:45,060
We're on the website under conditionals. Conditional exercises. We have about a half an hour left

1041
01:46:46,060 --> 01:46:53,060
here. I think 12.15, I think is the time I should be stopping here because lunch is at

1042
01:46:53,060 --> 01:46:58,060
12.30. And we took a 15 minute break. Is my reasoning right there? Anyone want to correct

1043
01:46:58,060 --> 01:47:05,060
me? Calendar says to 12.30. Okay. The video may be a little bit longer. I'm fine going

1044
01:47:06,340 --> 01:47:12,620
until 12.30. Everyone fine with 12.30? Excellent. We'll go to 12.30 then. We might want to stop

1045
01:47:12,660 --> 01:47:17,820
like a couple minutes before just so we get a head start on lunch. But yeah, 12.30 basically

1046
01:47:17,820 --> 01:47:24,820
is when we'll stop. Oh, and if you find yourself stuck while you're writing an if statement,

1047
01:47:28,180 --> 01:47:32,380
probably it's a syntax error, but I want you to put up a red sticky and we'll try to help

1048
01:47:32,380 --> 01:47:36,980
you out. So put up a red sticky when you find yourself stuck. If you end up writing an if,

1049
01:47:36,980 --> 01:47:43,980
if statement or if statement rather successfully, put up a green sticky. So if you're trying

1050
01:47:49,260 --> 01:47:56,260
to take and ask two questions at the same time in Python, for example, is the year less

1051
01:47:56,420 --> 01:48:03,420
than 1999 or is the year greater than 1999? In other programming languages, suppose you've

1052
01:48:03,420 --> 01:48:10,420
done them before, how do you do or? Right, yeah, like this. This way, whatever that symbol

1053
01:48:12,260 --> 01:48:19,260
is. Nobody knows the name of that thing. This thing, it's called a pipe symbol. Year, or,

1054
01:48:20,140 --> 01:48:25,780
year. This doesn't work in Python. Anyone found out what this is, what we have to do instead?

1055
01:48:25,780 --> 01:48:32,220
Yeah, it's deceptively like English. Or. We have or and we have and. So if you find yourself

1056
01:48:32,220 --> 01:48:39,220
wanting to ask two questions at once, we've got or and we've got and. All right. I know

1057
01:48:47,180 --> 01:48:54,180
that wasn't long. But we are going to move on because we don't have too much time left.

1058
01:48:55,060 --> 01:49:00,820
We're going to move on to talk about finally our first data structure in Python. Anyone

1059
01:49:00,900 --> 01:49:04,940
want to guess what our first data structure is going to do? If those of you who've done

1060
01:49:04,940 --> 01:49:11,940
some programming, what is a data structure? I want to try to explain that. I'll give you

1061
01:49:13,700 --> 01:49:20,700
a hint. It's a structure and there's data involved. Yes, it stores data. A data structure

1062
01:49:21,620 --> 01:49:26,820
stores data. It's kind of boring. Data structure is really just a way of saying we've got some

1063
01:49:26,820 --> 01:49:32,060
stuff. It's not a string. It's not a number. Something more than that. Something more sophisticated.

1064
01:49:32,060 --> 01:49:37,300
And there's a common way we tend to want to work with it. The first data structure you

1065
01:49:37,300 --> 01:49:44,300
typically see in Python, the very most common one, is this. What do other programming languages

1066
01:49:45,020 --> 01:49:49,580
sometimes call this thing where you've got multiple things stored together in a particular

1067
01:49:49,580 --> 01:49:56,020
order? Yeah, an array or a list. In Python we call it a list. Some languages call it

1068
01:49:56,060 --> 01:50:00,820
an array, an array of things, a list of things. I kind of like list because it sounds like

1069
01:50:00,820 --> 01:50:07,320
a shopping list, a grocery list, a list of things. I might list things out. It's also

1070
01:50:07,320 --> 01:50:12,460
kind of a verb. This list, and we can check its type using the built-in type function

1071
01:50:12,460 --> 01:50:19,260
and confirm it is in fact a new type, class list. If we want to get the first thing in

1072
01:50:19,260 --> 01:50:24,580
this list, what could we try to do? I'll give you a hint. It's similar to when we got the

1073
01:50:24,580 --> 01:50:31,580
first character in a string. Yeah, square bracket. And then what do we put in there?

1074
01:50:31,580 --> 01:50:38,580
Yeah, why not one? We're programmers, so we start counting at zero for some strange reason.

1075
01:50:39,380 --> 01:50:42,780
There are good reasons for this, but we start counting at zero. That's the thing to internalize

1076
01:50:42,780 --> 01:50:49,780
to remember there. What if I put in 10? What's your guess? Could be an error. Could be nothing.

1077
01:50:49,900 --> 01:50:56,900
Yeah, what's the thing that represents nothing in Python? None. Turns out it is an error.

1078
01:50:58,060 --> 01:51:02,300
Sometimes we get none back, though getting an index of 10 on a list that doesn't have

1079
01:51:02,300 --> 01:51:06,220
10 things, that is an error. How could we find out how many things are in this list,

1080
01:51:06,220 --> 01:51:10,980
do you think? Yeah, somehow get its length. A lot of languages have this notion of you

1081
01:51:10,980 --> 01:51:17,380
take a list, you access a length attribute. A.B. is an attribute lookup. We don't have

1082
01:51:17,380 --> 01:51:24,380
a length attribute in Python. Right, we have len, but it's not a method. It's actually

1083
01:51:24,420 --> 01:51:31,420
a built-in function. So to get the len of something or the length of something, you

1084
01:51:31,980 --> 01:51:37,100
pass PyCon feelings to the length function. Kind of weird that it's a built-in function.

1085
01:51:37,100 --> 01:51:44,100
It doesn't live on the object. Why is that, do you think? What else might have a length?

1086
01:51:47,380 --> 01:51:54,380
Right, it might work with anything that you could count the number of. If it has a length

1087
01:52:00,540 --> 01:52:06,020
that's kind of a property, could be a generic property, we can index strings and lists.

1088
01:52:06,020 --> 01:52:11,260
It's not a method we use. We use square brackets as a special syntax. Kind of similar. We use

1089
01:52:11,260 --> 01:52:15,500
a special built-in function just as you can convert multiple things to an integer or a

1090
01:52:15,900 --> 01:52:22,060
You can get the length of multiple things. So if I say length of a string, we get the

1091
01:52:22,060 --> 01:52:25,580
length of the string. Now, the length of everything in Python is not four. Let's do something

1092
01:52:25,580 --> 01:52:31,580
that's not four. Length of an empty string is zero. Length of a list with, by the way,

1093
01:52:31,580 --> 01:52:35,900
you can have mixed things in a list. We have strings, we've got numbers. You can even mix

1094
01:52:35,900 --> 01:52:40,860
up your strings and numbers. Python really doesn't care about types all that much. We

1095
01:52:40,860 --> 01:52:47,860
practice something called, if I can find this here, this. You probably can't see it on the

1096
01:52:48,180 --> 01:52:55,180
recording. What is this little thing I'm holding up? A rubber ducky, which is also useful for

1097
01:52:56,300 --> 01:52:59,460
debugging your code, by the way. You can look up rubber duck debugging on Wikipedia. It

1098
01:52:59,460 --> 01:53:04,100
is a real thing. If you find yourself stuck and you're not in a room of myself and Melanie

1099
01:53:04,100 --> 01:53:09,300
and other people to ask questions to, talk to your rubber duck. It's not going to respond.

1100
01:53:09,940 --> 01:53:15,380
I mean, hopefully it won't respond. You've got other problems if it responds. Or you've

1101
01:53:15,380 --> 01:53:18,860
got maybe a talking, maybe it's good if it responds. It depends on the type of duck.

1102
01:53:18,860 --> 01:53:22,900
Talk to your rubber duck and just verbalizing the question will sometimes help you figure

1103
01:53:22,900 --> 01:53:27,820
out a possible landscape of answers. Anyways, in Python we both have rubber duck debugging,

1104
01:53:27,820 --> 01:53:32,900
but we also have duck typing, which is the idea that if it looks like a duck and it quacks

1105
01:53:32,940 --> 01:53:39,940
like a duck, it's a duck. So if I'm asking, do these objects work with plus? I don't check

1106
01:53:42,260 --> 01:53:46,780
them and say, well, are they plusable objects? I just try out the plus operator and if it

1107
01:53:46,780 --> 01:53:53,380
works, it works. That happens a lot. The built-in len function is another example of that. I

1108
01:53:53,380 --> 01:53:58,020
could pass x to it. I don't know what x is. If it works with the built-in len function,

1109
01:53:58,020 --> 01:54:04,620
we'll get a length. If it doesn't, it won't. Now, what was x? Oh, it was zero, apparently

1110
01:54:04,620 --> 01:54:09,500
in a string. Let's make y four. What do you think the length of the number four might

1111
01:54:09,500 --> 01:54:16,500
be? Could be zero. Could be one. Could be four. Oh, that was the length of x. It is

1112
01:54:16,500 --> 01:54:23,500
an error. You can't get the length of an integer. So practicing duck typing, we try

1113
01:54:30,820 --> 01:54:35,580
it out. If it works, it works. If it doesn't, it doesn't. But multiple things can work

1114
01:54:35,580 --> 01:54:40,740
with the built-in len function. Lists are one of them, strings are another. Okay, so

1115
01:54:40,740 --> 01:54:47,740
we've made a list. We made a list of PyCon feelings here. How could we change a list?

1116
01:54:49,460 --> 01:54:53,320
Typically with a list of things, the most common thing to do with lists in Python is

1117
01:54:53,320 --> 01:54:59,420
to stick something on the end or to remove something from the end. After that, it's common

1118
01:54:59,420 --> 01:55:06,180
to change a particular value. So we know that if we wanted to get amazing from this list,

1119
01:55:06,180 --> 01:55:12,460
how could we do that? We'd have to know its position. What is its position in the list?

1120
01:55:12,460 --> 01:55:19,460
Remember, we start counting at zero. Yeah, zero, one, two. So position two. I can assign

1121
01:55:20,420 --> 01:55:26,980
to PyCon feelings position two to change this feeling. What feelings should we put in here?

1122
01:55:26,980 --> 01:55:33,980
Super amazing. We really like PyCon. And it's changed it to super amazing. If I want to

1123
01:55:34,460 --> 01:55:38,860
add to the end, what's your guess? There's a method we can use. What verb do you think

1124
01:55:38,860 --> 01:55:44,700
we might use? Could be append. You already knew the answer. What's another verb we could

1125
01:55:44,700 --> 01:55:51,600
use? One that's not quite right. Yeah, add is the one I often would guess first. We do

1126
01:55:51,600 --> 01:55:56,780
have an add in Python. It doesn't exist on list. It does exist on sets. Instead, we have

1127
01:55:56,780 --> 01:56:03,780
append. What's another feeling? Anything. Lacking Bs is a valid feeling. You can put

1128
01:56:03,940 --> 01:56:10,940
anything here. What's a feeling you have? Hungry. Yeah, I also have that feeling. So

1129
01:56:11,860 --> 01:56:18,860
append. What's the opposite of append, do you think? Remove. Confusingly, we do have

1130
01:56:20,780 --> 01:56:27,780
a remove method on lists. It doesn't remove the last thing. It's not the opposite of append.

1131
01:56:28,020 --> 01:56:31,860
You have to give it a thing to remove, and if that thing is in that list, it removes

1132
01:56:31,860 --> 01:56:38,860
it. To remove from the end, we pop. So this is a computer sciencey term. If you have a

1133
01:56:41,380 --> 01:56:46,860
stack, like a stack of plates, you can pop something from the top of the stack. Anyone

1134
01:56:46,860 --> 01:56:51,900
know what the opposite of pop is in computer science land? You push something onto the

1135
01:56:51,900 --> 01:56:57,580
stack. We don't have push in Python. Perl has a push and a pop. Python has an append

1136
01:56:57,580 --> 01:57:03,140
and a pop. I'm not sure how that mishap happened, but that's the way things are. I actually

1137
01:57:03,140 --> 01:57:07,120
like append better than push, but it's a little bit unfortunate that we have pop, even though

1138
01:57:07,120 --> 01:57:13,100
the opposite of pop is push. So to add to the end of a list, you can append, and to

1139
01:57:13,100 --> 01:57:18,140
remove from the end, you can pop. Let's make sure it's actually in the list first. Yep,

1140
01:57:18,140 --> 01:57:25,140
it did add to the end. Now, notice pop gives us back the thing that it's popping, and it

1141
01:57:25,140 --> 01:57:29,760
changes the list. That's a little bit unusual. Most functions in Python either do a thing

1142
01:57:29,760 --> 01:57:35,820
or they return a thing. Pop does both. It gives us the thing back, and it changed the

1143
01:57:35,820 --> 01:57:42,060
list. Some functions do both do a thing and return a thing. It is unusual, though, in

1144
01:57:42,060 --> 01:57:47,300
Python. Questions on lists, thoughts on lists. We're going to get some practice with lists

1145
01:57:47,300 --> 01:57:54,300
in a moment here. Question for you. How could I find out if I had a list of things that

1146
01:57:55,140 --> 01:58:02,140
I'm scared of? Weather. Scared is one of the things in this list. Yeah. We had an in operator

1147
01:58:06,580 --> 01:58:12,000
that works on strings. It works on lists, too. It's a very common theme you'll see in Python.

1148
01:58:12,000 --> 01:58:16,560
If you know how to do something with one type of object, similar objects often work with

1149
01:58:16,560 --> 01:58:21,660
that same operation, kind of in the same vein of duck typing, that lots of things have the

1150
01:58:21,660 --> 01:58:27,220
notion of containment. Does in work with them? They have a length. Does len work with them?

1151
01:58:27,220 --> 01:58:34,220
They can be indexed with those square brackets or the indexable. We have some exercises here.

1152
01:58:35,420 --> 01:58:42,420
We actually have two sets of exercises. You can pick which one you'd like to do. The first

1153
01:58:42,420 --> 01:58:49,420
one is lists, list exercises. That one does not involve changing lists at all, only asking

1154
01:58:55,660 --> 01:58:59,540
questions of lists. The other one, if you've done a little bit of programming before, you

1155
01:58:59,540 --> 01:59:05,620
might find a little bit more interesting. It's in more lists, more list exercises at

1156
01:59:05,620 --> 01:59:12,140
the bottom of the page there. The first one there is a random vacation planner. It's a

1157
01:59:12,580 --> 01:59:18,060
picking random locations, random amounts of time, and random destinations to go on a vacation.

1158
01:59:18,060 --> 01:59:22,060
Not the greatest Python program, but kind of a funny one. After that, there's a state

1159
01:59:22,060 --> 01:59:27,800
capital guesser, which is kind of fun because you start with the U.S. states and capitals,

1160
01:59:27,800 --> 01:59:32,100
and then you have to make a program that prompts the user and tells them whether they guessed

1161
01:59:32,100 --> 01:59:38,140
correctly there. That first one is a guest list and a couple other exercises and list

1162
01:59:38,180 --> 01:59:45,180
exercises there. I'm going to give you a little bit of time on these here. After this, we'll

1163
01:59:47,580 --> 01:59:54,220
talk about iteration in Python. I'd like to answer your questions. If you have a question,

1164
01:59:54,220 --> 01:59:58,380
you've had questions, try to write them down because we will have a little bit of time

1165
01:59:58,380 --> 02:00:02,820
at the end to answer questions before lunch. Any questions right now as you're going through

1166
02:00:02,820 --> 02:00:06,620
these, put up a red sticky. If you get through an exercise, it doesn't matter which exercise

1167
02:00:06,660 --> 02:00:12,100
it is. If you get through an exercise right now, stick up a green sticky, and I'll be

1168
02:00:12,100 --> 02:00:19,100
floating around the room here. I have a question for you as you're working on this. Who has

1169
02:00:20,300 --> 02:00:27,300
found a way to get a random thing from a list in Python? What was it? There's something in

1170
02:00:28,860 --> 02:00:35,860
the random module. There's actually a couple things you might be able to use. Yeah, there's

1171
02:00:35,860 --> 02:00:39,060
a couple things. That's what I would recommend using. If you have, say, a random list of

1172
02:00:39,060 --> 02:00:44,940
colors here, you can say random.choice and give it your list. It will give you a random

1173
02:00:44,940 --> 02:00:48,060
thing from that list. I would recommend if you're doing that random vacation planner,

1174
02:00:48,060 --> 02:00:55,060
you might want to check out random.choice. Reminder, if you find yourself stuck, put

1175
02:00:58,540 --> 02:01:05,540
up a red sticky, even if you just want a rubber duck to chat with.

1176
02:01:05,860 --> 02:01:12,420
All right. We're going to solve one of these together real quick. I started with this states

1177
02:01:12,420 --> 02:01:19,420
and capitals.py file. Missing white space. Oh, I've got some funny... There we go. Hit

1178
02:01:20,540 --> 02:01:27,540
that. This is a very big list of lists. You can see this list has lots of lists in it.

1179
02:01:28,120 --> 02:01:35,120
Each has two things in it, a state and a capital. We're meant to ask the user, what is the capital

1180
02:01:35,520 --> 02:01:42,520
of a state? Which means we need to get a random state and capital. How could we do that? We've

1181
02:01:43,800 --> 02:01:50,800
got the random module. What could we use with this states and capitals list? Yeah, if we

1182
02:01:54,360 --> 02:01:58,920
need to get a random... What's the way that I just showed you to get a random item? Yeah,

1183
02:01:58,920 --> 02:02:04,320
random.choice. So random.choice, let's just print that out just to see if it even works.

1184
02:02:04,320 --> 02:02:09,040
This is a good way to write your code is not do everything at once. Don't try to be

1185
02:02:09,040 --> 02:02:14,240
super ambitious. Just try to see if the very basic thing works. Can we get a random state

1186
02:02:14,240 --> 02:02:17,760
and capital? We got Hawaii, Honolulu. We got a different one. That's good enough for me.

1187
02:02:17,760 --> 02:02:24,760
It looks random. Okay. So this is our state and capital. We now want to ask the user,

1188
02:02:24,760 --> 02:02:31,760
what is the capital of a state, of a particular state? How do we get access to the state?

1189
02:02:38,280 --> 02:02:45,280
Yeah, it's in that state and capital list, which is a two item list. How do you get the

1190
02:02:45,920 --> 02:02:52,920
first thing in a two item list? Zero. So plus state and capital index zero. Okay. So we

1191
02:02:55,120 --> 02:03:00,520
need a question mark at the end now. So question mark and a space to make this look a little

1192
02:03:00,520 --> 02:03:06,600
bit nicer. And it's supposed to prompt them. I'm using print. How do we prompt a user?

1193
02:03:06,600 --> 02:03:12,920
Write input. So input will both print and get a response. So we'll say guess equals

1194
02:03:12,920 --> 02:03:17,320
this thing. Our code's a little bit long. I'm actually going to break this up over multiple

1195
02:03:17,320 --> 02:03:20,880
lines. This is something you're allowed to do in Python. Normally when you hit enter

1196
02:03:20,880 --> 02:03:25,440
in the middle of a line of code, Python complains. It doesn't care here. Anyone want to guess

1197
02:03:25,440 --> 02:03:32,440
why? Yeah, that open parenthesis lets Python know there is more to come. So it's okay with

1198
02:03:32,720 --> 02:03:36,640
us writing that over multiple lines of code. Anyone guess what the capital of Pennsylvania

1199
02:03:36,640 --> 02:03:43,640
is? I have no idea whether it was right. It didn't tell us. So now we need to do something

1200
02:03:43,640 --> 02:03:50,640
with that guess. What question do we ask? We've got an if. So if index one, which should

1201
02:03:59,480 --> 02:04:05,280
be the correct capital, if it is equal to our guess, then we'll print out yay, great

1202
02:04:05,280 --> 02:04:12,280
job. Otherwise we'll print out, maybe we should say what the actual capital is. So if index

1203
02:04:13,640 --> 02:04:20,640
one is incorrect, the capital is actually, now we need to say state and capital one.

1204
02:04:32,640 --> 02:04:39,640
Virginia. Sacramento. Oh, interesting. It wasn't Sacramento. So we'll print out, oh,

1205
02:04:43,640 --> 02:04:49,440
Sacramento. It was apparently Charleston. It seems like it works. Let's do one that's

1206
02:04:49,440 --> 02:04:56,440
actually valid. New Mexico. Yay, great job. We made a working program. Questions or thoughts

1207
02:05:00,040 --> 02:05:07,040
in our last 10 minutes here. So one more thing I want to show you before we wrap up. Yep.

1208
02:05:13,640 --> 02:05:20,640
This is a great question. So the question is, if you said I'm good and you've got a

1209
02:05:20,640 --> 02:05:27,640
list of things, there's good in there, but I'm good isn't in good. And you'd have to

1210
02:05:27,640 --> 02:05:34,640
somehow maybe loop over your list and say, well, is good and I'm good, or is part of

1211
02:05:49,680 --> 02:05:55,640
what I have in that thing. So we're about to talk about loops. You could loop over your

1212
02:05:55,640 --> 02:06:01,520
list and say, instead of is my item here within the list, ask the opposite. Is each

1213
02:06:01,520 --> 02:06:06,240
of the items in the list or any of these in what I'm working with here is good and I'm

1214
02:06:06,240 --> 02:06:11,360
good. The other way is a scary thing that is often used in text processing in many programming

1215
02:06:11,360 --> 02:06:16,880
languages. Anyone know what I'm about to say? Parsing, even scarier than that. It's called

1216
02:06:16,880 --> 02:06:21,600
regular expressions. It's a programming language inside of a programming language where everything

1217
02:06:21,600 --> 02:06:25,600
is on one line of code, there's no white space in comments, and every symbol is actually

1218
02:06:25,600 --> 02:06:31,120
a line of code. It sounds awful. And it is a little bit awful, although it's also very

1219
02:06:31,120 --> 02:06:35,360
powerful. Regular expressions are one way to maybe do some pattern matching. We're not

1220
02:06:35,360 --> 02:06:39,960
going to do regular expressions, though. I do have a tutorial online, that website. We'll

1221
02:06:39,960 --> 02:06:46,960
take you to a PyCon tutorial on that, though. So what I'd like to do now is take a list

1222
02:06:47,160 --> 02:06:54,160
of items and do something for every single item in the list. What can I use for this

1223
02:06:55,960 --> 02:07:02,960
in Python? A for loop. Yeah, a lot of programming languages have a notion of a for loop. Many

1224
02:07:03,440 --> 02:07:09,440
of them look like this. For i equals zero, i is less than the length of fruits, and then

1225
02:07:09,440 --> 02:07:15,280
i plus equals one. We don't have this in Python. We're thinking in terms of indexes here. Python

1226
02:07:15,320 --> 02:07:22,320
doesn't have that at all. Instead, we say for fruit in fruits. No index. We just get

1227
02:07:24,400 --> 02:07:31,240
each item. If you look up in Wikipedia, for each, all one word, a for each loop, that's

1228
02:07:31,240 --> 02:07:36,180
what we have. We call it for in. We're typically just for, because that's our only for loop

1229
02:07:36,180 --> 02:07:41,180
in Python, is a for in loop. It gets each item in the list.

1230
02:07:41,180 --> 02:07:48,180
Right. How could we do something four times, like meditative breathing, for example? Great

1231
02:07:53,300 --> 02:07:58,340
question. Ideas. Ooh, I like that. That's a thing that's a little bit more advanced,

1232
02:07:58,340 --> 02:08:01,340
but we can take a look at that. What other ideas?

1233
02:08:01,340 --> 02:08:08,340
We would need a wild one. We could do something like that.

1234
02:08:12,140 --> 02:08:17,900
If you want to manually add things, you have a condition, and you've got something you're

1235
02:08:17,900 --> 02:08:22,900
incrementing maybe. If you need a loop with a condition, that's called a while loop. So

1236
02:08:22,900 --> 02:08:27,580
while, say, x is greater than ten, something like that, and you're decrementing x. We have

1237
02:08:27,580 --> 02:08:31,540
that. We don't tend to use them often. The reason is we tend to try to model everything

1238
02:08:31,540 --> 02:08:36,180
in Python from the perspective of an iterable that is something you were able to iterate

1239
02:08:36,180 --> 02:08:39,820
over. So a list is an iterable. If you can write a for loop to loop over it, it's an

1240
02:08:39,820 --> 02:08:46,820
iterable. Can I loop over a string, do you think? Yeah. In fact, before I loop over a

1241
02:08:46,820 --> 02:08:53,660
string, how does Python know the singular of fruits? It doesn't. That's a variable name.

1242
02:08:53,660 --> 02:08:59,780
I can call that whatever I want. I'm essentially assigning, I'm defining a variable there.

1243
02:08:59,780 --> 02:09:06,780
X is under our control. So I could say, let's take a string like my name. For x in name,

1244
02:09:06,780 --> 02:09:13,780
what do you think this will print? It's kind of like when we index, right? Every character,

1245
02:09:14,700 --> 02:09:19,940
every character in the string. Anything you can loop over is an iterable. So there is

1246
02:09:19,940 --> 02:09:26,940
an iterable in Python called a range that you can get from calling the range function.

1247
02:09:28,560 --> 02:09:35,240
Range of ten gives you this thing that if you loop over it, will count upward from zero

1248
02:09:35,240 --> 02:09:40,600
to just before ten. You see this a lot in Python, either a built-in function or some

1249
02:09:40,600 --> 02:09:45,080
kind of utility for making an iterable when you didn't have an iterable because you need

1250
02:09:45,080 --> 02:09:50,480
to loop. We really love our for loops in Python. Not that we don't use while loops, but we

1251
02:09:50,480 --> 02:09:54,440
like modeling things from the perspective of a for loop. Now, if you didn't know about

1252
02:09:54,440 --> 02:10:01,440
range, how could you make a string that has ten zeros in it? Yeah, zero. How could you

1253
02:10:05,400 --> 02:10:11,800
make that ten? We could loop over a string to get the same thing there, or we learned

1254
02:10:11,800 --> 02:10:17,880
about how strings and lists are similar in many ways. That works on lists too. You can

1255
02:10:17,880 --> 02:10:23,760
actually also use plus on lists. You can concatenate strings, you can concatenate lists. You can

1256
02:10:23,760 --> 02:10:28,400
also multiply lists by themselves, self-concatenation. Now, range would probably be the right way

1257
02:10:28,400 --> 02:10:35,400
to do this, though, the easy way to do it. Other questions on loops? Yep. Right, yeah,

1258
02:10:38,400 --> 02:10:42,440
you can't do that. It's kind of funny because in, we've seen in, it was for containment

1259
02:10:42,440 --> 02:10:49,440
checking, is x in y. This is a different in. For x in name, this doesn't work because it's

1260
02:10:49,440 --> 02:10:56,440
actually not the in operator. It's a different in. It's actually part of the for loop syntax.

1261
02:10:59,600 --> 02:11:04,800
Kind of confusing. You see this a lot in Python, in fact. Else isn't just for if else. There's

1262
02:11:04,800 --> 02:11:09,320
try else. There's even a for else. I think there's a while else. You hopefully won't

1263
02:11:09,320 --> 02:11:14,520
see those because they're weird. Try else you might see. If else, you'll almost certainly

1264
02:11:14,520 --> 02:11:18,920
see. So sometimes the same keyword is used in different ways in Python, which is kind

1265
02:11:18,920 --> 02:11:25,920
of confusing, but it's just the way things are. It would be for x in range for, yep.

1266
02:11:40,240 --> 02:11:43,040
You don't have to print x. You do something else. You'd probably ignore x. In fact, if

1267
02:11:43,040 --> 02:11:46,080
you want to ignore a variable and you want to make it clear you don't care what it is,

1268
02:11:46,080 --> 02:11:51,760
sometimes people use underscore. Underscore is a valid variable name. It's a throw away

1269
02:11:51,760 --> 02:11:56,600
variable saying I don't care what the value is. We wouldn't usually use underscore there.

1270
02:11:56,600 --> 02:12:03,200
We'd say print hello. We'd print hello four times. Of course, you can call it whatever

1271
02:12:03,200 --> 02:12:09,360
you want for x in, for y in, for count in. So we don't have too much time for you to

1272
02:12:09,360 --> 02:12:14,040
do exercises individually. What I'd like to do instead is in our last few minutes together,

1273
02:12:14,040 --> 02:12:21,040
that breathe.py that some of you worked on earlier where we used time.sleep to sleep

1274
02:12:22,160 --> 02:12:29,160
for a few seconds. And we would say breathe in and then breathe out. You were supposed

1275
02:12:29,240 --> 02:12:36,240
to do this over and over for two minutes. How can we do this over and over? Right. You

1276
02:12:36,240 --> 02:12:43,240
could have copy pasted before, but now that we know about range, let's say for x in range,

1277
02:12:47,520 --> 02:12:53,080
now how many times do we want to do it? So we were supposed to do this for two minutes,

1278
02:12:53,080 --> 02:13:00,080
and we wanted it to be, I think it was, was it six times a minute? Once every six seconds.

1279
02:13:01,000 --> 02:13:07,680
So I guess seconds equals six. Once every six seconds there. So how many times we would

1280
02:13:07,680 --> 02:13:14,680
do it would be, what's our math involved? Two times 60 is the number of seconds total,

1281
02:13:14,680 --> 02:13:21,680
divided by six, is that right? Let's see if it works. Oop, float object cannot be interpreted

1282
02:13:23,720 --> 02:13:29,520
as an integer. Ah, what's going on here? On this line of code, by the way, this is called

1283
02:13:29,520 --> 02:13:34,240
a trace back. Who's seen a trace back before? Everyone should be raising their hands. You've

1284
02:13:34,240 --> 02:13:39,120
all seen this even though you didn't know it. Whenever you see an error in Python, you

1285
02:13:39,120 --> 02:13:44,600
see this printed out. The last one, the last line there is the line you read first. That

1286
02:13:44,600 --> 02:13:48,440
tells you the type of error and hopefully a helpful message. Honestly, it's not helpful

1287
02:13:48,440 --> 02:13:51,960
some of the time though. That's the thing you would copy paste into Google and hope

1288
02:13:51,960 --> 02:13:56,040
for an answer. If that doesn't work, go to chat GPT and hope that it gives you an answer.

1289
02:13:56,040 --> 02:14:00,480
If that doesn't work, ask a friend. I don't know what you do. But it's in the context

1290
02:14:00,480 --> 02:14:05,440
of the code. Just up from that, that's your actual code. The deepest line in your code

1291
02:14:05,440 --> 02:14:10,360
where you are. Python programs when they run, they use something called a stack and a stack

1292
02:14:10,360 --> 02:14:14,080
frame. A function can call a function that calls a function. We can go as deep as we

1293
02:14:14,080 --> 02:14:18,200
want. This is the deepest line in our code. If there were more lines above it, it would

1294
02:14:18,200 --> 02:14:23,320
be going up the call stack there. So you read from the bottom up, the last line is the most

1295
02:14:23,320 --> 02:14:30,680
important. It's saying on line seven, this is a float. It's supposed to be an integer.

1296
02:14:30,680 --> 02:14:40,160
How do we fix that? Yeah, we can wrap it in int. So range, it actually can't use floating

1297
02:14:40,160 --> 02:14:45,320
point numbers. There's another way to solve this, though. In Python, there's a slash slash

1298
02:14:45,320 --> 02:14:49,440
operator. I'm only going to show it off here because it exists. But you could just use

1299
02:14:50,080 --> 02:14:53,880
It does integer division. That would have been another way to solve it. So we're breathing

1300
02:14:53,880 --> 02:15:00,400
in, we're breathing out. Hopefully it's only six seconds. Oh, it's funny. It's printing

1301
02:15:00,400 --> 02:15:05,800
things in groups, right? So we maybe should have done three second pause and then a three

1302
02:15:05,800 --> 02:15:13,520
second pause. Oh, is it six each time? Okay, then I probably should have divided this a

1303
02:15:13,600 --> 02:15:19,640
little differently. I think I would have needed to do a divide by two there. You can play

1304
02:15:19,640 --> 02:15:22,520
with this on your own. Something you might want to try if you do end up playing with

1305
02:15:22,520 --> 02:15:29,960
this program, you could do something in between. You could say, let's print, for example, period,

1306
02:15:29,960 --> 02:15:37,240
and then we'll sleep for one second. And then we'll print out period twice and kind of make

1307
02:15:37,280 --> 02:15:46,640
a little line that gets bigger and smaller as you go. I'll show it here real quick with

1308
02:15:46,640 --> 02:15:55,640
a slightly smaller line. You know, to signify you're breathing in, you're breathing out,

1309
02:15:55,640 --> 02:16:01,720
you can make this whatever you'd like here. We are about to eat lunch in two minutes,

1310
02:16:01,720 --> 02:16:06,400
so I want to let you go so that you can actually eat. So I'm going to wrap things up. It has

1311
02:16:06,400 --> 02:16:10,840
been a pleasure. If you have questions, I will stick around afterward as we eat. Feel

1312
02:16:10,840 --> 02:16:15,920
free to ask. If this is your first PyCon, as I know it is for most of you, the newcomers

1313
02:16:15,920 --> 02:16:20,280
orientation tomorrow night, I will be on stage along with some other folks. I recommend going

1314
02:16:20,280 --> 02:16:24,680
there because you want to orient yourself to this conference that will be even scarier

1315
02:16:24,680 --> 02:16:30,000
tomorrow as more and more people show up. If you would like stickers for a Python exercise

1316
02:16:30,000 --> 02:16:34,600
service that I run where I do screencasts and exercises for Python morsels, I have them

1317
02:16:34,600 --> 02:16:38,960
somewhere. I'll pass them out in the back of the room in a moment here. Have a great

1318
02:16:38,960 --> 02:16:39,360
PyCon.

