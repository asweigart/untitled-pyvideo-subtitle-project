1
00:00:00,000 --> 00:00:02,000
Buenas.

2
00:00:02,000 --> 00:00:04,000
Sí, buenas.

3
00:00:04,000 --> 00:00:06,000
Eso.

4
00:00:06,000 --> 00:00:08,000
Quiero energía.

5
00:00:08,000 --> 00:00:10,000
Somos latino la mayoría, ¿verdad?

6
00:00:10,000 --> 00:00:12,000
Pero algunos lo tenemos en la sangre,

7
00:00:12,000 --> 00:00:14,000
otros nacimos en latina, pero de igual

8
00:00:14,000 --> 00:00:16,000
forma somos latinoamericanos.

9
00:00:16,000 --> 00:00:18,000
Así que quiero energía. Espero que le estén pasando bien.

10
00:00:18,000 --> 00:00:20,000
Y que el break que tuvieron

11
00:00:20,000 --> 00:00:22,000
ahora les dio suficiente tiempo para

12
00:00:22,000 --> 00:00:24,000
refrescar, café,

13
00:00:24,000 --> 00:00:26,000
té, agua, lo que

14
00:00:26,000 --> 00:00:28,000
decidieron. Porque la charla que viene ahora es

15
00:00:28,000 --> 00:00:30,000
una charla muy interesante.

16
00:00:30,000 --> 00:00:32,000
Tenemos a Sebastián Ramírez,

17
00:00:32,000 --> 00:00:34,000
conocido en la comunidad como

18
00:00:34,000 --> 00:00:36,000
Tiangolo. Creo que

19
00:00:36,000 --> 00:00:38,000
ese handle en Twitter, muchas personas

20
00:00:38,000 --> 00:00:40,000
lo conocen ya, es el creador de

21
00:00:40,000 --> 00:00:42,000
FastAPI y es exactamente sobre

22
00:00:42,000 --> 00:00:44,000
FastAPI que Tiangolo nos va a venir

23
00:00:44,000 --> 00:00:46,000
a hablar la tarde de hoy. Espero que lo disfruten

24
00:00:46,000 --> 00:00:48,000
y que

25
00:00:48,000 --> 00:00:50,000
los disfruten. Y que aprendan mucho.

26
00:00:54,000 --> 00:00:56,000
Muchas gracias.

27
00:00:56,000 --> 00:00:58,000
Espero que ustedes pueden hacer lo mejor

28
00:00:58,000 --> 00:01:00,000
ese aplauso. Vamos, que lo disfruten.

29
00:01:00,000 --> 00:01:02,000
Muchas gracias.

30
00:01:04,000 --> 00:01:06,000
Hola, ¿me escuchan ahí?

31
00:01:06,000 --> 00:01:08,000
Ya tengo el micrófono bien.

32
00:01:08,000 --> 00:01:10,000
Qué divertido estar aquí con ustedes.

33
00:01:10,000 --> 00:01:12,000
Qué bacano.

34
00:01:12,000 --> 00:01:14,000
¿Hablan español? ¿Todos hablan español?

35
00:01:18,000 --> 00:01:20,000
Voy a tratar de hablar

36
00:01:20,000 --> 00:01:22,000
despacio.

37
00:01:22,000 --> 00:01:24,000
Y no lo voy a lograr. Pero voy a intentar.

38
00:01:24,000 --> 00:01:26,000
Vamos a hacer una

39
00:01:26,000 --> 00:01:28,000
introducción a FastAPI.

40
00:01:30,000 --> 00:01:32,000
High performance.

41
00:01:32,000 --> 00:01:34,000
Esto está en inglés porque es como la parte del loguito.

42
00:01:34,000 --> 00:01:36,000
Primero,

43
00:01:36,000 --> 00:01:38,000
¿quién soy yo? Soy Sebastián Ramírez.

44
00:01:38,000 --> 00:01:40,000
Vivo en Berlín, Alemania. Pero yo soy de Colombia,

45
00:01:40,000 --> 00:01:42,000
en América Latina.

46
00:01:42,000 --> 00:01:44,000
Normalmente en una charla en inglés diría

47
00:01:44,000 --> 00:01:46,000
por eso es el acento. Pero en este caso

48
00:01:46,000 --> 00:01:48,000
estoy hablando español.

49
00:01:48,000 --> 00:01:50,000
Me pueden encontrar por ahí.

50
00:01:50,000 --> 00:01:52,000
Yo creo FastAPI, Typer, SQLModel,

51
00:01:52,000 --> 00:01:54,000
Sinker y otras cosas de código libre.

52
00:01:54,000 --> 00:01:56,000
Hoy estamos hablando de FastAPI.

53
00:01:56,000 --> 00:01:58,000
Para los que no saben,

54
00:01:58,000 --> 00:02:00,000
FastAPI es un framework

55
00:02:00,000 --> 00:02:02,000
para hacer web APIs.

56
00:02:02,000 --> 00:02:04,000
Tiene un poco de estrellitas

57
00:02:04,000 --> 00:02:06,000
en GitHub.

58
00:02:06,000 --> 00:02:08,000
A la gente le ha ido gustando.

59
00:02:08,000 --> 00:02:10,000
Lo usan en un poco de empresas

60
00:02:10,000 --> 00:02:12,000
como Microsoft, Netflix y otro poco de lados.

61
00:02:12,000 --> 00:02:14,000
Y el desempeño es

62
00:02:14,000 --> 00:02:16,000
entre lo más alto que se puede lograr

63
00:02:16,000 --> 00:02:18,000
en Python.

64
00:02:18,000 --> 00:02:20,000
Entonces, chévere.

65
00:02:20,000 --> 00:02:22,000
Es el tercero más usado

66
00:02:22,000 --> 00:02:24,000
según el Python Developer Survey.

67
00:02:24,000 --> 00:02:26,000
Es el de más rápido crecimiento.

68
00:02:26,000 --> 00:02:28,000
Y el tercero más amado

69
00:02:28,000 --> 00:02:30,000
en Stack Overflow.

70
00:02:30,000 --> 00:02:32,000
Esto cambió en algún punto

71
00:02:32,000 --> 00:02:34,000
después de que fue

72
00:02:34,000 --> 00:02:36,000
mucho más usado. Entonces, todas esas estadísticas

73
00:02:36,000 --> 00:02:38,000
van variando. Pero en este caso,

74
00:02:38,000 --> 00:02:40,000
en esta encuesta, Stack Overflow

75
00:02:40,000 --> 00:02:42,000
era también incluyendo entre frontend

76
00:02:42,000 --> 00:02:44,000
y backend. Entonces, quedaba

77
00:02:44,000 --> 00:02:46,000
por encima de React

78
00:02:46,000 --> 00:02:48,000
y Vue.js o algo así.

79
00:02:48,000 --> 00:02:50,000
Es súper cool. Bueno, eso es FastAPI.

80
00:02:50,000 --> 00:02:52,000
Eso es de lo que vamos a hablar.

81
00:02:52,000 --> 00:02:54,000
La idea de FastAPI es que es

82
00:02:54,000 --> 00:02:56,000
basado en estándares como OpenAPI,

83
00:02:56,000 --> 00:02:58,000
JSON Schema o Auth2

84
00:02:58,000 --> 00:03:00,000
o Auth2.

85
00:03:00,000 --> 00:03:02,000
Y gracias a estos estándares

86
00:03:02,000 --> 00:03:04,000
y porque está hecho todo para ser basado

87
00:03:04,000 --> 00:03:06,000
en esos estándares, se puede obtener

88
00:03:06,000 --> 00:03:08,000
muy buenas integraciones y

89
00:03:08,000 --> 00:03:10,000
utilizarlo muy bien con otras herramientas.

90
00:03:10,000 --> 00:03:12,000
Por ejemplo, se puede tener API Docs

91
00:03:12,000 --> 00:03:14,000
automáticos. Documentación del

92
00:03:14,000 --> 00:03:16,000
API automáticamente, como esto que se ve aquí.

93
00:03:16,000 --> 00:03:18,000
Les voy a mostrar más ejemplos de eso.

94
00:03:18,000 --> 00:03:20,000
Todo esto es basado en las anotaciones de tipos

95
00:03:20,000 --> 00:03:22,000
estándar de Python. Entonces,

96
00:03:22,000 --> 00:03:24,000
no hay que aprender

97
00:03:24,000 --> 00:03:26,000
como una herramienta nueva para poder

98
00:03:26,000 --> 00:03:28,000
usar estos tipos. No hay que decir importar

99
00:03:28,000 --> 00:03:30,000
de FastAPI el super string de FastAPI,

100
00:03:30,000 --> 00:03:32,000
sino que es el mismo string de Python.

101
00:03:32,000 --> 00:03:34,000
Pero encima de tener las ventajas

102
00:03:34,000 --> 00:03:36,000
de esas anotaciones de tipo,

103
00:03:36,000 --> 00:03:38,000
tenemos conversión de datos automática y validación

104
00:03:38,000 --> 00:03:40,000
de datos automática. Y ya les voy a mostrar eso qué

105
00:03:40,000 --> 00:03:42,000
significa y por qué es que es útil y cómo es que funciona.

106
00:03:42,000 --> 00:03:44,000
El punto es que es

107
00:03:44,000 --> 00:03:46,000
basada en estándares y sin esfuerzo extra.

108
00:03:46,000 --> 00:03:48,000
Es el mismo código que uno ya escribe,

109
00:03:48,000 --> 00:03:50,000
pero ¡ah! tengo una aplicación basada en estándares.

110
00:03:50,000 --> 00:03:52,000
¡Qué profesional!

111
00:03:52,000 --> 00:03:54,000
Bueno, la idea es que esto está

112
00:03:54,000 --> 00:03:56,000
basado en anotaciones de tipo y

113
00:03:56,000 --> 00:03:58,000
porque las anotaciones de tipo es estándar

114
00:03:58,000 --> 00:04:00,000
de Python.

115
00:04:00,000 --> 00:04:02,000
La gente tiende a decir como términos

116
00:04:02,000 --> 00:04:04,000
super sofisticados como ¡ah! static analysis,

117
00:04:04,000 --> 00:04:06,000
análisis estático de los datos

118
00:04:06,000 --> 00:04:08,000
y type safety y cosas así

119
00:04:08,000 --> 00:04:10,000
que suenan muy reumbombantes, pero se les

120
00:04:10,000 --> 00:04:12,000
olvida decir los puntos importantes, que es autocompletado

121
00:04:12,000 --> 00:04:14,000
en el editor y chequeo de tipos

122
00:04:14,000 --> 00:04:16,000
y errores. Cuando están en el editor

123
00:04:16,000 --> 00:04:18,000
y le dicen control espacio

124
00:04:18,000 --> 00:04:20,000
o comand espacio para que autocomplete,

125
00:04:20,000 --> 00:04:22,000
eso funciona gracias a las anotaciones

126
00:04:22,000 --> 00:04:24,000
de tipos. Y cuando

127
00:04:24,000 --> 00:04:26,000
suelen los squiggly lands

128
00:04:26,000 --> 00:04:28,000
las rayitas rojitas diciendo

129
00:04:28,000 --> 00:04:30,000
¡hey! aquí hay un error, el editor

130
00:04:30,000 --> 00:04:32,000
les puede dar esa información gracias a esas

131
00:04:32,000 --> 00:04:34,000
anotaciones de tipos. Entonces, por usar

132
00:04:34,000 --> 00:04:36,000
anotaciones de tipos, tenemos todas esas ventajas.

133
00:04:36,000 --> 00:04:38,000
Ya les voy a mostrar más ejemplos de eso

134
00:04:38,000 --> 00:04:40,000
específicamente. El punto es que podemos tener

135
00:04:40,000 --> 00:04:42,000
autocompletado en todas partes

136
00:04:42,000 --> 00:04:44,000
en el código. Ese era uno de los ideas

137
00:04:44,000 --> 00:04:46,000
principales de FastAPI,

138
00:04:46,000 --> 00:04:48,000
poder tener autocompletado para todo. Que uno necesita

139
00:04:48,000 --> 00:04:50,000
poner un parámetro, o sea, control espacio y le

140
00:04:50,000 --> 00:04:52,000
diga a uno cuáles son las listas de parámetros que puede

141
00:04:52,000 --> 00:04:54,000
uno pasar, todo ese tipo de cosas.

142
00:04:54,000 --> 00:04:56,000
Y así uno puede ser un desarrollador feliz como

143
00:04:56,000 --> 00:04:58,000
este muñequito.

144
00:04:58,000 --> 00:05:00,000
¡Qué divertido es hacer esto en vivo con personas

145
00:05:00,000 --> 00:05:02,000
en vivo! He hecho tantas

146
00:05:02,000 --> 00:05:04,000
charlas en línea durante la pandemia,

147
00:05:04,000 --> 00:05:06,000
mirando a la camarita y muestro un mem de esos

148
00:05:06,000 --> 00:05:08,000
y es como los crickets

149
00:05:08,000 --> 00:05:10,000
en el fondo.

150
00:05:10,000 --> 00:05:12,000
Y aquí oírlos reír a ustedes.

151
00:05:12,000 --> 00:05:14,000
¡Qué nice!

152
00:05:14,000 --> 00:05:16,000
Bueno, la idea es que FastAPI es fácil y corto.

153
00:05:16,000 --> 00:05:18,000
Esta es una aplicación entera

154
00:05:18,000 --> 00:05:20,000
de FastAPI. Entonces, lo que hacemos

155
00:05:20,000 --> 00:05:22,000
es, from FastAPI importamos la clase

156
00:05:22,000 --> 00:05:24,000
FastAPI, creamos un objeto app,

157
00:05:24,000 --> 00:05:26,000
que es un instance de esta clase, FastAPI.

158
00:05:26,000 --> 00:05:28,000
Luego, con este objeto

159
00:05:28,000 --> 00:05:30,000
vamos a decorar una función.

160
00:05:30,000 --> 00:05:32,000
Decorar es usar este cosito, este

161
00:05:32,000 --> 00:05:34,000
arroba. Y cuando uno usa

162
00:05:34,000 --> 00:05:36,000
este arroba, lo que le está diciendo es, a lo que sea

163
00:05:36,000 --> 00:05:38,000
este método que haga, necesito, le estamos diciendo,

164
00:05:38,000 --> 00:05:40,000
¡Hey! FastAPI, quiero que usted coja lo que

165
00:05:40,000 --> 00:05:42,000
está debajo de esto y haga lo que sea que usted

166
00:05:42,000 --> 00:05:44,000
tenga que hacer con eso. Eso significa

167
00:05:44,000 --> 00:05:46,000
decorar, eso es lo que hace este

168
00:05:46,000 --> 00:05:48,000
arroba. Simplemente que el

169
00:05:48,000 --> 00:05:50,000
resultado de esto es como una función que va a

170
00:05:50,000 --> 00:05:52,000
recibir esta cosa aquí abajo. El punto es que aquí

171
00:05:52,000 --> 00:05:54,000
le estamos diciendo a FastAPI, cuando alguien

172
00:05:54,000 --> 00:05:56,000
haga un request, cuando haga una petición

173
00:05:56,000 --> 00:05:58,000
por HTTP, que vaya para

174
00:05:58,000 --> 00:06:00,000
slash, o sea para la reaís directamente,

175
00:06:00,000 --> 00:06:02,000
y que sea un HTTP

176
00:06:02,000 --> 00:06:04,000
get, o sea que el método o la operación

177
00:06:04,000 --> 00:06:06,000
sea get, esta es la función

178
00:06:06,000 --> 00:06:08,000
que yo quiero que usted use para manejar

179
00:06:08,000 --> 00:06:10,000
ese request, para manejar ese mensaje.

180
00:06:10,000 --> 00:06:12,000
Y aquí entonces

181
00:06:12,000 --> 00:06:14,000
estamos creando una función async, que está

182
00:06:14,000 --> 00:06:16,000
devolviendo un diccionario. FastAPI

183
00:06:16,000 --> 00:06:18,000
se va a encargar de convertir este diccionario en JSON

184
00:06:18,000 --> 00:06:20,000
automáticamente. Entonces el

185
00:06:20,000 --> 00:06:22,000
cliente que esté enviando el request

186
00:06:22,000 --> 00:06:24,000
recibe JSON automáticamente.

187
00:06:24,000 --> 00:06:26,000
FastAPI por debajo

188
00:06:26,000 --> 00:06:28,000
de cuerdas es un framework asíncrono

189
00:06:28,000 --> 00:06:30,000
que usa async y await

190
00:06:30,000 --> 00:06:32,000
por dentro. Sin embargo, también es compatible

191
00:06:32,000 --> 00:06:34,000
con funciones no async y await.

192
00:06:34,000 --> 00:06:36,000
Entonces realmente no tienen que

193
00:06:36,000 --> 00:06:38,000
usar async y await, y

194
00:06:38,000 --> 00:06:40,000
todo va a funcionar bien. Ahorita ya les muestro un poquito cómo.

195
00:06:40,000 --> 00:06:42,000
Pero el caso es que es

196
00:06:42,000 --> 00:06:44,000
fácil y cortito. Entonces

197
00:06:44,000 --> 00:06:46,000
entre más código de FastAPI hay uno que escribe,

198
00:06:46,000 --> 00:06:48,000
menos código de la API escribe.

199
00:06:48,000 --> 00:06:50,000
La idea es que pueda uno enfocarse

200
00:06:50,000 --> 00:06:52,000
en cuál es el business logic, cuál

201
00:06:52,000 --> 00:06:54,000
es la lógica de negocio, cuál es el código

202
00:06:54,000 --> 00:06:56,000
importante y la lógica para el producto que uno

203
00:06:56,000 --> 00:06:58,000
está construyendo, y no entonces

204
00:06:58,000 --> 00:07:00,000
en todos los detalles de cómo hacer una API.

205
00:07:00,000 --> 00:07:02,000
La idea es que uno pueda escribir la menor cantidad

206
00:07:02,000 --> 00:07:04,000
de código posible de FastAPI

207
00:07:04,000 --> 00:07:06,000
y que la mayor cantidad de código sea

208
00:07:06,000 --> 00:07:08,000
lo que es importante para uno

209
00:07:08,000 --> 00:07:10,000
del trabajo que está haciendo.

210
00:07:10,000 --> 00:07:12,000
Vamos a hacer una app un poquito

211
00:07:12,000 --> 00:07:14,000
más grande. Esto es más o menos lo que teníamos

212
00:07:14,000 --> 00:07:16,000
hasta ahora. Y si se fijan ya le quité el

213
00:07:16,000 --> 00:07:18,000
async, ahora estamos usando funciones def normales.

214
00:07:18,000 --> 00:07:20,000
Y eso es lo que normalmente uno haría,

215
00:07:20,000 --> 00:07:22,000
y probablemente así están la mayoría de las aplicaciones

216
00:07:22,000 --> 00:07:24,000
de FastAPI. O sea, no hay que

217
00:07:24,000 --> 00:07:26,000
usar async y await. Y lo

218
00:07:26,000 --> 00:07:28,000
por defecto, lo más fácil y lo más

219
00:07:28,000 --> 00:07:30,000
seguro es no usar async y await,

220
00:07:30,000 --> 00:07:32,000
sino usar esto así normal. Y cuando

221
00:07:32,000 --> 00:07:34,000
necesiten optimizar o hacer cosas con concurrencia

222
00:07:34,000 --> 00:07:36,000
o apretar

223
00:07:36,000 --> 00:07:38,000
el performance y sacarle el

224
00:07:38,000 --> 00:07:40,000
mayor jugo a todo, ahí puede

225
00:07:40,000 --> 00:07:42,000
ser entonces empezar a usar async y await.

226
00:07:42,000 --> 00:07:44,000
Pero de resto puede uno usar funciones así normalitas

227
00:07:44,000 --> 00:07:46,000
y simplemente reutilizar

228
00:07:46,000 --> 00:07:48,000
todo el código que ya probablemente tiene

229
00:07:48,000 --> 00:07:50,000
y que puedes haber estado usando con otro framework

230
00:07:50,000 --> 00:07:52,000
o lo que sea. Ahora le estamos diciendo

231
00:07:52,000 --> 00:07:54,000
FastAPI. Bueno, cuando alguien venga

232
00:07:54,000 --> 00:07:56,000
y vaya a una URL como está debajo, miremos esta URL

233
00:07:56,000 --> 00:07:58,000
primero. Alguien viene, digamos que nuestra aplicación

234
00:07:58,000 --> 00:08:00,000
está aquí en https://sondomain.com

235
00:08:00,000 --> 00:08:02,000
Cuando alguien vaya

236
00:08:02,000 --> 00:08:04,000
para slash items slash

237
00:08:04,000 --> 00:08:06,000
este 5, este número va a ser

238
00:08:06,000 --> 00:08:08,000
dinámico, o sea puede ser cualquier otro número

239
00:08:08,000 --> 00:08:10,000
y lo que le queremos decir a FastAPI

240
00:08:10,000 --> 00:08:12,000
es extraiga este 5 y pásenmelo en un

241
00:08:12,000 --> 00:08:14,000
parámetro. Entonces le decimos a FastAPI.

242
00:08:14,000 --> 00:08:16,000
Cuando alguien le haga un http get,

243
00:08:16,000 --> 00:08:18,000
una operación o un método get

244
00:08:18,000 --> 00:08:20,000
que vaya para slash items

245
00:08:20,000 --> 00:08:22,000
slash, y luego aquí adentro

246
00:08:22,000 --> 00:08:24,000
de esto, esto queremos que sea un parámetro de path,

247
00:08:24,000 --> 00:08:26,000
o sea un parámetro de la ruta.

248
00:08:26,000 --> 00:08:28,000
Y estamos usando los mismos

249
00:08:28,000 --> 00:08:30,000
corchetes o los mismos

250
00:08:30,000 --> 00:08:32,000
no sé, creo que a este símbolo

251
00:08:32,000 --> 00:08:34,000
lo llevamos diferente en cada parte de la que hablamos español

252
00:08:34,000 --> 00:08:36,000
pero pues estos

253
00:08:36,000 --> 00:08:38,000
squiggly brackets

254
00:08:38,000 --> 00:08:40,000
o como sea.

255
00:08:40,000 --> 00:08:42,000
Aquí estamos, si se fijan, son los mismos que usamos

256
00:08:42,000 --> 00:08:44,000
para los F strings, para los

257
00:08:44,000 --> 00:08:46,000
strings formateados. Pero

258
00:08:46,000 --> 00:08:48,000
no le ponemos la F aquí al principio.

259
00:08:48,000 --> 00:08:50,000
Sin embargo, como es la misma sintaxis, debería ser

260
00:08:50,000 --> 00:08:52,000
relativamente fácil de acordarse como es que se le dice

261
00:08:52,000 --> 00:08:54,000
que esto es un parámetro. Entonces

262
00:08:54,000 --> 00:08:56,000
aquí le decimos a FastAPI.

263
00:08:56,000 --> 00:08:58,000
Lo que va después de este slash, esto es un parámetro

264
00:08:58,000 --> 00:09:00,000
de path, quiero que extraiga esto

265
00:09:00,000 --> 00:09:02,000
y usamos el mismo nombre en el

266
00:09:02,000 --> 00:09:04,000
parámetro que pasamos aquí a la función. Entonces

267
00:09:04,000 --> 00:09:06,000
FastAPI va a extraer desde aquí, desde la ura

268
00:09:06,000 --> 00:09:08,000
L, o sea va a sacar este 5

269
00:09:08,000 --> 00:09:10,000
y lo va a meter en este parámetro dentro

270
00:09:10,000 --> 00:09:12,000
de la función. Y aquí estamos usando

271
00:09:12,000 --> 00:09:14,000
los type annotations, las anotaciones de tipos

272
00:09:14,000 --> 00:09:16,000
para decirle al código

273
00:09:16,000 --> 00:09:18,000
esto es de tipo integer, o sea esto es un

274
00:09:18,000 --> 00:09:20,000
entero, esto es un número. Aquí no le

275
00:09:20,000 --> 00:09:22,000
estamos diciendo, esto no es el símbolo igual, sino

276
00:09:22,000 --> 00:09:24,000
dos puntos, con esto es con lo que le decimos

277
00:09:24,000 --> 00:09:26,000
ese es el tipo de este parámetro.

278
00:09:26,000 --> 00:09:28,000
Y entonces FastAPI se va

279
00:09:28,000 --> 00:09:30,000
a asegurar de que lo que recibimos acá

280
00:09:30,000 --> 00:09:32,000
sea efectivamente un número entero.

281
00:09:32,000 --> 00:09:34,000
No vamos a recibir un string,

282
00:09:34,000 --> 00:09:36,000
si se fijan esto aquí está en la parte de la ura L,

283
00:09:36,000 --> 00:09:38,000
o sea esto naturalmente esto es un string,

284
00:09:38,000 --> 00:09:40,000
esto viene como un string desde el protocolo

285
00:09:40,000 --> 00:09:42,000
de HTTP, pero FastAPI

286
00:09:42,000 --> 00:09:44,000
se va a encargar de convertir esto

287
00:09:44,000 --> 00:09:46,000
en un integer para que lo que recibamos sea un

288
00:09:46,000 --> 00:09:48,000
número. Y también le estamos diciendo

289
00:09:48,000 --> 00:09:50,000
ah, también tenemos este parámetro q

290
00:09:50,000 --> 00:09:52,000
que es de tipo

291
00:09:52,000 --> 00:09:54,000
string y por defecto es

292
00:09:54,000 --> 00:09:56,000
none, o sea el valor por defecto es

293
00:09:56,000 --> 00:09:58,000
none. Entonces eso significa

294
00:09:58,000 --> 00:10:00,000
que aquí le estamos diciendo a FastAPI quiero que

295
00:10:00,000 --> 00:10:02,000
extraiga este parámetro q también del

296
00:10:02,000 --> 00:10:04,000
request. Como este parámetro q

297
00:10:04,000 --> 00:10:06,000
no hace parte del path, FastAPI

298
00:10:06,000 --> 00:10:08,000
sabe que lo tiene que extraer desde los query

299
00:10:08,000 --> 00:10:10,000
parámetros, es decir, desde los parámetros

300
00:10:10,000 --> 00:10:12,000
de query que son los que van después de este símbolo

301
00:10:12,000 --> 00:10:14,000
de pregunta. Y aquí le estamos diciendo

302
00:10:14,000 --> 00:10:16,000
q va a ser igual a some query,

303
00:10:16,000 --> 00:10:18,000
entonces este texto, some query, FastAPI

304
00:10:18,000 --> 00:10:20,000
lo va a coger y lo va a meter en este parámetro q.

305
00:10:20,000 --> 00:10:22,000
Y vamos a tener este texto

306
00:10:22,000 --> 00:10:24,000
aquí dentro de nuestro código.

307
00:10:24,000 --> 00:10:26,000
Como esto por defecto tiene un valor de none,

308
00:10:26,000 --> 00:10:28,000
significa que no es requerido,

309
00:10:28,000 --> 00:10:30,000
es opcional. Entonces

310
00:10:30,000 --> 00:10:32,000
pues podríamos no pasarle el q

311
00:10:32,000 --> 00:10:34,000
y pues todo funcionaría como un incorriente.

312
00:10:34,000 --> 00:10:36,000
Y el código, en el

313
00:10:36,000 --> 00:10:38,000
código si no le pasamos q entonces este q va

314
00:10:38,000 --> 00:10:40,000
a tener el valor por defecto de none.

315
00:10:40,000 --> 00:10:42,000
Y aquí simplemente estamos usando eso

316
00:10:42,000 --> 00:10:44,000
por dentro y bueno, ya lo podemos usar.

317
00:10:44,000 --> 00:10:46,000
Realmente es un montón de

318
00:10:46,000 --> 00:10:48,000
como es que funcionan todos estos pedacitos,

319
00:10:48,000 --> 00:10:50,000
pero si se fijan es simplemente una función

320
00:10:50,000 --> 00:10:52,000
normal con parámetros

321
00:10:52,000 --> 00:10:54,000
y anotaciones de tipos comunes

322
00:10:54,000 --> 00:10:56,000
y corrientes de Python.

323
00:10:56,000 --> 00:10:58,000
Luego si nos vamos a SlashDocs

324
00:10:58,000 --> 00:11:00,000
FastAPI porque está

325
00:11:00,000 --> 00:11:02,000
basado en estos estándares y todo esto, nos genera

326
00:11:02,000 --> 00:11:04,000
automáticamente documentación

327
00:11:04,000 --> 00:11:06,000
interactiva de la API. Entonces

328
00:11:06,000 --> 00:11:08,000
aquí tenemos el primer get que va para el root,

329
00:11:08,000 --> 00:11:10,000
la ruta

330
00:11:10,000 --> 00:11:12,000
raíz. Y tenemos este otro

331
00:11:12,000 --> 00:11:14,000
que acabamos de crear que es SlashItems

332
00:11:14,000 --> 00:11:16,000
SlashItemId. Y este

333
00:11:16,000 --> 00:11:18,000
ItemId le estamos diciendo que esto es un

334
00:11:18,000 --> 00:11:20,000
parámetro que se extrae desde el path

335
00:11:20,000 --> 00:11:22,000
y que tiene que ser un integer

336
00:11:22,000 --> 00:11:24,000
y además es requerido.

337
00:11:24,000 --> 00:11:26,000
Toda esta información se está extrayendo automáticamente

338
00:11:26,000 --> 00:11:28,000
desde el código que escribimos. No tenemos

339
00:11:28,000 --> 00:11:30,000
que hacer nada más para que esto funcione. Eso se genera

340
00:11:30,000 --> 00:11:32,000
dinámicamente desde el código. Ni siquiera hay como

341
00:11:32,000 --> 00:11:34,000
un paso de compilar o algo así, no.

342
00:11:34,000 --> 00:11:36,000
Todo se genera automáticamente.

343
00:11:36,000 --> 00:11:38,000
También tenemos aquí el otro parámetro q que es un string

344
00:11:38,000 --> 00:11:40,000
y que se extrae del query.

345
00:11:40,000 --> 00:11:42,000
Y

346
00:11:42,000 --> 00:11:44,000
la idea es que podemos escribir código

347
00:11:44,000 --> 00:11:46,000
muy simple y Good Guy Fast API

348
00:11:46,000 --> 00:11:48,000
nos hace docs automáticamente. Entonces ya

349
00:11:48,000 --> 00:11:50,000
no hay que estar escribiendo docs en un documento

350
00:11:50,000 --> 00:11:52,000
de Google Docs que está olvidado

351
00:11:52,000 --> 00:11:54,000
y perdido hace tres años sin actualizarse

352
00:11:54,000 --> 00:11:56,000
mientras el frontend está quejándose de

353
00:11:56,000 --> 00:11:58,000
por qué no funciona el endpoint porque pues

354
00:11:58,000 --> 00:12:00,000
todo lo cambiamos. Ya no hay que escribir docs.

355
00:12:00,000 --> 00:12:02,000
Esa es la gracia.

356
00:12:02,000 --> 00:12:04,000
Vamos a hacer una app ahora un poquito

357
00:12:04,000 --> 00:12:06,000
más compleja. Esta va a recibir un

358
00:12:06,000 --> 00:12:08,000
cuerpo de mensaje. Es decir, va a esperar

359
00:12:08,000 --> 00:12:10,000
que el cliente le envíe un payload

360
00:12:10,000 --> 00:12:12,000
que le envíe contenido en JSON.

361
00:12:12,000 --> 00:12:14,000
Entonces ahora ya no estamos usando

362
00:12:14,000 --> 00:12:16,000
get, sino que estamos usando post.

363
00:12:16,000 --> 00:12:18,000
Le decimos, cuando alguien envíe un HTTP

364
00:12:18,000 --> 00:12:20,000
post, un request con HTTP

365
00:12:20,000 --> 00:12:22,000
post, con un método o una

366
00:12:22,000 --> 00:12:24,000
operación post y que vaya

367
00:12:24,000 --> 00:12:26,000
para slash food, esa es la

368
00:12:26,000 --> 00:12:28,000
función que queremos

369
00:12:28,000 --> 00:12:30,000
que lo reciban.

370
00:12:30,000 --> 00:12:32,000
Y lo que le estamos diciendo aquí en esta función es, esto va

371
00:12:32,000 --> 00:12:34,000
a tener un parámetro que se llama food y va a ser

372
00:12:34,000 --> 00:12:36,000
de tipo este food que estamos declarando

373
00:12:36,000 --> 00:12:38,000
acá.

374
00:12:38,000 --> 00:12:40,000
Este food lo estamos

375
00:12:40,000 --> 00:12:42,000
creando acá, es una clase.

376
00:12:42,000 --> 00:12:44,000
Esta es la sintaxis de estándar para decirle

377
00:12:44,000 --> 00:12:46,000
este parámetro debe ser un instance

378
00:12:46,000 --> 00:12:48,000
o

379
00:12:48,000 --> 00:12:50,000
un ejemplar. En español a veces decimos

380
00:12:50,000 --> 00:12:52,000
instancia aunque pues eso realmente no tiene mucho sentido.

381
00:12:52,000 --> 00:12:54,000
Pero pues va a ser un instance de esta clase

382
00:12:54,000 --> 00:12:56,000
food.

383
00:12:56,000 --> 00:12:58,000
Esta es la sintaxis de estándar para decir

384
00:12:58,000 --> 00:13:00,000
eso. Esto no significa que food va a ser

385
00:13:00,000 --> 00:13:02,000
la clase en sí, sino un instance de esa

386
00:13:02,000 --> 00:13:04,000
clase. La manera en la que creamos

387
00:13:04,000 --> 00:13:06,000
esta clase es que importamos desde

388
00:13:06,000 --> 00:13:08,000
Pydantic importamos base model.

389
00:13:08,000 --> 00:13:10,000
Fast API está hecho encima de dos herramientas,

390
00:13:10,000 --> 00:13:12,000
una es Starlet que hace toda la parte web,

391
00:13:12,000 --> 00:13:14,000
la otra es Pydantic que hace toda la parte de datos.

392
00:13:14,000 --> 00:13:16,000
El procesamiento de datos, validación

393
00:13:16,000 --> 00:13:18,000
y todo eso.

394
00:13:18,000 --> 00:13:20,000
La manera en la que funciona Pydantic es también

395
00:13:20,000 --> 00:13:22,000
basada en las mismas anotaciones de tipos.

396
00:13:22,000 --> 00:13:24,000
Entonces aquí le estamos diciendo

397
00:13:24,000 --> 00:13:26,000
esta clase food va a tener

398
00:13:26,000 --> 00:13:28,000
un name y esto va a

399
00:13:28,000 --> 00:13:30,000
ser de tipo string. También va a tener

400
00:13:30,000 --> 00:13:32,000
ingredients que va a ser una lista de

401
00:13:32,000 --> 00:13:34,000
strings y por defecto va a ser una lista

402
00:13:34,000 --> 00:13:36,000
vacía. De nuevo, estas son anotaciones

403
00:13:36,000 --> 00:13:38,000
de tipo standard. Este list lo estamos

404
00:13:38,000 --> 00:13:40,000
importando desde typing, eso es lo que tienen que

405
00:13:40,000 --> 00:13:42,000
hacer si están usando Python menor

406
00:13:42,000 --> 00:13:44,000
a 3.9.

407
00:13:44,000 --> 00:13:46,000
Si están en 3.9 ya ni siquiera tienen que importar

408
00:13:46,000 --> 00:13:48,000
de typing list y pueden usar el list

409
00:13:48,000 --> 00:13:50,000
que viene con el lowercase, con

410
00:13:50,000 --> 00:13:52,000
minúsculas en vez de usar este con mayúsculas.

411
00:13:52,000 --> 00:13:54,000
Si están en una versión anterior, se importa

412
00:13:54,000 --> 00:13:56,000
aquí desde typing. Typing es parte

413
00:13:56,000 --> 00:13:58,000
de Python en sí, es parte del standard

414
00:13:58,000 --> 00:14:00,000
library, o sea no hay que instalar algo adicional

415
00:14:00,000 --> 00:14:02,000
para utilizar este typing.

416
00:14:02,000 --> 00:14:04,000
Y bueno, ingredients tiene por defecto

417
00:14:04,000 --> 00:14:06,000
una lista vacía. FastAPI se va a encargar

418
00:14:06,000 --> 00:14:08,000
de que lo que recibimos aquí

419
00:14:08,000 --> 00:14:10,000
en este parámetro sea efectivamente un instance

420
00:14:10,000 --> 00:14:12,000
de esta clase tal cual como la definimos.

421
00:14:12,000 --> 00:14:14,000
Entonces podemos acceder a los atributos

422
00:14:14,000 --> 00:14:16,000
por dentro del código.

423
00:14:16,000 --> 00:14:18,000
Y luego cuando nos vamos a los docs

424
00:14:18,000 --> 00:14:20,000
vamos a ver que la información

425
00:14:20,000 --> 00:14:22,000
que declaramos en ese modelo de

426
00:14:22,000 --> 00:14:24,000
Pydantic es extraída por FastAPI

427
00:14:24,000 --> 00:14:26,000
y queda en la documentación automáticamente.

428
00:14:26,000 --> 00:14:28,000
Ya tenemos que esto espera recibir

429
00:14:28,000 --> 00:14:30,000
el equivalente a un diccionario de Python

430
00:14:30,000 --> 00:14:32,000
o en términos de JSON, un objeto

431
00:14:32,000 --> 00:14:34,000
de JSON que por dentro tiene un name

432
00:14:34,000 --> 00:14:36,000
que es un string y tiene ingredients

433
00:14:36,000 --> 00:14:38,000
que es el equivalente, va a ser una lista

434
00:14:38,000 --> 00:14:40,000
de Python o en términos de JSON, una array

435
00:14:40,000 --> 00:14:42,000
de strings.

436
00:14:42,000 --> 00:14:44,000
Y entonces el punto

437
00:14:44,000 --> 00:14:46,000
cool de esto es que estamos

438
00:14:46,000 --> 00:14:48,000
definiendo automáticamente

439
00:14:48,000 --> 00:14:50,000
la documentación, se genera automáticamente

440
00:14:50,000 --> 00:14:52,000
de los datos importantes para nuestra

441
00:14:52,000 --> 00:14:54,000
aplicación. Esto no es algo que

442
00:14:54,000 --> 00:14:56,000
esto no es un modelo

443
00:14:56,000 --> 00:14:58,000
o una clase que viene con FastAPI, sino

444
00:14:58,000 --> 00:15:00,000
algo que creamos para lo que nos importa

445
00:15:00,000 --> 00:15:02,000
recibir en nuestra aplicación. Y toda la

446
00:15:02,000 --> 00:15:04,000
documentación y toda la evaluación se está haciendo

447
00:15:04,000 --> 00:15:06,000
automáticamente con esas anotaciones

448
00:15:06,000 --> 00:15:08,000
de tipos.

449
00:15:08,000 --> 00:15:10,000
Si le déjenme volver un segundito,

450
00:15:10,000 --> 00:15:12,000
entonces estamos acá. Si le hacemos click

451
00:15:12,000 --> 00:15:14,000
a este botón, try it out, esto es todo en el navegador,

452
00:15:14,000 --> 00:15:16,000
si le hacemos click a try it out,

453
00:15:16,000 --> 00:15:18,000
podemos interactuar con nuestra

454
00:15:18,000 --> 00:15:20,000
aplicación que estamos desarrollando ahí

455
00:15:20,000 --> 00:15:22,000
en vivo y podemos interactuar desde el navegador y enviarle

456
00:15:22,000 --> 00:15:24,000
requests y recibir los responses

457
00:15:24,000 --> 00:15:26,000
y ver cómo está funcionando todo

458
00:15:26,000 --> 00:15:28,000
sin tener que hacer un frontend, sin tener que aprender

459
00:15:28,000 --> 00:15:30,000
a usar todos los detalles de cool,

460
00:15:30,000 --> 00:15:32,000
nada más, podemos interactuar directamente ahí con el API

461
00:15:32,000 --> 00:15:34,000
que estamos construyendo. Por ejemplo,

462
00:15:34,000 --> 00:15:36,000
le podemos enviar un cuerpo

463
00:15:36,000 --> 00:15:38,000
del food que queremos crear, en este caso es

464
00:15:38,000 --> 00:15:40,000
una empanada que los ingredientes son harina, carne,

465
00:15:40,000 --> 00:15:42,000
arroz y sabrosura, como todos ustedes

466
00:15:42,000 --> 00:15:44,000
ya saben. Espero que

467
00:15:44,000 --> 00:15:46,000
sepan. Y entonces

468
00:15:46,000 --> 00:15:48,000
aquí le decimos execute y esto

469
00:15:48,000 --> 00:15:50,000
efectivamente le envía este request,

470
00:15:50,000 --> 00:15:52,000
se lo envía al servidor que tenemos

471
00:15:52,000 --> 00:15:54,000
ahí ejecutando en el mismo computador mientras estamos

472
00:15:54,000 --> 00:15:56,000
desarrollando, va a ejecutar

473
00:15:56,000 --> 00:15:58,000
el request, nos va a devolver el response

474
00:15:58,000 --> 00:16:00,000
y vemos el response aquí en la misma

475
00:16:00,000 --> 00:16:02,000
interfaz interactiva. Entonces podemos

476
00:16:02,000 --> 00:16:04,000
ver que nos preparó una empanada.

477
00:16:04,000 --> 00:16:06,000
¡Qué belleza!

478
00:16:06,000 --> 00:16:08,000
Entonces podemos pedir requests llenos de empanadas

479
00:16:08,000 --> 00:16:10,000
y vernos así. Yo vivo en Alemania

480
00:16:10,000 --> 00:16:12,000
y no hay empanadas.

481
00:16:12,000 --> 00:16:14,000
Por eso es que

482
00:16:14,000 --> 00:16:16,000
hago esta carita cuando veo empanadas.

483
00:16:16,000 --> 00:16:18,000
Bueno, vamos ahora a hacer

484
00:16:18,000 --> 00:16:20,000
un request que recibió un cuerpo y recibió

485
00:16:20,000 --> 00:16:22,000
un query. Seguimos haciendo lo

486
00:16:22,000 --> 00:16:24,000
mismo que hacíamos, definimos parámetros

487
00:16:24,000 --> 00:16:26,000
con anotaciones de tipos y

488
00:16:26,000 --> 00:16:28,000
FastTapYS encarga de hacer el resto. Aquí le decimos

489
00:16:28,000 --> 00:16:30,000
full, va a ser un instance de full, delivery

490
00:16:30,000 --> 00:16:32,000
va a ser un boolean, o sea esto va a ser true

491
00:16:32,000 --> 00:16:34,000
o false, que por de facto es false.

492
00:16:34,000 --> 00:16:36,000
Esto

493
00:16:36,000 --> 00:16:38,000
de nuevo son los query parameters

494
00:16:38,000 --> 00:16:40,000
y vienen en

495
00:16:40,000 --> 00:16:42,000
la URL que pues esto es un string

496
00:16:42,000 --> 00:16:44,000
grande. FastTapYS va a encargar de

497
00:16:44,000 --> 00:16:46,000
extraer la información y convertirla a un boolean

498
00:16:46,000 --> 00:16:48,000
de manera que el tipo de dato que recibimos

499
00:16:48,000 --> 00:16:50,000
aquí dentro de nuestro código va a ser

500
00:16:50,000 --> 00:16:52,000
efectivamente un boolean. Cuando nos vamos

501
00:16:52,000 --> 00:16:54,000
a la documentación, así es como

502
00:16:54,000 --> 00:16:56,000
vamos a enviar la URL. Dijamos que lo vamos a

503
00:16:56,000 --> 00:16:58,000
decidir de libre y es igual true, pues esto

504
00:16:58,000 --> 00:17:00,000
viene en un string pero FastTapYS lo extrae y lo convierte

505
00:17:00,000 --> 00:17:02,000
como un boolean. Como la documentación

506
00:17:02,000 --> 00:17:04,000
automática sabe que esto solamente puede

507
00:17:04,000 --> 00:17:06,000
ser de tipo boolean, nos da las dos

508
00:17:06,000 --> 00:17:08,000
únicas opciones posibles que son true o false

509
00:17:08,000 --> 00:17:10,000
dentro de esta documentación interactiva.

510
00:17:10,000 --> 00:17:12,000
Entonces no tenemos que poner

511
00:17:12,000 --> 00:17:14,000
todo en el cuerpo, podemos usar los query parameters

512
00:17:14,000 --> 00:17:16,000
cuando tiene sentido.

513
00:17:16,000 --> 00:17:18,000
Vamos a ver

514
00:17:18,000 --> 00:17:20,000
la gente reírse de verdad.

515
00:17:22,000 --> 00:17:24,000
Listo, ahora digamos que queremos enviar

516
00:17:24,000 --> 00:17:26,000
no queremos enviar un solo objeto de JSON, sino queremos

517
00:17:26,000 --> 00:17:28,000
enviar una estructura compleja, queremos enviar

518
00:17:28,000 --> 00:17:30,000
una lista de diccionarios o

519
00:17:30,000 --> 00:17:32,000
el equivalente en JSON es un JSONArray

520
00:17:32,000 --> 00:17:34,000
de JSONObjects.

521
00:17:34,000 --> 00:17:36,000
Seguimos usando las mismas anotaciones de tipos

522
00:17:36,000 --> 00:17:38,000
estándar. Ahora le decimos ya no vamos a recibir

523
00:17:38,000 --> 00:17:40,000
un solo food item, sino que vamos a recibir

524
00:17:40,000 --> 00:17:42,000
una lista de instances

525
00:17:42,000 --> 00:17:44,000
de food que vamos a meter dentro de orders.

526
00:17:44,000 --> 00:17:46,000
Y FastCPA se encarga de asegurarse que

527
00:17:46,000 --> 00:17:48,000
eso es lo que recibimos. Entonces ya podemos

528
00:17:48,000 --> 00:17:50,000
iterar por cada uno de los foods

529
00:17:50,000 --> 00:17:52,000
dentro de este orders y luego por

530
00:17:52,000 --> 00:17:54,000
cada uno de los ingredients dentro de cada

531
00:17:54,000 --> 00:17:56,000
ingredient y podemos hacer todas las operaciones aquí que

532
00:17:56,000 --> 00:17:58,000
quedamos dentro del código con

533
00:17:58,000 --> 00:18:00,000
los datos que recibimos según las anotaciones

534
00:18:00,000 --> 00:18:02,000
que hicimos, según las anotaciones de los

535
00:18:02,000 --> 00:18:04,000
tipos de datos. Si nos vamos

536
00:18:04,000 --> 00:18:06,000
a la documentación automática vemos que

537
00:18:06,000 --> 00:18:08,000
ya tenemos estos otros square brackets

538
00:18:08,000 --> 00:18:10,000
o

539
00:18:10,000 --> 00:18:12,000
no sé qué términos

540
00:18:12,000 --> 00:18:14,000
tengan esto en español según la región de donde

541
00:18:14,000 --> 00:18:16,000
vengan. Es como banana es lo único

542
00:18:16,000 --> 00:18:18,000
que es igual en todos los idiomas, pero

543
00:18:18,000 --> 00:18:20,000
fresa, frutilla, no sé qué

544
00:18:20,000 --> 00:18:22,000
más nombres tiene. El caso es que

545
00:18:22,000 --> 00:18:24,000
aquí estamos recibiendo una lista

546
00:18:24,000 --> 00:18:26,000
de objetos de JSON.

547
00:18:26,000 --> 00:18:28,000
Entonces si queremos poner JSON y lo queremos

548
00:18:28,000 --> 00:18:30,000
poner dentro del JSON podemos hacer eso.

549
00:18:30,000 --> 00:18:32,000
La idea es podemos definir

550
00:18:32,000 --> 00:18:34,000
estructuras de datos que pueden ser

551
00:18:34,000 --> 00:18:36,000
tan arbitrariamente complejas

552
00:18:36,000 --> 00:18:38,000
y anidadas de las formas que necesitemos

553
00:18:38,000 --> 00:18:40,000
para el código que tenemos que crear

554
00:18:40,000 --> 00:18:42,000
simplemente usando las mismas anotaciones

555
00:18:42,000 --> 00:18:44,000
de tipos. No hay que usar nada más,

556
00:18:44,000 --> 00:18:46,000
sino las mismas anotaciones de tipos standard

557
00:18:46,000 --> 00:18:48,000
de Python.

558
00:18:48,000 --> 00:18:50,000
Ahora les he estado diciendo que FastAPI

559
00:18:50,000 --> 00:18:52,000
se asegura de que lo que recibimos es exactamente

560
00:18:52,000 --> 00:18:54,000
eso que pedimos que fuéramos a recibir.

561
00:18:54,000 --> 00:18:56,000
¿Qué pasa si alguien envía datos que son inválidos?

562
00:18:56,000 --> 00:18:58,000
Entonces esto es JSON

563
00:18:58,000 --> 00:19:00,000
válido. Como JSON es válido, no es que le

564
00:19:00,000 --> 00:19:02,000
falta una coma, no es que tenga una coma extra aquí al final

565
00:19:02,000 --> 00:19:04,000
o alguna cosa así. Pero los datos

566
00:19:04,000 --> 00:19:06,000
no son exactamente como definimos

567
00:19:06,000 --> 00:19:08,000
que queríamos recibirlos. Le estamos enviando

568
00:19:08,000 --> 00:19:10,000
listos. Esto es una gran lista que por dentro tiene objetos.

569
00:19:10,000 --> 00:19:12,000
Hasta ahí estamos bien.

570
00:19:12,000 --> 00:19:14,000
El primer objeto tiene un name, que es un

571
00:19:14,000 --> 00:19:16,000
string empanada, muy bien.

572
00:19:16,000 --> 00:19:18,000
Ingredients es una lista que por dentro tiene

573
00:19:18,000 --> 00:19:20,000
strings, este está bien.

574
00:19:20,000 --> 00:19:22,000
Miremos el segundo elemento. Tiene un name

575
00:19:22,000 --> 00:19:24,000
que es pizza, este no tiene ingredients,

576
00:19:24,000 --> 00:19:26,000
pero dijimos que ingredients tenía un valor por defecto

577
00:19:26,000 --> 00:19:28,000
de una lista vacía.

578
00:19:30,000 --> 00:19:32,000
Entonces, como tiene un valor por defecto, no es requerido.

579
00:19:32,000 --> 00:19:34,000
Entonces este elemento también

580
00:19:34,000 --> 00:19:36,000
está bien. Pero ahora miramos este elemento,

581
00:19:36,000 --> 00:19:38,000
tiene un name, está bien. Ingredients

582
00:19:38,000 --> 00:19:40,000
es una lista, está bien.

583
00:19:40,000 --> 00:19:42,000
El primer ingredient es un string.

584
00:19:42,000 --> 00:19:44,000
Hasta aquí vamos bien.

585
00:19:44,000 --> 00:19:46,000
Pero aquí el segundo ingredient,

586
00:19:46,000 --> 00:19:48,000
el segundo ingrediente que tenemos, no es

587
00:19:48,000 --> 00:19:50,000
un string, es un objeto

588
00:19:50,000 --> 00:19:52,000
con alacranes por dentro y eso no lo queremos

589
00:19:52,000 --> 00:19:54,000
dentro de la comida.

590
00:19:54,000 --> 00:19:56,000
Espero. Aunque no sé, hay gente que le gusta

591
00:19:56,000 --> 00:19:58,000
mucho el picante.

592
00:19:58,000 --> 00:20:00,000
Pero el caso es que esto aquí

593
00:20:00,000 --> 00:20:02,000
tiene un error, pero está muy

594
00:20:02,000 --> 00:20:04,000
metido por dentro de la estructura de datos.

595
00:20:04,000 --> 00:20:06,000
Sin embargo, aquí adentro de esa estructura

596
00:20:06,000 --> 00:20:08,000
de datos, no es exactamente

597
00:20:08,000 --> 00:20:10,000
lo que dijimos que queríamos recibir.

598
00:20:10,000 --> 00:20:12,000
Y luego tenemos este último que tiene un food name

599
00:20:12,000 --> 00:20:14,000
que es pan viejo,

600
00:20:14,000 --> 00:20:16,000
pero lo que dijimos es que queremos recibir un name,

601
00:20:16,000 --> 00:20:18,000
no un food name. Entonces este en realidad

602
00:20:18,000 --> 00:20:20,000
tampoco tiene ese. Si tratamos

603
00:20:20,000 --> 00:20:22,000
de enviar este request, pasta y pizza

604
00:20:22,000 --> 00:20:24,000
van a encargar de validar los datos

605
00:20:24,000 --> 00:20:26,000
y devolverle al cliente, no solamente decirle

606
00:20:26,000 --> 00:20:28,000
hey, estos datos son inválidos

607
00:20:28,000 --> 00:20:30,000
y usted verá cómo los arreglas,

608
00:20:30,000 --> 00:20:32,000
sino que le dice exactamente en dónde está el problema.

609
00:20:32,000 --> 00:20:34,000
Entonces dentro del cuerpo, dentro de las órdenes,

610
00:20:34,000 --> 00:20:36,000
en el índex 2, dentro de los ingredientes,

611
00:20:36,000 --> 00:20:38,000
en el índex 1, o sea el índex

612
00:20:38,000 --> 00:20:40,000
1 es el primero, índex 1 es el segundo,

613
00:20:40,000 --> 00:20:42,000
un string type was

614
00:20:42,000 --> 00:20:44,000
expected, o sea esperábamos recibir

615
00:20:44,000 --> 00:20:46,000
un string, pero usted nos envió un objeto

616
00:20:46,000 --> 00:20:48,000
con alacranes. Y tenemos

617
00:20:48,000 --> 00:20:50,000
también el otro error de una vez que nos dice

618
00:20:50,000 --> 00:20:52,000
dentro del cuerpo, dentro de las órdenes, en el

619
00:20:52,000 --> 00:20:54,000
string 3, el name era requerido

620
00:20:54,000 --> 00:20:56,000
y no nos lo envió. Entonces no solamente

621
00:20:56,000 --> 00:20:58,000
está diciendo hey, hay un error acá, sino que dice

622
00:20:58,000 --> 00:21:00,000
exactamente dónde está el error. Esto puede ayudar

623
00:21:00,000 --> 00:21:02,000
a un montón de bugueando

624
00:21:02,000 --> 00:21:04,000
los APIs para poder hacer las cosas mucho

625
00:21:04,000 --> 00:21:06,000
más rápido. Y todo eso

626
00:21:06,000 --> 00:21:08,000
fue basado en las anotaciones

627
00:21:08,000 --> 00:21:10,000
de tipos. Entonces solamente definimos

628
00:21:10,000 --> 00:21:12,000
cuál es el tipo de datos que queremos recibir

629
00:21:12,000 --> 00:21:14,000
y con eso tenemos autocompletado,

630
00:21:14,000 --> 00:21:16,000
errores en línea, todo eso, y FastAPS

631
00:21:16,000 --> 00:21:18,000
se encarga de validar los datos por nosotros.

632
00:21:18,000 --> 00:21:20,000
Eso nos ahorra, no sé, 50 líneas de código por cada

633
00:21:20,000 --> 00:21:22,000
función revisando, ay, esto es un diccionario o no,

634
00:21:22,000 --> 00:21:24,000
es una lista o no, tiene este elemento o no,

635
00:21:24,000 --> 00:21:26,000
es del tipo que es, todo ese tipo de cosas

636
00:21:26,000 --> 00:21:28,000
podemos evitarlas. Entonces

637
00:21:28,000 --> 00:21:30,000
cuando los datos son inválidos, FastAPI

638
00:21:30,000 --> 00:21:32,000
nos protege el código

639
00:21:32,000 --> 00:21:34,000
de ejecutarse con cosas que no funcionan,

640
00:21:34,000 --> 00:21:36,000
pero cuando los datos

641
00:21:36,000 --> 00:21:38,000
son válidos, FastAPI simplemente

642
00:21:38,000 --> 00:21:40,000
sigue el flujo normal del código

643
00:21:40,000 --> 00:21:42,000
y el código se ejecuta como lo

644
00:21:42,000 --> 00:21:44,000
definimos que esperábamos

645
00:21:44,000 --> 00:21:46,000
ejecutarlo. Y pues también podemos

646
00:21:46,000 --> 00:21:48,000
ser felices como este perrito.

647
00:21:48,000 --> 00:21:50,000
Ahora

648
00:21:50,000 --> 00:21:52,000
como les decía, todo esto está basado en las anotaciones

649
00:21:52,000 --> 00:21:54,000
de tipos estándar. Significa que

650
00:21:54,000 --> 00:21:56,000
tenemos autocompletado en todo el código

651
00:21:56,000 --> 00:21:58,000
por dentro. Si se fijan aquí estamos en un

652
00:21:58,000 --> 00:22:00,000
for loop que está doblemente

653
00:22:00,000 --> 00:22:02,000
anidado

654
00:22:02,000 --> 00:22:04,000
y aún así podemos tener autocompletado para cada uno

655
00:22:04,000 --> 00:22:06,000
de estos ingredientes. El editor sabe

656
00:22:06,000 --> 00:22:08,000
que cada ingrediente

657
00:22:08,000 --> 00:22:10,000
es un string, entonces nos puede dar autocompletado

658
00:22:10,000 --> 00:22:12,000
para los strings. Estos son los métodos

659
00:22:12,000 --> 00:22:14,000
que podemos usar en strings y el editor lo sabe.

660
00:22:14,000 --> 00:22:16,000
Y lo sabe porque sabe que cada ingredient es un

661
00:22:16,000 --> 00:22:18,000
string, porque sabe que cada ingredient

662
00:22:18,000 --> 00:22:20,000
viene de esta lista que es food

663
00:22:20,000 --> 00:22:22,000
.ingredients. Y eso lo

664
00:22:22,000 --> 00:22:24,000
definimos acá, que ingredients era una

665
00:22:24,000 --> 00:22:26,000
lista de strings. Y sabe que este

666
00:22:26,000 --> 00:22:28,000
food

667
00:22:28,000 --> 00:22:30,000
es un instance de esta clase

668
00:22:30,000 --> 00:22:32,000
porque este food viene desde los orders

669
00:22:32,000 --> 00:22:34,000
y orders lo definimos aquí

670
00:22:34,000 --> 00:22:36,000
como que era una lista de los instances de food.

671
00:22:36,000 --> 00:22:38,000
Entonces el punto es

672
00:22:38,000 --> 00:22:40,000
declaramos con anotaciones de tipos estándar

673
00:22:40,000 --> 00:22:42,000
de Python, cuáles son los datos que

674
00:22:42,000 --> 00:22:44,000
esperamos recibir y ya

675
00:22:44,000 --> 00:22:46,000
por hacer eso en cualquier aplicación de Python

676
00:22:46,000 --> 00:22:48,000
sin fast API, ya con eso van a tener

677
00:22:48,000 --> 00:22:50,000
autocompletado que

678
00:22:50,000 --> 00:22:52,000
pues yo no tengo muy buena memoria

679
00:22:52,000 --> 00:22:54,000
yo no me acuerdo así como de

680
00:22:54,000 --> 00:22:56,000
así de la nada cuáles son los métodos, los nombres

681
00:22:56,000 --> 00:22:58,000
que puse como que voy a saber

682
00:22:58,000 --> 00:23:00,000
autocompletado, para eso está el editor.

683
00:23:00,000 --> 00:23:02,000
Entonces ya con usar las anotaciones

684
00:23:02,000 --> 00:23:04,000
de tipos tenemos un montón de autocompletado

685
00:23:04,000 --> 00:23:06,000
pero usándolas con fast API tenemos

686
00:23:06,000 --> 00:23:08,000
validación de datos automática

687
00:23:08,000 --> 00:23:10,000
y documentación automática

688
00:23:10,000 --> 00:23:12,000
sobre todos esos datos.

689
00:23:12,000 --> 00:23:14,000
Además también tenemos chequeos de tipos

690
00:23:14,000 --> 00:23:16,000
tenemos errores en línea, estas rayitas

691
00:23:16,000 --> 00:23:18,000
rojitas que nos dicen, eh ya que hay un error

692
00:23:18,000 --> 00:23:20,000
nos está diciendo ingredient, no se puede

693
00:23:20,000 --> 00:23:22,000
sumar con un número entero

694
00:23:22,000 --> 00:23:24,000
porque no puede combinar strings

695
00:23:24,000 --> 00:23:26,000
no los puede sumar con integers

696
00:23:26,000 --> 00:23:28,000
y eso es porque sabe que ingredient es

697
00:23:28,000 --> 00:23:30,000
un string, si no tuviéramos las anotaciones

698
00:23:30,000 --> 00:23:32,000
de tipos no tendría ni idea, el editor

699
00:23:32,000 --> 00:23:34,000
no podría decirnos cuál es el tipo de

700
00:23:34,000 --> 00:23:36,000
datos de esta variable ingredient

701
00:23:36,000 --> 00:23:38,000
sería como, ni idea, usted verá qué está haciendo

702
00:23:38,000 --> 00:23:40,000
pero acá nos puede decir

703
00:23:40,000 --> 00:23:42,000
hey, aquí hay un error, entonces podemos

704
00:23:42,000 --> 00:23:44,000
arreglarlo incluso antes de que

705
00:23:44,000 --> 00:23:46,000
hagamos git commit, lo cual significa

706
00:23:46,000 --> 00:23:48,000
que nunca hicimos el error

707
00:23:48,000 --> 00:23:50,000
nunca se explotó en producción y podemos decir

708
00:23:50,000 --> 00:23:52,000
ah, soy un ingeniero de SX o alguna cosa así

709
00:23:52,000 --> 00:23:54,000
eh, porque pues

710
00:23:54,000 --> 00:23:56,000
este error nunca llegó a

711
00:23:56,000 --> 00:23:58,000
producción, nunca se explotó por allá, nunca

712
00:23:58,000 --> 00:24:00,000
afectó a ningún customer, simplemente

713
00:24:00,000 --> 00:24:02,000
lo arreglamos incluso antes de hacer git commit

714
00:24:02,000 --> 00:24:04,000
porque vemos el error que en el editor

715
00:24:04,000 --> 00:24:06,000
todo esto está basado en tipos

716
00:24:06,000 --> 00:24:08,000
estándar de Python, en ningún momento

717
00:24:08,000 --> 00:24:10,000
importamos desde fast API el string

718
00:24:10,000 --> 00:24:12,000
de fast API o algo así, sino que usamos los mismos

719
00:24:12,000 --> 00:24:14,000
strings normales de Python

720
00:24:14,000 --> 00:24:16,000
eh, ahora sobre el

721
00:24:16,000 --> 00:24:18,000
desempeño, esto es

722
00:24:18,000 --> 00:24:20,000
un benchmark que es ejecutado

723
00:24:20,000 --> 00:24:22,000
por un

724
00:24:22,000 --> 00:24:24,000
tercer partido, un tercero

725
00:24:24,000 --> 00:24:26,000
que se llama Tekken Power y ellos

726
00:24:26,000 --> 00:24:28,000
hacen benchmarks de un montón de lenguajes, un montón

727
00:24:28,000 --> 00:24:30,000
de frameworks y un montón de combinaciones

728
00:24:30,000 --> 00:24:32,000
de cosas como para probar el

729
00:24:32,000 --> 00:24:34,000
performance de todas estas herramientas

730
00:24:34,000 --> 00:24:36,000
aquí les estoy mostrando, filtrando solamente por las cosas

731
00:24:36,000 --> 00:24:38,000
escritas en Go, que es un lenguaje

732
00:24:38,000 --> 00:24:40,000
programación compilado y las cosas en Python

733
00:24:40,000 --> 00:24:42,000
Python está en azul, Go

734
00:24:42,000 --> 00:24:44,000
por ser compilado tiene

735
00:24:44,000 --> 00:24:46,000
que ser mucho más rápido que Python

736
00:24:46,000 --> 00:24:48,000
porque es un lenguaje compilado, hay que hacer todo

737
00:24:48,000 --> 00:24:50,000
un montón de trabajo extra para poder programar en Go

738
00:24:50,000 --> 00:24:52,000
sin embargo, porque fast API

739
00:24:52,000 --> 00:24:54,000
usa estas herramientas aquí por debajo

740
00:24:54,000 --> 00:24:56,000
fast API y algunos otros, pocos acá

741
00:24:56,000 --> 00:24:58,000
que también usan ese mismo tipo de trucos

742
00:24:58,000 --> 00:25:00,000
de funcionar de forma

743
00:25:00,000 --> 00:25:02,000
asíncrona y utilizar estas otras herramientas

744
00:25:02,000 --> 00:25:04,000
de alto desempeño por debajo

745
00:25:04,000 --> 00:25:06,000
logra tener un muy buen desempeño que

746
00:25:06,000 --> 00:25:08,000
puede ser incluso comparable con algunos de los

747
00:25:08,000 --> 00:25:10,000
frameworks de Go

748
00:25:10,000 --> 00:25:12,000
entonces pues, se puede tener muy

749
00:25:12,000 --> 00:25:14,000
buen performance, digamos que

750
00:25:14,000 --> 00:25:16,000
en el ballpark, como en el rango

751
00:25:16,000 --> 00:25:18,000
dentro de lo mejor sito que se puede tener

752
00:25:18,000 --> 00:25:20,000
dentro de Python

753
00:25:20,000 --> 00:25:22,000
¿Cuál de estos es el más rápido de todos?

754
00:25:22,000 --> 00:25:24,000
también tiene un poquito de ruido

755
00:25:24,000 --> 00:25:26,000
porque por ejemplo, Ubicorn está aquí debajo

756
00:25:26,000 --> 00:25:28,000
Ubicorn no es un framework, Ubicorn es el servidor

757
00:25:28,000 --> 00:25:30,000
que ejecuta fast API

758
00:25:30,000 --> 00:25:32,000
del que Marcelo es el maintainer

759
00:25:32,000 --> 00:25:34,000
en este momento

760
00:25:34,000 --> 00:25:36,000
y Ubicorn en realidad

761
00:25:36,000 --> 00:25:38,000
Ubicorn en realidad no es un framework

762
00:25:38,000 --> 00:25:40,000
tiene que ser, y todos estos otros

763
00:25:40,000 --> 00:25:42,000
frameworks están utilizando Ubicorn por debajo

764
00:25:42,000 --> 00:25:44,000
Ubicorn tendría que estar aquí por encima de todo

765
00:25:44,000 --> 00:25:46,000
pero pues bueno, ahí tenemos un poquito de

766
00:25:46,000 --> 00:25:48,000
random error, el punto es con fast API

767
00:25:48,000 --> 00:25:50,000
aquí estamos pudiendo tener 15.000

768
00:25:50,000 --> 00:25:52,000
requests por segundo en este benchmark

769
00:25:52,000 --> 00:25:54,000
específico, y pues esos son más de 9.000

770
00:25:54,000 --> 00:25:56,000
requests por segundo, entonces pues, nice

771
00:25:56,000 --> 00:25:58,000
y bueno

772
00:25:58,000 --> 00:26:00,000
hay otro montón de características, hay un sistema

773
00:26:00,000 --> 00:26:02,000
de inyección de dependencias que facilita

774
00:26:02,000 --> 00:26:04,000
un montón de integraciones con un montón de cosas

775
00:26:04,000 --> 00:26:06,000
de manera que no se necesitan realmente

776
00:26:06,000 --> 00:26:08,000
plugins, porque uno puede simplemente

777
00:26:08,000 --> 00:26:10,000
usar funciones que le dice a fast API

778
00:26:10,000 --> 00:26:12,000
ejecuta esto por mi

779
00:26:12,000 --> 00:26:14,000
y ahí puede utilizar los paquetes

780
00:26:14,000 --> 00:26:16,000
que sea que necesite para autenticación, para

781
00:26:16,000 --> 00:26:18,000
log, para lo que sea

782
00:26:18,000 --> 00:26:20,000
y para otro montón de cositas

783
00:26:20,000 --> 00:26:22,000
también hay integración

784
00:26:22,000 --> 00:26:24,000
integración con OAuth 2

785
00:26:24,000 --> 00:26:26,000
esto es lo que usan por ejemplo, no sé

786
00:26:26,000 --> 00:26:28,000
Facebook, Google, GitHub, cuando uno le dice autenticar con

787
00:26:28,000 --> 00:26:30,000
todo eso es basado en esto

788
00:26:30,000 --> 00:26:32,000
entonces uno puede crear aplicaciones de fast API

789
00:26:32,000 --> 00:26:34,000
que fácilmente se pueden

790
00:26:34,000 --> 00:26:36,000
decir autenticar con Google

791
00:26:36,000 --> 00:26:38,000
también puede uno crear aplicaciones

792
00:26:38,000 --> 00:26:40,000
con las que otros

793
00:26:40,000 --> 00:26:42,000
se pueden autenticar utilizando la herramienta

794
00:26:42,000 --> 00:26:44,000
de uno, cosas así

795
00:26:44,000 --> 00:26:46,000
todo esto es basado en esos estándares que son

796
00:26:46,000 --> 00:26:48,000
en lo que se basa todo fast API

797
00:26:48,000 --> 00:26:50,000
soporte para web sockets, archivos, tareas en segundo plano

798
00:26:50,000 --> 00:26:52,000
templates, integración con GraphQL

799
00:26:52,000 --> 00:26:54,000
un montón de cositas, las cosas que uno esperaría

800
00:26:54,000 --> 00:26:56,000
de un framework de estos

801
00:26:56,000 --> 00:26:58,000
un montón de cosas así por el estilo, digamos que

802
00:26:58,000 --> 00:27:00,000
el objetivo es web APIs

803
00:27:00,000 --> 00:27:02,000
pero

804
00:27:02,000 --> 00:27:04,000
lo están usando para un montón de cosas

805
00:27:04,000 --> 00:27:06,000
también muy locas incluso

806
00:27:06,000 --> 00:27:08,000
entonces pues bueno, uno puede conseguir todas las cositas que uno esperaría

807
00:27:08,000 --> 00:27:10,000
cuando no es buena idea

808
00:27:10,000 --> 00:27:12,000
ponerse a moverse a fast API

809
00:27:12,000 --> 00:27:14,000
digamos que uno ya tiene una aplicación con Django

810
00:27:14,000 --> 00:27:16,000
es estable, funciona

811
00:27:16,000 --> 00:27:18,000
no hay que agregarle

812
00:27:18,000 --> 00:27:20,000
ninguna nueva característica, no es una API

813
00:27:20,000 --> 00:27:22,000
no hay ninguna necesidad de

814
00:27:22,000 --> 00:27:24,000
cambiarse a fast API

815
00:27:24,000 --> 00:27:26,000
sin embargo hay equipos que lo han hecho

816
00:27:26,000 --> 00:27:28,000
y pues han estado contentos

817
00:27:28,000 --> 00:27:30,000
no sé por qué, pero pues no es necesario

818
00:27:30,000 --> 00:27:32,000
ponerse a migrar todo a fast API

819
00:27:32,000 --> 00:27:34,000
a menos de que uno

820
00:27:34,000 --> 00:27:36,000
se vaya a beneficiar de los features

821
00:27:36,000 --> 00:27:38,000
que uno necesite el autocompletado

822
00:27:38,000 --> 00:27:40,000
que necesite los chequeos en línea

823
00:27:40,000 --> 00:27:42,000
que esté agregando nuevos features

824
00:27:42,000 --> 00:27:44,000
que en realidad es una API, que va a facilitar

825
00:27:44,000 --> 00:27:46,000
el desarrollo más rápido

826
00:27:46,000 --> 00:27:48,000
en casos así tal vez tenga sentido

827
00:27:48,000 --> 00:27:50,000
pero pues hay muchos casos en los que realmente no tiene sentido

828
00:27:50,000 --> 00:27:52,000
como vamos a mirar todo a fast API

829
00:27:52,000 --> 00:27:54,000
en muchos casos es también

830
00:27:54,000 --> 00:27:56,000
muy

831
00:27:56,000 --> 00:27:58,000
válido y muy común

832
00:27:58,000 --> 00:28:00,000
compartir el mismo código de todas las

833
00:28:00,000 --> 00:28:02,000
herramientas internas de la aplicación que se está haciendo

834
00:28:02,000 --> 00:28:04,000
por un lado usarlos dentro de Django

835
00:28:04,000 --> 00:28:06,000
por el otro lado usarlos dentro de fast API

836
00:28:06,000 --> 00:28:08,000
o migrar gradualmente

837
00:28:08,000 --> 00:28:10,000
alguna aplicación que se tenga en fast API

838
00:28:10,000 --> 00:28:12,000
en Django o en Flash o alguna cosa así

839
00:28:12,000 --> 00:28:14,000
pero bueno, el caso es que no siempre tiene sentido

840
00:28:14,000 --> 00:28:16,000
siempre decir ah, cambiamos todo a fast API

841
00:28:16,000 --> 00:28:18,000
necesariamente

842
00:28:18,000 --> 00:28:20,000
bueno, ahora sí

843
00:28:20,000 --> 00:28:22,000
algunos de los detalles técnicos

844
00:28:22,000 --> 00:28:24,000
no mentiras, no los voy a aburrir con más cosas

845
00:28:26,000 --> 00:28:28,000
este mem solo lo puedo usar aquí

846
00:28:28,000 --> 00:28:30,000
esto ni siquiera fue popular solamente

847
00:28:30,000 --> 00:28:32,000
entre los latinos

848
00:28:32,000 --> 00:28:34,000
eso ni siquiera fue internacional

849
00:28:34,000 --> 00:28:36,000
muy pocas veces que lo puedo usar

850
00:28:38,000 --> 00:28:40,000
super cool por usar

851
00:28:40,000 --> 00:28:42,000
muchas gracias por todo

852
00:28:42,000 --> 00:28:44,000
no creo que alcancemos a tener mucho tiempo para preguntas

853
00:28:44,000 --> 00:28:46,000
yo igual estoy aquí por los corredores y estoy aquí también mañana

854
00:28:46,000 --> 00:28:48,000
y el resto de la semana voy a estar por ahí

855
00:28:48,000 --> 00:28:50,000
entonces me pueden saludar y decir como

856
00:28:50,000 --> 00:28:52,000
hey

857
00:28:52,000 --> 00:28:54,000
mejor Flask

858
00:28:54,000 --> 00:28:56,000
muchas gracias

859
00:28:56,000 --> 00:28:58,000
muchas gracias por estar acá

