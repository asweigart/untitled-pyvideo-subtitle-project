1
00:00:00,000 --> 00:00:07,000
Hello, my name is Jonas, I'm the session chair for the upcoming session of three talks.

2
00:00:07,000 --> 00:00:16,000
The first speaker I want to introduce to you is Victor Sinner, who will be talking to us about introducing incompatible changes in Python.

3
00:00:16,000 --> 00:00:18,000
Take it away.

4
00:00:18,000 --> 00:00:26,000
Hi everybody, I'm here to talk about how to introduce incompatible changes in Python,

5
00:00:26,000 --> 00:00:32,000
and especially how to reduce the number of affected people and reduce the number of grumpy people.

6
00:00:32,000 --> 00:00:40,000
My name is Victor Sinner, I'm coming from France, and I'm paid by Red Hat to maintain Python downstream and upstream.

7
00:00:40,000 --> 00:00:49,000
Downstream is to maintain Python in the Fedora and Red Hat operating system, and upstream is Python.org, so the main pattern.

8
00:00:50,000 --> 00:00:58,000
I'm a code developer since 2010, and since 2010 I went through many incompatible changes,

9
00:00:58,000 --> 00:01:06,000
and my work at Red Hat is mostly about incompatible changes and how to deal with them, so I would like to talk about that.

10
00:01:06,000 --> 00:01:12,000
I'm a happy Fedora and Red Hat user, and you can find me on Twitter.

11
00:01:13,000 --> 00:01:22,000
First I would like to travel in the past and see the previous approach regarding incompatible changes, which is called the D-Day approach.

12
00:01:22,000 --> 00:01:28,000
You may notice on the picture that everything is out of the way, and you will understand why.

13
00:01:28,000 --> 00:01:41,000
So if you travel in time, for about 14 years ago, before the Python 3, a long time ago, in a galaxy far, far away, there was Python 3.

14
00:01:42,000 --> 00:01:55,000
So maybe some of you used Python tools, and one of the big things with Python tools was to handle text, especially what is called the Unicode Errors,

15
00:01:55,000 --> 00:02:02,000
because everything was biased and it was causing a lot of problems.

16
00:02:02,000 --> 00:02:09,000
And in the Python tool era, Django started to become a real critical of the PHP framework and Ruby on Rails.

17
00:02:09,000 --> 00:02:16,000
But one of the common issues in Django was to handle Unicode text, especially non-nasty characters.

18
00:02:16,000 --> 00:02:26,000
And as a French person, I can say that we are very aware of Unicode Errors, because even in the first time, we can get non-nasty characters,

19
00:02:26,000 --> 00:02:32,000
and this was just enough to close the big description on our world web browser.

20
00:02:32,000 --> 00:02:38,000
And just in Python 2 in general, handling Unicode Errors was a frequently asked question.

21
00:02:38,000 --> 00:02:43,000
So for the rule, we didn't choose Python 2.

22
00:02:43,000 --> 00:02:49,000
You have to know that just a string, LBC, this is a byte string.

23
00:02:49,000 --> 00:02:52,000
This is not a string made of characters, but of bytes.

24
00:02:52,000 --> 00:03:00,000
And if you try to concatenate a byte string and a unicode string in Python 2, you get an Unicode Error.

25
00:03:00,000 --> 00:03:09,000
If one of them is non-nasty, and that's not something very obvious, because if all of your content is made of asked characters, you're fine.

26
00:03:09,000 --> 00:03:16,000
But as soon as a French person starts to draw and give you his name, you get into trouble.

27
00:03:16,000 --> 00:03:21,000
And getting Unicode correctly was very complicated in Python 2.

28
00:03:21,000 --> 00:03:29,000
So what was decided to work around this issue is to fix what you call the root issue of this problem.

29
00:03:29,000 --> 00:03:35,000
The root issue of this problem is to make the Unicode type a first-itizen class.

30
00:03:35,000 --> 00:03:38,000
For Scrapper, first-itizen, sorry.

31
00:03:38,000 --> 00:03:45,000
And for example, to combat this infamous LBC string, now this string is a Unicode string,

32
00:03:45,000 --> 00:03:50,000
which means that each part of the string is a real character and not a byte.

33
00:03:50,000 --> 00:03:54,000
And this is the major difference between Python 2 and Python 3.

34
00:03:54,000 --> 00:04:05,000
Sadly, the big deal with that is if you come from the Python 2 world and want to embrace the beautiful Python 3 world,

35
00:04:05,000 --> 00:04:08,000
you have to go through all of this Unicode issue at once.

36
00:04:08,000 --> 00:04:15,000
And this is really painful, because in Python 2, if you only have asked characters, you're good.

37
00:04:15,000 --> 00:04:18,000
But as soon as you have non-nasty characters, you get into trouble.

38
00:04:18,000 --> 00:04:24,000
In the Python 2 world, it's very different, because you get zero as soon as you start your operation.

39
00:04:24,000 --> 00:04:30,000
And you have to fix all issues at once to be able to integrate Python 3.

40
00:04:30,000 --> 00:04:38,000
And in the old era of Python 2, we also started to introduce new concepts.

41
00:04:38,000 --> 00:04:47,000
For example, what is called the iterator, the type 234, that was introduced in Python 2.2.

42
00:04:47,000 --> 00:04:52,000
And also a new concept called the numerators, and that was a long time ago.

43
00:04:52,000 --> 00:04:55,000
That's the type 255.

44
00:04:55,000 --> 00:05:04,000
And because it was a new theme in Python 2.2, things like a built-in function, mark, and zip were still written and used.

45
00:05:04,000 --> 00:05:11,000
And this is fine for most of the cases, when you are manipulating biometric data,

46
00:05:11,000 --> 00:05:17,000
because you have to add a little bit too much memory, because you have to complete all values at once.

47
00:05:17,000 --> 00:05:25,000
And that's not the most efficient way to process a file or process it from a data in your application.

48
00:05:25,000 --> 00:05:35,000
So to switch to the new fancy world of iterator and generator, you have to opt-in for something called the iterator's module,

49
00:05:35,000 --> 00:05:40,000
and to use imap and izip, which this one returned a generator.

50
00:05:40,000 --> 00:05:55,000
And another example of that is that for the built-in type dictionary, you can iterate on pairs of key and values using the items method.

51
00:05:55,000 --> 00:05:59,000
But if you call this one again, you get a list.

52
00:05:59,000 --> 00:06:08,000
And if you wanted to use a more efficient generator, you have to opt-in for the iter items.

53
00:06:08,000 --> 00:06:19,000
So again, Python 3 decided to make the language consistent and to fix that issue by changing the map and zip built-in functions.

54
00:06:19,000 --> 00:06:22,000
So now this one returns an iterator.

55
00:06:22,000 --> 00:06:28,000
You don't have to opt-in for the iterator's module, it's just the default.

56
00:06:28,000 --> 00:06:33,000
And the same for the dictionary method, they also return generators.

57
00:06:33,000 --> 00:06:40,000
And if you really want to get a list, you have to explicitly cast the generator to a list, and that's it.

58
00:06:42,000 --> 00:06:47,000
So the Python language evolved as Python 3, that has same default module,

59
00:06:47,000 --> 00:06:58,000
because we want the users to have the most efficient and the best method by default, and not ask for help to use something uncommon.

60
00:06:58,000 --> 00:07:09,000
So the default module is now to use Unicard to create generators, and to make the whole language consistent again.

61
00:07:10,000 --> 00:07:21,000
The big deal with all of these changes is that, from the Python 2 world, when you migrate Python 3, all of these changes are backward in the compiler.

62
00:07:22,000 --> 00:07:35,000
So, the next question is, why did we decide to break up everything and to change the default and to bring a lot of change to all of our users?

63
00:07:35,000 --> 00:07:41,000
I think that one of the reasons can be found in the Zen of Python, SuperPonty,

64
00:07:41,000 --> 00:07:48,000
which shows that there should be one, preferably only one obvious way to do it.

65
00:07:49,000 --> 00:07:57,000
What it means is that when you write Python operation, Python module, we are trying to get consistent coding style,

66
00:07:57,000 --> 00:08:02,000
Python language should be easy to teach, and also easy to review.

67
00:08:02,000 --> 00:08:08,000
So when you read the code, it should be very obvious, and you should not have to think about,

68
00:08:08,000 --> 00:08:13,000
oh, is it the correct way, or should I use the other way to do it?

69
00:08:15,000 --> 00:08:20,000
So, it's a deciding approach for the migration to Python 3.

70
00:08:21,000 --> 00:08:23,000
Honestly, it was very simple.

71
00:08:23,000 --> 00:08:30,000
The rule was that everybody has to run an application called 2-3 to migrate their code base,

72
00:08:30,000 --> 00:08:39,000
and the idea was everybody has to do it on the same day, and suddenly everybody becomes compatible with Python 3.

73
00:08:40,000 --> 00:08:50,000
Well, it didn't work as expected, because we did not expect that we got something called Jogos,

74
00:08:50,000 --> 00:08:56,000
and in fact we had many, many users, way more than expected,

75
00:08:56,000 --> 00:09:04,000
and something that was not really prepared is that when you have a large application with dependencies,

76
00:09:04,000 --> 00:09:11,000
and one of them is not compatible with Python 3, you are blocked by this single dependency.

77
00:09:11,000 --> 00:09:19,000
So first, you have to migrate this dependency to Python 3, just to be able to start coding your code to Python 3.

78
00:09:19,000 --> 00:09:27,000
So it's a long process of connecting all dependencies, and also dependencies of dependencies, so you can have a long chain.

79
00:09:28,000 --> 00:09:35,000
And the other issue is that this wonderful program called 2-3 is a one-way tool.

80
00:09:35,000 --> 00:09:39,000
So you go to Python 3, but you cannot go back out.

81
00:09:39,000 --> 00:09:45,000
It means that when you run the application, you drop support support into,

82
00:09:45,000 --> 00:09:51,000
and that was not something that we wanted as a maintainer of our project,

83
00:09:51,000 --> 00:09:57,000
because Python 2 was simply the most commonly used version of Python.

84
00:09:57,000 --> 00:10:01,000
Python 3 was a new thing. It was full of bugs, it was slower.

85
00:10:01,000 --> 00:10:05,000
So we had to find a way to support both.

86
00:10:05,000 --> 00:10:13,000
And the last problem is that the migration by itself took over 10 years, which is quite long.

87
00:10:14,000 --> 00:10:22,000
So to explain to you this problem of the D-Day, I found another example in the history of the Sundown County.

88
00:10:22,000 --> 00:10:28,000
So they decided that on one day, on the 3rd September of 1967,

89
00:10:28,000 --> 00:10:35,000
they switched from driving on the left-hand side of the road to the right-hand side of the road.

90
00:10:35,000 --> 00:10:39,000
It's called the D-Day, or D-Day in Swedish.

91
00:10:39,000 --> 00:10:42,000
And they took four years to prepare the city for this migration,

92
00:10:42,000 --> 00:10:46,000
because it would impact the world, people of the country.

93
00:10:46,000 --> 00:10:50,000
For example, to give you an idea of the cost of the migration,

94
00:10:50,000 --> 00:10:58,000
they had to change more than 350,000 signs to remove them or to replace them.

95
00:10:58,000 --> 00:11:03,000
And just in the city of Stockholm, they had to change 20,000 signs.

96
00:11:03,000 --> 00:11:10,000
So it's not only about the signs, it's also about the bus with the door on the one side,

97
00:11:10,000 --> 00:11:15,000
it's about the bus stop, about the tram and many, many other things.

98
00:11:16,000 --> 00:11:21,000
So to advertise this change, they even created their logo.

99
00:11:21,000 --> 00:11:28,000
And the logo is quite straightforward. You move from the left to the right with the date below.

100
00:11:28,000 --> 00:11:32,000
So they created underwear and socks.

101
00:11:32,000 --> 00:11:40,000
And I think it's quite a good idea to advertise the change and prepare everybody for this big day.

102
00:11:40,000 --> 00:11:46,000
And T.V. Channel also decided to organize a contest of the dance song.

103
00:11:46,000 --> 00:11:51,000
And this is the winner, keep to the right, Svenson.

104
00:11:51,000 --> 00:11:55,000
It's a song to advertise the migration.

105
00:11:56,000 --> 00:12:01,000
Okay, so we talked about the Python language Excel.

106
00:12:01,000 --> 00:12:07,000
But on my side, I care about what is called CIPI.

107
00:12:07,000 --> 00:12:13,000
For people who don't know that, the CIPI is used to expand the Python language

108
00:12:13,000 --> 00:12:18,000
because Python has already many modules as part of the standard memory.

109
00:12:18,000 --> 00:12:22,000
But sometimes you want things which are not supported by default.

110
00:12:22,000 --> 00:12:26,000
So you want to expand the language by writing three extensions.

111
00:12:26,000 --> 00:12:31,000
And for that, you need a way to connect the three codes to the Python.

112
00:12:31,000 --> 00:12:35,000
And thanks to the CIPI, we have great modules.

113
00:12:35,000 --> 00:12:42,000
And this is really part of the success of the Python language as a whole community.

114
00:12:42,000 --> 00:12:47,000
And without the CIPI, there is no Python, there is no non-Python,

115
00:12:47,000 --> 00:12:50,000
so there is no scientific community.

116
00:12:50,000 --> 00:12:55,000
You cut large parts of the Python's success.

117
00:12:55,000 --> 00:12:59,000
And now drivers for data analysis, etc.

118
00:12:59,000 --> 00:13:05,000
This is an example of recent changes in the CIPI.

119
00:13:05,000 --> 00:13:11,000
There is a huge and growing work for Microsoft to optimize Python.

120
00:13:11,000 --> 00:13:14,000
And by the way, you should be required to Python 3.11.

121
00:13:14,000 --> 00:13:20,000
It's a big system which uses less memory, which is quite impressive.

122
00:13:20,000 --> 00:13:27,000
But to achieve this goal, we have to make some deep changes in the internals of Python,

123
00:13:27,000 --> 00:13:30,000
in the code which executes the bytecode.

124
00:13:30,000 --> 00:13:36,000
And to make these changes, we have to modify what we call the structures of the language,

125
00:13:36,000 --> 00:13:42,000
like the code object, the frame object, and also the thread state.

126
00:13:42,000 --> 00:13:49,000
The problem with these changes is that sadly, some people rely on the exact structures,

127
00:13:49,000 --> 00:13:53,000
on the exact behavior, and there is no abstraction.

128
00:13:53,000 --> 00:13:58,000
So people access their thing to the structures, and as soon as one of the members changes,

129
00:13:58,000 --> 00:14:04,000
that becomes an irreparable change.

130
00:14:04,000 --> 00:14:12,000
So for example, when you access your thing to the funderscore code member of the code object,

131
00:14:12,000 --> 00:14:15,000
it doesn't work anymore.

132
00:14:15,000 --> 00:14:18,000
Now you have to call a function for that,

133
00:14:18,000 --> 00:14:21,000
pyncode underscore getCode,

134
00:14:21,000 --> 00:14:26,000
and you have to make some changes for the frame and for the thread state.

135
00:14:26,000 --> 00:14:32,000
And the new problem with that is that these functions are new in Python 3.11,

136
00:14:32,000 --> 00:14:37,000
and you cannot get access to these functions in Python 3.10, because these functions are new.

137
00:14:37,000 --> 00:14:41,000
So to make your code compatible with Python 3.11,

138
00:14:41,000 --> 00:14:48,000
one of the ways is to have what you call if-dev, to have conditional code depending on the version of Python,

139
00:14:48,000 --> 00:14:53,000
or you can simply decide that everybody has to move to Python 3.11,

140
00:14:53,000 --> 00:14:59,000
and you give up on supporting old Python.

141
00:14:59,000 --> 00:15:05,000
Okay, so that was a long introduction of what was done in the past.

142
00:15:05,000 --> 00:15:09,000
Now let me introduce what is done in QL Clinic,

143
00:15:09,000 --> 00:15:16,000
and what we learned on how we are making things differently on Edge.

144
00:15:16,000 --> 00:15:24,000
So first of all, I think this was one of the technical solutions to a major issue

145
00:15:24,000 --> 00:15:28,000
in the transition from Python 2 to Python 4.

146
00:15:28,000 --> 00:15:32,000
Benjamin Peterson created a module called 6,

147
00:15:32,000 --> 00:15:41,000
and this module allows you to write code working on Python 2 and Python 3 using a single code base.

148
00:15:41,000 --> 00:15:45,000
So depending on the version of Python, the implementation will be different,

149
00:15:45,000 --> 00:15:50,000
but the code is always the same on the 2 version of Python.

150
00:15:50,000 --> 00:15:55,000
This is really something very important for the migration,

151
00:15:55,000 --> 00:16:02,000
because this is really a very different approach for the migration to Python 3.

152
00:16:02,000 --> 00:16:09,000
Instead of running 2 to 3 and drop support for Python 2, something that nobody wants,

153
00:16:09,000 --> 00:16:13,000
the new approach is to add support for Python 3.

154
00:16:13,000 --> 00:16:17,000
So you don't use support for the old version, you add support for the new version.

155
00:16:17,000 --> 00:16:22,000
And this is way better, because nobody will lose anything,

156
00:16:22,000 --> 00:16:27,000
you just add support for new users, and this is way better.

157
00:16:27,000 --> 00:16:31,000
So the new approach is to port infinitely the code,

158
00:16:31,000 --> 00:16:35,000
so you don't have to port everything at once.

159
00:16:35,000 --> 00:16:39,000
So for example, if you have 10 files, you can go one by one,

160
00:16:39,000 --> 00:16:44,000
and this is way easier to migrate on an application.

161
00:16:44,000 --> 00:16:49,000
So we just say that as we do play the approach using 2 to 3,

162
00:16:49,000 --> 00:16:55,000
the new approach just abandons, because it doesn't work in practice.

163
00:16:55,000 --> 00:17:00,000
So I would like to say that we learned that that was not a good approach,

164
00:17:00,000 --> 00:17:04,000
and we can do it differently.

165
00:17:04,000 --> 00:17:09,000
About incompatible changes, what I said previously is that

166
00:17:09,000 --> 00:17:16,000
to make some optimization, to add new features, to keep the language consistent,

167
00:17:16,000 --> 00:17:19,000
we have to introduce incompatible changes,

168
00:17:19,000 --> 00:17:23,000
but there are some ongoing discussions to say that,

169
00:17:23,000 --> 00:17:28,000
okay, maybe we can have a different timeline for these changes,

170
00:17:28,000 --> 00:17:31,000
because we don't have to make them right now,

171
00:17:31,000 --> 00:17:36,000
maybe sometimes we need more time to migrate everybody.

172
00:17:36,000 --> 00:17:40,000
So in the engagement cycle of Python 3.11,

173
00:17:40,000 --> 00:17:45,000
we identified that the two changes were causing a lot of troubles,

174
00:17:45,000 --> 00:17:50,000
and the problem is that a lot of Python commissioners in the world

175
00:17:50,000 --> 00:17:53,000
still wanted to support Python 2.7,

176
00:17:53,000 --> 00:17:57,000
and the support for Python 2.7 just ended up clean,

177
00:17:57,000 --> 00:18:00,000
because it was three years ago,

178
00:18:00,000 --> 00:18:06,000
and dropping Python 2.7 right now was not an option,

179
00:18:06,000 --> 00:18:10,000
so we decided just to revert some changes,

180
00:18:10,000 --> 00:18:15,000
just to give people more time to embrace Python 3,

181
00:18:15,000 --> 00:18:18,000
and slowly drop the support for Python 2,

182
00:18:18,000 --> 00:18:22,000
but don't require people to drop it right now.

183
00:18:22,000 --> 00:18:25,000
I think this is something new in the Python community,

184
00:18:25,000 --> 00:18:27,000
and we learned from our mistakes,

185
00:18:27,000 --> 00:18:31,000
and we are trying to learn from the feedback of the community,

186
00:18:31,000 --> 00:18:35,000
and to make things smoother for everybody.

187
00:18:35,000 --> 00:18:41,000
So the two reverted changes are one flag when you open a file,

188
00:18:41,000 --> 00:18:46,000
it was a flag which was ignored on Python 3 for 10 years,

189
00:18:46,000 --> 00:18:49,000
we just decided to keep it for one more release,

190
00:18:49,000 --> 00:18:55,000
and the other one are aliases for collection abstract,

191
00:18:55,000 --> 00:18:57,000
there is classes,

192
00:18:57,000 --> 00:19:00,000
these aliases are just kept for one more collection,

193
00:19:00,000 --> 00:19:04,000
but again we remove them in the next Python 3.11.

194
00:19:06,000 --> 00:19:09,000
So again, in the recently released Python 3.11,

195
00:19:09,000 --> 00:19:18,000
we also noticed that a bunch of changes were causing too many troubles to 20 projects,

196
00:19:18,000 --> 00:19:23,000
so we identified that unique test aliases removal,

197
00:19:23,000 --> 00:19:28,000
the deprecated conflict parser functions removal,

198
00:19:28,000 --> 00:19:30,000
and the removal of the wall,

199
00:19:30,000 --> 00:19:34,000
I think our model was causing too much trouble,

200
00:19:34,000 --> 00:19:38,000
and we decided to keep them for one more release,

201
00:19:38,000 --> 00:19:41,000
and to remove them in the next Python 3.12.

202
00:19:42,000 --> 00:19:45,000
Because again, it affected too many packages,

203
00:19:45,000 --> 00:19:51,000
and the idea is to give one more year to everybody to embrace this change.

204
00:19:51,000 --> 00:19:56,000
About the policy, we have a PEP called the Backward Compatibility Policy,

205
00:19:56,000 --> 00:19:59,000
the PEP 387,

206
00:19:59,000 --> 00:20:03,000
and this one describes how we deprecate something in Python,

207
00:20:03,000 --> 00:20:06,000
and how this theory is written for.

208
00:20:06,000 --> 00:20:10,000
Previously, we could remove in a single version,

209
00:20:10,000 --> 00:20:12,000
deprecate in one version,

210
00:20:12,000 --> 00:20:14,000
and remove in the next version.

211
00:20:14,000 --> 00:20:18,000
So in two versions, you could remove from one version,

212
00:20:18,000 --> 00:20:25,000
and it was fine because we got a Python release every 18 months,

213
00:20:25,000 --> 00:20:32,000
but since the release of Python is exactly once per year,

214
00:20:32,000 --> 00:20:35,000
so the development cycle is shorter,

215
00:20:35,000 --> 00:20:38,000
and the deprecation period was shorter,

216
00:20:38,000 --> 00:20:40,000
and a little bit too short,

217
00:20:40,000 --> 00:20:45,000
so after our discussion, we decided to give the last version,

218
00:20:45,000 --> 00:20:50,000
so after our discussion, we decided to give two years to everybody

219
00:20:50,000 --> 00:20:58,000
to notice the deprecation and adapt the project for the studio's removal.

220
00:20:59,000 --> 00:21:04,000
For example, if you want to remove a function in Python 3.11,

221
00:21:04,000 --> 00:21:07,000
it has to remain deprecated in 3.12,

222
00:21:07,000 --> 00:21:11,000
and you can only remove it in 3.13.

223
00:21:11,000 --> 00:21:14,000
So overall, it takes three years.

224
00:21:15,000 --> 00:21:18,000
By the way, about the deprecation running,

225
00:21:18,000 --> 00:21:23,000
we decided to hide the deprecation running by default,

226
00:21:23,000 --> 00:21:29,000
because we noticed that this running was causing too many troubles to users,

227
00:21:29,000 --> 00:21:35,000
because most of the users of Python are actually teams of users,

228
00:21:35,000 --> 00:21:37,000
and not really developers.

229
00:21:37,000 --> 00:21:43,000
So the best is to fit the use case of the majority of users,

230
00:21:43,000 --> 00:21:46,000
which is to hide the warnings,

231
00:21:46,000 --> 00:21:53,000
and to suggest to the developers to opt in to show these warnings.

232
00:21:53,000 --> 00:21:57,000
In Python 3.37, we made a private challenge,

233
00:21:57,000 --> 00:22:00,000
which is that for scripts, for the main module,

234
00:22:00,000 --> 00:22:03,000
these warnings are shown again by default.

235
00:22:03,000 --> 00:22:07,000
So if your developer wants to see these warnings,

236
00:22:07,000 --> 00:22:09,000
there are different ways,

237
00:22:09,000 --> 00:22:14,000
and one of them is to use the command line option uppercase W.

238
00:22:14,000 --> 00:22:18,000
With the value default, you display this warning once,

239
00:22:18,000 --> 00:22:23,000
and if you pass er, you treat all warnings as enough.

240
00:22:23,000 --> 00:22:26,000
And if need, you can go into the documentation

241
00:22:26,000 --> 00:22:31,000
and see how to filter warnings per module or per file,

242
00:22:31,000 --> 00:22:35,000
and there are many ways to control the warnings.

243
00:22:35,000 --> 00:22:39,000
And I also added something called the Python development mode,

244
00:22:39,000 --> 00:22:42,000
which shows the warning by default,

245
00:22:42,000 --> 00:22:49,000
that it also enables other kinds of helpers for developers to detect bugs earlier.

246
00:22:49,000 --> 00:22:52,000
And if you want to enable the development mode,

247
00:22:52,000 --> 00:22:57,000
you can add the option dash uppercase x.

248
00:22:58,000 --> 00:23:05,000
So what I would propose for smooth deprecation of a function in Python,

249
00:23:05,000 --> 00:23:10,000
so how to have a smooth integration for incompatible changes,

250
00:23:10,000 --> 00:23:13,000
is to follow this step.

251
00:23:13,000 --> 00:23:17,000
So first of all, what you can do is to add the new API,

252
00:23:17,000 --> 00:23:22,000
because adding an API has no impact, this is just fine for everybody.

253
00:23:22,000 --> 00:23:27,000
Slowly, you can duplicate as an old way in the documentation,

254
00:23:27,000 --> 00:23:30,000
but only in the documentation.

255
00:23:30,000 --> 00:23:34,000
Afterwards, you can start to edit a warning at runtime,

256
00:23:34,000 --> 00:23:38,000
so when you actually use a function.

257
00:23:38,000 --> 00:23:41,000
And what is really important in my opinion,

258
00:23:41,000 --> 00:23:45,000
is to explain how to update the code to the new way,

259
00:23:45,000 --> 00:23:49,000
and it provides a solution to run a single code base

260
00:23:49,000 --> 00:23:53,000
working for the old way and the new way.

261
00:23:53,000 --> 00:23:58,000
Because this is the only acceptable solution to have an integration,

262
00:23:58,000 --> 00:24:05,000
otherwise people just get empty and will abandon Python and switch to something else.

263
00:24:05,000 --> 00:24:13,000
And the explanation is the documentation and providing a concrete solution to our single code base.

264
00:24:13,000 --> 00:24:15,000
I think this is something new in Python,

265
00:24:15,000 --> 00:24:19,000
and I think that we should do that even more.

266
00:24:19,000 --> 00:24:24,000
When you did all of the steps, in that case, okay, you can remove the old way,

267
00:24:24,000 --> 00:24:28,000
you can remove the old API.

268
00:24:28,000 --> 00:24:33,000
So as part of my job, what I did is to use code charge.

269
00:24:33,000 --> 00:24:41,000
So when I noticed that one of the challenges can cause incompatible change,

270
00:24:41,000 --> 00:24:48,000
what you can do is to first download the source code of the most popular API project.

271
00:24:48,000 --> 00:24:54,000
For example, with the script, you download the source code of 5,000 projects.

272
00:24:54,000 --> 00:25:01,000
And once you have everything locally, you can use a tool to charge using a regular expression.

273
00:25:01,000 --> 00:25:05,000
And this way, you can identify which projects are affected,

274
00:25:05,000 --> 00:25:08,000
how many projects are affected,

275
00:25:08,000 --> 00:25:12,000
and then you can also look how the API is used,

276
00:25:12,000 --> 00:25:24,000
so to think about how to update the code and how you can explain to people how to migrate to the new one.

277
00:25:24,000 --> 00:25:29,000
So overall, for me, the ideal integration would be to add an API,

278
00:25:29,000 --> 00:25:35,000
document the challenge, and also provide coding to help the integration,

279
00:25:35,000 --> 00:25:39,000
and then you can automate most of the steps even better.

280
00:25:39,000 --> 00:25:47,000
Identify projects which are affected by your change, and if possible, update this affected project.

281
00:25:47,000 --> 00:25:53,000
And the most difficult part is the next part, is to wait until you get your release,

282
00:25:53,000 --> 00:25:57,000
because fixing an issue in the code is easy,

283
00:25:57,000 --> 00:26:02,000
but if you don't have the release included in the code, people are still affected in practice,

284
00:26:02,000 --> 00:26:09,000
because they just use a different style of something, and they are still getting the old version with the issue.

285
00:26:09,000 --> 00:26:15,000
So in an ideal integration, you should wait for release of all affected projects,

286
00:26:15,000 --> 00:26:21,000
then you can think about duplicating the API, and then remove the API.

287
00:26:21,000 --> 00:26:29,000
So this plan takes between three and five years, depending on how many projects are affected.

288
00:26:29,000 --> 00:26:36,000
Okay, now there is a new category of projects, which is causing more trouble than the other one.

289
00:26:36,000 --> 00:26:43,000
It's projects which are only maintained by the single person, and this person is unable to wait about.

290
00:26:43,000 --> 00:26:49,000
And the problem with that is that if there are core dependency scores,

291
00:26:49,000 --> 00:26:58,000
means that they are very common, so you cannot hold them, and you are really blocked by these dependencies.

292
00:26:58,000 --> 00:27:04,000
So why a maintainer can be busy? In fact, there are different reasons.

293
00:27:04,000 --> 00:27:13,000
People can be busy with their work, with life duties, they can be bored by the project and move to something else,

294
00:27:13,000 --> 00:27:17,000
they can move to a different programming language, they can move to a different job,

295
00:27:17,000 --> 00:27:26,000
they can get someone sick in their family, in their friends, they can just change their life for the higher-level.

296
00:27:26,000 --> 00:27:37,000
I don't like what we call the birth factor, or saying that the only way to deal with a project is a good maintainer or not,

297
00:27:37,000 --> 00:27:44,000
it's depending on how many people maintain the project, because if they are hit by a bus, they can die.

298
00:27:44,000 --> 00:27:48,000
I don't like this comparison, because the death is something uncommon.

299
00:27:48,000 --> 00:27:57,000
But moving to a new job or being bored is something very common, and it's becoming a big issue in the open source community.

300
00:27:57,000 --> 00:28:05,000
So now the question is how can you update this project when the maintainer doesn't reply?

301
00:28:05,000 --> 00:28:15,000
Honestly, I don't know, because sometimes the maintainer decides to come back, sometimes there is no reply and you are blocked.

302
00:28:15,000 --> 00:28:19,000
One way is to force the project and create a new one.

303
00:28:19,000 --> 00:28:28,000
Maybe you can use authorities and they'll cover the project, but this is really an easy issue.

304
00:28:28,000 --> 00:28:39,000
You may be aware of that, but this is also the issue of funding, because maintaining a package which is very popular can take a lot of time,

305
00:28:39,000 --> 00:28:43,000
a lot of energy, and usually could allow the pay for that.

306
00:28:43,000 --> 00:28:52,000
So if you consider that the dependency is very important for your project, please think about funding and help these people not get in trouble.

307
00:28:52,000 --> 00:29:03,000
Another problem with this project is maintaining a project which is very popular, which I think has won't work,

308
00:29:03,000 --> 00:29:07,000
because it's very uncommon to get a thank you email.

309
00:29:07,000 --> 00:29:18,000
Most communication that you get from users only comprises one and they get the request that we need, the request that we need to do this, and then they say that,

310
00:29:18,000 --> 00:29:27,000
oh, my boss asked me to do that and you have to do it for me.

311
00:29:27,000 --> 00:29:32,000
The other category of projects is what I call the hidden project.

312
00:29:32,000 --> 00:29:37,000
There are projects which are developed behind closed doors.

313
00:29:37,000 --> 00:29:45,000
You can think about the resource groups or giant applications made of millions of lines of code.

314
00:29:45,000 --> 00:29:52,000
A different way to describe them is a closed source project.

315
00:29:52,000 --> 00:30:00,000
The issue with this one is if you think about a new compatible challenge, you don't have access to this project.

316
00:30:00,000 --> 00:30:04,000
So you cannot estimate how many of these projects are affected.

317
00:30:04,000 --> 00:30:07,000
You cannot help them to migrate.

318
00:30:07,000 --> 00:30:14,000
How you can do is to expect that some people will be affected, but you don't know how many.

319
00:30:14,000 --> 00:30:20,000
Usually this category of projects is a very old code base.

320
00:30:20,000 --> 00:30:22,000
It's no longer maintained.

321
00:30:22,000 --> 00:30:26,000
And as a result, Turnover is a development team.

322
00:30:26,000 --> 00:30:32,000
So the people who created this project usually moved to a different new, higher project.

323
00:30:32,000 --> 00:30:38,000
And the new team who is supposed to maintain this project doesn't understand anything about the code.

324
00:30:38,000 --> 00:30:45,000
So it's very difficult to reduce the technical depth and to upgrade it to the new API.

325
00:30:45,000 --> 00:30:50,000
One solution for that is to use a script called the ParryUpgrade.

326
00:30:50,000 --> 00:31:00,000
ParryUpgrade identifies some code patterns and tries to use a new way in Python, which is compatible with the newer Python.

327
00:31:00,000 --> 00:31:04,000
For example, when there is a new API or a new syntax.

328
00:31:04,000 --> 00:31:07,000
So you should give a try to this tool.

329
00:31:07,000 --> 00:31:13,000
And for the C API, I wrote a project called Upgrade.CAPI.

330
00:31:13,000 --> 00:31:24,000
So this project takes your C extension and adds support for the new Python without losing support for the old Python, which is very important.

331
00:31:24,000 --> 00:31:34,000
Obviously, if you cannot use this tool, if you don't know how to update your code, there is always the last resort option.

332
00:31:34,000 --> 00:31:36,000
Just keep the old Python.

333
00:31:36,000 --> 00:31:39,000
It will continue to work forever.

334
00:31:39,000 --> 00:31:48,000
Just be aware that you will be in a lot of security issues and many vulnerabilities in Python.

335
00:31:48,000 --> 00:31:53,000
So if your application is isolated from the rest of the world, it's fine.

336
00:31:53,000 --> 00:31:59,000
If it's connected to the Internet, be prepared for attacks.

337
00:31:59,000 --> 00:32:08,000
To come back to the C API, I wrote a project called the Bikest API compatibility.

338
00:32:08,000 --> 00:32:18,000
So the idea is that when there are new functions, for example in Python 3.11, I provide an implementation of this function for old Python version.

339
00:32:18,000 --> 00:32:28,000
And so you can modify your C extensions to use a new way and you are still compatible with your old Python version.

340
00:32:28,000 --> 00:32:36,000
So three years ago, I created the project, which is quick to update your C extensions automatically.

341
00:32:36,000 --> 00:32:46,000
The year after, I added support for Python 2.7, which is quite old, but it was needed to be able to use it on Markerio.

342
00:32:46,000 --> 00:32:51,000
Last year, I added a bunch of new functions for Python 3.11.

343
00:32:51,000 --> 00:32:57,000
So if you want to use these functions, they are already implemented for Python 3.10 and others.

344
00:32:57,000 --> 00:33:09,000
For example, 10 projects decided to switch to this compatibility layer to support Python 3.10 and 3.11.

345
00:33:09,000 --> 00:33:18,000
So the idea of the script is that you take your C extension, you run the script, and they use the new functions.

346
00:33:18,000 --> 00:33:28,000
And thanks to the compatibility header file, you get access to the new functions on all the Python versions.

347
00:33:28,000 --> 00:33:40,000
And then I'm trying to keep support for the very old Python 2.7 because of material and other projects which still want to support the old Python.

348
00:33:40,000 --> 00:33:48,000
But the nice part is that you should not have to do this often. You should have to do it only once.

349
00:33:48,000 --> 00:33:58,000
Once you convert your extensions to the new one, there is no need to update it on a frequency basis. It's one step, actually.

350
00:33:58,000 --> 00:34:12,000
To make the CLP more future-proof, we designed some guidelines to try to avoid the mistakes that we did in the past.

351
00:34:12,000 --> 00:34:24,000
For example, when in Python we add new C functions, we require that you don't return a borrowed response, but a strong response.

352
00:34:24,000 --> 00:34:36,000
It means that the result that you have, you control the lifecycle of this object, and you know that the object remains valid until your benefit.

353
00:34:36,000 --> 00:34:45,000
New functions must not steal responses, which is a little bit similar to borrowed responses, but a different kind of issue.

354
00:34:45,000 --> 00:34:55,000
We also require to well define the ownership of the object and the memory, and also the lifetime of arguments and structure menus.

355
00:34:55,000 --> 00:35:06,000
The idea of all of these guidelines is that the CLP should be easier to implement on Python implementation or the other 3 Python.

356
00:35:06,000 --> 00:35:14,000
Because there is also PyPy, REST Python, IWRM Python, JARLTN, and some others.

357
00:35:14,000 --> 00:35:24,000
By the way, we are trying to fix this CLPI by grouping the CLPI in 3 different categories.

358
00:35:24,000 --> 00:35:32,000
For now, you have the EliminatedCLPI, which is linked to what I call the stable API.

359
00:35:32,000 --> 00:35:37,000
You have the Public CLPI, which is wider, so it contains more functions.

360
00:35:37,000 --> 00:35:45,000
And the last category is the Internal API, which should only be used by C Python itself.

361
00:35:45,000 --> 00:35:59,000
To come back to my work at Reddit, what my team is doing is that as soon as there is the first alpha release of our new Python version,

362
00:35:59,000 --> 00:36:07,000
we grab this version, we put it in the Fedora project, and we try to rebuild it all Python packages, which is quite big.

363
00:36:07,000 --> 00:36:11,000
It's about more than 5,000 packages.

364
00:36:11,000 --> 00:36:22,000
And we try to identify... we check for failures, and if there are failures, we try to identify the root cause of a failure.

365
00:36:22,000 --> 00:36:29,000
Because sometimes if one dependency is broken, it can cause the failure of 50 packages.

366
00:36:29,000 --> 00:36:34,000
So it takes a lot of time to go through all the logs of the big failures.

367
00:36:34,000 --> 00:36:44,000
And once we identify an issue, either we report the issue to upstream, or sometimes we even propose a fix.

368
00:36:44,000 --> 00:36:49,000
And the idea of our team is to detect issues as soon as possible.

369
00:36:49,000 --> 00:36:57,000
This is something very important because detecting bugs earlier gives more time to fix them.

370
00:36:57,000 --> 00:37:05,000
And we try to collaborate with upstream projects to get the fix image as soon as possible.

371
00:37:05,000 --> 00:37:14,000
So to summarize what we did in the last years in the Python to make the situation better,

372
00:37:14,000 --> 00:37:21,000
we are trying to check in a proactive way for affected projects using Pro Church or other means.

373
00:37:21,000 --> 00:37:28,000
We are trying to document how to migrate user code without losing support for the old Python.

374
00:37:28,000 --> 00:37:36,000
We are trying to help affected projects to update them and prepare them for the new Python.

375
00:37:37,000 --> 00:37:42,000
My team working on the Fedora is providing feedback quite early on,

376
00:37:42,000 --> 00:37:49,000
so we have more time to think about solutions or maybe sometimes continue to revert some changes.

377
00:37:49,000 --> 00:37:57,000
And there is this new project, the Python C API Compatibility Linear, for the specific issues of the C API.

378
00:37:57,000 --> 00:38:05,000
So what can we do tomorrow for the API to avoid incompatible changes?

379
00:38:05,000 --> 00:38:14,000
First of all, you have to know that for C extensions, there is something called a stable API.

380
00:38:14,000 --> 00:38:22,000
The idea is that you compile your C extensions on your walls, and the binary is compatible with all Python versions.

381
00:38:22,000 --> 00:38:30,000
So you can distribute a single binary, which is way better than one binary per condition.

382
00:38:30,000 --> 00:38:38,000
And in Python 3.10, now we have better test-free products, we have better documentation,

383
00:38:38,000 --> 00:38:47,000
so we keep track of all this limited API and the stable API to make sure that we don't introduce regression.

384
00:38:47,000 --> 00:38:56,000
And also for Twilio, there is a CI which is checking the wall API to make sure that one Python is released,

385
00:38:56,000 --> 00:38:58,000
so the API doesn't change anymore.

386
00:38:58,000 --> 00:39:05,000
And just for two examples, the cryptography and Python project are using the stable API.

387
00:39:05,000 --> 00:39:13,000
I really care about the CI care, so I want to introduce you to a new project.

388
00:39:13,000 --> 00:39:19,000
So the problem with the C API is that fixing issues one by one will take a long time,

389
00:39:19,000 --> 00:39:26,000
and it will take further to fix the root design issues of the C API.

390
00:39:26,000 --> 00:39:34,000
So Go for Feedback is able to create a new, brand new C API, we can the correct way from scratch,

391
00:39:34,000 --> 00:39:42,000
so it's rather good at design, and also to have an API which is stable and provide a stable API.

392
00:39:42,000 --> 00:39:49,000
So there is a brand new project called Hpy, it's getting more and more ready to be used,

393
00:39:49,000 --> 00:39:58,000
and by the way there is an ongoing integration of the new Python project to Hpy, so that's getting serious.

394
00:39:58,000 --> 00:40:08,000
And the main advantage of Hpy compared to the existing CI API is that if you take care of Python,

395
00:40:08,000 --> 00:40:14,000
you can expect a huge speed up, because I ported the micro-gson module,

396
00:40:14,000 --> 00:40:20,000
and just by switching to Hpy it became three times faster on Python.

397
00:40:20,000 --> 00:40:25,000
I also would like to ask you something today,

398
00:40:25,000 --> 00:40:32,000
is that I'm a Python developer, and as a developer we need your feedback,

399
00:40:32,000 --> 00:40:37,000
so please test the isolation of Python, or at least the deterioration of Python,

400
00:40:37,000 --> 00:40:41,000
and provide feedback as soon as possible.

401
00:40:41,000 --> 00:40:49,000
Testing manually is one way, but the best way is to put it in a serial and test what we call the 90 bits of Python,

402
00:40:49,000 --> 00:40:54,000
for example in GitHub you can get access to it very easily.

403
00:40:54,000 --> 00:40:59,000
And if you find any kind of issue, please report our update to Python upstream,

404
00:40:59,000 --> 00:41:06,000
and we will help you figure it out if it's on the Python side or on your side or both.

405
00:41:06,000 --> 00:41:11,000
And the idea is that if you report issues as soon as possible,

406
00:41:11,000 --> 00:41:16,000
we will have more time to design a fix and to help you to get it fixed.

407
00:41:16,000 --> 00:41:23,000
So thank you for your attention, and if you have any questions, there are two mics over there.

408
00:41:23,000 --> 00:41:26,000
Thank you.

409
00:41:26,000 --> 00:41:38,000
We started a few minutes late, so we have time for one or two questions if you would come to this microphone.

410
00:41:47,000 --> 00:41:51,000
I think one of the biggest hidden problems that you mentioned,

411
00:41:51,000 --> 00:42:01,000
is that I'm the one who wants to make it easier for people in the future to maintain it on my account or I move on.

412
00:42:01,000 --> 00:42:11,000
So what did you have for making my code easier to maintain or more friendly to do this for other people?

413
00:42:11,000 --> 00:42:13,000
This is a hard question.

414
00:42:13,000 --> 00:42:19,000
So, first we want to expect what we think are the most important changes in Python.

415
00:42:19,000 --> 00:42:26,000
What you can do is to test the development action of the next Python, select 3.12,

416
00:42:26,000 --> 00:42:30,000
and try to get the issue to be aware of the issue as soon as possible,

417
00:42:30,000 --> 00:42:36,000
because there is basically one year until the next release,

418
00:42:36,000 --> 00:42:44,000
so having one year is way better than having Python released and the emergency to get it fixed as soon as possible.

419
00:42:44,000 --> 00:42:47,000
So, thank you.

420
00:42:50,000 --> 00:42:54,000
Looks like no more questions, so thank you, Victor.

421
00:42:54,000 --> 00:42:57,000
Thank you.

