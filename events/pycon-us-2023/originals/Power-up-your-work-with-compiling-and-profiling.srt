1
00:00:00,000 --> 00:00:07,680
Okay, so all doors closed, so I assume that we can all start.

2
00:00:07,680 --> 00:00:10,240
So thank you for coming for the workshop

3
00:00:10,240 --> 00:00:12,800
or tutorial, whatever you call it.

4
00:00:12,800 --> 00:00:15,560
So this workshop, we'll have, first of all,

5
00:00:15,560 --> 00:00:17,080
we'll have a break in the middle.

6
00:00:17,080 --> 00:00:19,720
It will be around 30 minutes.

7
00:00:19,720 --> 00:00:23,520
I will try to be, stick to the schedule, have a break

8
00:00:23,520 --> 00:00:27,420
around like 10, 30, but it really depends on the pace

9
00:00:27,420 --> 00:00:29,520
of like how people are feeling and so.

10
00:00:29,520 --> 00:00:33,000
So if you would need a break or anything, you don't have

11
00:00:33,000 --> 00:00:35,400
to wait for the break, you can just like go get a coffee

12
00:00:35,400 --> 00:00:40,320
or use the bathroom if you have to, don't worry about that.

13
00:00:40,320 --> 00:00:43,680
Another thing, because I think I've already sent a message

14
00:00:43,680 --> 00:00:46,840
about where you can find all these material

15
00:00:46,840 --> 00:00:50,280
and slides beforehand, but if you haven't got the time

16
00:00:50,280 --> 00:00:52,320
to check it, don't worry.

17
00:00:52,320 --> 00:00:53,940
This is the link.

18
00:00:53,940 --> 00:00:57,520
So it's on GitHub, so it's, you know, on my account

19
00:00:57,560 --> 00:00:59,640
and it's called using Numba.

20
00:00:59,640 --> 00:01:02,800
So if you go to that repo, you can clone it,

21
00:01:02,800 --> 00:01:05,040
you'll have all the Jupyter Notebook that you need

22
00:01:05,040 --> 00:01:07,840
and also there will be a link to the slide deck as well.

23
00:01:07,840 --> 00:01:14,200
So, yes, that's the kind of what I want to say beforehand.

24
00:01:14,200 --> 00:01:16,760
Also, I'm Chirk, I work for Alaconda.

25
00:01:16,760 --> 00:01:22,920
That's why I work with the Numba team, you know, I don't match

26
00:01:22,920 --> 00:01:26,040
with them like physically, but I do talk to them regularly.

27
00:01:26,080 --> 00:01:29,360
So kind of, you know, if you have any questions,

28
00:01:29,360 --> 00:01:32,320
I would try to answer, if not, I would direct you to them,

29
00:01:32,320 --> 00:01:34,920
direct the question to them for answering.

30
00:01:34,920 --> 00:01:38,440
I love open source, that's why I have been, you know,

31
00:01:38,440 --> 00:01:40,200
getting involved in lots of open source projects

32
00:01:40,200 --> 00:01:43,360
for a few years and also I organize events.

33
00:01:43,360 --> 00:01:45,520
So I don't want to, you know, tell you

34
00:01:45,520 --> 00:01:47,360
about all these different events you can go to

35
00:01:47,360 --> 00:01:50,960
because you have now just started at a very amazing one.

36
00:01:50,960 --> 00:01:55,080
So, yeah, you can enjoy if I can do this first.

37
00:01:55,120 --> 00:01:59,440
So I want to know like what's people's background a little bit

38
00:01:59,440 --> 00:02:05,240
first, so who is actually considered themselves data

39
00:02:05,240 --> 00:02:09,960
scientists and handling data and doing analysis of data?

40
00:02:09,960 --> 00:02:12,600
One, two, three, some of you?

41
00:02:12,600 --> 00:02:14,120
So what do other people do?

42
00:02:14,120 --> 00:02:18,200
Are you a developer that just write code and you are curious

43
00:02:18,200 --> 00:02:20,440
about Numba and what does it do?

44
00:02:20,440 --> 00:02:24,320
Okay, so maybe you have, we all have the same problem

45
00:02:24,520 --> 00:02:27,040
that like we think our code are too slow

46
00:02:27,040 --> 00:02:29,560
and we want it to be faster.

47
00:02:29,560 --> 00:02:34,720
So for today I'm going to, you know, mainly explain Numba.

48
00:02:34,720 --> 00:02:39,000
So Numba is actually designed to use, I can show you later.

49
00:02:39,000 --> 00:02:42,040
So yeah, Numba actually is designed to use

50
00:02:42,040 --> 00:02:47,840
with a lot of data science work, but if, you know, if you're

51
00:02:47,840 --> 00:02:50,640
like curious, there's other things that also do similar things

52
00:02:50,640 --> 00:02:53,240
that can compile code, I can tell you a little bit more later

53
00:02:53,440 --> 00:02:54,840
about Numba, if you found that, you know,

54
00:02:54,840 --> 00:02:57,320
the exercise today is not very applicable to your work

55
00:02:57,320 --> 00:02:59,240
because you don't work with data, it's fine.

56
00:02:59,240 --> 00:03:02,360
I can also give you other recommendation to other tools

57
00:03:02,360 --> 00:03:04,680
that you may try out.

58
00:03:04,680 --> 00:03:08,720
So for those of you who are mainly doing

59
00:03:08,720 --> 00:03:11,520
like statistical analysis, doing like data science work,

60
00:03:11,520 --> 00:03:14,680
it may be a little bit new to you, like what is profiling,

61
00:03:14,680 --> 00:03:18,160
what is compiling, like why do we care about that?

62
00:03:18,160 --> 00:03:21,720
Because I just, you know, day to day you load in some data

63
00:03:21,760 --> 00:03:24,920
through maybe pandas, your CSV files, and then you load it in,

64
00:03:24,920 --> 00:03:27,440
and you do some data kind of manipulation,

65
00:03:27,440 --> 00:03:30,040
maybe you deploy some scikit-learn algorithm,

66
00:03:30,040 --> 00:03:32,080
and you know, you get your results

67
00:03:32,080 --> 00:03:35,560
and then create a beautiful dashboard or story to tell

68
00:03:35,560 --> 00:03:41,080
to your teammate or, you know, your boss, then well, we are happy.

69
00:03:41,080 --> 00:03:43,520
Why do we care about this?

70
00:03:43,520 --> 00:03:48,880
So if your code is too slow, a lot of times you may wonder,

71
00:03:48,880 --> 00:03:50,520
why is it slow, right?

72
00:03:50,800 --> 00:03:53,000
Why it got stuck?

73
00:03:53,000 --> 00:03:57,720
So profiling, I know some of you who are like,

74
00:03:57,720 --> 00:03:59,960
maybe you're a software developer, if you come from a,

75
00:03:59,960 --> 00:04:02,680
you know, computer science, academic background, this is,

76
00:04:02,680 --> 00:04:04,720
you know, all trivial to you, but I'm just going

77
00:04:04,720 --> 00:04:06,880
to get everybody in the same place.

78
00:04:06,880 --> 00:04:11,320
So profiling is actually we are investigating what our code is

79
00:04:11,320 --> 00:04:13,800
doing, right?

80
00:04:13,800 --> 00:04:16,560
We call that dynamic analysis because, you know,

81
00:04:16,560 --> 00:04:19,480
there are different ways you can analyze your code,

82
00:04:19,480 --> 00:04:22,640
but how profiling do is actually some kind of tool that is

83
00:04:22,640 --> 00:04:24,880
like running along with your program and then kind

84
00:04:24,880 --> 00:04:28,960
of inspect what it is doing when it's got executed.

85
00:04:28,960 --> 00:04:32,160
So, you know, those are called profilers.

86
00:04:32,160 --> 00:04:33,480
They're different type of profilers.

87
00:04:33,480 --> 00:04:38,600
I have also, you know, a few days ago I was in PyCon DE

88
00:04:38,600 --> 00:04:41,760
and I give a talk about profile, memory profiling,

89
00:04:41,760 --> 00:04:43,080
which is another type of profiling.

90
00:04:43,080 --> 00:04:46,120
Today we care more about the speed.

91
00:04:46,160 --> 00:04:50,880
So, you know, there are tools that do that and we want to investigate

92
00:04:50,880 --> 00:04:52,640
because we want to know which part is slow.

93
00:04:52,640 --> 00:04:56,040
Maybe we can improve that part that's actually slow.

94
00:04:56,040 --> 00:04:59,720
So compiling is another tool, kind of things you could do

95
00:04:59,720 --> 00:05:02,800
to improve the speed of your code.

96
00:05:02,800 --> 00:05:09,040
So for those of you who is like maybe from a science background,

97
00:05:09,040 --> 00:05:12,960
from another background that is not computer science, then, you know,

98
00:05:12,960 --> 00:05:14,880
you may heard about the term compiling a lot,

99
00:05:14,920 --> 00:05:17,480
but you don't actually know what it does.

100
00:05:17,480 --> 00:05:20,960
So for some programming languages,

101
00:05:20,960 --> 00:05:24,680
compiling is required to execute your code.

102
00:05:24,680 --> 00:05:27,800
For Python doesn't work that way, but there are other programming

103
00:05:27,800 --> 00:05:29,240
languages that work that way.

104
00:05:29,240 --> 00:05:33,120
So compiling is actually because your computer actually, you know,

105
00:05:33,120 --> 00:05:34,680
they're dealing with zero and ones, right?

106
00:05:34,680 --> 00:05:39,160
So they can only understand things that are low level,

107
00:05:39,160 --> 00:05:40,720
which is for example machine code.

108
00:05:40,720 --> 00:05:42,020
They are basically numbers.

109
00:05:42,020 --> 00:05:43,320
They are zero and ones.

110
00:05:43,320 --> 00:05:44,640
So your machine can understand.

111
00:05:44,640 --> 00:05:48,440
But that's, you know, nobody want to write code in machine code

112
00:05:48,440 --> 00:05:49,760
because it's so difficult.

113
00:05:49,760 --> 00:05:53,560
So that's why we want to write in a programming language

114
00:05:53,560 --> 00:05:58,120
that can be compiled into a model level code that kind of, you know,

115
00:05:58,120 --> 00:06:02,040
is like a translator who translate a piece of article

116
00:06:02,040 --> 00:06:04,000
like a Google translate from a foreign language

117
00:06:04,000 --> 00:06:05,320
to a language that you understand.

118
00:06:05,320 --> 00:06:08,440
So compiling is translating that from a human understandable one

119
00:06:08,440 --> 00:06:11,520
to the machine understandable one.

120
00:06:11,520 --> 00:06:13,880
So before doing that, like I said,

121
00:06:13,920 --> 00:06:15,320
Python works slightly differently

122
00:06:15,320 --> 00:06:19,160
before other programming language, for example C, C++.

123
00:06:19,160 --> 00:06:22,320
The program needs to be executed before it can be,

124
00:06:22,320 --> 00:06:26,360
the programming to be compiled before it can be executed.

125
00:06:26,360 --> 00:06:30,920
So sometimes you make actually, I heard people talk about that

126
00:06:30,920 --> 00:06:33,600
for beginners actually, you know, C and C++ is very,

127
00:06:33,600 --> 00:06:36,760
you know, a little bit difficult to learn comparing to Python

128
00:06:36,760 --> 00:06:38,580
because every time you make some changes,

129
00:06:38,580 --> 00:06:41,800
you have to compile the code before it can get executed again.

130
00:06:41,800 --> 00:06:45,520
So if you have a huge chunk of code, as I remember my time

131
00:06:45,520 --> 00:06:48,680
in university that like, you know, the C++ course,

132
00:06:48,680 --> 00:06:52,040
they teach a C++ for the first programming language, scary.

133
00:06:52,040 --> 00:06:54,320
And then you have a lot of different files, you know,

134
00:06:54,320 --> 00:06:57,000
if the program is big, then you have to compile all of them

135
00:06:57,000 --> 00:07:01,920
and then run it super slow to kind of test things out.

136
00:07:01,920 --> 00:07:05,120
So, but there is a good thing about compiling is

137
00:07:05,120 --> 00:07:08,240
that once you compile the code, it's actually because, you know,

138
00:07:08,240 --> 00:07:10,600
it's already in a form that the machine understands.

139
00:07:10,600 --> 00:07:12,800
So actually it can be very fast.

140
00:07:12,800 --> 00:07:16,760
But Python doesn't do it like that.

141
00:07:16,760 --> 00:07:19,840
So again, like, you know, we are here.

142
00:07:19,840 --> 00:07:23,640
We want to make our code faster, especially during data science work.

143
00:07:23,640 --> 00:07:28,200
So this is the strategy that we're going to deploy today.

144
00:07:28,200 --> 00:07:30,800
We'll analyze what make the code very slow.

145
00:07:30,800 --> 00:07:35,200
So at the beginning of this workshop, you know,

146
00:07:35,200 --> 00:07:39,040
unfortunately there's a lot of concept, a lot of things

147
00:07:39,040 --> 00:07:40,340
like how to use NumPy or this.

148
00:07:40,340 --> 00:07:44,240
I need to clarify first through the first few exercises.

149
00:07:44,240 --> 00:07:49,320
And after you get a chance to get your hands on to a final big project

150
00:07:49,320 --> 00:07:51,840
that you're trying to improve the code.

151
00:07:51,840 --> 00:07:53,160
So this is your strategy, right?

152
00:07:53,160 --> 00:07:57,080
You can analyze it and then you see which part is slow.

153
00:07:57,080 --> 00:07:59,040
You try to make the slow code faster.

154
00:07:59,040 --> 00:08:01,840
Sometimes compiling is not needed.

155
00:08:01,840 --> 00:08:04,960
For example, NumPy, because it's already have a lot

156
00:08:04,960 --> 00:08:07,880
of optimization of itself.

157
00:08:07,920 --> 00:08:12,800
Then what it does is that, you know, for example,

158
00:08:12,800 --> 00:08:17,320
if you have used NumPy, you know that avoid element-wise operation.

159
00:08:17,320 --> 00:08:21,080
Try to use matrix operation because NumPy is optimized for that.

160
00:08:21,080 --> 00:08:24,120
So that would make your code faster without using NumPy

161
00:08:24,120 --> 00:08:27,080
or any other things to compile your code.

162
00:08:27,080 --> 00:08:31,680
But sometimes, you know, even you try to avoid all the slow code,

163
00:08:31,680 --> 00:08:33,600
sometimes it's not avoidable.

164
00:08:33,600 --> 00:08:36,400
Then compiling may actually help you.

165
00:08:36,440 --> 00:08:39,440
But how? Then I will go into the detail later.

166
00:08:39,440 --> 00:08:42,600
So number, number is a JIT compiler.

167
00:08:42,600 --> 00:08:47,240
So again, at the first half of the workshop,

168
00:08:47,240 --> 00:08:48,800
a lot of concept need to be clear, right?

169
00:08:48,800 --> 00:08:50,120
What is a JIT compiler?

170
00:08:50,120 --> 00:08:51,440
Scratch your head.

171
00:08:51,440 --> 00:08:53,600
What is JIT?

172
00:08:53,600 --> 00:08:56,840
But what we can get from this definition, which I copy

173
00:08:56,840 --> 00:09:00,600
from the documentation, is that we know that it's worth for NumPy.

174
00:09:00,600 --> 00:09:04,400
So it's very good for a lot of numerical code because a lot

175
00:09:04,400 --> 00:09:06,040
of numerical code actually use NumPy.

176
00:09:06,080 --> 00:09:09,520
So it's kind of designed for that.

177
00:09:09,520 --> 00:09:11,640
It translates a set of Python codes.

178
00:09:11,640 --> 00:09:14,920
So translating code, something to do with compiling.

179
00:09:14,920 --> 00:09:18,080
Well, compiler already told you that it's doing some compiling.

180
00:09:18,080 --> 00:09:19,400
That's why it does.

181
00:09:19,400 --> 00:09:22,400
And so your code will be, you know,

182
00:09:22,400 --> 00:09:26,760
a chunk of your code will become low-level code, which is faster.

183
00:09:26,760 --> 00:09:31,520
So, but what makes it different from the compiling

184
00:09:31,520 --> 00:09:32,840
that I explained earlier?

185
00:09:32,840 --> 00:09:35,120
What is the difference from, for example, C or C++

186
00:09:35,120 --> 00:09:36,800
that you compile the whole program?

187
00:09:36,800 --> 00:09:38,720
Is that, is a JIT compiler.

188
00:09:38,720 --> 00:09:40,040
It's not just a compiler.

189
00:09:40,040 --> 00:09:43,920
But JIT, JIT, stands for just in time.

190
00:09:43,920 --> 00:09:46,560
So I found this term very funny.

191
00:09:46,560 --> 00:09:49,880
And once I know what it means that I use it in my daily life,

192
00:09:49,880 --> 00:09:52,880
I'll be like, oh, just in time finishing a presentation,

193
00:09:52,880 --> 00:09:54,560
you know, that kind of thing.

194
00:09:54,560 --> 00:09:58,800
Which means that it basically finish it last minute

195
00:09:58,800 --> 00:10:00,120
when it does compiling.

196
00:10:00,120 --> 00:10:04,920
So, hmm, it's getting more questions than answer right now.

197
00:10:04,920 --> 00:10:06,800
Because how Python work is

198
00:10:06,800 --> 00:10:08,840
that Python does not compile the program.

199
00:10:08,840 --> 00:10:11,400
Like I said before, you don't have to, you know,

200
00:10:11,400 --> 00:10:13,400
write all your Python code and then run some command

201
00:10:13,400 --> 00:10:17,120
to compile all your Python code, which is maybe something.py,

202
00:10:17,120 --> 00:10:19,080
into a low-level code.

203
00:10:19,080 --> 00:10:22,400
So, so Python doesn't work that way.

204
00:10:22,400 --> 00:10:24,880
Python is actually an interpreter.

205
00:10:24,880 --> 00:10:28,600
So for those of you who have not thought about that before,

206
00:10:28,600 --> 00:10:31,360
Python, that is on your machine.

207
00:10:31,360 --> 00:10:34,240
It could be, for example, you download it from PyPI,

208
00:10:34,280 --> 00:10:35,720
or maybe you get it from Alaconda,

209
00:10:35,720 --> 00:10:37,400
there's a Python inside.

210
00:10:37,400 --> 00:10:40,640
So that, well, Python itself, we all know,

211
00:10:40,640 --> 00:10:41,960
is a programming language.

212
00:10:41,960 --> 00:10:43,720
But that thing that's in your machine,

213
00:10:43,720 --> 00:10:46,520
that is actually an executable file.

214
00:10:46,520 --> 00:10:49,360
So it's actually a small program in your computer

215
00:10:49,360 --> 00:10:53,040
that interprets your Python code into code

216
00:10:53,040 --> 00:10:54,720
that the machine understands.

217
00:10:54,720 --> 00:10:57,800
So, for example, C Python is actually interprets Python

218
00:10:57,800 --> 00:11:02,240
into C, and then C, of course, is, you know, can be compiled

219
00:11:02,240 --> 00:11:04,200
into lower-level code so your machine will understand

220
00:11:04,240 --> 00:11:08,000
those C code and it will understand your Python code.

221
00:11:08,000 --> 00:11:09,680
So it takes time.

222
00:11:09,680 --> 00:11:11,400
So Python, that's why you have heard a lot

223
00:11:11,400 --> 00:11:13,280
of people say Python is slow, right?

224
00:11:13,280 --> 00:11:16,120
Because, you know, every time you have to go through these steps

225
00:11:16,120 --> 00:11:21,040
of like, you know, when you see Python, you know,

226
00:11:21,040 --> 00:11:23,480
if you use Windows, actually, it's Python.exe,

227
00:11:23,480 --> 00:11:27,600
so it's executable file, it will see your code,

228
00:11:27,600 --> 00:11:31,000
and then it will, like, pass it to the C APIs, and it will, like,

229
00:11:31,240 --> 00:11:33,000
and then it starts to work.

230
00:11:33,000 --> 00:11:34,300
It's slow.

231
00:11:34,300 --> 00:11:38,000
It's not like your, for example, you write a program purely in C

232
00:11:38,000 --> 00:11:40,000
that before you run it, it's already compiled.

233
00:11:40,000 --> 00:11:42,360
So every time you run it, you run that compiled form,

234
00:11:42,360 --> 00:11:43,660
so it's super fast.

235
00:11:43,660 --> 00:11:46,800
So what, how can we, how can we,

236
00:11:46,800 --> 00:11:51,440
how can this compiler kind of modify the, you know,

237
00:11:51,440 --> 00:11:54,480
the behavior and to make things faster for ourselves?

238
00:11:54,480 --> 00:11:58,520
Is that when you can, you'll see the code later,

239
00:11:58,520 --> 00:12:01,520
well, you can define this part, I want it to be applied

240
00:12:01,560 --> 00:12:05,560
to be compiled, and every time the number

241
00:12:05,560 --> 00:12:09,040
or other JIT compiler see that bit, and then, okay,

242
00:12:09,040 --> 00:12:11,840
if you're going to, you know, the first time you saw it,

243
00:12:11,840 --> 00:12:13,400
for example, in your definition, it's not going

244
00:12:13,400 --> 00:12:17,280
to do anything yet, but until that part,

245
00:12:17,280 --> 00:12:20,760
that function is called, then it knows that, oh,

246
00:12:20,760 --> 00:12:22,120
you're not writing things for nothing.

247
00:12:22,120 --> 00:12:23,420
You're actually using it.

248
00:12:23,420 --> 00:12:24,720
Okay, I'll compile it for you.

249
00:12:24,720 --> 00:12:27,320
So next time you use it, it will be faster.

250
00:12:27,320 --> 00:12:29,800
So that's the magic, right?

251
00:12:29,800 --> 00:12:34,800
So remember one thing, when the JIT compiler sees your code

252
00:12:35,520 --> 00:12:37,840
that want to get executed for the first time,

253
00:12:37,840 --> 00:12:39,040
it will compile it.

254
00:12:39,960 --> 00:12:41,740
Okay, so what does that mean?

255
00:12:41,740 --> 00:12:44,320
It means that if you just use that function

256
00:12:44,320 --> 00:12:47,480
for the first time, you will go through the step

257
00:12:47,480 --> 00:12:49,880
of the compiler will compile your code

258
00:12:49,880 --> 00:12:52,200
and it got executed, right?

259
00:12:52,200 --> 00:12:53,540
But the first, the second time,

260
00:12:53,540 --> 00:12:55,640
when you record that function again,

261
00:12:55,640 --> 00:12:58,640
it won't compile the code again because the same thing,

262
00:12:58,800 --> 00:13:00,480
you haven't changed the definition of your function.

263
00:13:00,480 --> 00:13:02,440
It's going to be just the same thing.

264
00:13:02,440 --> 00:13:05,520
So it got to look for the already compiled code

265
00:13:05,520 --> 00:13:07,000
and execute that one.

266
00:13:07,000 --> 00:13:09,460
So it means that the first time and the second time,

267
00:13:09,460 --> 00:13:12,560
when you call that compiled function,

268
00:13:12,560 --> 00:13:14,420
the speed will be different, okay?

269
00:13:14,420 --> 00:13:16,440
So bear that in mind because that will be useful

270
00:13:16,440 --> 00:13:18,320
in our exercise later.

271
00:13:18,320 --> 00:13:22,460
And that's also explain why a lot of times, you know,

272
00:13:22,460 --> 00:13:24,160
people just use a JIT compiler and stuff

273
00:13:24,160 --> 00:13:26,480
and it may not speed up your code,

274
00:13:26,480 --> 00:13:29,760
but if you have a loop that you actually do the same thing

275
00:13:29,760 --> 00:13:33,440
again and again and again, then that would actually help you.

276
00:13:33,440 --> 00:13:35,880
So be smart, don't use the JIT compiler

277
00:13:35,880 --> 00:13:37,840
for things that are not looping

278
00:13:37,840 --> 00:13:40,360
because then that may actually be slower.

279
00:13:40,360 --> 00:13:45,360
So, well, numbers, a number is designed for NumPy.

280
00:13:45,600 --> 00:13:50,600
Like I said, it's designed for scientific kind of coding.

281
00:13:51,280 --> 00:13:53,640
There's another thing you may have heard about called Cython.

282
00:13:53,640 --> 00:13:56,040
Cython, again, is, you know, is a JIT compiler.

283
00:13:56,080 --> 00:13:57,380
It will compile your code.

284
00:13:57,380 --> 00:14:01,840
That is more kind of, you say, I would say more general.

285
00:14:01,840 --> 00:14:05,480
And actually a lot of your, the thing that you use,

286
00:14:05,480 --> 00:14:07,240
for example, Panda, actually under the hood,

287
00:14:07,240 --> 00:14:10,920
it uses a lot of NumPy because it will help, you know,

288
00:14:10,920 --> 00:14:13,080
type Pandas to be faster.

289
00:14:13,080 --> 00:14:15,720
And for example, Cycular also uses a lot of Cython.

290
00:14:15,720 --> 00:14:17,520
It kind of helped the algorithm to be faster.

291
00:14:17,520 --> 00:14:21,880
So, yeah, so this, the NumPy or Cython, they are all

292
00:14:21,880 --> 00:14:24,440
like JIT compiler and they have been used in other libraries

293
00:14:24,440 --> 00:14:27,200
without you kind of knowing.

294
00:14:27,200 --> 00:14:30,320
So it's actually there everywhere.

295
00:14:30,320 --> 00:14:33,600
And so a number, again, like I said, because it's a JIT compiler,

296
00:14:33,600 --> 00:14:37,320
it kind of, for the things that are loops, is where it shines.

297
00:14:37,320 --> 00:14:40,360
So if it's, again, be smart.

298
00:14:40,360 --> 00:14:43,960
Think about when you use it, where you use it.

299
00:14:43,960 --> 00:14:47,280
So in a number, there are different modes that you could use.

300
00:14:47,280 --> 00:14:50,760
So ideally, you want everything to be no Python mode

301
00:14:50,800 --> 00:14:55,760
because I think now you may already understand Python is slow.

302
00:14:55,760 --> 00:14:57,880
So we want to avoid Python.

303
00:14:57,880 --> 00:15:02,160
So using no Python mode means that everything that is defined

304
00:15:02,160 --> 00:15:05,440
in that, all the code that you include

305
00:15:05,440 --> 00:15:09,480
into no Python mode should be compiled into something

306
00:15:09,480 --> 00:15:12,320
that is slow level, that is, you know, it doesn't go

307
00:15:12,320 --> 00:15:15,600
through the Python CAPI, which is the interpreter that I talk about.

308
00:15:15,600 --> 00:15:16,840
You know, it will see your Python code

309
00:15:16,840 --> 00:15:18,280
and it tells the CAPI to do stuff.

310
00:15:18,320 --> 00:15:19,600
So we want to bypass that.

311
00:15:19,600 --> 00:15:22,800
We want to directly compile that bit of the code

312
00:15:22,800 --> 00:15:27,640
and then it will get called directly in like very fast speed

313
00:15:27,640 --> 00:15:30,880
because it's low level code.

314
00:15:30,880 --> 00:15:32,720
Its performance is very good.

315
00:15:32,720 --> 00:15:35,120
If you can make all the things no Python mode,

316
00:15:35,120 --> 00:15:39,480
then you would probably have a very fast time with, you know,

317
00:15:39,480 --> 00:15:42,240
if you don't count the compiling time.

318
00:15:42,240 --> 00:15:46,160
But it's not always the case, right, because, you know,

319
00:15:46,200 --> 00:15:49,480
a lot of number things, a lot of, you know, simple calculation,

320
00:15:49,480 --> 00:15:51,200
you can use no Python mode.

321
00:15:51,200 --> 00:15:53,880
But we all have been there, right?

322
00:15:53,880 --> 00:15:56,840
We have, you know, used different Python objects

323
00:15:56,840 --> 00:15:58,360
to do different things.

324
00:15:58,360 --> 00:16:02,200
So those Python objects, if you are using it,

325
00:16:02,200 --> 00:16:05,840
then you can't use no Python mode because they are Python object

326
00:16:05,840 --> 00:16:07,680
and Numbar doesn't understand.

327
00:16:07,680 --> 00:16:12,640
So you have to use something called object mode, which is kind of,

328
00:16:12,640 --> 00:16:16,080
it can still have some capability of handling Python object,

329
00:16:16,080 --> 00:16:17,360
but for the base that it sees

330
00:16:17,360 --> 00:16:19,640
that actually you can bypass it, it will bypass it.

331
00:16:19,640 --> 00:16:22,600
So it's kind of a middle ground between not doing anything

332
00:16:22,600 --> 00:16:25,680
and using no Python mode.

333
00:16:25,680 --> 00:16:29,600
So, you know, it sometimes kind of make your life easier,

334
00:16:29,600 --> 00:16:35,280
but then you have no control of what is actually being done.

335
00:16:35,280 --> 00:16:39,720
So this is, you'll see the syntax very soon when we go

336
00:16:39,720 --> 00:16:41,040
to the Jupyter Notebook.

337
00:16:41,040 --> 00:16:45,360
So to use Numbar, we just call in the decorators.

338
00:16:45,400 --> 00:16:48,760
So there are two decorators, you know, JIT and NJIT.

339
00:16:48,760 --> 00:16:51,000
So NJIT means no Python mode.

340
00:16:51,000 --> 00:16:55,320
JIT means by default it's object mode, but you can also,

341
00:16:55,320 --> 00:16:58,680
like here, see that actually you can also change JIT

342
00:16:58,680 --> 00:17:00,640
into no Python mode.

343
00:17:00,640 --> 00:17:03,880
But sometimes if you use everything no Python mode,

344
00:17:03,880 --> 00:17:08,440
instead of typing so many things, you can just call in NJIT.

345
00:17:08,440 --> 00:17:10,600
So, yeah, I've already covered this.

346
00:17:10,600 --> 00:17:14,560
You know, ideally you want everything to be no Python mode,

347
00:17:14,600 --> 00:17:18,600
to be optimum performance, but a lot of times, you know,

348
00:17:18,600 --> 00:17:21,960
you may accidentally or in under the hood is using some Python

349
00:17:21,960 --> 00:17:24,000
object that you can't avoid that.

350
00:17:24,000 --> 00:17:28,200
Then maybe to make things work, you just switch to object mode.

351
00:17:28,200 --> 00:17:34,520
So there are other things that actually Numbar would be very

352
00:17:34,520 --> 00:17:35,840
useful as well.

353
00:17:35,840 --> 00:17:38,320
For those of you, for example, you all work with a cluster,

354
00:17:38,320 --> 00:17:42,800
you work with the CUDA GPUs or you have a CUDA GPU at home,

355
00:17:42,840 --> 00:17:47,480
then you may wonder, okay, you know, does Numbar help me?

356
00:17:47,480 --> 00:17:50,840
Because Numbar does support CUDA GPU, but I'm not going

357
00:17:50,840 --> 00:17:54,240
to cover it today because not everybody is using a GPU,

358
00:17:54,240 --> 00:17:56,480
CUDA GPU especially.

359
00:17:56,480 --> 00:18:01,000
So, but there's talk that actually talk about that in detail.

360
00:18:01,000 --> 00:18:03,520
If you, those of you who use it

361
00:18:03,520 --> 00:18:06,880
and you wonder how you can use it to get a number,

362
00:18:06,880 --> 00:18:10,080
that is the place that you could look into.

363
00:18:10,160 --> 00:18:14,640
So I think I talked too much and so we better look

364
00:18:14,640 --> 00:18:16,400
at the notebook and do it together.

365
00:18:16,400 --> 00:18:18,720
Like I said, there's a lot of things that at the beginning,

366
00:18:18,720 --> 00:18:20,520
there's a lot of concept when you clear a bar.

367
00:18:20,520 --> 00:18:23,480
So unfortunately, you have to hear me talk a lot,

368
00:18:23,480 --> 00:18:26,800
but after that, there will be chance for you to kind of code

369
00:18:26,800 --> 00:18:30,920
and then, you know, try to, you know, in a similar kind of setting

370
00:18:30,920 --> 00:18:32,640
of when you're working and stuff.

371
00:18:32,640 --> 00:18:37,760
So get the Red Bull and then, oh, by the way,

372
00:18:37,760 --> 00:18:39,080
the Wi-Fi is already there.

373
00:18:39,160 --> 00:18:42,360
I hope you already discovered it before I start talking.

374
00:18:42,360 --> 00:18:47,040
So let's, oh, I, you know, always have the documentation ready.

375
00:18:47,040 --> 00:18:48,340
It's very useful.

376
00:18:48,340 --> 00:18:51,520
If you have an error, you don't know what it work, why it's

377
00:18:51,520 --> 00:18:54,600
like this and you don't understand how it works or how to,

378
00:18:54,600 --> 00:18:56,760
you know, even the syntax, just refer

379
00:18:56,760 --> 00:18:58,680
to the documentation, it's fine.

380
00:18:58,680 --> 00:19:01,120
So in the notebook, you have a few things.

381
00:19:01,120 --> 00:19:04,280
Ignore the others, but maybe have a look at readme

382
00:19:04,280 --> 00:19:06,240
if you just downloaded it.

383
00:19:06,240 --> 00:19:08,640
But otherwise, other things, you know, you just need

384
00:19:08,680 --> 00:19:10,560
to worry about the notebook.

385
00:19:10,560 --> 00:19:14,920
So I hope you already have the capacity

386
00:19:14,920 --> 00:19:17,720
of opening a Jupyter notebook.

387
00:19:17,720 --> 00:19:19,440
There are a lot of ways to set it up.

388
00:19:19,440 --> 00:19:21,880
For me, I just, because this is my personal computer, I just,

389
00:19:21,880 --> 00:19:24,360
you know, set up myself, install Jupyter notebook

390
00:19:24,360 --> 00:19:26,600
and install these things by pip install.

391
00:19:26,600 --> 00:19:29,320
But if you don't want to, you know, set up yourself,

392
00:19:29,320 --> 00:19:31,520
you are already, you know, using Alaconda.

393
00:19:31,520 --> 00:19:35,320
Alaconda will have all of them included as well.

394
00:19:35,360 --> 00:19:39,760
So let's open the first notebook.

395
00:19:39,760 --> 00:19:41,920
We will do it together and then we will read the code together

396
00:19:41,920 --> 00:19:44,160
to try to understand what's going on here.

397
00:19:44,160 --> 00:19:47,200
Oh, so far any questions?

398
00:19:47,200 --> 00:19:48,480
I talk too much.

399
00:19:48,480 --> 00:19:51,080
So any questions I want you to talk?

400
00:19:51,080 --> 00:19:53,480
No? Yes, no?

401
00:19:53,480 --> 00:19:54,800
Okay, all good?

402
00:19:54,800 --> 00:19:56,200
Following? Good.

403
00:19:56,200 --> 00:20:01,360
So, you know, this is the exclamation mark magic.

404
00:20:01,360 --> 00:20:04,960
It just means that you can execute some kind of command

405
00:20:05,000 --> 00:20:07,320
on the, like, command prompt.

406
00:20:07,320 --> 00:20:10,320
So if you haven't got, like, number and unpy install,

407
00:20:10,320 --> 00:20:11,640
you run this out.

408
00:20:11,640 --> 00:20:13,160
But if you have installed it, this is useless for you.

409
00:20:13,160 --> 00:20:14,480
So don't do anything.

410
00:20:14,480 --> 00:20:17,560
I'm just skipping it.

411
00:20:17,560 --> 00:20:24,160
So this is kind of like demonstrating how number works.

412
00:20:24,160 --> 00:20:27,080
So like I said before, there's JIT and NJIT.

413
00:20:27,080 --> 00:20:31,760
They are decorators that you could import from number.

414
00:20:31,760 --> 00:20:34,280
So the decorator would decorate the function

415
00:20:34,320 --> 00:20:38,080
and then just basically is marking that number,

416
00:20:38,080 --> 00:20:41,040
understand that bit that we want to compile.

417
00:20:41,040 --> 00:20:45,360
So, yeah, so you have to, so first thing I think, like,

418
00:20:45,360 --> 00:20:47,680
people asked me before, they're like, oh,

419
00:20:47,680 --> 00:20:49,520
what if I have just a bunch of code?

420
00:20:49,520 --> 00:20:51,400
Well, you have to wrap it in a function.

421
00:20:51,400 --> 00:20:54,880
Otherwise, I don't know, like, can you just, like,

422
00:20:54,880 --> 00:20:56,200
kind of turn it on and off?

423
00:20:56,200 --> 00:20:59,880
Maybe, but the most, you know, official way to do it is

424
00:20:59,880 --> 00:21:01,200
to use the decorator.

425
00:21:01,880 --> 00:21:06,120
You have to wrap your process, your calculation,

426
00:21:06,120 --> 00:21:08,040
whatever, in the function.

427
00:21:08,040 --> 00:21:12,280
So we are also doing some timing here just to check,

428
00:21:12,280 --> 00:21:16,240
like, comparing the time with or without the compiling.

429
00:21:16,240 --> 00:21:17,960
So this is doing something very simple, right?

430
00:21:17,960 --> 00:21:20,520
You just have a huge NumPy array

431
00:21:20,520 --> 00:21:24,760
and then we would just do some kind of calculation with it.

432
00:21:24,760 --> 00:21:29,520
And so these two functions are basically the same.

433
00:21:29,560 --> 00:21:33,120
The only difference is that one of them, we would modify

434
00:21:33,120 --> 00:21:35,520
that function by applying a decorator,

435
00:21:35,520 --> 00:21:37,840
which is the JIT decorator.

436
00:21:37,840 --> 00:21:40,280
And we are using no Python mode, so, you know,

437
00:21:40,280 --> 00:21:41,720
you can actually change it.

438
00:21:41,720 --> 00:21:43,800
If you want, you can change it to NJIT.

439
00:21:43,800 --> 00:21:47,240
And then you can change it to NJIT and then delete this.

440
00:21:47,240 --> 00:21:48,560
This will be the same.

441
00:21:48,560 --> 00:21:50,440
All right?

442
00:21:50,440 --> 00:21:52,640
You can try both, but I would just stick

443
00:21:52,640 --> 00:21:54,360
to the original one for now.

444
00:21:54,360 --> 00:21:57,000
They are basically the same, like I said before.

445
00:21:57,040 --> 00:22:00,680
So that's why this is an experiment,

446
00:22:00,680 --> 00:22:03,960
so there's not much we can do, but we can look at the result

447
00:22:03,960 --> 00:22:06,760
and try to make sense out of it.

448
00:22:06,760 --> 00:22:12,320
So which one is the fastest?

449
00:22:14,040 --> 00:22:15,340
Which one?

450
00:22:15,340 --> 00:22:16,640
It's quite obvious.

451
00:22:16,640 --> 00:22:17,940
Or you can look at your machine.

452
00:22:17,940 --> 00:22:19,240
Your machine may be different,

453
00:22:19,240 --> 00:22:20,880
but it should give the same result.

454
00:22:20,880 --> 00:22:25,780
Who get the without compilation the fastest?

455
00:22:25,780 --> 00:22:26,760
Let me know.

456
00:22:27,360 --> 00:22:29,360
You have the without compilation the fastest.

457
00:22:29,360 --> 00:22:36,360
Yeah, so you can see it's very interesting here.

458
00:22:36,360 --> 00:22:39,320
It's like with compilation, and then after compilation,

459
00:22:39,320 --> 00:22:41,200
why there's like two different things, right?

460
00:22:41,200 --> 00:22:44,880
We are comparing the one with the JIT, one without the JIT,

461
00:22:44,880 --> 00:22:47,720
but why there's two here?

462
00:22:47,720 --> 00:22:50,120
So if you look at the comments, it's already trying

463
00:22:50,120 --> 00:22:51,880
to explain it.

464
00:22:51,880 --> 00:22:54,480
So without compilation is your baseline, so it's

465
00:22:54,520 --> 00:22:58,240
like what you do, normally do, with like Python doing Python thing,

466
00:22:58,240 --> 00:23:01,120
you don't interrupt it, you just let Python be Python.

467
00:23:01,120 --> 00:23:03,600
So this is the without compilation time.

468
00:23:03,600 --> 00:23:05,920
So you can see they are at the different amount,

469
00:23:05,920 --> 00:23:10,480
so be careful when we do this kind of experiment.

470
00:23:10,480 --> 00:23:12,680
Be careful of like what scale are you looking at.

471
00:23:12,680 --> 00:23:14,600
So you can see the first one and the last one.

472
00:23:14,600 --> 00:23:16,040
Actually they are comparable,

473
00:23:16,040 --> 00:23:21,200
but the last one is actually kind of one-third of the time

474
00:23:21,200 --> 00:23:22,500
that you take, maybe half.

475
00:23:22,700 --> 00:23:28,620
Let's say it's like half the time, which is like double the speed.

476
00:23:28,620 --> 00:23:33,140
But the one in the middle is the puzzle that we have, right?

477
00:23:33,140 --> 00:23:34,500
Like why this one is so slow?

478
00:23:34,500 --> 00:23:41,540
It's like in order of like five, it's like slower.

479
00:23:41,540 --> 00:23:46,940
It takes like, how could it be like one to the power,

480
00:23:46,940 --> 00:23:50,100
ten to the power of five times slower?

481
00:23:50,140 --> 00:23:51,860
Well, actually ten to the power of four times slower,

482
00:23:51,860 --> 00:23:54,580
but it's very, very slow, the one in the middle.

483
00:23:54,580 --> 00:23:56,100
So what happened?

484
00:23:56,100 --> 00:24:00,100
What happened is that if you re-look at the code, right?

485
00:24:00,100 --> 00:24:03,820
So this is without compiling, this is Python, okay fine.

486
00:24:03,820 --> 00:24:05,740
So this is the one that we are using GoFast,

487
00:24:05,740 --> 00:24:11,140
which is the one we add the JIT here.

488
00:24:11,140 --> 00:24:15,100
So this one is supposed to go fast.

489
00:24:15,100 --> 00:24:16,860
Why is this so slow?

490
00:24:16,900 --> 00:24:20,620
The reason being, like the opening, I already planned the seat

491
00:24:20,620 --> 00:24:23,820
in your head that compiling is slow.

492
00:24:23,820 --> 00:24:27,500
And because it's a JIT compiler, it doesn't compile this bit

493
00:24:27,500 --> 00:24:29,460
of code beforehand, right?

494
00:24:29,460 --> 00:24:32,500
When you execute it, so Python is reading, you know,

495
00:24:32,500 --> 00:24:35,180
it's like okay, I'm trying to talk to CAPI,

496
00:24:35,180 --> 00:24:37,060
try to get your thing done, until here.

497
00:24:37,060 --> 00:24:41,500
It's like oh, now the number come in and say like wait a second,

498
00:24:41,500 --> 00:24:43,940
that is the JIT, so that's like me doing my thing,

499
00:24:43,940 --> 00:24:45,300
now I will compile it.

500
00:24:45,340 --> 00:24:48,660
So okay, Python said fine, okay, Numbah compiled it,

501
00:24:48,660 --> 00:24:50,500
but compilation takes time.

502
00:24:50,500 --> 00:24:52,620
So this one, that's why it takes so long,

503
00:24:52,620 --> 00:24:53,940
because it's compiling.

504
00:24:53,940 --> 00:24:56,820
So for example, if you only call GoFast once,

505
00:24:56,820 --> 00:24:59,540
so what would you do is actually have a slower program

506
00:24:59,540 --> 00:25:02,180
than the original one, than the normal one.

507
00:25:02,180 --> 00:25:04,180
So this is not a good thing.

508
00:25:04,180 --> 00:25:07,620
However, if you call GoFast a second time,

509
00:25:07,620 --> 00:25:09,900
since it's already compiled, so again, you know,

510
00:25:09,900 --> 00:25:13,700
Python read all the code and then go here and then Numbah jump

511
00:25:13,740 --> 00:25:15,780
in again and say hold on a minute,

512
00:25:15,780 --> 00:25:17,220
this one I have already compiled,

513
00:25:17,220 --> 00:25:19,460
just grab that already compiled things,

514
00:25:19,460 --> 00:25:21,620
don't need to talk to the CAPI anymore.

515
00:25:21,620 --> 00:25:25,380
It's like okay, so execute that super fast, all right.

516
00:25:26,660 --> 00:25:27,980
Yes?

517
00:25:27,980 --> 00:25:30,500
So if this is compiled in like a certain scope,

518
00:25:30,500 --> 00:25:32,740
does it apply to the outside of that scope?

519
00:25:32,740 --> 00:25:34,460
Use the function again or it's only that?

520
00:25:34,460 --> 00:25:36,420
No, it's only that bit.

521
00:25:36,420 --> 00:25:39,620
So that's why you have to wrap the bit that you want to speed

522
00:25:39,620 --> 00:25:42,740
up in a function and then apply a decorator to it.

523
00:25:42,780 --> 00:25:45,260
So for those of you who are maybe new to decorator,

524
00:25:45,260 --> 00:25:49,300
this add thing is actually would take what it decorates,

525
00:25:49,300 --> 00:25:52,100
which is a function, and then modify it, right.

526
00:25:52,100 --> 00:25:55,460
So well, normally you can write a decorator

527
00:25:55,460 --> 00:25:58,620
and modify it using Python code, but this time, of course,

528
00:25:58,620 --> 00:26:00,620
Numbah is doing the Numbah magic, right.

529
00:26:00,620 --> 00:26:06,260
It will come in and modify it and make it into another blob

530
00:26:06,260 --> 00:26:08,020
of things, which is the compiled code

531
00:26:08,020 --> 00:26:09,340
and then it will get referenced.

532
00:26:09,420 --> 00:26:13,420
So next time when Python see it, it won't talk to the CAPI

533
00:26:13,420 --> 00:26:18,300
to try to do what it normally do, but that will try to call

534
00:26:18,300 --> 00:26:22,340
that already compiled bit or if it's the first time, compile it.

535
00:26:22,340 --> 00:26:26,940
So yes, questions?

536
00:26:26,940 --> 00:26:28,740
Yes?

537
00:26:29,380 --> 00:26:31,180
Okay.

538
00:26:49,180 --> 00:26:50,660
You mean comparing?

539
00:26:50,660 --> 00:27:08,580
So, if you're asking what's the difference between the GOFAST calling first time

540
00:27:08,580 --> 00:27:09,940
and the GOFAST calling the second time?

541
00:27:09,940 --> 00:27:15,540
Ah, so if you put in a different X, you mean?

542
00:27:15,540 --> 00:27:24,300
You are very ahead of our time because, no, no, no, it's a very good question

543
00:27:24,300 --> 00:27:27,140
because you have very good thinking.

544
00:27:27,140 --> 00:27:31,620
That's why you already see the problem that we may encounter in the future, right?

545
00:27:31,620 --> 00:27:35,060
So, you will see later when we go to Chapter 2,

546
00:27:35,060 --> 00:27:37,700
sometimes we would come into some problem.

547
00:27:37,700 --> 00:27:41,380
Is that because Python do dynamic typing, right?

548
00:27:41,420 --> 00:27:45,500
So, in Python code, this input can be anything.

549
00:27:45,500 --> 00:27:51,700
It could be integer, it could be floating point, it could be imaginary number even.

550
00:27:51,700 --> 00:27:57,980
But for NGIT or the JIT no Python mode, it doesn't work that way.

551
00:27:57,980 --> 00:28:00,660
You need to have a defined type.

552
00:28:00,660 --> 00:28:05,740
So, that's why if you like the scenario, you suggest that, oh,

553
00:28:05,740 --> 00:28:08,820
what if I put another X in GOFAST the second time?

554
00:28:08,820 --> 00:28:10,940
What if it's a floating point this time?

555
00:28:10,940 --> 00:28:15,900
Hmm, well, it won't happen because we can't compile it if that's the case.

556
00:28:15,900 --> 00:28:19,700
If we don't know the type of the input, then it can't be compiled.

557
00:28:19,700 --> 00:28:22,500
We will see that problem later, then it will make more sense.

558
00:28:22,500 --> 00:28:26,780
But it's very good that you raised this question because all

559
00:28:26,780 --> 00:28:30,180
of us will have this question later, okay?

560
00:28:30,180 --> 00:28:31,340
It's very good.

561
00:28:31,340 --> 00:28:34,980
So, now we have the basic understanding.

562
00:28:34,980 --> 00:28:39,460
So, this example is just to explain that what it's actually doing

563
00:28:39,500 --> 00:28:41,900
and the first time actually is slower.

564
00:28:41,900 --> 00:28:46,180
So, we have to remember that is the main thing that people got confused

565
00:28:46,180 --> 00:28:47,500
when they start using number.

566
00:28:47,500 --> 00:28:50,140
And that's why they think, oh, it's not really helping me.

567
00:28:50,140 --> 00:28:53,100
So, it may be one of the reason why.

568
00:28:53,100 --> 00:28:57,660
So, now we are learning something about not just number,

569
00:28:57,660 --> 00:28:59,060
about NumPy as well.

570
00:28:59,060 --> 00:29:03,060
So, like I said before, NumPy is designed for numerical calculation,

571
00:29:03,060 --> 00:29:06,540
especially for matrix calculation, right?

572
00:29:06,580 --> 00:29:11,620
So, we are now, so in this experiment or example,

573
00:29:11,620 --> 00:29:17,620
we are creating a NumPy array that's quite big, okay?

574
00:29:17,620 --> 00:29:20,500
So, we are doing some calculation with it.

575
00:29:20,500 --> 00:29:23,980
So, this is something with sine and cosine there.

576
00:29:23,980 --> 00:29:28,860
I don't like the name of this, like, it's some trickle-o-machy thing,

577
00:29:28,860 --> 00:29:31,580
right, like, you know, like the triangle, you calculate that,

578
00:29:31,580 --> 00:29:33,420
the tangent, whatever, the bit.

579
00:29:33,420 --> 00:29:34,940
So, I'm not going to explain the math.

580
00:29:34,940 --> 00:29:39,460
But there are multiple ways of doing this calculation.

581
00:29:39,460 --> 00:29:45,220
So, for example, the first one, I'm using a NumPy operation,

582
00:29:45,220 --> 00:29:49,180
which is basically, you know, for example,

583
00:29:49,180 --> 00:29:53,980
if x is a NumPy array, I would just use the NumPy method,

584
00:29:53,980 --> 00:29:58,100
the sine and cosine there, and do the thing, do the calculation,

585
00:29:58,100 --> 00:30:01,260
instead of the second one here.

586
00:30:01,300 --> 00:30:04,860
So, I would run this, I know this is out of order,

587
00:30:04,860 --> 00:30:07,300
but I will run this code because I'm explaining this one.

588
00:30:07,300 --> 00:30:10,900
So, this one, I'm doing a loop.

589
00:30:10,900 --> 00:30:12,820
I'm doing element-wise operation.

590
00:30:12,820 --> 00:30:18,020
So, the difference is that this one, because this np.cosine

591
00:30:18,020 --> 00:30:22,340
and np.sine, they are NumPy methods that is built

592
00:30:22,340 --> 00:30:24,140
to handle NumPy array.

593
00:30:24,140 --> 00:30:28,100
So, you don't have to worry about each element in this array.

594
00:30:28,100 --> 00:30:30,740
It will just handle it by itself.

595
00:30:30,780 --> 00:30:32,260
We don't know what it does.

596
00:30:32,260 --> 00:30:37,020
Actually, we know, but I'm not going to show it yet.

597
00:30:37,020 --> 00:30:42,460
So, this is if you don't understand NumPy, if you think

598
00:30:42,460 --> 00:30:47,980
about it in a more kind of more, you know, deep dive way,

599
00:30:47,980 --> 00:30:51,500
it's like, wait a second, I have to, you know,

600
00:30:51,500 --> 00:30:52,820
calculate one by one, right?

601
00:30:52,820 --> 00:30:55,700
Because it's a matrix, you know, and it's very complicated.

602
00:30:55,700 --> 00:30:59,860
I want to do it one by one, so just so that, you know,

603
00:30:59,900 --> 00:31:01,420
I am in control.

604
00:31:01,420 --> 00:31:02,740
I know what's going on.

605
00:31:02,740 --> 00:31:06,020
Okay. So, if you compare these two, so,

606
00:31:06,020 --> 00:31:07,340
oh, you already see the warning.

607
00:31:07,340 --> 00:31:10,700
It means that this one's quite slow.

608
00:31:10,700 --> 00:31:14,460
So, I'm going to explain a little bit about what's going on.

609
00:31:14,460 --> 00:31:16,900
Why this one is way quicker than this one,

610
00:31:16,900 --> 00:31:22,900
because in NumPy, it uses not just Python, right?

611
00:31:22,900 --> 00:31:25,460
So, if you do this inside NumPy,

612
00:31:25,460 --> 00:31:28,740
it won't do what you think it's doing.

613
00:31:28,780 --> 00:31:31,780
So, you may think, oh, NumPy is calculating it element-wise,

614
00:31:31,780 --> 00:31:34,140
you know, it's just a shortcut for us to use this,

615
00:31:34,140 --> 00:31:35,500
make our code cleaner.

616
00:31:35,500 --> 00:31:36,820
No, it's more than that.

617
00:31:36,820 --> 00:31:41,260
NumPy will have some already compiled component.

618
00:31:41,260 --> 00:31:42,540
They are low-level code.

619
00:31:42,540 --> 00:31:44,380
They are not written in Python,

620
00:31:44,380 --> 00:31:47,900
and it will just make this calculation way faster.

621
00:31:47,900 --> 00:31:50,260
So, that's why in NumPy, a lot of times,

622
00:31:50,260 --> 00:31:53,260
people tell you do matrix operation,

623
00:31:53,260 --> 00:31:55,660
don't do element-wide operation, because they are super slow.

624
00:31:55,660 --> 00:31:56,960
You see, it's still running.

625
00:31:57,000 --> 00:32:01,160
It's slow, because if you do this,

626
00:32:01,160 --> 00:32:05,280
it's just purely using Python to do this element-wise operation,

627
00:32:05,280 --> 00:32:08,720
and Python is very slow, and you are looping it a lot,

628
00:32:08,720 --> 00:32:10,160
because this one is one to the power of seven,

629
00:32:10,160 --> 00:32:12,880
so it's actually a lot of numbers that we are looping,

630
00:32:12,880 --> 00:32:14,160
doing it one by one.

631
00:32:14,160 --> 00:32:19,400
It's very, very slow, and you want to avoid it.

632
00:32:19,400 --> 00:32:21,240
But why do I talk about that?

633
00:32:21,240 --> 00:32:24,080
Why do I talk about, like, element-wise operation?

634
00:32:24,080 --> 00:32:26,560
It is because sometimes, you know,

635
00:32:26,600 --> 00:32:30,840
so this one, we already have a very nice NumPy built-in method

636
00:32:30,840 --> 00:32:34,200
that can handle it for us, so we don't have to worry about it.

637
00:32:34,200 --> 00:32:37,520
Just do the NumPy way, and we will get it done.

638
00:32:37,520 --> 00:32:38,840
But sometimes, you want to do something

639
00:32:38,840 --> 00:32:42,360
that is maybe a little bit specific,

640
00:32:42,360 --> 00:32:47,880
that it doesn't have a NumPy operation that has to do that for you.

641
00:32:47,880 --> 00:32:50,680
You have to do it element-wise.

642
00:32:50,680 --> 00:32:53,280
I can't think of a very good example on the top of my head,

643
00:32:53,320 --> 00:32:57,840
but sometimes, for example, because there's always a way

644
00:32:57,840 --> 00:33:01,040
that you could do some smart thing with NumPy and get away with it.

645
00:33:01,040 --> 00:33:04,000
But for example, you do very, very strange things

646
00:33:04,000 --> 00:33:06,800
that you compare to array, and then you do a Fibolochi number,

647
00:33:06,800 --> 00:33:10,400
whatever, that is like, nobody do that except you.

648
00:33:10,400 --> 00:33:11,840
Then it won't be in NumPy.

649
00:33:11,840 --> 00:33:13,080
You have to do it element-wise.

650
00:33:13,080 --> 00:33:14,800
You have to do it yourself.

651
00:33:14,800 --> 00:33:18,000
So you have to write it like this yourself.

652
00:33:18,000 --> 00:33:22,440
So, oh, no, this time, you see this is like 10 times slower.

653
00:33:22,480 --> 00:33:23,760
This is millisecond, right?

654
00:33:23,760 --> 00:33:28,760
This is second, so it's like already 3-0 slower.

655
00:33:28,760 --> 00:33:32,120
So it's very, very slow.

656
00:33:32,120 --> 00:33:35,480
But sometimes, you kind of avoid,

657
00:33:35,480 --> 00:33:38,120
because you're doing some very, very specific things,

658
00:33:38,120 --> 00:33:40,400
and I need to do it element-wise.

659
00:33:40,400 --> 00:33:43,120
But I don't want to have a program that basically runs overnight,

660
00:33:43,120 --> 00:33:45,520
because every time I run an experiment, I change something

661
00:33:45,520 --> 00:33:48,200
that would cost me a day to run, which is bad,

662
00:33:48,200 --> 00:33:50,200
especially for data scientists.

663
00:33:50,240 --> 00:33:53,360
Because sometimes we have project that you have to have result

664
00:33:53,360 --> 00:33:56,880
within a week, within a month, oh, no, can't, don't have that time.

665
00:33:56,880 --> 00:33:59,320
So, what should I do?

666
00:33:59,320 --> 00:34:02,240
So you see that now we're using NGIT.

667
00:34:02,240 --> 00:34:04,200
Basically, it's the same thing like we do before,

668
00:34:04,200 --> 00:34:06,480
no Python mode, okay?

669
00:34:06,480 --> 00:34:08,840
Just to show it can be done differently.

670
00:34:08,840 --> 00:34:10,960
If you want, you can again change it into no Python mode

671
00:34:10,960 --> 00:34:13,560
if you want to try it yourself.

672
00:34:13,560 --> 00:34:17,160
So this is element-wise operation.

673
00:34:17,200 --> 00:34:21,280
It's stuff that, oh, this is not error, okay, sorry,

674
00:34:21,280 --> 00:34:22,560
confused a little bit.

675
00:34:22,560 --> 00:34:24,240
The element-wise operation is here, down there, loops.

676
00:34:24,240 --> 00:34:25,560
There's those element-wise.

677
00:34:25,560 --> 00:34:30,880
So let's try to use number to see if it will help us to be faster,

678
00:34:30,880 --> 00:34:33,080
right, because every time things are slow,

679
00:34:33,080 --> 00:34:37,240
it's like, oh, I would use number.

680
00:34:37,240 --> 00:34:38,560
You see that?

681
00:34:38,560 --> 00:34:41,080
We try to run it first, because again,

682
00:34:41,080 --> 00:34:45,280
if we time it the first time, you can actually try it.

683
00:34:45,320 --> 00:34:48,720
You can try not executing this, and you have

684
00:34:48,720 --> 00:34:51,240
to restart your kernel, but you can try.

685
00:34:51,240 --> 00:34:52,800
If you haven't done it, you haven't run it,

686
00:34:52,800 --> 00:34:55,560
you can try running this one first, and then run,

687
00:34:55,560 --> 00:34:59,040
and then you can like do it again, or run it two times.

688
00:34:59,040 --> 00:35:02,840
It will say that, because the result, if you forget

689
00:35:02,840 --> 00:35:05,160
to run this one and run this one, the result will tell you

690
00:35:05,160 --> 00:35:07,960
that, oh, actually the result is a bit strange.

691
00:35:07,960 --> 00:35:11,440
The first one is super slow, but the mean won't be correct

692
00:35:11,440 --> 00:35:15,120
because the first one is slower than the rest.

693
00:35:15,200 --> 00:35:18,280
So it gives you a hint that, oh, I haven't compiled it yet.

694
00:35:18,280 --> 00:35:23,280
But this is the speed when it has been compiled.

695
00:35:23,280 --> 00:35:27,160
So it's quite an improvement, one to four compared to 200.

696
00:35:27,160 --> 00:35:29,200
So it's a slight improvement, but it's an improvement.

697
00:35:29,200 --> 00:35:30,520
Good. We love it.

698
00:35:30,520 --> 00:35:32,360
We love seeing improvement.

699
00:35:32,360 --> 00:35:37,600
But this element-wise thing, right, this thing that you try

700
00:35:37,600 --> 00:35:41,000
to avoid very, very hard, but sometimes you can't avoid,

701
00:35:41,000 --> 00:35:44,560
now NumBot is going to be a Superman and come and save you.

702
00:35:44,600 --> 00:35:48,320
So let's compare this to the one before.

703
00:35:48,320 --> 00:35:50,240
This one, this cell, I give you a warning

704
00:35:50,240 --> 00:35:52,040
that it takes a long time to run.

705
00:35:52,040 --> 00:35:59,080
But this one is still running, but already, yes, it's fast.

706
00:35:59,080 --> 00:36:00,360
It's already done.

707
00:36:00,360 --> 00:36:01,680
And this one is actually even faster

708
00:36:01,680 --> 00:36:04,280
than the original NumPy.

709
00:36:04,280 --> 00:36:07,360
So, wow, what happened here?

710
00:36:07,360 --> 00:36:09,080
Yes, it's crazy, right?

711
00:36:09,080 --> 00:36:13,200
Like we, this is, you know, everybody use NumPy as a scale

712
00:36:13,240 --> 00:36:14,600
of these element-wise operations.

713
00:36:14,600 --> 00:36:16,240
We know it's going to take forever.

714
00:36:16,240 --> 00:36:19,120
And now using NumPy is super fast, because again,

715
00:36:19,120 --> 00:36:22,840
the magic is the reason why it's so slow is

716
00:36:22,840 --> 00:36:25,600
that because it loops for a lot of time, right?

717
00:36:25,600 --> 00:36:27,680
Remember how big it is.

718
00:36:27,680 --> 00:36:30,560
The bigger your array, if you do element-wise,

719
00:36:30,560 --> 00:36:31,880
it's each one of them.

720
00:36:31,880 --> 00:36:36,280
So this one got one to the power of, you know, 10 to the power of seven.

721
00:36:36,280 --> 00:36:38,920
So if you do it one by one, it's very slow.

722
00:36:38,920 --> 00:36:41,360
It adds up, you know, even if it's not, you know,

723
00:36:41,400 --> 00:36:45,120
even if one of them is not super slow, but it all adds up, right?

724
00:36:45,120 --> 00:36:50,560
So if one of them is improved by, let's say, half the time,

725
00:36:50,560 --> 00:36:52,480
it's already saved you a lot of time,

726
00:36:52,480 --> 00:36:57,280
because it has got compiled and it's super fast, right?

727
00:36:57,280 --> 00:36:59,960
So it's a good thing.

728
00:36:59,960 --> 00:37:01,240
It's a good thing.

729
00:37:01,240 --> 00:37:03,960
And next time, if you're stuck, right, if you're, oh my God,

730
00:37:03,960 --> 00:37:07,360
I have to do element-wise operation in NumPy, like I have to loop,

731
00:37:07,360 --> 00:37:10,400
or even, you know, you have to loop a lot of things, right?

732
00:37:10,440 --> 00:37:14,320
So if you're like, for example, calculating a, for example,

733
00:37:14,320 --> 00:37:17,760
you're calling the, with the Fibolochi or whatever that, like,

734
00:37:17,760 --> 00:37:20,000
you know, you have to call a lot of the function,

735
00:37:20,000 --> 00:37:24,600
a lot of time, then this is here to help you.

736
00:37:24,600 --> 00:37:29,000
So the rest of this notebook is going to tell you all these,

737
00:37:29,000 --> 00:37:30,440
like, kind of smaller things.

738
00:37:30,440 --> 00:37:35,600
So those two that I talked to you about, the main key takeaway.

739
00:37:35,600 --> 00:37:36,900
These are the small things

740
00:37:36,900 --> 00:37:38,920
that you can improve a little bit more.

741
00:37:38,920 --> 00:37:40,220
Yes?

742
00:37:40,220 --> 00:37:42,300
It will help you when you write the loop yourself,

743
00:37:42,300 --> 00:37:45,580
but it won't help much if you don't write the loop.

744
00:37:45,580 --> 00:37:46,880
It will still help.

745
00:37:46,880 --> 00:37:49,820
If you compare these two, it will have a slight improvement.

746
00:37:49,820 --> 00:37:53,220
It won't go slower, but it, well, unless you have

747
00:37:53,220 --> 00:37:55,420
to compile it the first time, then it's slower.

748
00:37:55,420 --> 00:37:58,240
But you will still get, generally,

749
00:37:58,240 --> 00:38:00,980
like after compilation, you'll get an improvement.

750
00:38:00,980 --> 00:38:04,300
But if it's not a loop, then, you know, you have to compile it,

751
00:38:04,300 --> 00:38:06,500
and you may as well not do it.

752
00:38:06,500 --> 00:38:09,900
So yeah, like, loop is where it shines the most.

753
00:38:09,980 --> 00:38:13,780
So try to improve it when you have to loop.

754
00:38:13,780 --> 00:38:15,580
Or, yes?

755
00:38:39,900 --> 00:38:41,700
Yeah, so.

756
00:39:10,900 --> 00:39:12,700
So.

757
00:39:30,700 --> 00:39:33,740
So I think there's multiple scenario

758
00:39:33,740 --> 00:39:35,420
that we're encountering here.

759
00:39:35,460 --> 00:39:41,460
So, for example, let me clarify, because now we are learning,

760
00:39:41,460 --> 00:39:43,500
right, that's why we will compile it first and then run it.

761
00:39:43,500 --> 00:39:49,940
But in a practical scenario, you won't write it separately.

762
00:39:49,940 --> 00:39:51,860
You would just like, for example, you have a loop.

763
00:39:51,860 --> 00:39:56,380
You would just call it, because, you know, you don't, we don't,

764
00:39:56,380 --> 00:40:01,340
how can I say, we don't actually comparing the actual compiled

765
00:40:01,340 --> 00:40:02,700
and the non-compiled version.

766
00:40:02,740 --> 00:40:06,300
This is, you know, in a teaching setting that we do that.

767
00:40:06,300 --> 00:40:09,300
But if you, for example, oh, I have this piece of code,

768
00:40:09,300 --> 00:40:13,500
and it's in my project, and I have to make it faster.

769
00:40:13,500 --> 00:40:16,340
You just apply this engine and then run it.

770
00:40:16,340 --> 00:40:18,820
You won't be, you know, oh, I have to write it first

771
00:40:18,820 --> 00:40:20,120
and then write it second time.

772
00:40:20,120 --> 00:40:21,980
You won't, you just, for example, you won't even write time it,

773
00:40:21,980 --> 00:40:23,280
because you just want it to be fast.

774
00:40:23,280 --> 00:40:25,980
And then you already, maybe you already tried before,

775
00:40:25,980 --> 00:40:27,820
but in production, you won't write time it.

776
00:40:27,820 --> 00:40:29,900
So you just run it once.

777
00:40:29,940 --> 00:40:33,500
For your question, that, oh, if I'm reading, for example,

778
00:40:33,500 --> 00:40:37,340
I'm reading a lot of things, I'm processing all this data,

779
00:40:37,340 --> 00:40:39,940
then how can I be faster?

780
00:40:39,940 --> 00:40:42,740
Well, so again, you can think of this

781
00:40:42,740 --> 00:40:44,420
as the case of element-wide operation.

782
00:40:44,420 --> 00:40:46,700
For example, each row is an element.

783
00:40:46,700 --> 00:40:51,540
Then you could actually, you know, compile handling each row.

784
00:40:51,540 --> 00:40:56,180
And then every time, it would be like very fast.

785
00:40:56,180 --> 00:40:59,740
But we have to be careful, because, again,

786
00:40:59,780 --> 00:41:01,140
number is designed for numpy.

787
00:41:01,140 --> 00:41:03,260
So it's not designed to handle io,

788
00:41:03,260 --> 00:41:05,540
which is reading the data, those kind of things.

789
00:41:05,540 --> 00:41:08,500
It really can't, because io is a thing

790
00:41:08,500 --> 00:41:12,140
that number is not going to be speed up,

791
00:41:12,140 --> 00:41:13,580
because that is a Python object.

792
00:41:13,580 --> 00:41:16,900
And those things, like, it's not what number is designed for.

793
00:41:16,900 --> 00:41:20,340
So, and also, a lot of times, io is more complicated.

794
00:41:20,340 --> 00:41:23,500
It's not just how your, you know, your code work and stuff.

795
00:41:23,500 --> 00:41:26,060
It's also about, like, how your computer files system

796
00:41:26,060 --> 00:41:27,540
or this more complicated stuff.

797
00:41:27,580 --> 00:41:31,660
So it was, we are trying to speed up the internal part,

798
00:41:31,660 --> 00:41:36,500
but not the reading and, you know, and output the data part.

799
00:41:36,500 --> 00:41:39,340
So, yeah, so there's multiple things.

800
00:41:39,340 --> 00:41:41,660
I know it's very complicated, and you're thinking, oh,

801
00:41:41,660 --> 00:41:42,940
if I work, how can I use it?

802
00:41:42,940 --> 00:41:46,140
So hopefully by the end, when we try to use it,

803
00:41:46,140 --> 00:41:48,260
then it's getting more clear.

804
00:41:48,260 --> 00:41:52,820
So these are small things that you could use together

805
00:41:52,820 --> 00:41:55,860
with what we just explained and make it go fast.

806
00:41:55,860 --> 00:41:57,300
So, oh, what is fast map?

807
00:41:57,540 --> 00:41:58,820
What is this swing?

808
00:41:58,820 --> 00:42:00,140
Scratch your head.

809
00:42:00,140 --> 00:42:01,460
This is kind of the case that I would see

810
00:42:01,460 --> 00:42:05,740
that it's not being used a lot, because a lot of times, it may,

811
00:42:05,740 --> 00:42:07,260
it's a very, very minor thing,

812
00:42:07,260 --> 00:42:09,460
that kind of smoothing the edge or something like that.

813
00:42:09,460 --> 00:42:14,340
Now, what happened is that for these computer, this chip,

814
00:42:14,340 --> 00:42:16,780
and how they handle mathematical calculation,

815
00:42:16,780 --> 00:42:18,900
there is a compliance that they follow.

816
00:42:18,900 --> 00:42:22,340
Reason being that, you know, because your computer

817
00:42:22,340 --> 00:42:25,500
or this memory and stuff, they are finite, right?

818
00:42:25,540 --> 00:42:27,900
So if it's not handled correctly,

819
00:42:27,900 --> 00:42:29,820
you may accidentally get wrong results

820
00:42:29,820 --> 00:42:32,660
because the digits are overflowing, all these things,

821
00:42:32,660 --> 00:42:35,140
that I'm not going to explain it again.

822
00:42:35,140 --> 00:42:37,180
Like, you can read it yourself if you want,

823
00:42:37,180 --> 00:42:38,860
but it's a very complicated thing

824
00:42:38,860 --> 00:42:42,740
that someone has a PhD published, so I'm not that smart.

825
00:42:42,740 --> 00:42:48,620
But so what happened is that if you use fast map with NGIT,

826
00:42:48,620 --> 00:42:51,780
it means that we'll relax this compliance,

827
00:42:51,820 --> 00:42:58,820
meaning that we are not following this, but why do we do that, right?

828
00:42:58,820 --> 00:43:01,540
Because sometimes following the compliance to make sure

829
00:43:01,540 --> 00:43:04,900
that all the precision, you know, sometimes, you know,

830
00:43:04,900 --> 00:43:07,700
a flow number can have a lot of precision, right?

831
00:43:07,700 --> 00:43:09,780
Sometimes we don't need all those digits, right?

832
00:43:09,780 --> 00:43:12,300
At the end, for example, when you report your result,

833
00:43:12,300 --> 00:43:14,260
you're truncated anyway, so all these digits,

834
00:43:14,260 --> 00:43:16,620
at the end, you don't really care.

835
00:43:16,620 --> 00:43:19,300
So what you can do is to use fast map,

836
00:43:19,340 --> 00:43:21,380
you release that compliance.

837
00:43:21,380 --> 00:43:24,740
It may introduce, in a very unfortunate case,

838
00:43:24,740 --> 00:43:26,540
it may introduce some small error at those digits

839
00:43:26,540 --> 00:43:29,460
that you don't care, but you don't care anyway, so it's fine.

840
00:43:29,460 --> 00:43:32,180
But by releasing this compliance, then we don't have

841
00:43:32,180 --> 00:43:35,700
to follow the rules of, for example, doing this operation first

842
00:43:35,700 --> 00:43:39,780
and then do this, then you won't have the precision error.

843
00:43:39,780 --> 00:43:44,100
But fast map kind of, you know, we sacrifice the decision

844
00:43:44,100 --> 00:43:46,340
but to increase speed because we don't have

845
00:43:46,340 --> 00:43:47,620
to really follow the order.

846
00:43:47,660 --> 00:43:49,420
We just do whatever order is the fastest

847
00:43:49,420 --> 00:43:51,100
for the computer to handle.

848
00:43:51,100 --> 00:43:57,700
So this is a small demonstration about how it can be faster.

849
00:43:57,700 --> 00:44:02,780
But again, for me, I see it as more like a kind of last speech

850
00:44:02,780 --> 00:44:07,260
of things you can do because, you know, it does improve

851
00:44:07,260 --> 00:44:10,380
but it's not the major improve like, for example,

852
00:44:10,380 --> 00:44:14,220
the looping things that we showed earlier that can do.

853
00:44:14,260 --> 00:44:19,540
So, yes, this comparing using fast map and not using fast map.

854
00:44:19,540 --> 00:44:21,460
So they're both using NGIT.

855
00:44:21,460 --> 00:44:25,140
They are supposed to also do the sum very fast.

856
00:44:25,140 --> 00:44:28,780
But if we relax the compliance, which is using fast map,

857
00:44:28,780 --> 00:44:31,940
then it's slightly faster.

858
00:44:31,940 --> 00:44:36,980
So you can see that it's like five-mini-second faster.

859
00:44:36,980 --> 00:44:40,300
Like, again, it's not a huge, it's not like, oh,

860
00:44:40,300 --> 00:44:41,600
multiple improvement.

861
00:44:41,640 --> 00:44:45,440
It's a slight improvement for, if you, again, looping and doing a lot

862
00:44:45,440 --> 00:44:49,000
of agromatical calculation, then your computer, if they don't have

863
00:44:49,000 --> 00:44:52,080
to follow the compliance, they can just do it as fast as they can.

864
00:44:52,080 --> 00:44:53,360
It will be slightly faster.

865
00:44:53,360 --> 00:44:56,680
But this is the last bit of improvement that you want to do.

866
00:44:56,680 --> 00:45:01,840
For example, you, you know, you have nothing else to optimize, right?

867
00:45:01,840 --> 00:45:03,160
You have already done a good job.

868
00:45:03,160 --> 00:45:05,280
You want to just go through the finish line,

869
00:45:05,280 --> 00:45:07,320
do it a little bit better than you can maybe think

870
00:45:07,320 --> 00:45:11,160
about whether you can use fast map.

871
00:45:11,200 --> 00:45:14,800
Another thing that you could improve is to use multiple cores.

872
00:45:14,800 --> 00:45:17,800
For example, my computer, now, you know, nowadays,

873
00:45:17,800 --> 00:45:21,200
you can easily get a computer that has multiple core.

874
00:45:21,200 --> 00:45:24,480
If you do something on your cloud service,

875
00:45:24,480 --> 00:45:26,400
you can also use multiple cores.

876
00:45:26,400 --> 00:45:28,400
So it could be fast.

877
00:45:28,400 --> 00:45:29,700
When I write this tutorial,

878
00:45:29,700 --> 00:45:31,720
I was still using a very old dual core thing.

879
00:45:31,720 --> 00:45:34,080
So it's, but you can still see some improvements.

880
00:45:34,080 --> 00:45:38,560
So if I run it now with this new computer, it should be quite good.

881
00:45:38,600 --> 00:45:40,920
So.

882
00:45:40,920 --> 00:45:44,320
Before it's 130 something, right?

883
00:45:44,320 --> 00:45:47,520
Yeah. So this one is the same thing, cosine sine.

884
00:45:47,520 --> 00:45:48,820
Remember this thing?

885
00:45:48,820 --> 00:45:52,440
So if we use, so my new computer is eight cores.

886
00:45:52,440 --> 00:45:58,120
So if you compare one to four, this is without the multiple core.

887
00:45:58,120 --> 00:46:03,000
This is with, so it's kind of like one-third of the time saved.

888
00:46:03,000 --> 00:46:07,960
So, so yeah, it's kind of three times faster, right?

889
00:46:08,000 --> 00:46:13,200
So, you know, Python, Python by default is not multi-core.

890
00:46:13,200 --> 00:46:14,520
It's not multi-thread.

891
00:46:14,520 --> 00:46:17,280
Python by default is single thread.

892
00:46:17,280 --> 00:46:21,880
So by using this, we would also, I don't know what it does.

893
00:46:21,880 --> 00:46:23,180
Maybe remove the GIL.

894
00:46:23,180 --> 00:46:24,480
I don't know.

895
00:46:24,480 --> 00:46:29,440
Then, yeah, it would be using the power of multiple cores faster.

896
00:46:29,440 --> 00:46:32,360
What if you do not want to use parallel?

897
00:46:32,360 --> 00:46:37,400
It seems like it does.

898
00:46:37,400 --> 00:46:40,240
I would say sometimes there were, you may come,

899
00:46:40,240 --> 00:46:42,480
and I can't think of a good example again.

900
00:46:42,480 --> 00:46:43,960
Like, but some algorithms

901
00:46:43,960 --> 00:46:47,540
that multi-thread actually can damage the result.

902
00:46:47,540 --> 00:46:50,400
Yeah, because it's kind of similar to the concept, right?

903
00:46:50,400 --> 00:46:52,440
Like, fast math, it has to follow certain order

904
00:46:52,440 --> 00:46:53,920
to make the precision.

905
00:46:53,920 --> 00:46:56,400
But for some other algorithms, for example,

906
00:46:56,440 --> 00:46:59,440
like parallel would actually mess things up.

907
00:46:59,440 --> 00:47:01,000
And sometimes, you know, the scary bit is

908
00:47:01,000 --> 00:47:03,080
that it will mess things up, and then you don't actually know

909
00:47:03,080 --> 00:47:04,380
that it got messed up.

910
00:47:04,380 --> 00:47:06,360
So you get the wrong result, and then you thought it's right.

911
00:47:06,360 --> 00:47:10,720
So yeah, for this thing, like, you know, this is demonstration,

912
00:47:10,720 --> 00:47:14,800
and we all know how it works, and that's fine, but be careful.

913
00:47:14,800 --> 00:47:16,600
Yeah.

914
00:47:16,600 --> 00:47:18,400
Yeah.

915
00:47:18,400 --> 00:47:41,200
You mean like this one, or?

916
00:47:41,200 --> 00:47:42,960
Yeah. Yeah.

917
00:47:42,960 --> 00:48:01,480
So if, actually, I can quickly do an experiment, if you allow me.

918
00:48:01,480 --> 00:48:04,040
So I can restart the kernel, okay, restart.

919
00:48:04,040 --> 00:48:08,560
So it, go back to original state, and then we try to quickly want

920
00:48:08,760 --> 00:48:11,080
to run some of the thing that I need, for example,

921
00:48:11,080 --> 00:48:13,520
I need to import whatever things here.

922
00:48:13,520 --> 00:48:15,680
Oh, I need this, probably.

923
00:48:15,680 --> 00:48:19,600
And then, okay, so yeah, I think I have the njt and jit, right?

924
00:48:19,600 --> 00:48:20,900
I'll run a few of these.

925
00:48:20,900 --> 00:48:23,480
Oh, yeah, njt's not defined, so I'll run off these.

926
00:48:23,480 --> 00:48:25,880
So, okay, now let's go back to here.

927
00:48:25,880 --> 00:48:27,180
I think it should be fine.

928
00:48:27,180 --> 00:48:30,520
So I have these, right, parallel ones, so I created this.

929
00:48:30,520 --> 00:48:32,640
And I don't run, I don't compile it this time.

930
00:48:32,640 --> 00:48:34,480
I jump directly to this one.

931
00:48:34,480 --> 00:48:38,400
If I run it, yeah, you will see that.

932
00:48:38,480 --> 00:48:43,680
What happened is that here is, actually it's not, maybe it's strange

933
00:48:43,680 --> 00:48:45,920
because, yeah, it doesn't show.

934
00:48:45,920 --> 00:48:49,120
But anyway, like, what this does is that it will compile,

935
00:48:49,120 --> 00:48:51,760
so maybe I have some previous memory of this, say, if you have

936
00:48:51,760 --> 00:48:55,600
to go back to maybe, like, restart this, or whatever.

937
00:48:55,600 --> 00:48:59,120
So yeah, what I want to show is that, like,

938
00:48:59,120 --> 00:49:01,720
if I run it after I've compiled it,

939
00:49:01,720 --> 00:49:04,440
because the first one is always slower, right?

940
00:49:04,440 --> 00:49:07,280
Like, for example, this, go back to this example.

941
00:49:07,280 --> 00:49:11,000
You see that this is doing the same thing, go fast, right?

942
00:49:11,000 --> 00:49:12,600
So the first time is always lower.

943
00:49:12,600 --> 00:49:16,280
So when I want to compare the results, it depends.

944
00:49:16,280 --> 00:49:20,680
You know, sometimes you may be like, oh, I want to see, actually,

945
00:49:20,680 --> 00:49:23,280
right, actually when I want to code, how much it improved.

946
00:49:23,280 --> 00:49:25,280
Then you may want to include the first one,

947
00:49:25,280 --> 00:49:28,520
because the compilation time should be taken into account.

948
00:49:28,520 --> 00:49:32,920
But if you just want to do a pure comparison, how fast it is,

949
00:49:32,920 --> 00:49:36,800
by compiling it, then that's why in this notebook,

950
00:49:36,840 --> 00:49:38,560
we always run it second time,

951
00:49:38,560 --> 00:49:41,720
because the first time we want to exclude that, right?

952
00:49:41,720 --> 00:49:43,880
But yeah, I don't know why it's not showing,

953
00:49:43,880 --> 00:49:45,560
but like, if you don't run this cell,

954
00:49:45,560 --> 00:49:48,000
if you directly run it, it should show you that, oh,

955
00:49:48,000 --> 00:49:50,160
the result is a bit strange, because, you know,

956
00:49:50,160 --> 00:49:51,880
the first one is actually slower.

957
00:49:51,880 --> 00:49:54,440
They will tell you that, you know, the deviation is very big

958
00:49:54,440 --> 00:49:57,840
because of the first one, very slow, something like that.

959
00:49:57,840 --> 00:49:59,880
But yeah, mess around with the notebook.

960
00:49:59,880 --> 00:50:03,920
You may be able to see that, strange things yourself.

961
00:50:03,920 --> 00:50:06,200
So yes?

962
00:50:06,200 --> 00:50:09,440
I know this is probably only for the second time,

963
00:50:09,440 --> 00:50:14,440
but have you tested within this OL,

964
00:50:14,440 --> 00:50:19,440
if you can put out, like in every,

965
00:50:19,440 --> 00:50:24,440
the second would be something, something for the book.

966
00:50:25,960 --> 00:50:28,960
I would think probably with the file mode,

967
00:50:28,960 --> 00:50:31,960
you have like, reading from outside,

968
00:50:31,960 --> 00:50:36,960
like, you might be able to do faster than that.

969
00:50:37,960 --> 00:50:40,000
Yeah, that's something that I think is worth trying.

970
00:50:40,000 --> 00:50:42,640
I haven't tried myself, again, like,

971
00:50:42,640 --> 00:50:45,640
I don't know if numbers are gonna work in that scenario,

972
00:50:45,640 --> 00:50:47,920
because probably if you, anything involve IO,

973
00:50:47,920 --> 00:50:50,440
you can't use NGIT mode, you have to use the object mode,

974
00:50:50,440 --> 00:50:51,720
which is just the JIT.

975
00:50:53,240 --> 00:50:58,240
But yeah, like, multi-fretting, practically,

976
00:50:58,400 --> 00:51:00,920
is supposed to be faster, right?

977
00:51:00,920 --> 00:51:03,160
But for example, IO, that kind of things,

978
00:51:03,160 --> 00:51:05,800
then you also have to use a tool

979
00:51:05,800 --> 00:51:08,080
that is also be thread safe,

980
00:51:08,080 --> 00:51:11,080
because especially when you're accessing the same object

981
00:51:11,080 --> 00:51:14,520
with different thread, and it could, weird thing can happen.

982
00:51:14,520 --> 00:51:19,240
So I would say that, yeah, you can look at Numbah,

983
00:51:19,240 --> 00:51:20,920
but also maybe look at Siphon,

984
00:51:20,920 --> 00:51:22,560
maybe they know how to handle it.

985
00:51:22,560 --> 00:51:25,160
I haven't looked, I haven't used Siphon for ages,

986
00:51:25,160 --> 00:51:27,160
but I've just talked to the commenting,

987
00:51:27,160 --> 00:51:28,680
like a few days ago in Germany.

988
00:51:28,680 --> 00:51:33,080
So yeah, if you encounter him in a conference,

989
00:51:33,080 --> 00:51:35,520
then you can ask him, like, oh, is it thread safe?

990
00:51:37,080 --> 00:51:42,080
But yeah, I think, you know, but also,

991
00:51:42,240 --> 00:51:45,040
so my talk tomorrow, we talk about, like,

992
00:51:45,040 --> 00:51:46,760
sometimes scientific programming,

993
00:51:46,760 --> 00:51:49,000
do we get the improvement of using multi-fret?

994
00:51:49,000 --> 00:51:50,800
It depends.

995
00:51:50,800 --> 00:51:53,920
So yeah, so come to my talk tomorrow,

996
00:51:53,920 --> 00:51:56,480
if you want to talk more about multi-fretting,

997
00:51:56,480 --> 00:51:57,540
JIT and other stuff.

998
00:51:58,380 --> 00:52:01,540
So yeah, so that's the first notebook.

999
00:52:01,540 --> 00:52:02,780
Any other questions?

1000
00:52:02,780 --> 00:52:04,380
Do you want a coffee?

1001
00:52:04,380 --> 00:52:06,300
Do you want a break?

1002
00:52:06,300 --> 00:52:08,020
Yes, I can see some nothing.

1003
00:52:08,020 --> 00:52:13,220
So originally, the plan is 1030, we have a 30-minute break.

1004
00:52:13,220 --> 00:52:15,660
How about now we have a 15-minute break,

1005
00:52:15,660 --> 00:52:18,060
and then we would maybe have another break later?

1006
00:52:18,060 --> 00:52:19,860
Okay, good.

1007
00:52:19,860 --> 00:52:23,060
So we will come back at 1015.

1008
00:52:23,060 --> 00:52:26,020
Okay, so we are about to start.

1009
00:52:26,300 --> 00:52:30,340
Before we move on, actually, I have a question as a survey.

1010
00:52:30,340 --> 00:52:34,900
So I want to know what environment people are using normally

1011
00:52:34,900 --> 00:52:37,220
for work or for example, this,

1012
00:52:37,220 --> 00:52:38,980
I know that we're all using juvenile notebook,

1013
00:52:38,980 --> 00:52:43,500
but so what would you use, for example, do you prefer,

1014
00:52:43,500 --> 00:52:47,020
who do you use PIP to install your things?

1015
00:52:47,020 --> 00:52:48,860
PIP? PIP.

1016
00:52:48,860 --> 00:52:50,340
Who use Conda?

1017
00:52:50,340 --> 00:52:53,780
So a few of them, okay.

1018
00:52:53,820 --> 00:52:58,100
Okay, so who use, so this is very tricky.

1019
00:52:58,100 --> 00:53:02,020
Who use Pi Env to manage your environment?

1020
00:53:03,020 --> 00:53:06,100
Okay, how many use Conda?

1021
00:53:06,100 --> 00:53:07,740
Okay, oh, actually it's quite even.

1022
00:53:07,740 --> 00:53:10,860
Okay, Poetry?

1023
00:53:10,860 --> 00:53:12,540
Oh, Poetry is getting more popular.

1024
00:53:12,540 --> 00:53:15,580
Okay, who is using others that I haven't asked?

1025
00:53:15,580 --> 00:53:21,220
Okay, I don't know that one.

1026
00:53:21,220 --> 00:53:22,540
Any others?

1027
00:53:22,540 --> 00:53:23,860
Okay, good.

1028
00:53:23,860 --> 00:53:27,660
I just want to know what people are using.

1029
00:53:27,660 --> 00:53:29,780
So thank you for participating.

1030
00:53:29,780 --> 00:53:34,540
Okay, let's go back to Numba.

1031
00:53:34,540 --> 00:53:39,100
So, okay, so there are, so I think some

1032
00:53:39,100 --> 00:53:40,940
of you already kind of very smart, right?

1033
00:53:40,940 --> 00:53:43,260
You already have questions about, oh, you know,

1034
00:53:43,260 --> 00:53:45,140
why do we have JIT and NJIT?

1035
00:53:45,140 --> 00:53:46,460
When do we use it?

1036
00:53:46,460 --> 00:53:48,140
And what if it doesn't work?

1037
00:53:48,140 --> 00:53:49,460
And all those things.

1038
00:53:49,740 --> 00:53:54,540
We now going to debugging or problem solving territory

1039
00:53:54,540 --> 00:53:56,380
that like when you start using Numba,

1040
00:53:56,380 --> 00:53:59,060
you may come across some of these.

1041
00:53:59,060 --> 00:54:04,380
Again, Numba is, you know, so some of you ask me like, oh,

1042
00:54:04,380 --> 00:54:06,340
so when will I use it because, you know,

1043
00:54:06,340 --> 00:54:09,580
a lot of mathematical library already optimized.

1044
00:54:09,580 --> 00:54:11,820
I would say that for most of you,

1045
00:54:11,820 --> 00:54:14,380
you may actually be using Numba without you thinking

1046
00:54:14,380 --> 00:54:17,820
about Numba because it's written in some of your libraries.

1047
00:54:17,860 --> 00:54:21,620
So I would say that the maintainers, they use it the most.

1048
00:54:21,620 --> 00:54:24,260
So but for those of you who, you know, doesn't have plan

1049
00:54:24,260 --> 00:54:27,380
to contribute to that project or become a maintainer,

1050
00:54:27,380 --> 00:54:31,100
then maybe one day there's an edge case that like, for example,

1051
00:54:31,100 --> 00:54:34,660
you have a thing that no library is providing that for you.

1052
00:54:34,660 --> 00:54:36,380
You have to write it yourself.

1053
00:54:36,380 --> 00:54:39,740
And so you also have to do some optimization yourself.

1054
00:54:39,740 --> 00:54:42,380
Then this is the time that, you know,

1055
00:54:42,380 --> 00:54:44,380
you suddenly remember this and maybe you look

1056
00:54:44,380 --> 00:54:46,900
at this Jibudana book again.

1057
00:54:46,940 --> 00:54:50,540
So yeah, so it's not a very,

1058
00:54:50,540 --> 00:54:52,540
that's why it's not a very popular tool.

1059
00:54:52,540 --> 00:54:53,860
A lot of people don't know about it,

1060
00:54:53,860 --> 00:54:56,780
but actually they're using it without knowing.

1061
00:54:56,780 --> 00:55:01,700
Okay, so that's why sometimes it's difficult

1062
00:55:01,700 --> 00:55:04,140
when you come across, encounter a problem.

1063
00:55:04,140 --> 00:55:07,940
For example, remember when you learn pandas, you know,

1064
00:55:07,940 --> 00:55:11,020
you have some error message or how do I do this?

1065
00:55:11,020 --> 00:55:14,220
You can Google and a lot of answers will be provided, right,

1066
00:55:14,220 --> 00:55:16,460
because the user base is very big.

1067
00:55:16,500 --> 00:55:20,900
For number, it's a bit tricky because a lot of times, you know,

1068
00:55:20,900 --> 00:55:25,260
you can't find exactly what you want the answer easily.

1069
00:55:25,260 --> 00:55:29,020
So, but I hope that by this notebook it can solve some

1070
00:55:29,020 --> 00:55:34,380
of the very more common problems that beginners may came across.

1071
00:55:34,380 --> 00:55:37,860
So it already saves some of your time to troubleshoot.

1072
00:55:37,860 --> 00:55:43,420
So now we are doing something that someone already mentioned.

1073
00:55:43,460 --> 00:55:47,460
Oh, what if I compile the function and it's designed for integer

1074
00:55:47,460 --> 00:55:50,180
and then I now put in a float?

1075
00:55:50,180 --> 00:55:51,460
So what happened?

1076
00:55:51,460 --> 00:55:55,780
So this is the problem that is caused by the type.

1077
00:55:55,780 --> 00:56:00,860
So, you know, in Python, types are very dynamic.

1078
00:56:00,860 --> 00:56:02,140
You can put in anything.

1079
00:56:02,140 --> 00:56:07,660
You can change the type or, you know, but for program

1080
00:56:07,660 --> 00:56:09,820
that need compiling doesn't work like that, right?

1081
00:56:09,820 --> 00:56:12,660
If you have learned other programming languages, for example,

1082
00:56:12,700 --> 00:56:16,020
against C or C++, those you have to define the type

1083
00:56:16,020 --> 00:56:17,340
of the variable.

1084
00:56:17,340 --> 00:56:19,420
It's not dynamic like Python.

1085
00:56:19,420 --> 00:56:24,340
So those are actually, you know, designed to be compiled, right?

1086
00:56:24,340 --> 00:56:26,820
So it's not like Python.

1087
00:56:26,820 --> 00:56:29,980
Python is like I said, it's interpret bit by bit.

1088
00:56:29,980 --> 00:56:32,500
So it's kind of figured out as it goes.

1089
00:56:32,500 --> 00:56:36,020
But for compiled program, you need to know beforehand

1090
00:56:36,020 --> 00:56:40,380
because the code needs to be translated into something

1091
00:56:40,420 --> 00:56:41,820
that a machine understand.

1092
00:56:41,820 --> 00:56:46,140
And if you can't just suddenly decide a type

1093
00:56:46,140 --> 00:56:47,580
because it has been translated

1094
00:56:47,580 --> 00:56:49,820
and the machine is not very smart.

1095
00:56:49,820 --> 00:56:51,100
It's very rigid.

1096
00:56:51,100 --> 00:56:52,580
You need to know the type beforehand.

1097
00:56:52,580 --> 00:56:57,220
So now, so let's look at this.

1098
00:56:57,220 --> 00:57:00,940
This again, it was reminding that like NGIT is like,

1099
00:57:00,940 --> 00:57:03,300
it's the no Python mode.

1100
00:57:03,300 --> 00:57:05,300
So we are compiling this for sure.

1101
00:57:05,300 --> 00:57:06,940
And we're adding two numbers.

1102
00:57:06,940 --> 00:57:09,900
And this is something that you may do in Python, right?

1103
00:57:09,940 --> 00:57:12,620
X and Y, there may be a naughty user putting something

1104
00:57:12,620 --> 00:57:13,940
that is not integer.

1105
00:57:13,940 --> 00:57:17,300
Or if it got passed in from another function

1106
00:57:17,300 --> 00:57:20,140
and then it may come in as a string.

1107
00:57:20,140 --> 00:57:24,140
For example, if you're running your Python code

1108
00:57:24,140 --> 00:57:27,060
and then having the, you know, when you're typing the command,

1109
00:57:27,060 --> 00:57:31,100
Python my code.py and then one and two.

1110
00:57:31,100 --> 00:57:33,660
So those one and two actually come in as a string.

1111
00:57:33,660 --> 00:57:34,940
So this is what you would do.

1112
00:57:34,940 --> 00:57:38,300
Oh, I'll convert into integer and then it will be fine, right?

1113
00:57:38,340 --> 00:57:42,780
So it's fine in Python, but it's not always fine.

1114
00:57:42,780 --> 00:57:45,340
So this is no Python mode.

1115
00:57:45,340 --> 00:57:47,580
So this is, you know, again, the more rigid mode.

1116
00:57:47,580 --> 00:57:49,660
I can't handle Python object.

1117
00:57:49,660 --> 00:57:55,340
So this is kind of working fine, you know,

1118
00:57:55,340 --> 00:57:57,620
because both of them are integer.

1119
00:57:57,620 --> 00:57:59,380
It know what to do because these two are supposed

1120
00:57:59,380 --> 00:58:00,680
to be integer, right?

1121
00:58:00,680 --> 00:58:01,980
So everything is fine.

1122
00:58:01,980 --> 00:58:05,860
But like I said before, if this one, this is what it will come

1123
00:58:05,900 --> 00:58:09,700
in through your arguments from the command line.

1124
00:58:09,700 --> 00:58:11,000
It is a string.

1125
00:58:11,000 --> 00:58:12,900
It's not an integer.

1126
00:58:12,900 --> 00:58:15,260
Then you will have a scary error.

1127
00:58:15,260 --> 00:58:18,180
You have a type error.

1128
00:58:18,180 --> 00:58:20,620
So it doesn't work.

1129
00:58:20,620 --> 00:58:23,540
But then you will scratch your head, right,

1130
00:58:23,540 --> 00:58:26,060
in normally because, well, I have already done this in Python.

1131
00:58:26,060 --> 00:58:27,360
Why it doesn't work?

1132
00:58:27,360 --> 00:58:29,260
Well, because this is a compiled code.

1133
00:58:29,260 --> 00:58:33,020
It works in Python, but it doesn't work if it's compiled.

1134
00:58:33,060 --> 00:58:44,460
So another thing you can do is to use, so this is what's going

1135
00:58:44,460 --> 00:58:45,760
on here.

1136
00:58:45,760 --> 00:58:49,220
So I suggest like, oh, you want to be very fast.

1137
00:58:49,220 --> 00:58:52,740
You use njit, very, you know, optimistic, very ambitious.

1138
00:58:52,740 --> 00:58:54,580
And then, oh, no, this does not work.

1139
00:58:54,580 --> 00:58:56,100
I don't know what happened.

1140
00:58:56,100 --> 00:58:59,100
Okay. The quickest fix is to remove the n.

1141
00:58:59,100 --> 00:59:02,220
So I will just use jit instead of njit.

1142
00:59:02,260 --> 00:59:06,180
Then instead of getting an error saying that, no, no, no, no,

1143
00:59:06,180 --> 00:59:07,480
I can't do that.

1144
00:59:07,480 --> 00:59:08,780
Number can't do this.

1145
00:59:08,780 --> 00:59:10,080
Number will say that.

1146
00:59:10,080 --> 00:59:14,100
Okay. It's not recommended, but number will handle it for you.

1147
00:59:14,100 --> 00:59:15,860
This is what happened.

1148
00:59:15,860 --> 00:59:18,140
But again, you know, this tradeoff is

1149
00:59:18,140 --> 00:59:23,380
that the code won't be, you know, as fast as you want.

1150
00:59:23,380 --> 00:59:30,140
So, yeah. So this is another case that we may come

1151
00:59:30,180 --> 00:59:33,140
into the similar problem is that for some of the return type.

1152
00:59:33,140 --> 00:59:38,860
So this is the problem that we have with a type

1153
00:59:38,860 --> 00:59:41,860
that the input type is not what we are expecting.

1154
00:59:41,860 --> 00:59:45,300
We're expecting integer, and now it's not an integer.

1155
00:59:45,300 --> 00:59:48,900
This is the other side of the problem is that what

1156
00:59:48,900 --> 00:59:52,700
about the return type is not defined, right?

1157
00:59:52,700 --> 00:59:57,740
For this one, what is the return type of this function?

1158
00:59:58,660 --> 01:00:00,940
What's the return type?

1159
01:00:00,940 --> 01:00:02,220
It's an object.

1160
01:00:02,220 --> 01:00:06,340
It's a very, very good answer.

1161
01:00:06,340 --> 01:00:07,820
You apply to everything.

1162
01:00:07,820 --> 01:00:12,020
So for those of you who like love typing, you'll be like, oh,

1163
01:00:12,020 --> 01:00:15,540
you would maybe mark it as union, string,

1164
01:00:15,540 --> 01:00:18,820
and integer, something like that.

1165
01:00:18,820 --> 01:00:24,860
But again, it doesn't, you know, njit doesn't like it.

1166
01:00:24,860 --> 01:00:26,580
It can't be both.

1167
01:00:26,620 --> 01:00:27,900
It needs to be one.

1168
01:00:27,900 --> 01:00:30,980
So this can't be done.

1169
01:00:30,980 --> 01:00:35,100
So yeah. So we have to use a proper decorator for that.

1170
01:00:35,100 --> 01:00:37,260
So this is your time to shine.

1171
01:00:37,260 --> 01:00:40,500
Can you fix that for me, please?

1172
01:00:40,500 --> 01:00:43,220
But if you have the notebook open, go to this cell,

1173
01:00:43,220 --> 01:00:46,980
you may be able to find it using the to do.

1174
01:00:46,980 --> 01:00:48,280
Can you fix this?

1175
01:00:48,280 --> 01:00:52,420
I will give you maybe three minutes to fix it.

1176
01:00:52,420 --> 01:00:55,140
It should be quite straightforward.

1177
01:00:56,580 --> 01:00:58,900
Yeah.

1178
01:01:14,340 --> 01:01:15,660
Yeah, scary warning.

1179
01:01:15,660 --> 01:01:16,940
I don't like it.

1180
01:01:16,940 --> 01:01:19,500
Yeah. It doesn't mean a lot of things as well.

1181
01:01:19,500 --> 01:01:20,820
It's like I would scratch my head.

1182
01:01:20,820 --> 01:01:22,100
What's going on?

1183
01:01:22,100 --> 01:01:25,420
And can't find a lot of answers on Stack Overflow either.

1184
01:01:25,420 --> 01:01:29,220
It's not as easy to find as other things.

1185
01:01:29,220 --> 01:01:31,020
For example, if you use pure Python,

1186
01:01:31,020 --> 01:01:33,180
a lot of people use Python, they would answer your question

1187
01:01:33,180 --> 01:01:34,620
with Numba.

1188
01:01:34,620 --> 01:01:36,620
You have to be very lucky to find someone

1189
01:01:36,620 --> 01:01:40,860
who you expect to use Numba and answer your question.

1190
01:01:55,420 --> 01:02:07,260
Or you can split into two functions.

1191
01:02:07,260 --> 01:02:09,420
For example, you sacrifice one value and then

1192
01:02:09,420 --> 01:02:14,420
that value is an error value and then you have another function

1193
01:02:14,420 --> 01:02:16,660
to mark it up or something.

1194
01:02:16,660 --> 01:02:19,140
Yeah. There's always a way to rewrite the code.

1195
01:02:19,140 --> 01:02:20,900
It's just that, does it work the effort?

1196
01:02:20,900 --> 01:02:23,140
Do you want to do it?

1197
01:02:23,140 --> 01:02:23,940
Yeah.

1198
01:02:23,940 --> 01:02:32,140
Yeah, you can always break it into two parts,

1199
01:02:32,140 --> 01:02:35,740
but yeah, this is a very oversimplified example.

1200
01:02:35,740 --> 01:02:37,900
A lot of things are not that straightforward.

1201
01:02:37,900 --> 01:02:39,180
They're very tangled.

1202
01:02:39,180 --> 01:02:42,180
There's a lot of loops and stuff.

1203
01:02:42,180 --> 01:02:45,740
You will see later when we look into the scary bits.

1204
01:02:46,220 --> 01:02:51,980
So one more minute.

1205
01:02:51,980 --> 01:02:55,940
Who already, I see some of you already stopped,

1206
01:02:55,940 --> 01:02:58,740
so I guess you have done it.

1207
01:02:58,740 --> 01:03:19,220
So who still need more time?

1208
01:03:19,220 --> 01:03:21,500
Let me know.

1209
01:03:21,500 --> 01:03:23,020
No? No one responds.

1210
01:03:23,020 --> 01:03:26,100
So I assume people already guessed the result is

1211
01:03:26,140 --> 01:03:30,740
to remove the end and use JIT.

1212
01:03:30,740 --> 01:03:35,540
So yeah, so if you do like JIT, I think I've imported before.

1213
01:03:35,540 --> 01:03:37,140
It should be fine.

1214
01:03:37,140 --> 01:03:41,140
And then run it, then like, you know.

1215
01:03:41,140 --> 01:03:42,780
Then yeah, I get a scary warning,

1216
01:03:42,780 --> 01:03:44,300
but it's not a scary error.

1217
01:03:44,300 --> 01:03:47,700
So again, like this, if you don't want to see them,

1218
01:03:47,700 --> 01:03:50,900
you can change your setting in your Python or Jupyter notebook

1219
01:03:50,900 --> 01:03:54,340
and get rid of them and as if everything is fine, you know.

1220
01:03:54,380 --> 01:03:55,860
But some, yeah.

1221
01:03:55,860 --> 01:04:02,020
It's telling you that you could add them without a force object

1222
01:04:02,020 --> 01:04:05,740
and then it doesn't give you the warning, right?

1223
01:04:05,740 --> 01:04:10,700
No, it's basically telling you that it's not optimized.

1224
01:04:10,700 --> 01:04:13,220
Mine has like a, there's a deprecation warning.

1225
01:04:13,220 --> 01:04:14,500
You have a deprecation warning?

1226
01:04:14,500 --> 01:04:15,260
Oh.

1227
01:04:15,260 --> 01:04:18,540
Right there.

1228
01:04:18,540 --> 01:04:20,940
Well, you have to add force object equals true.

1229
01:04:20,940 --> 01:04:23,500
I think that's what it's saying.

1230
01:04:23,620 --> 01:04:29,180
Yeah, it's, yeah, there's number one as well.

1231
01:04:29,180 --> 01:04:30,900
That one again was compiled in object.

1232
01:04:30,900 --> 01:04:32,180
Yeah.

1233
01:04:32,180 --> 01:04:37,420
That parameter to the decorator, the warning was wrong.

1234
01:04:37,420 --> 01:04:39,900
Maybe. There's the multiple problem here.

1235
01:04:39,900 --> 01:04:43,260
You can see like, oh, you already compiled it before and stuff.

1236
01:04:43,260 --> 01:04:44,580
So without force object, it was true.

1237
01:04:44,580 --> 01:04:49,460
If you add that force object to the decorator,

1238
01:04:49,460 --> 01:04:51,300
it'll just pass without your warning.

1239
01:04:51,300 --> 01:04:53,980
Yeah, I think like now it's saying that like, well,

1240
01:04:53,980 --> 01:04:56,540
you're kind of like forcing it.

1241
01:04:56,540 --> 01:04:57,820
Do you really want to force it?

1242
01:04:57,820 --> 01:04:59,140
And then you said, yes, I want to force it.

1243
01:04:59,140 --> 01:05:02,580
Then it won't warn you because you already know what you're doing.

1244
01:05:02,580 --> 01:05:07,700
Yeah, it's just in case like if you, you know,

1245
01:05:07,700 --> 01:05:10,180
if you're kind of a beginner, you don't know like, you know,

1246
01:05:10,180 --> 01:05:12,620
your thought is this what the best you can do

1247
01:05:12,620 --> 01:05:16,140
and then it would just tell you a bunch of things.

1248
01:05:16,140 --> 01:05:18,860
But if you are very, you know, because it's ambiguous.

1249
01:05:18,860 --> 01:05:20,980
So Numba doesn't know whether that's something

1250
01:05:21,140 --> 01:05:23,820
that you want just to make sure you can always, you know,

1251
01:05:23,820 --> 01:05:27,300
get rid of it if you want.

1252
01:05:27,300 --> 01:05:29,700
So, ooh, extra task.

1253
01:05:29,700 --> 01:05:31,020
I love extra task.

1254
01:05:31,020 --> 01:05:33,980
So profile this tool and compare.

1255
01:05:33,980 --> 01:05:39,140
I will give you some time to run it yourself before I run it

1256
01:05:39,140 --> 01:05:40,860
and everybody see it.

1257
01:05:40,860 --> 01:05:44,820
Then you can have a thought about why is it different.

1258
01:05:44,820 --> 01:05:50,940
And yeah, what's going on there?

1259
01:05:50,940 --> 01:06:06,220
So let's, okay, so I guess you already seen the result.

1260
01:06:06,220 --> 01:06:07,300
I'll run it.

1261
01:06:07,300 --> 01:06:08,620
It took quite a while.

1262
01:06:08,620 --> 01:06:20,300
Right. Oh, actually I got a warning.

1263
01:06:20,340 --> 01:06:21,620
Oh my God.

1264
01:06:23,740 --> 01:06:25,060
Or is it still doing?

1265
01:06:25,060 --> 01:06:26,340
No. It's still running.

1266
01:06:26,340 --> 01:06:28,660
Yeah, it's very slow, this one.

1267
01:06:28,660 --> 01:06:29,980
Because it is a string.

1268
01:06:29,980 --> 01:06:31,420
Because it is a string.

1269
01:06:31,420 --> 01:06:35,100
Because it is 1.93.

1270
01:06:35,100 --> 01:06:38,220
So yeah. Ooh.

1271
01:06:38,220 --> 01:06:43,220
Oh, maybe because no.

1272
01:06:43,220 --> 01:06:44,500
This is nanosecond.

1273
01:06:44,500 --> 01:06:46,940
Okay, so it's like an order of magnitude difference.

1274
01:06:46,940 --> 01:06:50,220
Yeah. So yeah, you can see that it's slower

1275
01:06:51,180 --> 01:06:55,780
and it's, you know, have the conversion of the type.

1276
01:06:55,780 --> 01:07:01,860
Because, you know, again, it's, even if you use JIT, right,

1277
01:07:01,860 --> 01:07:05,220
so JIT will still try its best to help you.

1278
01:07:05,220 --> 01:07:08,140
So when JIT see that, oh, actually you are just passing integer

1279
01:07:08,140 --> 01:07:12,380
in and it should be, you know, NJIT instead of JIT.

1280
01:07:12,380 --> 01:07:15,260
Okay, I'll automatically do NJIT for you

1281
01:07:15,260 --> 01:07:16,580
so you will have it faster.

1282
01:07:16,580 --> 01:07:20,100
But then like if it's something that can't be NJIT,

1283
01:07:20,140 --> 01:07:22,820
that need to use object mode, can't be no Python,

1284
01:07:22,820 --> 01:07:25,260
then it will be slower.

1285
01:07:25,260 --> 01:07:27,140
So even though there are lots of scary warnings,

1286
01:07:27,140 --> 01:07:32,060
so sometimes it could be an easy fix because, you know,

1287
01:07:32,060 --> 01:07:37,820
if, even if you're using object mode, if it can be optimized,

1288
01:07:37,820 --> 01:07:39,660
it will be optimized.

1289
01:07:39,660 --> 01:07:42,340
So it's kind of, you know, nobody's trying its best

1290
01:07:42,340 --> 01:07:45,580
to be smart and try to help you.

1291
01:07:45,580 --> 01:07:49,180
So yeah, sometimes it's not a bad thing to use JIT

1292
01:07:49,220 --> 01:07:50,980
if you're really struggling.

1293
01:07:50,980 --> 01:07:54,620
It's just that some people may want to have full control

1294
01:07:54,620 --> 01:07:58,100
to make sure that nobody break this, it must be compiled

1295
01:07:58,100 --> 01:08:01,180
and NJIT will safeguard that for you.

1296
01:08:01,180 --> 01:08:07,780
So another thing is, okay, it's empty list.

1297
01:08:07,780 --> 01:08:09,900
So this one is showing the normal thing.

1298
01:08:09,900 --> 01:08:11,200
This is not an empty list.

1299
01:08:11,200 --> 01:08:13,020
So everything should be fine, right?

1300
01:08:13,020 --> 01:08:14,320
Everything's fine.

1301
01:08:14,320 --> 01:08:15,620
I can compile it.

1302
01:08:15,620 --> 01:08:16,920
No scary warning.

1303
01:08:16,920 --> 01:08:18,660
I can use NJIT, no scary warning, everything is good.

1304
01:08:18,660 --> 01:08:23,800
But if we do the empty list, as you can guess,

1305
01:08:23,800 --> 01:08:27,020
this will give you a scary warning, right?

1306
01:08:27,020 --> 01:08:33,220
Can you guess why it is the case?

1307
01:08:33,220 --> 01:08:36,660
Anybody already know what's going on here?

1308
01:08:36,660 --> 01:08:41,800
You don't know what type it is?

1309
01:08:41,800 --> 01:08:45,380
Yes, this is what Numbot doesn't like is to,

1310
01:08:45,380 --> 01:08:48,100
so this is even worse than this, right?

1311
01:08:48,320 --> 01:08:51,540
So you can say like this, for example, this, right?

1312
01:08:51,540 --> 01:08:54,660
It's like only two, kind of when, you know,

1313
01:08:54,660 --> 01:08:59,300
guess or something, but this really can be anything, right?

1314
01:08:59,300 --> 01:09:00,600
It's empty list.

1315
01:09:00,600 --> 01:09:01,900
You can put anything in it.

1316
01:09:01,900 --> 01:09:03,260
You can even put your self-defined

1317
01:09:03,260 --> 01:09:04,560
like a Python object.

1318
01:09:04,560 --> 01:09:07,060
You can put a magic mark, you know, you can put anything in it.

1319
01:09:07,060 --> 01:09:10,260
So Numbot really don't like it.

1320
01:09:10,260 --> 01:09:15,820
So this is a very, very, very difficult question,

1321
01:09:15,860 --> 01:09:18,020
but how can you create an empty list,

1322
01:09:18,020 --> 01:09:20,460
but you can still tell Numbot what type it is,

1323
01:09:20,460 --> 01:09:21,760
for example, integer.

1324
01:09:21,760 --> 01:09:27,540
Yeah, this is a fun kind of exercise.

1325
01:09:27,540 --> 01:09:28,860
Don't worry if you can't

1326
01:09:28,860 --> 01:09:30,620
because I already have the answer somewhere.

1327
01:09:30,620 --> 01:09:33,660
You can load it and check it yourself,

1328
01:09:33,660 --> 01:09:38,260
but I would give you maybe like five minutes to try it first.

1329
01:09:38,260 --> 01:09:42,220
It's really something that, you know, you would get an aha

1330
01:09:42,220 --> 01:09:45,780
when you see the answer, but give it a try.

1331
01:09:46,780 --> 01:09:48,900
See if your idea will work.

1332
01:09:48,900 --> 01:09:52,100
You'll give you five minutes to try it.

1333
01:09:52,100 --> 01:09:55,300
Who has confidence that they have got it?

1334
01:09:55,300 --> 01:09:58,340
Ooh. It's fine.

1335
01:09:58,340 --> 01:10:00,300
You can look it up because, you know,

1336
01:10:00,300 --> 01:10:02,700
we all look up things when we work, so it's fine.

1337
01:10:02,700 --> 01:10:06,100
So, but anyway, this is the answer that I have written before

1338
01:10:06,100 --> 01:10:09,140
or actually is actually in the documentation.

1339
01:10:09,140 --> 01:10:12,580
So if you're paying attention, then you will find it.

1340
01:10:12,620 --> 01:10:17,340
So this is, well, it's creating a list of integer, obviously,

1341
01:10:17,340 --> 01:10:20,020
but the funny bit is like it's in a range of zero,

1342
01:10:20,020 --> 01:10:23,300
so basically it's creating an empty list of integer.

1343
01:10:23,300 --> 01:10:24,600
I don't know if Python can do that.

1344
01:10:24,600 --> 01:10:26,620
Okay, range zero, I don't know, and I don't know

1345
01:10:26,620 --> 01:10:28,860
that like it actually registers an integer

1346
01:10:28,860 --> 01:10:30,380
because technically there's nothing in it,

1347
01:10:30,380 --> 01:10:32,500
so it's mind blowing.

1348
01:10:32,500 --> 01:10:34,300
Yeah?

1349
01:10:34,300 --> 01:10:47,380
You can do that as well, that maybe actually, yeah.

1350
01:10:47,380 --> 01:10:53,300
Yeah, the typing.

1351
01:10:53,300 --> 01:10:57,140
Yeah, so I have actually, I've talked to the maintainer saying

1352
01:10:57,140 --> 01:10:59,620
like oh, now everybody loves typing, right?

1353
01:10:59,620 --> 01:11:01,780
How about number can understand typing?

1354
01:11:01,780 --> 01:11:04,060
And then he said like that's a good suggestion,

1355
01:11:04,140 --> 01:11:06,380
but we don't have that in the near future,

1356
01:11:06,380 --> 01:11:08,540
so please be patient.

1357
01:11:08,540 --> 01:11:10,820
Or you can start contributing if you want

1358
01:11:10,820 --> 01:11:12,220
to solve that problem.

1359
01:11:12,220 --> 01:11:16,020
So yeah, so now actually other people's already having break,

1360
01:11:16,020 --> 01:11:20,820
so let's have a break until 1130 when, no, sorry, sorry, sorry,

1361
01:11:20,820 --> 01:11:23,700
sorry, wrong, 11 where everybody finished their break

1362
01:11:23,700 --> 01:11:25,900
and you also come back at 11.

1363
01:11:25,900 --> 01:11:28,700
It's like okay, good, yeah, okay, so.

1364
01:11:28,700 --> 01:11:31,540
Though you can meet up with your friend in another tutorial,

1365
01:11:31,540 --> 01:11:33,420
they may be having coffee outside, you know,

1366
01:11:33,740 --> 01:11:35,780
some cookie, I don't know what they have outside,

1367
01:11:35,780 --> 01:11:40,780
but come back at 11 and then we will finish the second part

1368
01:11:40,780 --> 01:11:42,100
of the tutorial.

1369
01:11:42,100 --> 01:11:48,700
Okay, it's about time we come back to the zone.

1370
01:11:48,700 --> 01:11:52,660
So before I started, again, I want to do a survey,

1371
01:11:52,660 --> 01:11:55,340
but this survey is irrelevant this time.

1372
01:11:55,340 --> 01:11:59,100
It's who has done this tutorial actually?

1373
01:11:59,100 --> 01:12:01,100
This tutorial, by the way, is actually

1374
01:12:01,140 --> 01:12:04,060
from the NumPy documentation.

1375
01:12:04,060 --> 01:12:07,580
It's about how to build a newer network from scratch

1376
01:12:07,580 --> 01:12:10,740
to distinguish the MNIST data set,

1377
01:12:10,740 --> 01:12:12,820
which is the handwritten digits.

1378
01:12:12,820 --> 01:12:15,220
Who has done this before?

1379
01:12:15,220 --> 01:12:16,540
One person.

1380
01:12:16,540 --> 01:12:21,100
Oh my God, you would be very fast ahead of us,

1381
01:12:21,100 --> 01:12:25,660
but who have actually maybe seen this but haven't really go

1382
01:12:25,660 --> 01:12:27,820
into detail about this before?

1383
01:12:27,820 --> 01:12:29,620
A few of you, okay.

1384
01:12:29,660 --> 01:12:34,060
So since the majority of people hasn't done this before,

1385
01:12:34,060 --> 01:12:38,500
I think what I'm going to do is I'm going to give you how much time,

1386
01:12:38,500 --> 01:12:42,380
maybe 20 minutes to go through this,

1387
01:12:42,380 --> 01:12:48,220
and then I will spend some time just like speed run this, you know,

1388
01:12:48,220 --> 01:12:51,380
so that we can make sure everybody's on the same page.

1389
01:12:51,380 --> 01:12:54,260
But I'm sorry for people who already have done it before,

1390
01:12:54,260 --> 01:12:58,220
already know you can already, like maybe you can read it again just

1391
01:12:58,260 --> 01:13:01,380
to like refresh your memory, and then you can move on to 3.2.

1392
01:13:01,380 --> 01:13:03,740
But otherwise, for the majority of people,

1393
01:13:03,740 --> 01:13:08,020
I will give you 20 minutes to go through this tutorial.

1394
01:13:08,020 --> 01:13:10,580
It's very good explanation there.

1395
01:13:10,580 --> 01:13:12,580
Just like I think understanding what's going

1396
01:13:12,580 --> 01:13:14,380
on will help you in the next exercise.

1397
01:13:14,380 --> 01:13:16,740
That's why I think it's worth spending some time to do it,

1398
01:13:16,740 --> 01:13:19,420
especially also loading the data as well.

1399
01:13:19,420 --> 01:13:24,780
So yeah, spend some time on this, and then I would do a sum

1400
01:13:24,980 --> 01:13:26,860
up and explanation right after.

1401
01:13:26,860 --> 01:13:30,380
But I will let you try it yourself first.

1402
01:13:30,380 --> 01:13:33,780
Okay? So it's about time.

1403
01:13:33,780 --> 01:13:36,940
So I know that people are at different places,

1404
01:13:36,940 --> 01:13:40,300
but unfortunately we have to finish the workshop.

1405
01:13:40,300 --> 01:13:43,340
So what I'm going to do is I'm going to go through this quickly.

1406
01:13:43,340 --> 01:13:45,620
I will point out a few things that we have to take note,

1407
01:13:45,620 --> 01:13:48,700
but I won't explain all the detail of the mathematic and how,

1408
01:13:48,700 --> 01:13:51,660
you know, back, you know, the forward propagation back.

1409
01:13:51,660 --> 01:13:53,940
I won't explain that because that will take a course

1410
01:13:53,980 --> 01:13:56,260
to understand the neural network.

1411
01:13:56,260 --> 01:13:59,740
So yeah, for those of you who are really interested

1412
01:13:59,740 --> 01:14:01,040
but you don't have the time to finish,

1413
01:14:01,040 --> 01:14:02,420
you can always come back to do this.

1414
01:14:02,420 --> 01:14:05,220
I think this is really good and very good explanation.

1415
01:14:05,220 --> 01:14:08,180
And even though like maybe you haven't heard

1416
01:14:08,180 --> 01:14:10,500
about machine learning and like, you know, network,

1417
01:14:10,500 --> 01:14:13,180
neural network and want to learn more, there's also online courses

1418
01:14:13,180 --> 01:14:14,460
that you can do as well.

1419
01:14:14,460 --> 01:14:18,100
So this graph explains how it works.

1420
01:14:18,100 --> 01:14:20,060
So it would be, you know, there's a hidden layer

1421
01:14:20,060 --> 01:14:22,460
which is just matrix, and then there would be like, you know,

1422
01:14:22,540 --> 01:14:25,980
there's a loop, so because every time you would calculate how much,

1423
01:14:25,980 --> 01:14:28,820
like how far off the prediction is and then we try to improve

1424
01:14:28,820 --> 01:14:32,300
itself by doing this forward and backward propagation thing,

1425
01:14:32,300 --> 01:14:36,580
which is some mathematic steps, which I won't go into the detail.

1426
01:14:36,580 --> 01:14:39,620
So this also, I hope you already have the library

1427
01:14:39,620 --> 01:14:41,500
so it's not a problem.

1428
01:14:41,500 --> 01:14:45,900
And then the NS data set, like I said, is a head-wintered digit

1429
01:14:45,900 --> 01:14:50,060
so they're back and white images or grayscale images.

1430
01:14:50,060 --> 01:14:54,940
So how an image works is basically, you know,

1431
01:14:54,940 --> 01:14:56,860
if you see it on the screen, it's a picture, but actually,

1432
01:14:56,860 --> 01:14:59,900
if you, you know, look inside how big they are, you know,

1433
01:14:59,900 --> 01:15:04,780
you pixelated, you know, because each pixel is actually a value.

1434
01:15:04,780 --> 01:15:08,700
So for grayscale image, actually, it's just showing

1435
01:15:08,700 --> 01:15:12,860
that how dark maybe like, you know, 0, 0, 0 is black and then

1436
01:15:12,860 --> 01:15:16,740
if it's like 2, 5, it's white.

1437
01:15:16,780 --> 01:15:20,020
So it's just how dark that pixel is.

1438
01:15:20,020 --> 01:15:22,860
So that's how we interpret the image.

1439
01:15:22,860 --> 01:15:25,100
So they are all like kind of, you can download them online

1440
01:15:25,100 --> 01:15:26,420
and stuff so it's using requests

1441
01:15:26,420 --> 01:15:28,740
to grab them somewhere on the internet.

1442
01:15:28,740 --> 01:15:30,460
So if you don't have good connection,

1443
01:15:30,460 --> 01:15:32,300
it will take you a while.

1444
01:15:32,300 --> 01:15:35,620
So yeah, it's just all this technical stuff and then

1445
01:15:35,620 --> 01:15:37,700
after that, then you have that image.

1446
01:15:37,700 --> 01:15:40,460
So if you draw it on the screen, it's kind of like that,

1447
01:15:40,460 --> 01:15:42,500
it's pixelated again, like each value kind

1448
01:15:42,500 --> 01:15:44,980
of represent how dark this pixel is.

1449
01:15:45,020 --> 01:15:48,980
So these are all zeros and this one probably 255,

1450
01:15:48,980 --> 01:15:50,300
something like that.

1451
01:15:50,300 --> 01:15:53,700
So all of them are actually like pictures,

1452
01:15:53,700 --> 01:15:55,060
they're handwritten image.

1453
01:15:55,060 --> 01:15:58,420
So the goal is to see if we can build a new network,

1454
01:15:58,420 --> 01:16:01,020
which is kind of very basic form of AI,

1455
01:16:01,020 --> 01:16:04,140
to see if we can determine this is a 3, this is an 8,

1456
01:16:04,140 --> 01:16:06,060
we can do it perfectly, right, as a human,

1457
01:16:06,060 --> 01:16:09,100
but can a computer see this?

1458
01:16:09,100 --> 01:16:12,740
So this is again just showing the image

1459
01:16:12,820 --> 01:16:14,500
and because image is just again,

1460
01:16:14,500 --> 01:16:17,100
just a matrix of numbers like this.

1461
01:16:17,100 --> 01:16:19,660
So yeah, it's just a bunch of values.

1462
01:16:19,660 --> 01:16:22,420
At this stage, this is integer so that you can see

1463
01:16:22,420 --> 01:16:24,700
that now we do some processing,

1464
01:16:24,700 --> 01:16:28,360
which like convert the integer into float.

1465
01:16:28,360 --> 01:16:31,300
So this is a point that you have to maybe put a mental note

1466
01:16:31,300 --> 01:16:35,060
in your mind that oh, all these will be floating numbers

1467
01:16:35,060 --> 01:16:37,340
so we know the data type, right, so it may help you

1468
01:16:37,340 --> 01:16:40,780
when you try to use compiling.

1469
01:16:40,940 --> 01:16:45,620
So now they are kind of, we call them normalized,

1470
01:16:45,620 --> 01:16:49,860
which is like from, because originally it's 0 to 255,

1471
01:16:49,860 --> 01:16:53,780
now it's divided by 255, so it becomes 0 to 1,

1472
01:16:53,780 --> 01:16:55,340
so we kind of compress the range

1473
01:16:55,340 --> 01:16:57,500
and they become floating point numbers.

1474
01:16:57,500 --> 01:17:00,940
So similar thing happened with the results.

1475
01:17:00,940 --> 01:17:02,820
So the result we do one-hot encoding,

1476
01:17:02,820 --> 01:17:05,140
which means that it will be a vector.

1477
01:17:05,140 --> 01:17:07,260
So if it's 1 and then all 0,

1478
01:17:07,260 --> 01:17:10,700
then it's representing the digit on the picture is 0,

1479
01:17:10,780 --> 01:17:12,580
if it's 0, 0, 0 and the last one is 1,

1480
01:17:12,580 --> 01:17:16,180
meaning that is number 9 represented the picture.

1481
01:17:16,180 --> 01:17:19,020
So this is called one-hot encoding, so which one it is.

1482
01:17:19,020 --> 01:17:21,300
So basically like if you imagine it's a checkbox,

1483
01:17:21,300 --> 01:17:23,260
which one is check, okay?

1484
01:17:24,340 --> 01:17:25,380
So that's like that.

1485
01:17:25,380 --> 01:17:27,700
It's like you see 0 and 1, all of them,

1486
01:17:27,700 --> 01:17:29,380
that's because they are one-hot encoded,

1487
01:17:29,380 --> 01:17:30,940
but because the data type need to match again,

1488
01:17:30,940 --> 01:17:33,180
they become float for some reason.

1489
01:17:33,180 --> 01:17:34,780
So you can see there's a dot there,

1490
01:17:34,780 --> 01:17:37,140
which means that they're floating point numbers.

1491
01:17:37,140 --> 01:17:42,140
So yeah, so this is the basics of what happened.

1492
01:17:42,460 --> 01:17:45,020
Now this is the scary bit, which is the neural network bit,

1493
01:17:45,020 --> 01:17:46,700
which again, if you're very interested,

1494
01:17:46,700 --> 01:17:47,900
look at this math,

1495
01:17:47,900 --> 01:17:50,660
it is neural network only have like three layers,

1496
01:17:50,660 --> 01:17:52,300
0, 1 and 2.

1497
01:17:52,300 --> 01:17:55,860
And I think that number 2 is the result

1498
01:17:55,860 --> 01:17:58,540
and you compare that with the one-hot encoding

1499
01:17:58,540 --> 01:17:59,660
and something like that.

1500
01:17:59,660 --> 01:18:01,780
I may be wrong though, you can look into the details.

1501
01:18:01,780 --> 01:18:04,860
There's also the weight that is for propagation

1502
01:18:04,860 --> 01:18:06,020
and things like that.

1503
01:18:06,020 --> 01:18:08,260
Again, we'll skip the detail for now.

1504
01:18:08,260 --> 01:18:10,540
These two actually are the functions

1505
01:18:10,540 --> 01:18:13,660
that is used quite a lot in machine learning.

1506
01:18:13,660 --> 01:18:16,780
So you will see this rather function in the spoiler,

1507
01:18:16,780 --> 01:18:19,140
you will see this rather function soon.

1508
01:18:19,140 --> 01:18:21,020
So pay attention to this.

1509
01:18:21,020 --> 01:18:24,740
This is quite an important function.

1510
01:18:24,740 --> 01:18:26,740
It's using backward propagation.

1511
01:18:27,900 --> 01:18:31,300
If you draw it on a graph, it's kind of like,

1512
01:18:31,300 --> 01:18:33,620
when it's positive, it's like this and then negative,

1513
01:18:33,620 --> 01:18:35,820
so it's like, so when it's negative,

1514
01:18:36,620 --> 01:18:38,220
it's like this, zero and then positive,

1515
01:18:38,220 --> 01:18:40,620
just like a diagonal line.

1516
01:18:40,620 --> 01:18:42,380
There's another function similar to ReLU,

1517
01:18:42,380 --> 01:18:44,420
but it's just like one and zero like this.

1518
01:18:46,140 --> 01:18:48,260
Yeah, so basically this is useful,

1519
01:18:48,260 --> 01:18:50,740
I think it's useful kind of seeing how wrong

1520
01:18:50,740 --> 01:18:51,700
or how correct you are,

1521
01:18:51,700 --> 01:18:54,180
it's useful to give feedback to your neural network

1522
01:18:54,180 --> 01:18:56,340
to correct itself, that's why it's needed.

1523
01:18:57,260 --> 01:18:59,820
So yeah, these two functions are quite tricky

1524
01:18:59,820 --> 01:19:02,100
because they are not your normal function.

1525
01:19:02,100 --> 01:19:04,820
If you know math, they are not smooth, right?

1526
01:19:04,820 --> 01:19:08,380
They are like, so, funny, funny.

1527
01:19:08,380 --> 01:19:12,500
And then we have this, these are hyperparameters.

1528
01:19:12,500 --> 01:19:14,420
You can change them when you do machine learning,

1529
01:19:14,420 --> 01:19:17,140
you can fine tune your model to make it better

1530
01:19:17,140 --> 01:19:19,020
and change it, but we won't change them,

1531
01:19:19,020 --> 01:19:20,260
we just leave it at this.

1532
01:19:21,660 --> 01:19:24,220
The wage, so this is the starting point

1533
01:19:24,220 --> 01:19:25,380
of where you start to train,

1534
01:19:25,380 --> 01:19:28,340
so this is just an initialization.

1535
01:19:28,340 --> 01:19:32,860
And then these are the steps that's doing your propagation,

1536
01:19:33,100 --> 01:19:34,780
your training the neural network.

1537
01:19:34,780 --> 01:19:39,460
So when you train a neural network, there will be loops,

1538
01:19:39,460 --> 01:19:41,820
there will be, because every time you will have a result

1539
01:19:41,820 --> 01:19:44,420
and then see, compare the results to the correct answer

1540
01:19:44,420 --> 01:19:47,500
and then you correct itself, so it's a looping thing.

1541
01:19:47,500 --> 01:19:51,060
So loops, then ah, take a mental note,

1542
01:19:51,060 --> 01:19:54,500
this may be the part that we could improve with number.

1543
01:19:54,500 --> 01:19:59,100
So yeah, and then, so originally they will print out

1544
01:19:59,100 --> 01:20:00,500
the result every single time,

1545
01:20:00,500 --> 01:20:02,180
you will see that I kind of muted it

1546
01:20:02,180 --> 01:20:05,620
when we go to the part, but I will explain more later.

1547
01:20:06,780 --> 01:20:10,340
So yeah, and then this is just plotting the progress

1548
01:20:10,340 --> 01:20:12,900
of the training, so not related to what we are trying

1549
01:20:12,900 --> 01:20:15,220
to achieve today, but if you're interested, they're there.

1550
01:20:15,220 --> 01:20:17,540
Again, this is, I'll just skip them,

1551
01:20:17,540 --> 01:20:19,140
it's for the other tutorial.

1552
01:20:19,140 --> 01:20:23,820
So basically that's that, so how are we gonna improve that?

1553
01:20:23,820 --> 01:20:27,500
So if you really want, you can change this one,

1554
01:20:27,500 --> 01:20:32,500
but I have make a simpler version for you in 3.2,

1555
01:20:32,540 --> 01:20:36,540
so I copy some of the code from the original tutorial

1556
01:20:36,540 --> 01:20:41,540
and I have put them, just delete all the explanation

1557
01:20:42,320 --> 01:20:44,740
because you have it in the other notebook already.

1558
01:20:44,740 --> 01:20:47,060
And so this is basically the same thing,

1559
01:20:47,060 --> 01:20:48,580
so first step, loading the data,

1560
01:20:48,580 --> 01:20:50,420
there's nothing much we're going to do that,

1561
01:20:50,420 --> 01:20:52,500
it's just input, output and things,

1562
01:20:52,500 --> 01:20:54,300
so we won't use number on it,

1563
01:20:54,300 --> 01:20:56,780
we just let it be whatever it is.

1564
01:20:56,820 --> 01:20:59,020
One-hot encoding, we're also not touching it this time,

1565
01:20:59,020 --> 01:21:01,020
so we'll just run it.

1566
01:21:01,020 --> 01:21:02,500
And it should be downloading something

1567
01:21:02,500 --> 01:21:04,860
on my computer right now, let's check.

1568
01:21:07,380 --> 01:21:08,400
Is it doing anything?

1569
01:21:08,400 --> 01:21:12,040
Oh, it's on the, because it's on a,

1570
01:21:13,180 --> 01:21:16,900
it's on a further dot dot slasher, you won't see it here.

1571
01:21:16,900 --> 01:21:20,100
It's somewhere, it's downloaded, I just trust it, I hope.

1572
01:21:20,100 --> 01:21:24,460
And then build and train a small neural network.

1573
01:21:24,460 --> 01:21:27,060
So this is the bit that is doing the training,

1574
01:21:27,060 --> 01:21:29,900
so this looks familiar but it's different.

1575
01:21:29,900 --> 01:21:32,940
So, oh, also I forgot to mention one thing here.

1576
01:21:34,020 --> 01:21:36,340
One second, let me find that, that's quite important,

1577
01:21:36,340 --> 01:21:37,900
but I forgot where I put that.

1578
01:21:41,700 --> 01:21:45,460
Oh yeah, so the original tutorial there,

1579
01:21:45,460 --> 01:21:47,700
if you have go through them already,

1580
01:21:47,700 --> 01:21:52,700
then they are using only a thousand examples

1581
01:21:53,020 --> 01:21:53,860
in their training.

1582
01:21:53,860 --> 01:21:57,060
Actually this one is very fast when you go through them

1583
01:21:57,060 --> 01:22:00,140
because they only use a small sample size.

1584
01:22:00,140 --> 01:22:01,820
So practically, a lot of times,

1585
01:22:01,820 --> 01:22:03,860
when you train a more sophisticated neural network,

1586
01:22:03,860 --> 01:22:08,240
you will want to use more pictures and more images.

1587
01:22:08,240 --> 01:22:10,740
So to make it more challenging for us,

1588
01:22:10,740 --> 01:22:14,380
to basically making the algorithm not run too fast

1589
01:22:14,380 --> 01:22:17,860
so we can't improve it, I have put more data in it,

1590
01:22:17,860 --> 01:22:20,260
I think I put 5,000 somewhere here,

1591
01:22:20,260 --> 01:22:22,140
you can change it if it's too slow for you,

1592
01:22:22,380 --> 01:22:23,340
yeah, here, 5,000.

1593
01:22:23,340 --> 01:22:26,980
So if you want to just give it a try first,

1594
01:22:26,980 --> 01:22:28,660
you don't want to make it too slow,

1595
01:22:28,660 --> 01:22:31,300
you can change it back to 1,000,

1596
01:22:31,300 --> 01:22:33,900
but I will start with 5,000 for now.

1597
01:22:33,900 --> 01:22:38,020
So yeah, just the sample size of the front.

1598
01:22:38,020 --> 01:22:43,020
Here, this is where the machine learning thing works

1599
01:22:44,200 --> 01:22:49,220
and I'm not touching this, I'm just copying them

1600
01:22:49,220 --> 01:22:51,060
and then making it into a new function.

1601
01:22:51,100 --> 01:22:54,740
So you can see this code is different from the tutorial,

1602
01:22:54,740 --> 01:22:57,940
I have made a new class and then I have put all these

1603
01:22:57,940 --> 01:23:00,180
forward propagation as a separate method,

1604
01:23:00,180 --> 01:23:01,740
backward propagation as a separate method,

1605
01:23:01,740 --> 01:23:04,020
you will see why very soon.

1606
01:23:04,020 --> 01:23:08,740
It's kind of because, well, I will just explain myself,

1607
01:23:08,740 --> 01:23:12,260
because you see that this process is just in a loop, right?

1608
01:23:12,260 --> 01:23:13,860
It's not in a function.

1609
01:23:13,860 --> 01:23:16,180
If it's not in a function, we can't apply the JIT

1610
01:23:16,180 --> 01:23:20,060
and ENGIN decorator, we can't apply it to a for loop.

1611
01:23:20,100 --> 01:23:23,740
So we have to write it into a function.

1612
01:23:23,740 --> 01:23:26,580
And just for the ease of passing all these layers

1613
01:23:26,580 --> 01:23:29,300
and variables, these need to be passed

1614
01:23:29,300 --> 01:23:31,100
between these various functions,

1615
01:23:31,100 --> 01:23:33,380
so I create a class for it.

1616
01:23:33,380 --> 01:23:35,940
So this weight and all these like layers,

1617
01:23:35,940 --> 01:23:38,700
very of the layers, they need to preserve

1618
01:23:38,700 --> 01:23:41,580
during the training, so I put them in as a class.

1619
01:23:42,500 --> 01:23:45,140
That's the main reason why it's written like that.

1620
01:23:45,140 --> 01:23:47,140
They're doing the same thing, trust me,

1621
01:23:47,140 --> 01:23:49,940
I've tracked the result, cross-tracked the result before.

1622
01:23:50,620 --> 01:23:53,820
So if you encounter anything weird, let me know.

1623
01:23:55,900 --> 01:23:58,060
So they are all kind of structure,

1624
01:23:58,060 --> 01:23:59,580
it's a very good start for you,

1625
01:23:59,580 --> 01:24:02,380
if you want to use JIT and ENGIN, it's already done for you,

1626
01:24:02,380 --> 01:24:04,940
so you can start attacking them right away.

1627
01:24:04,940 --> 01:24:07,460
But before we attack them, we want to do profiling.

1628
01:24:07,460 --> 01:24:10,340
There's another name in the title, right?

1629
01:24:10,340 --> 01:24:13,020
So now we are doing some profiling.

1630
01:24:13,020 --> 01:24:17,820
So how we do profiling, we use the very basic C profile

1631
01:24:17,820 --> 01:24:20,780
to do that, like I said, there's a lot of profiler

1632
01:24:20,780 --> 01:24:23,980
available out there, if you have another favorite,

1633
01:24:23,980 --> 01:24:26,260
then please don't be shy and use it,

1634
01:24:26,260 --> 01:24:29,020
but I'm just using what comes with CPython.

1635
01:24:30,900 --> 01:24:33,260
So here we are trying to do some profiling.

1636
01:24:33,260 --> 01:24:34,180
Have I run the code before?

1637
01:24:34,180 --> 01:24:36,060
I think I haven't run the code before, let me run this.

1638
01:24:36,060 --> 01:24:39,300
Okay, so it will take some time,

1639
01:24:39,300 --> 01:24:42,220
again, because I've upped the size of the sample.

1640
01:24:42,220 --> 01:24:46,460
So this is kind of standard how you do it,

1641
01:24:46,460 --> 01:24:50,460
but notice that, so okay, a few things to notice here.

1642
01:24:50,460 --> 01:24:55,060
So when profile.enable, it will start profiling.

1643
01:24:55,060 --> 01:24:56,700
Profile.disable, so basically it's that

1644
01:24:56,700 --> 01:24:58,660
and end of the profiling process.

1645
01:24:58,660 --> 01:25:01,340
So between these two is what I want to profile,

1646
01:25:01,340 --> 01:25:06,340
so this one is, you know, how I, you know, the training.

1647
01:25:07,260 --> 01:25:09,540
So I want to see all these different things going on

1648
01:25:09,540 --> 01:25:10,860
in the training.

1649
01:25:10,860 --> 01:25:12,940
And you are also, by looking at this,

1650
01:25:12,980 --> 01:25:16,740
you will also see why I put them into different methods

1651
01:25:16,740 --> 01:25:19,100
or functions like before.

1652
01:25:19,100 --> 01:25:20,780
I will show you in a bit.

1653
01:25:20,780 --> 01:25:22,660
But you will see that the statistic,

1654
01:25:22,660 --> 01:25:26,700
how we display them, you can change it a little bit

1655
01:25:26,700 --> 01:25:30,300
to play around, but what I do is I would sort them

1656
01:25:30,300 --> 01:25:31,900
according to accumulated time.

1657
01:25:32,780 --> 01:25:36,100
They are different things you can sort them with.

1658
01:25:36,100 --> 01:25:38,580
You can sort them with how many times they're called,

1659
01:25:38,620 --> 01:25:43,620
how many total times they are, they have been spent

1660
01:25:44,940 --> 01:25:48,700
to execute all these like different things you can use,

1661
01:25:48,700 --> 01:25:50,740
but I would use accumulated time.

1662
01:25:50,740 --> 01:25:51,900
Feel free to change it.

1663
01:25:51,900 --> 01:25:52,900
It's yours now.

1664
01:25:52,900 --> 01:25:53,860
It's your experiment.

1665
01:25:53,860 --> 01:25:55,260
You can play around with it.

1666
01:25:56,620 --> 01:25:59,300
So this looks a bit scary.

1667
01:26:00,340 --> 01:26:04,380
It's just because, you know, all this code are stored

1668
01:26:04,380 --> 01:26:07,500
in a very funny place because of how iPython, you know,

1669
01:26:07,580 --> 01:26:10,180
Jupyter notebook work, but what I would do normally

1670
01:26:10,180 --> 01:26:12,260
is just look at the end of it.

1671
01:26:12,260 --> 01:26:15,380
Usually it would just like have the name of the function,

1672
01:26:15,380 --> 01:26:18,380
for example, a module is just module, but train.

1673
01:26:18,380 --> 01:26:19,860
So train is the biggest one, right?

1674
01:26:19,860 --> 01:26:22,100
So of course it's taking the most time

1675
01:26:22,100 --> 01:26:24,100
because it's the matter of everything.

1676
01:26:24,100 --> 01:26:25,820
So everything run inside it.

1677
01:26:25,820 --> 01:26:27,500
So it's taking the most time.

1678
01:26:27,500 --> 01:26:30,900
But if you look at this, you can see the back propagation,

1679
01:26:30,900 --> 01:26:33,900
actually it's here, forward propagation is here.

1680
01:26:33,900 --> 01:26:38,060
So if you compare accumulated time of the backward

1681
01:26:38,060 --> 01:26:40,660
and forward propagation, you will see that backward

1682
01:26:40,660 --> 01:26:44,860
actually costs more, even though they are run at,

1683
01:26:44,860 --> 01:26:48,060
oh, actually this one, oh no, yeah.

1684
01:26:48,060 --> 01:26:49,860
They are both run how many times?

1685
01:26:49,860 --> 01:26:50,820
It's a bit difficult to see.

1686
01:26:50,820 --> 01:26:53,100
So yeah, this is the time they have been called.

1687
01:26:53,100 --> 01:26:56,820
So they have been called at the equivalent.

1688
01:26:56,820 --> 01:27:00,860
So number of times, this is like how many,

1689
01:27:00,900 --> 01:27:03,060
it's like a hundred thousand times,

1690
01:27:03,060 --> 01:27:04,700
both back and forward prop,

1691
01:27:04,700 --> 01:27:07,340
but the backward prop costs a little bit more time

1692
01:27:07,340 --> 01:27:10,700
because of the process costs a little bit more time.

1693
01:27:10,700 --> 01:27:13,100
There are also, of course, these have built in things

1694
01:27:13,100 --> 01:27:15,140
that you can't really do much about it,

1695
01:27:15,140 --> 01:27:17,740
but try to look for these ones that you name

1696
01:27:17,740 --> 01:27:21,060
and define yourself, then you'll have a better idea.

1697
01:27:21,060 --> 01:27:23,540
You can compare them to see which one get called more times,

1698
01:27:23,540 --> 01:27:27,340
which one is taking more time and all these things.

1699
01:27:27,340 --> 01:27:29,140
If you want, you can also break this up more.

1700
01:27:29,180 --> 01:27:34,300
This is, again, like I said, a starting point for you to compare

1701
01:27:34,300 --> 01:27:37,020
and try to break things down to investigate

1702
01:27:37,020 --> 01:27:40,980
which one actually costs the most time and where to attack it

1703
01:27:40,980 --> 01:27:44,940
to reduce the time that it took.

1704
01:27:44,940 --> 01:27:50,060
So yeah, so if you want, you can also like, oh,

1705
01:27:50,060 --> 01:27:51,820
maybe break down these steps a little bit more

1706
01:27:51,820 --> 01:27:56,380
so you can maybe see better or maybe later when you use JIT

1707
01:27:56,380 --> 01:27:58,820
or NJIT, then you can have a more detailed control

1708
01:27:58,900 --> 01:28:01,100
of what you are compiling.

1709
01:28:01,100 --> 01:28:05,620
So this is how it works and how you interpret it, right?

1710
01:28:05,620 --> 01:28:10,780
So it's just a very, you know, cover the basic of profiling.

1711
01:28:10,780 --> 01:28:16,460
Again, it looks a bit scary, but look for the ones that you define

1712
01:28:16,460 --> 01:28:19,100
and look for the time, which one costs more time,

1713
01:28:19,100 --> 01:28:23,660
then maybe that one you should worry more about.

1714
01:28:23,660 --> 01:28:25,060
So after that is your time.

1715
01:28:25,060 --> 01:28:27,260
So now I have add to do here,

1716
01:28:27,300 --> 01:28:28,780
which means that I haven't done anything yet,

1717
01:28:28,780 --> 01:28:30,740
so it's your time to do things.

1718
01:28:30,740 --> 01:28:36,780
I created another class just to, so they don't overlap each other.

1719
01:28:36,780 --> 01:28:40,540
So within that, again, you can change stuff.

1720
01:28:40,540 --> 01:28:45,380
You can decide which one you want to use the decoration.

1721
01:28:45,380 --> 01:28:48,660
You can choose JIT or NJIT.

1722
01:28:48,660 --> 01:28:53,900
Well, if you, I would say that try NJIT and see which doesn't work,

1723
01:28:53,940 --> 01:28:57,940
then you can use JIT, but then I would challenge all of you

1724
01:28:57,940 --> 01:29:00,140
to try to just use NJIT.

1725
01:29:00,140 --> 01:29:04,060
Maybe it will take you a week or a month, but you don't have

1726
01:29:04,060 --> 01:29:05,740
to do it today, you just get a taste.

1727
01:29:05,740 --> 01:29:08,220
Try to try your best to see how much you can improve

1728
01:29:08,220 --> 01:29:09,820
and then we'll profile it again.

1729
01:29:09,820 --> 01:29:11,700
Then you can compare the process,

1730
01:29:11,700 --> 01:29:14,700
like how much improvement you got compared to the first one

1731
01:29:14,700 --> 01:29:19,300
when you profile, or does it really, you know,

1732
01:29:19,300 --> 01:29:22,980
worth the effort to rewrite it and make it faster,

1733
01:29:23,060 --> 01:29:25,060
how fast you can go.

1734
01:29:25,060 --> 01:29:26,580
So yeah, all of them are open questions,

1735
01:29:26,580 --> 01:29:28,420
so it's now your time to try it.

1736
01:29:28,420 --> 01:29:31,900
At the end, I put the rest of the code in one cell

1737
01:29:31,900 --> 01:29:35,500
so you can compare the result with the previous one.

1738
01:29:35,500 --> 01:29:37,620
You can see that the neural network is not very good

1739
01:29:37,620 --> 01:29:40,460
if you use a huge amount of sample.

1740
01:29:40,460 --> 01:29:44,180
You know, the original tutorial have optimized everything,

1741
01:29:44,180 --> 01:29:48,860
but yeah, you can change the sample size for your liking

1742
01:29:48,860 --> 01:29:52,300
and just to see which one can make it faster.

1743
01:29:52,340 --> 01:29:55,300
So to have a better result, so you may wonder, like, oh,

1744
01:29:55,300 --> 01:29:57,580
how can I get better results with more samples?

1745
01:29:57,580 --> 01:29:59,220
You may have to change the hyperparameters,

1746
01:29:59,220 --> 01:30:02,420
so that bit I won't go into detail because we are here

1747
01:30:02,420 --> 01:30:04,660
to make it faster, not to make it more accurate.

1748
01:30:04,660 --> 01:30:06,660
Well, ideally you want to make it more accurate as well,

1749
01:30:06,660 --> 01:30:08,260
but then you have to put another effort

1750
01:30:08,260 --> 01:30:10,340
to change the hyperparameters.

1751
01:30:10,340 --> 01:30:15,980
So yeah, so now is a free time to try and do stuff,

1752
01:30:15,980 --> 01:30:19,220
ask questions if you want, if you already kind of talk

1753
01:30:19,220 --> 01:30:20,700
to your neighbor, you have make friends,

1754
01:30:20,700 --> 01:30:23,500
then you can work together maybe.

1755
01:30:23,500 --> 01:30:25,300
So now how much time we have?

1756
01:30:25,300 --> 01:30:28,620
We have around, so slightly shined, then an hour,

1757
01:30:28,620 --> 01:30:29,900
so you have plenty of time.

1758
01:30:29,900 --> 01:30:31,220
Try to challenge yourself.

1759
01:30:31,220 --> 01:30:35,220
This is your hands-on exercise bit and ask questions.

1760
01:30:40,060 --> 01:30:44,740
So we have around 15 minutes until the end of the tutorial.

1761
01:30:44,740 --> 01:30:47,100
You, of course, feel free to stay and then work

1762
01:30:47,100 --> 01:30:48,620
to the very, very end.

1763
01:30:48,660 --> 01:30:49,980
Or if you have questions,

1764
01:30:49,980 --> 01:30:52,460
this is your last chance, ask me questions.

1765
01:30:52,460 --> 01:30:55,180
But if you, for example, have questions in the future,

1766
01:30:55,180 --> 01:30:57,860
my DM on Twitter is open or you can find me on LinkedIn

1767
01:30:57,860 --> 01:31:00,500
and drop me a message and I would genuinely,

1768
01:31:00,500 --> 01:31:02,380
if I can help, I will help you.

1769
01:31:02,380 --> 01:31:05,580
But sometimes, you know, I may have to direct your questions

1770
01:31:05,580 --> 01:31:08,500
or if you can have a very clear question,

1771
01:31:08,500 --> 01:31:13,260
then I can just put it directly to someone who can help you.

1772
01:31:13,260 --> 01:31:18,380
So, you know, here's my contact and also the other thing I want

1773
01:31:18,420 --> 01:31:22,540
to tell you is EuroPython, which is, again, maybe not as big

1774
01:31:22,540 --> 01:31:25,780
as PyCon US, but also quite big conference in Europe.

1775
01:31:25,780 --> 01:31:29,860
There will be other maintainer, other developers there

1776
01:31:29,860 --> 01:31:31,180
that you can meet.

1777
01:31:31,180 --> 01:31:35,100
If you are based in Europe or if you are, you know,

1778
01:31:35,100 --> 01:31:37,340
want an excuse to go to Europe, this is your chance.

1779
01:31:37,340 --> 01:31:38,780
It's going to be somewhere in Prague.

1780
01:31:38,780 --> 01:31:41,460
It's going to be a very nice place to be.

1781
01:31:41,460 --> 01:31:43,500
You know, it's beautiful.

1782
01:31:43,500 --> 01:31:47,380
So I think that's it from me.

1783
01:31:47,420 --> 01:31:50,900
Also, one last thing, since you know I work for Alaconda,

1784
01:31:50,900 --> 01:31:52,200
we'll have a booth.

1785
01:31:52,200 --> 01:31:55,580
The opening will be later today, so please stay around and,

1786
01:31:55,580 --> 01:31:56,880
you know, come to our booth.

1787
01:31:56,880 --> 01:31:58,180
We'll have demonstration.

1788
01:31:58,180 --> 01:31:59,480
We'll have Pyscript people there.

1789
01:31:59,480 --> 01:32:00,780
We'll have Condor people there.

1790
01:32:00,780 --> 01:32:03,220
We'll have people who also show you how

1791
01:32:03,220 --> 01:32:05,620
to do your data science work on the cloud and things like that.

1792
01:32:05,620 --> 01:32:07,860
So please come and have a look.

1793
01:32:07,860 --> 01:32:09,180
I may be there as well.

1794
01:32:09,180 --> 01:32:12,700
So I hope you enjoy the rest of the conference.

1795
01:32:12,700 --> 01:32:14,420
And it's not the end.

1796
01:32:14,420 --> 01:32:15,720
You can still ask me questions.

1797
01:32:15,880 --> 01:32:17,640
I'm just going to announce it in case some people want

1798
01:32:17,640 --> 01:32:18,920
to leave earlier.

1799
01:32:18,920 --> 01:32:20,320
Thank you so much for coming.

1800
01:32:20,320 --> 01:32:23,320
Oh, by the way, they may also ask you a questionnaire

1801
01:32:23,320 --> 01:32:24,620
to give me feedback.

1802
01:32:24,620 --> 01:32:26,160
So all the feedback are very welcome.

1803
01:32:26,160 --> 01:32:28,320
But if you don't like anything,

1804
01:32:28,320 --> 01:32:31,000
could you please maybe mention a small thing that you like?

1805
01:32:31,000 --> 01:32:34,920
So it's not just like last year the questionnaire was quite,

1806
01:32:34,920 --> 01:32:37,080
you know, people are very honest.

1807
01:32:37,080 --> 01:32:41,000
So yeah, I welcome feedback, but if you, you know,

1808
01:32:41,000 --> 01:32:42,800
think that's something I have to improve,

1809
01:32:42,800 --> 01:32:45,040
maybe mention a small thing that you like first

1810
01:32:45,120 --> 01:32:47,920
to make me feel better, that would make me feel happier.

1811
01:32:47,920 --> 01:32:50,280
But anyway, thank you so much for coming.

1812
01:32:50,280 --> 01:32:53,760
And I'll be here answering your questions till the very end.

1813
01:32:53,760 --> 01:32:55,060
So thank you.

1814
01:32:55,060 --> 01:32:57,360
Thank you.

1815
01:32:57,360 --> 01:32:59,160
Thank you.

1816
01:32:59,160 --> 01:33:00,960
Thank you.

1817
01:33:00,960 --> 01:33:02,260
Thank you.

