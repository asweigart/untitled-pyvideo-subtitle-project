1
00:00:00,000 --> 00:00:05,000
Hello, welcome everyone to our second talk today.

2
00:00:05,000 --> 00:00:08,000
So our next speaker is Chitin Ho.

3
00:00:08,000 --> 00:00:11,000
She will be giving a talk on kind of

4
00:00:11,000 --> 00:00:14,000
trying to deal with scientific programming.

5
00:00:14,000 --> 00:00:16,000
So please welcome her to the stage.

6
00:00:16,000 --> 00:00:18,000
Thank you.

7
00:00:18,000 --> 00:00:30,000
My computer is leaking so I have to wait.

8
00:00:30,000 --> 00:00:33,000
Right.

9
00:00:33,000 --> 00:00:34,000
Hello everyone.

10
00:00:34,000 --> 00:00:36,000
So thank you so much for coming to my talk.

11
00:00:36,000 --> 00:00:38,000
I know it's the last talk of today,

12
00:00:38,000 --> 00:00:40,000
excluding the last talk.

13
00:00:40,000 --> 00:00:42,000
You may be very tired.

14
00:00:42,000 --> 00:00:45,000
But I feel that if you are here,

15
00:00:45,000 --> 00:00:47,000
then you must have some questions in your mind

16
00:00:47,000 --> 00:00:49,000
that you want to clear up.

17
00:00:49,000 --> 00:00:52,000
And maybe scientific programming is your thing.

18
00:00:52,000 --> 00:00:54,000
That's why you're interested in it.

19
00:00:54,000 --> 00:00:56,000
Or maybe you want to understand more about GIL.

20
00:00:56,000 --> 00:00:58,000
That's why you're here.

21
00:00:58,000 --> 00:00:59,000
Or GIL or GIL.

22
00:00:59,000 --> 00:01:00,000
I don't know how you pronounce it.

23
00:01:00,000 --> 00:01:01,000
GIL.

24
00:01:01,000 --> 00:01:02,000
GIL.

25
00:01:02,000 --> 00:01:03,000
You prefer GIL?

26
00:01:03,000 --> 00:01:04,000
Okay.

27
00:01:04,000 --> 00:01:08,000
So I usually would say the first slide

28
00:01:08,000 --> 00:01:11,000
is usually the most important slide of the whole slide deck.

29
00:01:11,000 --> 00:01:13,000
Because you have the link to the slide deck.

30
00:01:13,000 --> 00:01:15,000
So once you have this slide,

31
00:01:15,000 --> 00:01:17,000
you have the rest of the slide deck.

32
00:01:17,000 --> 00:01:21,000
So let's talk about GIL.

33
00:01:21,000 --> 00:01:23,000
So you know,

34
00:01:23,000 --> 00:01:25,000
that's why it's so difficult to pronounce it

35
00:01:25,000 --> 00:01:29,000
because it's actually the first letter of a term.

36
00:01:29,000 --> 00:01:32,000
So who knows what this term is?

37
00:01:32,000 --> 00:01:33,000
Ooh, a lot of you.

38
00:01:33,000 --> 00:01:35,000
I feel like I don't have to explain so much.

39
00:01:35,000 --> 00:01:39,000
But can you shout out to me?

40
00:01:39,000 --> 00:01:41,000
Yes, it's a GoPro interpreter lock.

41
00:01:41,000 --> 00:01:45,000
But before that, I'm going to tell you about me first.

42
00:01:45,000 --> 00:01:46,000
I'm Hyt.

43
00:01:46,000 --> 00:01:47,000
I work for Alaconda.

44
00:01:47,000 --> 00:01:49,000
And I love open source projects.

45
00:01:49,000 --> 00:01:51,000
In the past, I was involved in different open source projects.

46
00:01:51,000 --> 00:01:53,000
And I love community.

47
00:01:53,000 --> 00:01:55,000
I love conferences.

48
00:01:55,000 --> 00:01:57,000
That's why I'm always trying to be there

49
00:01:57,000 --> 00:01:59,000
and connect with you all.

50
00:01:59,000 --> 00:02:01,000
And I also help organize some of them as well.

51
00:02:01,000 --> 00:02:03,000
So GIL.

52
00:02:03,000 --> 00:02:04,000
Talk about GIL.

53
00:02:04,000 --> 00:02:05,000
Global interpreter lock.

54
00:02:05,000 --> 00:02:07,000
So D-I-L.

55
00:02:07,000 --> 00:02:09,000
That's why I, again, like sometimes

56
00:02:09,000 --> 00:02:11,000
I don't know how to pronounce it.

57
00:02:11,000 --> 00:02:16,000
So, well, it's in English.

58
00:02:16,000 --> 00:02:17,000
It's global interpreter lock.

59
00:02:17,000 --> 00:02:19,000
But it doesn't explain a lot of things.

60
00:02:19,000 --> 00:02:22,000
So people who may hear this term the first time,

61
00:02:22,000 --> 00:02:24,000
like for example, like the first time I heard about it,

62
00:02:24,000 --> 00:02:27,000
I was like, can someone explain it to me please?

63
00:02:27,000 --> 00:02:31,000
So I know some of you is already like maybe you're an expert

64
00:02:31,000 --> 00:02:32,000
in the field or something.

65
00:02:32,000 --> 00:02:36,000
But for the people who are not, I will be trying to maybe

66
00:02:36,000 --> 00:02:37,000
give you some information.

67
00:02:37,000 --> 00:02:42,000
So the thing about Python, Python is very interesting.

68
00:02:42,000 --> 00:02:46,000
So Python is very user friendly, you know,

69
00:02:46,000 --> 00:02:49,000
very good for beginners and stuff.

70
00:02:49,000 --> 00:02:51,000
And also Python is very, very secure.

71
00:02:51,000 --> 00:02:55,000
One thing about Python that is Python is interpreted

72
00:02:55,000 --> 00:02:59,000
in a way that is not, just by default,

73
00:02:59,000 --> 00:03:02,000
is not doing multi-threading.

74
00:03:02,000 --> 00:03:04,000
So what does that mean?

75
00:03:04,000 --> 00:03:08,000
So because Python, by default, has this global interpreter

76
00:03:08,000 --> 00:03:13,000
lock in it, so this lock is locking that so that only one

77
00:03:13,000 --> 00:03:18,000
thread can actually access an object at a time.

78
00:03:18,000 --> 00:03:22,000
So it means that, you know, all these like kind of very

79
00:03:22,000 --> 00:03:27,000
fancy things and like, you know how many call your laptop

80
00:03:27,000 --> 00:03:28,000
has?

81
00:03:28,000 --> 00:03:32,000
Probably more than four right now.

82
00:03:32,000 --> 00:03:37,000
So, you know, because of Python's nature of having

83
00:03:37,000 --> 00:03:40,000
the global interpreter lock, no matter how many calls

84
00:03:40,000 --> 00:03:44,000
your computer has, it will be the only one that can access

85
00:03:44,000 --> 00:03:47,000
your Python object at a time.

86
00:03:47,000 --> 00:03:52,000
So what's the good thing about it is not that we are talking

87
00:03:52,000 --> 00:03:54,000
about like, oh, we want to get rid of it, of course,

88
00:03:54,000 --> 00:03:56,000
we will get to that part.

89
00:03:56,000 --> 00:04:01,000
But before that is that why Python was defined this way

90
00:04:01,000 --> 00:04:03,000
there are actually some advantages.

91
00:04:03,000 --> 00:04:06,000
One of them is being that multi-threading is something

92
00:04:06,000 --> 00:04:10,000
that's quite tricky because if we look deep down into

93
00:04:10,000 --> 00:04:15,000
things, right, look deep down into each kind of moment how

94
00:04:15,000 --> 00:04:17,000
Python, when Python is running, what's going on,

95
00:04:17,000 --> 00:04:20,000
it makes it seem like if Python doesn't have the global

96
00:04:20,000 --> 00:04:25,000
interpreter lock and two threads trying to access the same

97
00:04:25,000 --> 00:04:27,000
object at the same time, it's not a good thing.

98
00:04:27,000 --> 00:04:29,000
The computer doesn't work that way.

99
00:04:29,000 --> 00:04:33,000
So, you know, you can imagine what's going on, right?

100
00:04:33,000 --> 00:04:37,000
Imagine there's a car and there's two persons sitting,

101
00:04:37,000 --> 00:04:39,000
you know, usually one is driving, one is sitting next to

102
00:04:39,000 --> 00:04:44,000
the driver, but now if two threads, actually the same object

103
00:04:44,000 --> 00:04:48,000
is kind of like two persons is fighting over the steering wheel.

104
00:04:48,000 --> 00:04:50,000
One friend is trying to do something, turn left,

105
00:04:50,000 --> 00:04:52,000
and the other friend is trying to turn right,

106
00:04:52,000 --> 00:04:55,000
and it is like the fact that it's going to happen.

107
00:04:55,000 --> 00:04:59,000
So, that's why this global interpreter lock is a very

108
00:04:59,000 --> 00:05:03,000
simple way to solve this problem is that, you know,

109
00:05:03,000 --> 00:05:07,000
we are driving from point A to point B and we only have one

110
00:05:07,000 --> 00:05:08,000
best-amidst driver.

111
00:05:08,000 --> 00:05:11,000
We won't be doing anything fancy except because we have

112
00:05:11,000 --> 00:05:14,000
only one driver, it won't be someone who other than the

113
00:05:14,000 --> 00:05:16,000
driver touching the steering wheel.

114
00:05:16,000 --> 00:05:20,000
But of course, this is not where everything works and how

115
00:05:20,000 --> 00:05:23,000
Python works is the, you know, someone started this problem

116
00:05:23,000 --> 00:05:25,000
by using the global interpreter lock which is

117
00:05:25,000 --> 00:05:26,000
simplified things.

118
00:05:26,000 --> 00:05:29,000
But, for example, there are other programs that maybe

119
00:05:29,000 --> 00:05:30,000
support multi-threading.

120
00:05:30,000 --> 00:05:33,000
What they do is that they would actually change the driver

121
00:05:33,000 --> 00:05:35,000
in the middle of the trip.

122
00:05:35,000 --> 00:05:38,000
So, imagine you have a long trip and you sometimes, you know,

123
00:05:38,000 --> 00:05:41,000
go to service station and then there's this driver,

124
00:05:41,000 --> 00:05:44,000
that can happen, you know, I mean that is not, you know,

125
00:05:44,000 --> 00:05:47,000
it's impossible, you can only have one driver, it can happen,

126
00:05:47,000 --> 00:05:50,000
but the interpreter will be much more complicated.

127
00:05:50,000 --> 00:05:55,000
So, Python decided to, you know, release the GIL instead of

128
00:05:55,000 --> 00:05:57,000
changing driver.

129
00:05:57,000 --> 00:06:00,000
So, what is no-GIL Python?

130
00:06:00,000 --> 00:06:04,000
So, especially for this version that I talked about is a

131
00:06:04,000 --> 00:06:06,000
clone of Python 3.9.

132
00:06:06,000 --> 00:06:11,000
So, you may already feel that, well, 3.9 is ancient history.

133
00:06:11,000 --> 00:06:14,000
Now we are at which Python version?

134
00:06:14,000 --> 00:06:17,000
3.11?

135
00:06:17,000 --> 00:06:18,000
Yes.

136
00:06:18,000 --> 00:06:21,000
You know, some talk is even talking about 3.12 already.

137
00:06:21,000 --> 00:06:25,000
So, yeah, like this one I just feel like history is true.

138
00:06:25,000 --> 00:06:31,000
But, actually, you use UI and, you know, as we talk about this,

139
00:06:31,000 --> 00:06:33,000
because it's the latest attempt to remove the GIL.

140
00:06:33,000 --> 00:06:36,000
In the past, there's actually like four attempts to do that,

141
00:06:36,000 --> 00:06:37,000
right?

142
00:06:37,000 --> 00:06:40,000
We have all these very smart people, smart Python experts,

143
00:06:40,000 --> 00:06:46,000
you know, we have attempts to remove the Python GIL before.

144
00:06:46,000 --> 00:06:49,000
So, I hope that doesn't surprise you.

145
00:06:49,000 --> 00:06:52,000
Otherwise, like, oh, yeah, yeah, oh, it's true that I can't see

146
00:06:52,000 --> 00:06:53,000
you.

147
00:06:53,000 --> 00:06:54,000
I'm so sorry.

148
00:06:54,000 --> 00:06:56,000
But I will talk to you after this book.

149
00:06:56,000 --> 00:06:59,000
So, you know, they have tried many times.

150
00:06:59,000 --> 00:07:02,000
You can see like every few years someone will give it a go,

151
00:07:02,000 --> 00:07:05,000
you know, but then maybe, you know, the discussion doesn't

152
00:07:05,000 --> 00:07:06,000
carry on.

153
00:07:06,000 --> 00:07:08,000
Then, you know, someone else try again.

154
00:07:08,000 --> 00:07:11,000
And this is the latest attempt by Sam Gross.

155
00:07:11,000 --> 00:07:15,000
I heard about it actually last year in your question because

156
00:07:15,000 --> 00:07:16,000
he was giving me keynote.

157
00:07:16,000 --> 00:07:21,000
So, a lot of this information is that I'm giving it before I show

158
00:07:21,000 --> 00:07:23,000
you my experiment results.

159
00:07:23,000 --> 00:07:26,000
So, this talk actually, let me, you know, give you some

160
00:07:26,000 --> 00:07:27,000
overview.

161
00:07:27,000 --> 00:07:29,000
I'm going to give you this information that is like, you

162
00:07:29,000 --> 00:07:33,000
know, that I digest about like what I know about GIL Python,

163
00:07:33,000 --> 00:07:36,000
and then I'll show you the experiment results that I've

164
00:07:36,000 --> 00:07:37,000
done.

165
00:07:37,000 --> 00:07:41,000
So, but you may, so let's go back to the topic, right?

166
00:07:41,000 --> 00:07:45,000
Like, but why we want to give Python, well, I think, I hope

167
00:07:45,000 --> 00:07:49,000
the analysis already kind of, you know, about driving will

168
00:07:49,000 --> 00:07:53,000
give you the idea that if we have only one driver, then even

169
00:07:53,000 --> 00:07:57,000
if you, for example, you go on a trip, right, you have multiple

170
00:07:57,000 --> 00:07:58,000
drivers available.

171
00:07:58,000 --> 00:07:59,000
Everybody got a driving license.

172
00:07:59,000 --> 00:08:01,000
They're all very good drivers, you know, very good

173
00:08:01,000 --> 00:08:02,000
behavior.

174
00:08:02,000 --> 00:08:03,000
They're not drunk.

175
00:08:03,000 --> 00:08:07,000
But for some reason, right, we have like, you know, we do a

176
00:08:07,000 --> 00:08:10,000
lucky draw and someone who was destined to be a driver,

177
00:08:10,000 --> 00:08:13,000
I'm so sorry, the trip is 10 hours and you have to go, you

178
00:08:13,000 --> 00:08:16,000
know, you are the best driver and you have to drive all the

179
00:08:16,000 --> 00:08:17,000
way for 10 hours.

180
00:08:17,000 --> 00:08:18,000
This is not interesting, right?

181
00:08:18,000 --> 00:08:20,000
For example, my computer got eight cores.

182
00:08:20,000 --> 00:08:23,000
I have eight drivers, but it would be better if I can fully

183
00:08:23,000 --> 00:08:24,000
utilize, right?

184
00:08:24,000 --> 00:08:27,000
Everybody, you know, then, you know, they can, you know,

185
00:08:27,000 --> 00:08:28,000
switch.

186
00:08:28,000 --> 00:08:31,000
So maybe if with one driver, they would get exhausted, then

187
00:08:31,000 --> 00:08:33,000
they may be good slower just to be more safe.

188
00:08:33,000 --> 00:08:36,000
But if you have, you know, everybody took a turn, then

189
00:08:36,000 --> 00:08:38,000
maybe, you know, we can go very efficiently.

190
00:08:38,000 --> 00:08:41,000
So before we call, we can actually, you know, in theory,

191
00:08:41,000 --> 00:08:44,000
things will be more efficient and we can trust that we can use

192
00:08:44,000 --> 00:08:46,000
all resources from the computer.

193
00:08:46,000 --> 00:08:55,000
So, but there's, like I said, a very simple way of finding the

194
00:08:55,000 --> 00:09:00,000
gil and there's a reason why, right?

195
00:09:00,000 --> 00:09:03,000
Because this challenges, if you want to remove the gil to make

196
00:09:03,000 --> 00:09:06,000
sure that we don't have a disaster where this happens.

197
00:09:06,000 --> 00:09:12,000
So first of all, if, for example, imagine we suddenly let

198
00:09:12,000 --> 00:09:16,000
the, well, it's not happening, but imagine in a hypothetical

199
00:09:16,000 --> 00:09:20,000
scenario, 3.12 suddenly we, no gil, yay.

200
00:09:20,000 --> 00:09:25,000
Then what if, you know, someone who want to do things

201
00:09:25,000 --> 00:09:29,000
efficiently, they can go further things, then it will be very

202
00:09:29,000 --> 00:09:32,000
slow for them because it's not designed for them, it's only

203
00:09:32,000 --> 00:09:35,000
designed for others rather than the result, which I think

204
00:09:35,000 --> 00:09:37,000
the community won't be happy about it.

205
00:09:37,000 --> 00:09:42,000
So before, you know, if one day Python takes a decision to do

206
00:09:42,000 --> 00:09:46,000
it, then we, of course, need to specify all the uses that

207
00:09:46,000 --> 00:09:49,000
everybody got in a CIFT, not just create some pit of users,

208
00:09:49,000 --> 00:09:50,000
right?

209
00:09:50,000 --> 00:09:54,000
And also, all these are technical difficulties, you know,

210
00:09:54,000 --> 00:09:58,000
reference counting, you know, because before we have one driver,

211
00:09:58,000 --> 00:10:02,000
we have one person who knows the map, who knows, like, when to

212
00:10:02,000 --> 00:10:06,000
turn and stuff, all the information won't be lost because

213
00:10:06,000 --> 00:10:07,000
it's very organized.

214
00:10:07,000 --> 00:10:11,000
Imagine, like, everybody, you know, one person, they just pick

215
00:10:11,000 --> 00:10:16,000
one to drive his car and then, you know, some people are like,

216
00:10:16,000 --> 00:10:19,000
oh, you want to make sure you turn left and turn right, you know,

217
00:10:19,000 --> 00:10:20,000
and then what?

218
00:10:20,000 --> 00:10:21,000
Can you say that again?

219
00:10:21,000 --> 00:10:26,000
So when they are, like, multi-thread, sometimes, like, when

220
00:10:26,000 --> 00:10:31,000
they, you know, reference objects, so what Python is doing now is

221
00:10:31,000 --> 00:10:35,000
that, like, we would always have, you know, counting how many

222
00:10:35,000 --> 00:10:37,000
references are to an object.

223
00:10:37,000 --> 00:10:41,000
When there's no reference to this object, that means that we don't

224
00:10:41,000 --> 00:10:45,000
need it and then it's heading to, you know, kind of do some magic

225
00:10:45,000 --> 00:10:48,000
things, to do some garbage collection, to free up the memory,

226
00:10:48,000 --> 00:10:49,000
all this stuff.

227
00:10:49,000 --> 00:10:52,000
But if this reference counting got messed up, like, you know, all

228
00:10:52,000 --> 00:10:55,000
this information on the map got messed up, then we won't get to

229
00:10:55,000 --> 00:10:57,000
the destination and things will go wrong.

230
00:10:57,000 --> 00:11:03,000
So there are actually some tricks that this version of Python is

231
00:11:03,000 --> 00:11:07,000
deploying to, you know, solve this problem.

232
00:11:07,000 --> 00:11:12,000
For example, some commonly used object, if you have to kind of do

233
00:11:12,000 --> 00:11:15,000
reference counting and, you know, all these different threads have to

234
00:11:15,000 --> 00:11:18,000
share some information that's too complicated, how about we just make

235
00:11:18,000 --> 00:11:22,000
them immortal because, you know, they just stay there forever until

236
00:11:22,000 --> 00:11:25,000
we end the program and we free the memory.

237
00:11:25,000 --> 00:11:29,000
So there's no use to reference count, but because those are commonly

238
00:11:29,000 --> 00:11:34,000
used objects, right, so we won't lose out, almost because they need to

239
00:11:34,000 --> 00:11:38,000
be referenced a lot of times anyway.

240
00:11:38,000 --> 00:11:43,000
Or sometimes, like, there's a technique that was used, it's called,

241
00:11:43,000 --> 00:11:48,000
like, the third reference counting, so it's actually when doing the

242
00:11:48,000 --> 00:11:53,000
garbage collection, then some reference count will be adding back, so

243
00:11:53,000 --> 00:11:58,000
kind of, you know, we kind of, you know, after drinking and eating and

244
00:11:58,000 --> 00:12:01,000
then we kind of look at the bill and then we kind of decide, like, okay,

245
00:12:01,000 --> 00:12:05,000
how much we take, right, and at the end we kind of, you know, do the

246
00:12:05,000 --> 00:12:07,000
calculation correctly.

247
00:12:07,000 --> 00:12:12,000
So also, you know, Python objects, right, a lot of them are mutable.

248
00:12:12,000 --> 00:12:17,000
So, for example, the object that we all love, you know, it's not really

249
00:12:17,000 --> 00:12:22,000
they are actually mutable objects, so, you know, it's not a good thing

250
00:12:22,000 --> 00:12:25,000
when you have multiple threads, because, you know, again, two threads can

251
00:12:25,000 --> 00:12:28,000
change something at the same time, it's going to be very, very weird.

252
00:12:28,000 --> 00:12:33,000
So instead of having a global encoder lock to lock everything to only one

253
00:12:33,000 --> 00:12:37,000
driver, we would have a small lock, which means that, for example, the

254
00:12:37,000 --> 00:12:40,000
piece of the station on the highway, we won't take driver, right, that's

255
00:12:40,000 --> 00:12:45,000
dangerous, because, you know, you're going, like, 18 miles an hour, and

256
00:12:45,000 --> 00:12:50,000
you're going to have to use it only to train drivers at the service station.

257
00:12:50,000 --> 00:12:55,000
So here, so we use smaller lock, we lock that journey, right, being between

258
00:12:55,000 --> 00:12:58,000
service stations, we are not changing drivers, but these are smaller locks.

259
00:12:58,000 --> 00:13:01,000
So instead of the whole journey, one lock, locking one driver, it's a big

260
00:13:01,000 --> 00:13:06,000
question, we have the best way to drive it, but we can change it.

261
00:13:06,000 --> 00:13:13,000
So then it means that we have to have some change of define for key Python.

262
00:13:13,000 --> 00:13:18,000
We have to write some new Python API to, you know, increment this small lock,

263
00:13:18,000 --> 00:13:21,000
so there's the new functionality that needs to be added.

264
00:13:21,000 --> 00:13:31,000
And also, Python uses built-in memory-allocated time-alog, so for those of

265
00:13:31,000 --> 00:13:34,000
you who know, you already know I don't have to explain, but for those of you

266
00:13:34,000 --> 00:13:40,000
who doesn't know, Python has allocate memory by, you know, blocks for small

267
00:13:40,000 --> 00:13:45,000
operations and they bundle them together, this is like second boxes.

268
00:13:45,000 --> 00:13:48,000
So that works for Python right now because we have to do.

269
00:13:48,000 --> 00:13:52,000
But without it too, there's these things that need to be implemented.

270
00:13:52,000 --> 00:13:57,000
So, instead of any scheme, I have this new now lock, so it's a different kind of

271
00:13:57,000 --> 00:14:02,000
mechanism, I won't go into detail because, you know, it's very complicated.

272
00:14:02,000 --> 00:14:07,000
So all these internal stuff needs to be changed.

273
00:14:07,000 --> 00:14:13,000
And also, sometimes, you know, you have to stop the world from garbage collection

274
00:14:13,000 --> 00:14:17,000
because, you know, what if I need that and then you thought I don't need it

275
00:14:17,000 --> 00:14:23,000
because the other spread said that, oh, oh, oh, oh, okay, that's better.

276
00:14:23,000 --> 00:14:26,000
I want to lower memory, I hope it's fine.

277
00:14:26,000 --> 00:14:32,000
So yeah, you have to, sometimes, you know, because you thought I don't need that object

278
00:14:32,000 --> 00:14:35,000
to be the other spread, especially using it, the communication is wrong, so you have

279
00:14:35,000 --> 00:14:41,000
to stop the world and again, like, it's really, we don't need it, okay, we can get rid of it.

280
00:14:41,000 --> 00:14:50,000
So, so all these are actually how, you know, Node.Gil Python is actually, that's why,

281
00:14:50,000 --> 00:14:54,000
it's only get tried, even though it's very useful, so I've noticed, I think that it's

282
00:14:54,000 --> 00:14:59,000
kind of a holy grail of very fast Python, but it's only been a 24 times, it's just,

283
00:14:59,000 --> 00:15:02,000
you know, you can see the complications and then now it's up to a fee fee.

284
00:15:02,000 --> 00:15:06,000
Actually, this is something that's kind of like a picture and you have, you know,

285
00:15:06,000 --> 00:15:09,000
to change the design of Python.

286
00:15:09,000 --> 00:15:12,000
But what about scientific programming?

287
00:15:12,000 --> 00:15:18,000
Because we all know scientific calculation is a very time consuming thing,

288
00:15:18,000 --> 00:15:23,000
especially for data scientists or scientists who handle a lot of data.

289
00:15:23,000 --> 00:15:31,000
So that would actually be very time consuming and also like resources consuming process.

290
00:15:31,000 --> 00:15:36,000
So those are the things, like you may have heard about NumPy, you know,

291
00:15:36,000 --> 00:15:39,000
how to learn audit from a civic library.

292
00:15:39,000 --> 00:15:47,000
They are designed to be, to handle all these mathematical calculations relatively efficiently.

293
00:15:47,000 --> 00:15:53,000
With a lot of different help, for example, if you look at the source code of NumPy,

294
00:15:53,000 --> 00:15:58,000
you will see it, instead of like all the code, all the source code is .py, there's like some .cpy,

295
00:15:58,000 --> 00:16:05,000
those things. So those are the external kind of things that help to speed up all these calculations.

296
00:16:05,000 --> 00:16:12,000
Sometimes they would maybe use a different color, NumPy, I just gave her a tutorial yesterday.

297
00:16:12,000 --> 00:16:17,000
So it's something that can be so strict to speed up your calculations.

298
00:16:17,000 --> 00:16:24,000
Also, Cython is also a thing that compiles on Python code in the C before hand and it can be faster.

299
00:16:25,000 --> 00:16:32,000
So, by applying Node-Drop Python, because we are trying to achieve the same thing, right?

300
00:16:32,000 --> 00:16:37,000
With Node-Drop Python, how further of these libraries to have their speed up?

301
00:16:37,000 --> 00:16:43,000
So we already are kind of, you know, the maintainer of the NumPy second-hand library.

302
00:16:43,000 --> 00:16:46,000
They already apply a lot of tricks to speed up the process.

303
00:16:46,000 --> 00:16:50,000
We'll apply Node-Drop Python even further to speed it up.

304
00:16:50,000 --> 00:16:57,000
Or, well, it's the price of that it doesn't work, or even worse in some cases,

305
00:16:57,000 --> 00:17:01,000
because it's not designed for that, it's some hiccup there.

306
00:17:01,000 --> 00:17:04,000
So I want to test it. I'm very curious about it.

307
00:17:04,000 --> 00:17:09,000
And also, you know, I'm from a data science background, I'm really curious that whether we find a new tool,

308
00:17:09,000 --> 00:17:14,000
or even tool that like can help us to have faster work, we don't have to wait for the whole day

309
00:17:14,000 --> 00:17:17,000
for the experiment to finish, right?

310
00:17:17,000 --> 00:17:26,000
So, I've designed something to test it, so it's, you know, it's not a research paper that I spent years

311
00:17:26,000 --> 00:17:29,000
to write a paper and publish it in some scientific journals,

312
00:17:29,000 --> 00:17:32,000
or it's not going to be super high-file scientific to bear with me.

313
00:17:32,000 --> 00:17:39,000
So, in my mind, what I want to test is, first of all, I want to try something with Pure Python.

314
00:17:39,000 --> 00:17:45,000
Because when I kind of start looking at mobile Python, I remember that there is some kind of

315
00:17:45,000 --> 00:17:52,000
speed comparison, I've seen that it's the original, which is 3.9, and then there's like speed equaled one,

316
00:17:52,000 --> 00:17:55,000
if I remember correctly, it's a 40 frames, something like that.

317
00:17:55,000 --> 00:18:01,000
So I want to try it myself to see if I use Pure Python, whether I thought it's 3.2.

318
00:18:01,000 --> 00:18:04,000
Then, so that's the baseline, right?

319
00:18:04,000 --> 00:18:09,000
So that's the baseline, right? That's supposed to be input, because someone already did the experiment

320
00:18:09,000 --> 00:18:12,000
and just to make sure that everything works.

321
00:18:12,000 --> 00:18:19,000
And then I'm going to try it on some algorithms that we use a lot in Pricular, those kind of

322
00:18:19,000 --> 00:18:27,000
the codec machines, those kind of things, NumPy, because again, it's a very huge matrix of numbers

323
00:18:27,000 --> 00:18:34,000
and because it works well together, and since I'm trying to do it, I end up don't do too much

324
00:18:34,000 --> 00:18:40,000
of the Python calculation because, you know, I focus on such and I'm in NumPy.

325
00:18:40,000 --> 00:18:44,000
So, also I want to do something about Neural Network, because Neural Network, for my part,

326
00:18:44,000 --> 00:18:49,000
the students usually takes a long time because of the training, of the loop, so I want to try something

327
00:18:49,000 --> 00:18:52,000
about that as well.

328
00:18:52,000 --> 00:18:58,000
So, in this experiment, I will of course compare the Node-Bio version and original 3.9 version,

329
00:18:58,000 --> 00:19:04,000
but since now we have the sadly 3.11 version, which is supposed to be also maybe sometimes

330
00:19:04,000 --> 00:19:10,000
20% faster than 3.9, so I want to compare it, like, allowed to be in the race.

331
00:19:10,000 --> 00:19:19,000
So, the code I tested on GitHub, so the GitHub, if you find the link, I have this, so one thing

332
00:19:19,000 --> 00:19:23,000
that I have improved ever, because this is not the first time I do this experiment,

333
00:19:23,000 --> 00:19:28,000
I thought that before I only run it on my local machine, it's super not scientific, which is,

334
00:19:28,000 --> 00:19:33,000
you know, don't do it like I did, but I won't be reproducible without, that's why I put everything

335
00:19:33,000 --> 00:19:41,000
in this code report, and so what I did is that I would have a lot of tests, so I would run,

336
00:19:41,000 --> 00:19:47,000
so I write some Python and also bash grid to execute the code.

337
00:19:47,000 --> 00:19:52,000
Inside the code, there would be some timing function to calculate the time, and all the result

338
00:19:52,000 --> 00:19:59,000
will be exported to 2.0 BIOS, which output the full file outage that I also do some

339
00:19:59,000 --> 00:20:05,000
view profiling, as well just for feel free if I want to investigate more about which part actually

340
00:20:05,000 --> 00:20:11,000
maybe takes long time or which part has the best improvement, I think, look more into detail.

341
00:20:12,000 --> 00:20:16,000
So, this is, as you can see, is run on a use-github action, so it's reproducible.

342
00:20:16,000 --> 00:20:21,000
If you want to do it yourself, if you pull this ripple, change whatever you want to change,

343
00:20:21,000 --> 00:20:26,000
so every time you make some changes and push it back, the GitHub action will be triggered.

344
00:20:26,000 --> 00:20:34,000
So as you can see here, I have run a lot of experiments in the past, so once the experiment is done,

345
00:20:34,000 --> 00:20:40,000
so we get a green tick, and then it will push a new branch, so it just kind of number it,

346
00:20:40,000 --> 00:20:45,000
because this is different time, so I have a few attempts here, this is a special attempt,

347
00:20:45,000 --> 00:20:52,000
and then you would get this output of tests and then profile out text, so this is the output file

348
00:20:52,000 --> 00:20:59,000
that is run by a experiment. So it's not very neat, the report, but like I said before,

349
00:20:59,000 --> 00:21:05,000
it runs on three different versions, and then all the results are recorded, all of them,

350
00:21:05,000 --> 00:21:10,000
because of accuracy, you know, some kind of strategic programming and stuff, you know,

351
00:21:10,000 --> 00:21:17,000
they may have some discrepancies, so I loop them and then I trace them out, so this is the result.

352
00:21:17,000 --> 00:21:23,000
Basically, you can see what's going on here, so I've put them into practice life.

353
00:21:23,000 --> 00:21:30,000
So, so first of all, this is the baseline, it's usually two Python to generate velocity numbers,

354
00:21:30,000 --> 00:21:36,000
we all have seen those on the textbook, we don't have to look at the code, and I hope you already know how to do it.

355
00:21:36,000 --> 00:21:41,000
So I've generated 25 numbers in the RedBlood series, and compared their performance,

356
00:21:41,000 --> 00:21:47,000
so as you can see, as promised, no good Python is super fast, it's like ticking only half the time,

357
00:21:47,000 --> 00:21:54,000
but this is, remember, this is GitHub Action, right? GitHub Action, because I didn't pay for extra resources,

358
00:21:54,000 --> 00:22:02,000
GitHub Action only gave me two calls on this Ubuntu-based image, which is Ubuntu.

359
00:22:02,000 --> 00:22:12,000
So this is, so this becomes the factor, if you look at 3.11, 3.11 is actually not slow,

360
00:22:12,000 --> 00:22:22,000
but in still, it can't beat no good Python, so you can see all the claims that we have heard before by the different developers,

361
00:22:22,000 --> 00:22:29,000
it's correct, no good faster than 3.9, and 3.11 is faster than 3.9 because there's inclusion in 3.11.

362
00:22:29,000 --> 00:22:36,000
So, but this is, what I really want to see, right, this is the scientific one, this is, you know,

363
00:22:36,000 --> 00:22:43,000
there's a whole support vector machine, we want to, so this is the very typical example you can find on the NumPy documentation,

364
00:22:43,000 --> 00:22:49,000
and it's recognized, I hand-written the case, so I use the support vector machine,

365
00:22:49,000 --> 00:22:54,000
and then you can see that actually there's no significant difference, you can kind of, you know,

366
00:22:54,000 --> 00:22:59,000
if you run the theorem a long time, you know, one can be faster than the other, you know, the other way around,

367
00:22:59,000 --> 00:23:05,000
because there's no significant difference in the, in the graph, so, you know, it's not a good thought.

368
00:23:05,000 --> 00:23:12,000
Then I prepare more experiments, so this is clustering, so what this does is that, again,

369
00:23:12,000 --> 00:23:17,000
they're kind of with the digits, but if they're using different methods, it costs a death,

370
00:23:17,000 --> 00:23:21,000
again, note the difference, some of the results actually note that it's worse than the others,

371
00:23:22,000 --> 00:23:27,000
so that is something that, you know, oh maybe because we already have to speed up,

372
00:23:27,000 --> 00:23:32,000
and look at how much to sign for it, you know, maybe it isn't, you know, the scientific result,

373
00:23:32,000 --> 00:23:37,000
something's wrong, this is the thing though, this is the thing, the logo is still faster,

374
00:23:37,000 --> 00:23:42,000
I don't know why, I still have to investigate more, so if you want to, you can help me out,

375
00:23:42,000 --> 00:23:49,000
you can, you know, pro-clone the code and have a look at the profile and maybe you can figure out why and what we know of this.

376
00:23:49,000 --> 00:23:55,000
So, 80 algebra, I highlighted the fastest one, so again, you know, even this, you know,

377
00:23:55,000 --> 00:24:03,000
3.11 is not fixing 3.9, so, you know, it's not easy, especially on scientific programming, right?

378
00:24:04,000 --> 00:24:11,000
Again, it makes me think that, you know, very fast, I don't know why, I actually have a theory,

379
00:24:11,000 --> 00:24:17,000
I'll tell you at the end, so, and I think that finally there's something that 3.11 is, you know,

380
00:24:17,000 --> 00:24:24,000
get the first price, it's the fastest, it's kind of similar performance to 3.9, but Nokia is significantly slower.

381
00:24:26,000 --> 00:24:31,000
I am kind of disappointed because at the beginning I thought that I found a new core,

382
00:24:31,000 --> 00:24:35,000
I can speed up my work and I can tell everybody, see, this Nokia Python is amazing.

383
00:24:37,000 --> 00:24:40,000
And it's, you know, we need to look at what happened.

384
00:24:40,000 --> 00:24:46,000
So, why we don't see much difference in a lot of results, I think my speculation may be correct

385
00:24:46,000 --> 00:24:53,000
because in a lot of those mathematics scientific libraries, we, the things that have already,

386
00:24:53,000 --> 00:24:56,000
have a lot of external packing to speed up, right?

387
00:24:56,000 --> 00:25:02,000
They already optimize the best they can and a lot of times the optimization is taking things

388
00:25:02,000 --> 00:25:05,000
out of Python to get taken care of.

389
00:25:05,000 --> 00:25:09,000
So, pure Python is a significantly smaller role in that.

390
00:25:11,000 --> 00:25:15,000
Also, this kind of communication, you know, the extensions and Python itself,

391
00:25:15,000 --> 00:25:23,000
it's actually, you know, from the development of the class, right, for example, if you compare them

392
00:25:23,000 --> 00:25:29,000
to like even 3.9 to 3.11, sometimes 3.9 is faster than 3.11, it may be when this extension,

393
00:25:29,000 --> 00:25:34,000
when this speed up was defined, it has been developed over time and it's been, you know,

394
00:25:34,000 --> 00:25:39,000
it has been developed over time and it's not the native 3.11, it's something new that's trying to be very fast.

395
00:25:39,000 --> 00:25:46,000
And then, you know, it's out of expectation, so maybe the communication between the extensions

396
00:25:46,000 --> 00:25:51,000
and the Python part is not as what is expected.

397
00:25:52,000 --> 00:25:57,000
So, in the future, if this, you know, if we come here, the essential removing the gifts,

398
00:25:57,000 --> 00:26:01,000
of course, like compatibility needs to be taken care of.

399
00:26:01,000 --> 00:26:07,000
And so, but, but not all hope is lost.

400
00:26:07,000 --> 00:26:14,000
I'm only comparing the results, I only run on a free version of GitHub engine, it's only dual call.

401
00:26:16,000 --> 00:26:22,000
So, maybe, because, you know, we have multiple call, multiple thread, you know, if you have more call,

402
00:26:22,000 --> 00:26:26,000
of course, like if there is any speed up, the difference may be more significant.

403
00:26:27,000 --> 00:26:32,000
So, maybe because I'm running on dual call machine, the difference is not big enough to show in every style,

404
00:26:32,000 --> 00:26:36,000
because, again, it's always on discrepancy, so maybe it's already got hidden,

405
00:26:36,000 --> 00:26:39,000
because it's not, the difference is not big enough.

406
00:26:41,000 --> 00:26:46,000
So, this, Node.Github is still working process, Sam is amazing, amazing maintainer,

407
00:26:46,000 --> 00:26:52,000
every time I was like, you know, I want this library to provide that for me, he would provide for me,

408
00:26:52,000 --> 00:26:57,000
like I say, which is amazing. So, he's still working on it.

409
00:26:57,000 --> 00:27:03,000
So, what do we learn, what do we learn, like, you know, they've been sitting here for like almost half an hour.

410
00:27:03,000 --> 00:27:09,000
So, first of all, Python is very versatile, when, you know, Python started, it's, you know,

411
00:27:09,000 --> 00:27:14,000
it's for ease of use, so it's very easy to jump on and get started.

412
00:27:14,000 --> 00:27:19,000
But then, when we do more kind of sophisticated things, like data science and all that stuff,

413
00:27:19,000 --> 00:27:25,000
then all this stuff cannot edit. So, it may be a good thing that we have four different tools for different jobs,

414
00:27:25,000 --> 00:27:33,000
so Python is kind of like a Swiss army knife, it can handle a lot of different things, so it's a good thing.

415
00:27:33,000 --> 00:27:40,000
But then, it makes that, creating a general strategy to make things faster for everybody is almost impossible,

416
00:27:40,000 --> 00:27:47,000
because, you know, it may be faster for pure Python people, but then, like for people who are using mathematical calculation,

417
00:27:47,000 --> 00:27:55,000
then it's a different game. So, I want to get this opportunity to thank all of those open source maintainers,

418
00:27:55,000 --> 00:28:03,000
core developers, and Simon and Phil, that is an amazing work, a lot of effort to try to improve the tool that we use every day,

419
00:28:03,000 --> 00:28:09,000
so thank you very much for them. And it comes to the end of my talk, so I hope that you get these flybacks,

420
00:28:09,000 --> 00:28:14,000
because they are very good, you know, you can watch the Sanxinok right here at EuroPython, you know,

421
00:28:14,000 --> 00:28:20,000
also last year there was some discussion in the Language Summit, and Lucas Rafferty proposed about it,

422
00:28:20,000 --> 00:28:28,000
so you can also check that out. So, EuroPython, right, so maybe this year we will also have amazing keynote at EuroPython,

423
00:28:28,000 --> 00:28:36,000
so maybe you'll consider going, so take a look at that. And the last thing, please check out the Colors Group,

424
00:28:36,000 --> 00:28:43,000
you know, we have a lot of demonstrations that may be interesting to you, and also, we are building a community,

425
00:28:43,000 --> 00:28:47,000
so we are looking for community leaders in the beta client, so if you're interested,

426
00:28:47,000 --> 00:28:52,000
this Q&A talk will bring you into the forum, and if you just tell us that, like, you know, introduce yourself,

427
00:28:52,000 --> 00:28:57,000
and you're interested, then we will talk to you later. So, I think I'm running out of time for questions,

428
00:28:57,000 --> 00:29:05,000
thank you so much for coming here, next will be a live speech talk in the main hall, so I hope you have a nice conference.

