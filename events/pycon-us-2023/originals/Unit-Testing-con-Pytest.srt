1
00:00:00,000 --> 00:00:07,000
Sí, buenas tardes nuevamente. Espero que hayan disfrutado la charla anterior.

2
00:00:07,000 --> 00:00:13,000
Y esta presentación es la última del slot y la última del día de hoy.

3
00:00:13,000 --> 00:00:17,000
Pero luego de aquí siguen los lightning talks como ustedes sabrán.

4
00:00:17,000 --> 00:00:23,000
Bueno, ya que ustedes vieron con Sebastián cómo podemos hacer APIs de forma más rápida,

5
00:00:23,000 --> 00:00:28,000
vamos a tener una charla que con el tiempo que nos sobra debemos hacer algo con ello.

6
00:00:28,000 --> 00:00:32,000
Y ahí básicamente lo que les recomiendo es que hagan unit testing.

7
00:00:32,000 --> 00:00:35,000
Siempre gritamos de que no tenemos tiempo para hacer unit testing.

8
00:00:35,000 --> 00:00:40,000
Entonces, Sofia Denner, una Python developer que viene desde Argentina,

9
00:00:40,000 --> 00:00:46,000
desde Mercado Libre, viene a hablarnos sobre cómo podemos hacer unit testing.

10
00:00:46,000 --> 00:00:49,000
¿Qué testear, cómo testear con PyTest?

11
00:00:49,000 --> 00:00:52,000
Un fuerte aplauso para Sofia.

12
00:00:52,000 --> 00:00:56,000
Gracias.

13
00:00:56,000 --> 00:00:59,000
Bueno, vamos a empezar.

14
00:00:59,000 --> 00:01:03,000
Bueno, un poco ya me presentaron recién. Muchas gracias.

15
00:01:03,000 --> 00:01:06,000
Mi nombre es Sofia Denner.

16
00:01:06,000 --> 00:01:12,000
Trabajo en Mercado Libre, que es una plataforma para comprar y vender productos

17
00:01:12,000 --> 00:01:15,000
similar a Amazon pero de Latinoamérica.

18
00:01:15,000 --> 00:01:18,000
Y bueno, ahí están mis datos.

19
00:01:18,000 --> 00:01:25,000
Y les vengo a contar cómo hacer test unitarios y puntualmente cómo hacerlos con PyTest.

20
00:01:25,000 --> 00:01:31,000
Pero antes de empezar, me gustaría conocerlos un poco más a ustedes porque vienen ustedes acá ahora

21
00:01:31,000 --> 00:01:37,000
y me imagino que puede haber muchas razones por las cuales ustedes quieren venir a una charla sobre test unitarios.

22
00:01:37,000 --> 00:01:41,000
Algunos puede ser que no estén haciendo test y quieran empezar a hacerlos.

23
00:01:41,000 --> 00:01:45,000
O ya están haciendo pero les gustaría aprender más a cómo hacerlos mejor.

24
00:01:45,000 --> 00:01:52,000
Así que me serviría mucho que levanten la mano quiénes de los que están presentes ya escriben test unitarios normalmente.

25
00:01:52,000 --> 00:01:55,000
OK, algunos, no todos.

26
00:01:55,000 --> 00:02:00,000
Me llevo el trabajo entonces de convencerlos a los que no están escribiendo para que empiecen a hacerlo.

27
00:02:00,000 --> 00:02:08,000
Y siguiente pregunta que me gustaría hacerles es, ¿en qué tipo de proyectos están usando Python normalmente?

28
00:02:08,000 --> 00:02:14,000
Esto me sirve a mí como para darle algunos ejemplos de test que se pueden hacer para distintos tipos de proyectos.

29
00:02:14,000 --> 00:02:20,000
¿Quiénes de los presentes, por ejemplo, hacen machine learning o algo con ciencias de datos que levanten la mano?

30
00:02:20,000 --> 00:02:22,000
Hay varios. Buenísimo.

31
00:02:22,000 --> 00:02:28,000
¿Y quiénes hacen web? Apis, la mayoría. Perfecto. Buenísimo.

32
00:02:28,000 --> 00:02:35,000
Bueno, y entre el resto me imagino que puede haber cosas de scripting o sistemas de escritorio o... Buenísimo.

33
00:02:36,000 --> 00:02:38,000
Buenísimo. Bueno.

34
00:02:38,000 --> 00:02:42,000
Vamos a empezar. ¿Por qué escribir test unitarios?

35
00:02:42,000 --> 00:02:48,000
Me traje la tarea de convencerlos así que quiero darles una buena razón de por qué es importante escribir test unitarios.

36
00:02:48,000 --> 00:02:53,000
Y la razón principal es que tener test unitarios nos da paso.

37
00:02:53,000 --> 00:02:58,000
¿Ahora qué quiere decir esto? ¿Qué significa que los test unitarios nos dan paso?

38
00:02:58,000 --> 00:03:10,000
Bueno, hay muchas razones. La primera es que nos permite con confianza hacer refactors, fixes, agregar features en código desconocido.

39
00:03:10,000 --> 00:03:15,000
¿Qué significa código desconocido? ¿Y puede ser que es código que escribió alguien más?

40
00:03:15,000 --> 00:03:21,000
O código que escribimos nosotros mismos pero hace dos meses y ya no recordamos qué estábamos haciendo.

41
00:03:21,000 --> 00:03:26,000
Y cuando queremos ir a tocarlo tenemos un miedo de que tocando algo se rompa todo porque a todos nos pasa.

42
00:03:26,000 --> 00:03:35,000
En cambio con teniendo test unitarios nos da más paso hacer este tipo de refactors, fixes, etc.

43
00:03:36,000 --> 00:03:43,000
Además, teniendo test unitarios garantizamos que se cumplen los requerimientos de nuestro proyecto.

44
00:03:43,000 --> 00:03:50,000
Por ejemplo, por alguna razón necesitamos que nuestra función siempre devuelva, no sé, strings todos en mayúscula

45
00:03:50,000 --> 00:03:58,000
o que siempre que hay un error devuelva tal código o distintas cosas que son requerimientos que pueden estar en documentación.

46
00:03:58,000 --> 00:04:06,000
Pero teniendo test unitarios que validen que esas cosas se cumplen nos da la paz mental de que no tenemos que ir a leer documentación

47
00:04:06,000 --> 00:04:13,000
para asegurarnos de que todas las cosas que hicimos, todos los cambios siguen cumpliendo todos los requerimientos.

48
00:04:16,000 --> 00:04:23,000
Otra cuestión muy importante es que los test son una forma de documentar lo que hace el código.

49
00:04:23,000 --> 00:04:30,000
Cuando entra un desarrollador nuevo al equipo seguro que podemos darle mucha documentación para que lea,

50
00:04:30,000 --> 00:04:35,000
podemos tener docstrings, podemos tener un montón de cosas para ayudarlos a que entiendan.

51
00:04:35,000 --> 00:04:42,000
Pero leyendo los test unitarios es una forma muy linda de entender qué es lo que quiso hacer esta persona con esta función.

52
00:04:42,000 --> 00:04:46,000
Porque vemos realmente cómo la usa, qué espera devolver, cómo espera que se comporte.

53
00:04:49,000 --> 00:04:56,000
Otra cosa importantísima es que nos ayuda a separar la interfaz de la implementación.

54
00:04:56,000 --> 00:05:03,000
Cosa que esta característica no es tan lineal, pero si se ponen a escribir muchos test se van a dar cuenta

55
00:05:03,000 --> 00:05:07,000
que está muy bueno tener estas cosas bien separadas.

56
00:05:07,000 --> 00:05:14,000
Si está bueno que por un lado exista código que se encargue de pensar cómo los usuarios van a usar tu herramienta

57
00:05:14,000 --> 00:05:22,000
y por otro lado código más si se quiere que va al hueso de tu producto o de tu negocio y que resuelva las características.

58
00:05:22,000 --> 00:05:29,000
Y tener estas funciones y estos comportamientos por separado hace que sea más fácil testearlo.

59
00:05:29,000 --> 00:05:37,000
Entonces mientras más test escribimos más nos acostumbramos a separar la lógica de esta forma y es una ganancia para nosotros.

60
00:05:40,000 --> 00:05:44,000
Y por último, pero no menos importante, nos ponen el rol de usuarios.

61
00:05:44,000 --> 00:05:49,000
Porque cuando escribimos test unitarios nos ponemos a pensar todos los casos posibles.

62
00:05:49,000 --> 00:05:56,000
¿Qué pasa si un usuario pone una variable que debería ser un número ahora la pone como un texto?

63
00:05:56,000 --> 00:06:00,000
¿Qué pasa si un montón de escenarios que se puedan dar?

64
00:06:00,000 --> 00:06:10,000
Entonces escribiendo test unitarios nos obligamos a pensar en cada uno de esos casos qué es lo que puede pasar y cómo debería comportarse nuestro código.

65
00:06:12,000 --> 00:06:20,000
Así que bueno, espero haberlos convencido, espero que a partir de ahora todos tengan muchas ganas de ir a escribir test unitarios para su proyecto.

66
00:06:20,000 --> 00:06:29,000
Así que les voy a mostrar cómo. Y van a ver que es súper, súper simple. Voy a empezar con un ejemplito súper básico.

67
00:06:29,000 --> 00:06:37,000
Esto es una función que define una operación, recibe dos parámetros a y b que supongamos que son números.

68
00:06:37,000 --> 00:06:47,000
Hace una operación a más b y devuelve un diccionario, de hecho la función se llama makeAid, con los valores de a, b y el resultado de esa operación.

69
00:06:47,000 --> 00:06:52,000
¿Cómo testemos esto? Bueno, fíjense que es muy, muy fácil.

70
00:06:52,000 --> 00:07:02,000
Definimos un test. Esto yo lo enfoco a PyTest porque es la herramienta que les quiero mostrar.

71
00:07:02,000 --> 00:07:06,000
Y para que funcionen los test con PyTest hay algunas cositas que hay que tener en cuenta.

72
00:07:06,000 --> 00:07:11,000
Por ejemplo la función tiene que llamarse, tiene que empezar llamándose con test.

73
00:07:11,000 --> 00:07:17,000
Esto pueden cambiarlo un poco pero por lo general es así, para que encuentre cuáles son los test que hay que ejecutar.

74
00:07:17,000 --> 00:07:25,000
Y el archivo donde definen los test también tiene que empezar con la palabra test.

75
00:07:25,000 --> 00:07:33,000
Definen una función entonces de testMakeAid, sería el test de la función inicial.

76
00:07:34,000 --> 00:07:40,000
Y fíjense lo que hacemos. Llamamos a la función con dos parámetros, dos y tres.

77
00:07:40,000 --> 00:07:42,000
Voy a señalar con esto, me parece más fácil.

78
00:07:42,000 --> 00:07:46,000
Llamamos a la función con los parámetros dos y tres.

79
00:07:46,000 --> 00:07:50,000
Definimos cuál es el valor que esperamos que devuelva nuestra función.

80
00:07:50,000 --> 00:07:55,000
Que en este caso, bueno, es muy simple, es muy tonto el código que les muestro pero no importa.

81
00:07:55,000 --> 00:07:57,000
Definimos que este es el diccionario que esperamos.

82
00:07:57,000 --> 00:08:00,000
Y listo. Y hacemos una assert.

83
00:08:00,000 --> 00:08:07,000
Esto sería como garantizar que mi diccionario es igual al diccionario que estoy esperando.

84
00:08:08,000 --> 00:08:10,000
Súper simple esto que les muestro.

85
00:08:10,000 --> 00:08:14,000
Corremos los test. Fíjense que yo corrí con el comando pytest.

86
00:08:14,000 --> 00:08:19,000
No lo aclaré pero pytest es una librería que se instala, pipi install pytest y listo.

87
00:08:20,000 --> 00:08:24,000
Le pasé unos parámetros extras para que sea verbose, después les cuento un poco más por qué.

88
00:08:24,000 --> 00:08:28,000
Pero fíjense que listo, corrió el test y me dijo que pasó.

89
00:08:29,000 --> 00:08:32,000
Ahora, ¿qué pasa si algo cambia? Porque las cosas cambian.

90
00:08:32,000 --> 00:08:37,000
En todos los proyectos siempre hay cosas que funcionan distinto y empiezan a cambiar.

91
00:08:37,000 --> 00:08:40,000
O nos piden alguna feature o lo que sea.

92
00:08:40,000 --> 00:08:44,000
Y hay cosas que cambian. Entonces, acá por ejemplo cambió la operación.

93
00:08:44,000 --> 00:08:47,000
En vez de hacer a más b hacemos a más b más dos.

94
00:08:47,000 --> 00:08:50,000
Y no cambiamos el test. Sigue siendo igual.

95
00:08:50,000 --> 00:08:55,000
Esperamos que el resultado sea cinco cuando claramente la operación cambió.

96
00:08:55,000 --> 00:08:57,000
¿Qué pasa cuando corremos los test?

97
00:08:57,000 --> 00:09:02,000
Corremos los test y falla. Y está perfecto que falle porque algo cambió.

98
00:09:02,000 --> 00:09:04,000
Algo no es como se esperaba.

99
00:09:04,000 --> 00:09:09,000
Ahora, fíjense, esto es clave y es una de las cosas más lindas que tiene pytest.

100
00:09:09,000 --> 00:09:14,000
Que nos muestra el detalle de por qué falló lo que falló.

101
00:09:14,000 --> 00:09:16,000
¿Qué es lo que no se esperaba que suceda?

102
00:09:16,000 --> 00:09:19,000
Fíjense que nos dice, hacer shone error.

103
00:09:19,000 --> 00:09:23,000
Este diccionario es distinto a este otro diccionario.

104
00:09:23,000 --> 00:09:26,000
O sea, esperábamos que sea igual y es distinto.

105
00:09:26,000 --> 00:09:28,000
Y nos hace un resumencito.

106
00:09:28,000 --> 00:09:32,000
Los ítems en común son a y b que son iguales. Genial.

107
00:09:32,000 --> 00:09:37,000
Pero el ítem que es diferente es el result que en uno es siete y que en el otro es cinco.

108
00:09:37,000 --> 00:09:41,000
Y de hecho, fíjense que después nos imprime el diccionario completo.

109
00:09:41,000 --> 00:09:45,000
Y nos marca con un piquito cuál es la diferencia.

110
00:09:45,000 --> 00:09:49,000
Esto que les muestro es súper simple porque era un ejemplo de juguete para la presentación.

111
00:09:49,000 --> 00:09:55,000
Pero imagínense, no sé, estar testiendo una API que devuelve un diccionario con cientos

112
00:09:55,000 --> 00:10:02,000
de claves y listas y cosas y encontrar cuál era la que difiere puede ser muy tedioso.

113
00:10:02,000 --> 00:10:07,000
PyTest nos resuelve esto porque nos marca específicamente qué fue lo que pasó.

114
00:10:07,000 --> 00:10:09,000
Que no era lo que se esperaba.

115
00:10:11,000 --> 00:10:17,000
Y bueno, la verdad que con estas cosas que les cuento, ya están listos para salir y escribir sus propios tests.

116
00:10:17,000 --> 00:10:20,000
Porque eso es, digamos, básicamente que todo.

117
00:10:20,000 --> 00:10:24,000
Pero como falta, tenemos un montón de tiempo todavía en la presentación.

118
00:10:24,000 --> 00:10:32,000
Voy a andar en algunos detalles extras de PyTest que hacen que sea muy fácil de usar y muy lindo para escribir tests.

119
00:10:33,000 --> 00:10:35,000
Primera cosa interesante.

120
00:10:35,000 --> 00:10:38,000
Y esto también es un punto importante.

121
00:10:38,000 --> 00:10:43,000
Los tests es código, entonces hay que escribirlo como cualquier código.

122
00:10:43,000 --> 00:10:48,000
Todas las cuestiones de estilo de código, don't repeat to yourself, etc.

123
00:10:48,000 --> 00:10:52,000
Está bueno mantenerlos en los tests tanto como en el código.

124
00:10:52,000 --> 00:10:58,000
PyTest nos da algunas herramientas que nos ayudan a escribir código lindo dentro de los tests.

125
00:10:58,000 --> 00:11:01,000
Fixtures es una de estas herramientas.

126
00:11:02,000 --> 00:11:09,000
Por ejemplo, de nuevo código super simple porque son ejemplitos chiquitos para la presentación y nada más.

127
00:11:09,000 --> 00:11:16,000
Tenemos dos tests que en sus cuerpos tienen que instanciar a una persona.

128
00:11:16,000 --> 00:11:22,000
Fíjense que instancian los dos a la misma persona con un nombre, con una edad y con una profesión.

129
00:11:22,000 --> 00:11:28,000
Y hacen el assert de dos funciones distintas porque son dos tests distintos.

130
00:11:28,000 --> 00:11:33,000
Pero el problema es que repitieron todo el código de cómo instanciar a una persona.

131
00:11:33,000 --> 00:11:41,000
Y si el día de mañana personas reciben más parámetros, hay que ir a cada uno de los tests y cambiar que persona recibe más parámetros, etc.

132
00:11:41,000 --> 00:11:43,000
Y no es lo que queremos testear.

133
00:11:43,000 --> 00:11:44,000
No queremos testear personas.

134
00:11:44,000 --> 00:11:46,000
Queremos testear en realidad esta función.

135
00:11:46,000 --> 00:11:51,000
Years and De-retirement, por ejemplo, Late-manage, etc.

136
00:11:51,000 --> 00:11:55,000
Entonces, ¿cómo podemos hacer esto más simple?

137
00:11:55,000 --> 00:12:08,000
Bueno, PyTest tiene esta cosa que se llama Fixtures, que es un pedazo de código que vos podés pedirle que se ejecute siempre antes de un test.

138
00:12:08,000 --> 00:12:10,000
¿Cómo funciona?

139
00:12:10,000 --> 00:12:16,000
Bueno, definimos una función, la marcamos con un decorador Fixture.

140
00:12:16,000 --> 00:12:20,000
Dentro de esa función escribimos el código que queremos que se ejecute siempre.

141
00:12:20,000 --> 00:12:23,000
Y podemos hacer un return de un valor.

142
00:12:23,000 --> 00:12:27,000
En este caso hacemos un return de la instancia de persona.

143
00:12:27,000 --> 00:12:31,000
Y este valor es el que va a recibir el test cuando corra.

144
00:12:31,000 --> 00:12:36,000
Entonces, definimos un Fixture que instancia a una persona.

145
00:12:36,000 --> 00:12:43,000
Y un test que recibe como parámetro Person, que es el nombre del Fixture.

146
00:12:43,000 --> 00:12:52,000
Acá hay algo que por ahí puede ser medio tricky, porque no es como estamos acostumbrados a que funcionen estas cosas.

147
00:12:52,000 --> 00:12:55,000
Pero es algo que PyTest lo hizo porque la verdad que simplifica mucho.

148
00:12:55,000 --> 00:13:06,000
Acá Person, si ven es el mismo nombre que la función Person, pero no es que recibimos a la función como parámetro, sino que recibimos el resultado de ejecutarla.

149
00:13:06,000 --> 00:13:12,000
Entonces, en esta variable Person vamos a tener la instancia persona.

150
00:13:12,000 --> 00:13:18,000
Y fíjense que esta es una forma muy fácil entonces de separar código en común entre varios test.

151
00:13:18,000 --> 00:13:24,000
Lo llevamos a otro lado, lo pasamos como Fixture y listo.

152
00:13:24,000 --> 00:13:30,000
En cada uno de los test se instancia a una persona diferente, o sea, podremos cambiarle los parámetros, lo que sea.

153
00:13:30,000 --> 00:13:35,000
Porque en cada uno de los test se va a volver a ejecutar ese Fixture y va a volver a ejecutar una instancia a persona.

154
00:13:37,000 --> 00:13:41,000
Acá hice un ejemplo devolviendo, por ejemplo, algo persona.

155
00:13:41,000 --> 00:13:45,000
También podemos usarlo para setear valores, por ejemplo.

156
00:13:45,000 --> 00:13:49,000
Acá hago un Fixture para cambiar a alguna setting.

157
00:13:49,000 --> 00:13:54,000
Le cambio el environment, le cambio alguna variable, etc.

158
00:13:54,000 --> 00:14:00,000
Y esto se va a ejecutar cada vez que yo corra un test que reciba como parámetro, makeSettings.

159
00:14:00,000 --> 00:14:09,000
Y en este yield, si quisiera, le podría devolver algo que es el resultado de lo que va a recibir en ese parámetro.

160
00:14:10,000 --> 00:14:18,000
Pero después del... O sea, esto funciona... Bueno, no sé quiénes de acá conocen cómo funcionan los yields, pero esto funciona de manera.

161
00:14:18,000 --> 00:14:22,000
Se ejecuta esta parte del código antes de correr el test.

162
00:14:22,000 --> 00:14:29,000
Corre el test, si acá le pasamos un parámetro, lo recibe como parámetro en el test.

163
00:14:29,000 --> 00:14:35,000
Y luego que termine la ejecución del test, se ejecuta esta otra porción de código.

164
00:14:35,000 --> 00:14:43,000
Entonces nos permite hacer cosas como antes de correr el test, hace todas estas settings, después puedes ir a correr el test.

165
00:14:43,000 --> 00:14:56,000
Y después acomodas tus settings como vos quieras, para no cambiar otros valores del test, o a lo mejor creaste archivos y después querés borrarlos, o cualquier cosa que quieras hacer en tu environment.

166
00:14:57,000 --> 00:15:08,000
PyTestMock es un fixture también que se instala, porque una cosa linda de los fixtures es que los puedes tener en librerías separadas de PyTest.

167
00:15:08,000 --> 00:15:12,000
Entonces cualquiera puede hacer fixtures que pueden ser útiles para la comunidad.

168
00:15:12,000 --> 00:15:20,000
Por ejemplo, Django tiene un conjunto de fixtures, no los tiene Django, pero hay una librería que hace fixtures para Django.

169
00:15:20,000 --> 00:15:24,000
Que puede, por ejemplo, hacer cosas con la base de datos.

170
00:15:24,000 --> 00:15:33,000
Entonces con un simple parámetro, puedes hacer que se crea una base de datos de cero, que se ejecuten los tests y después elimina la base de datos.

171
00:15:33,000 --> 00:15:39,000
Y esto te sirve para hacer pruebas donde no querés alterar tu base de datos real, obviamente.

172
00:15:39,000 --> 00:15:49,000
Pero bueno, como decía, PyTestMock es un fixture que también se instala y que es básicamente como UnitestMock.

173
00:15:49,000 --> 00:16:01,000
Que quienes ya escriben test y a lo mejor los hacen con Unitest, conocen de lo que hablo, quienes no tienen idea, no se preocupen, ahora lo explico un poco más.

174
00:16:01,000 --> 00:16:06,000
Pero es una forma fácil de usar ese módulo de Python puntualmente.

175
00:16:06,000 --> 00:16:10,000
¿En qué caso es útil hacer un test, un mock?

176
00:16:10,000 --> 00:16:16,000
Por ejemplo, esta es la función que teníamos al inicio, ¿se acuerdan? MakeAddict.

177
00:16:17,000 --> 00:16:29,000
Solamente que un poco distinta porque en vez de realizar la operación dentro de la función, nos llevamos la función que define ese cálculo a otro lado.

178
00:16:29,000 --> 00:16:33,000
Porque a lo mejor era un cálculo muy pesado, muy grande, muy lo que sea.

179
00:16:33,000 --> 00:16:36,000
Y queremos tenerlo separado en funciones distintas.

180
00:16:36,000 --> 00:16:44,000
Esto es un poco lo que decía antes de separar implementación de interfaz con el usuario quizás.

181
00:16:44,000 --> 00:16:49,000
Entonces tenemos una función que hace un diccionario, tenemos una función que hace cálculos.

182
00:16:49,000 --> 00:16:57,000
¿Cómo podemos testear estas dos cosas por separado? Porque nos interesa que la función que hace el diccionario sepa hacer bien el diccionario.

183
00:16:57,000 --> 00:17:02,000
Pero tener test separados para validar que SumCalculation hace bien sus cálculos.

184
00:17:02,000 --> 00:17:05,000
Entonces para hacer esto es fácil.

185
00:17:05,000 --> 00:17:11,000
El test de SumCalculation, fíjense que es muy muy simple, es muy parecido a lo que veníamos haciendo.

186
00:17:11,000 --> 00:17:16,000
A ser que llamándolo con un par de parámetros nos da lo que queremos que nos dé.

187
00:17:16,000 --> 00:17:28,000
Pero el test que vamos a hacer para la función MakeAddict, vamos a moquear la función SumCalculation.

188
00:17:28,000 --> 00:17:29,000
¿Por qué?

189
00:17:29,000 --> 00:17:37,000
Y porque imagínense que SumCalculation era una función súper pesada donde hacía cálculos súper complejos y nos llevaba minutos ejecutarla.

190
00:17:37,000 --> 00:17:42,000
No queremos estar ejecutándolo cada vez que corremos todos los test.

191
00:17:42,000 --> 00:17:44,000
Entonces queremos moquearla.

192
00:17:44,000 --> 00:17:51,000
Queremos solamente testear las cosas que hacen a MakeAddict y no ejecutar SumCalculation.

193
00:17:51,000 --> 00:17:53,000
¿Qué hacemos entonces?

194
00:17:53,000 --> 00:17:58,000
Usamos este fixture, mocker.patch.

195
00:17:58,000 --> 00:18:04,000
Nos sirve para patchear, para monkeypatchear esa función en particular.

196
00:18:04,000 --> 00:18:13,000
Tenemos que poner como primer parámetro un string con el lugar donde se usa esa función.

197
00:18:13,000 --> 00:18:17,000
Y esto es importante, donde se usa la función, no donde se define.

198
00:18:17,000 --> 00:18:20,000
En este caso era en el mismo archivo donde se usa.

199
00:18:20,000 --> 00:18:27,000
Pero hay muchos casos donde se definen funciones en un lado y después en otro lugar se importan y se usan.

200
00:18:27,000 --> 00:18:28,000
Bueno, no.

201
00:18:28,000 --> 00:18:32,000
Acá hay que poner el path a donde se está usando la función.

202
00:18:32,000 --> 00:18:35,000
Podemos definir algunas cosas como return value a las 5.

203
00:18:35,000 --> 00:18:39,000
Entonces no me importa cuál es el cálculo que hace tu función SumCalculation.

204
00:18:39,000 --> 00:18:41,000
Vamos a hacer de cuenta que devolve siempre 5.

205
00:18:41,000 --> 00:18:42,000
No importa.

206
00:18:42,000 --> 00:18:44,000
Le ponemos AutoSpecTrue.

207
00:18:44,000 --> 00:18:51,000
Esto también es una buena práctica porque nos permite que si cambia algo en la interfaz, no salte un error.

208
00:18:51,000 --> 00:18:56,000
Me gustaría mostrarles algún ejemplo, pero si me pongo a explicarles eso se me va a ir el tiempo.

209
00:18:56,000 --> 00:18:58,000
Pero es muy importante este parámetro, AutoSpecTrue.

210
00:18:58,000 --> 00:19:00,000
Pónganlo siempre.

211
00:19:00,000 --> 00:19:01,000
Y bueno, y listo.

212
00:19:01,000 --> 00:19:04,000
Después lo otro que ya conocíamos.

213
00:19:04,000 --> 00:19:06,000
Llamamos a la función MakeAddict.

214
00:19:06,000 --> 00:19:14,000
Y acá en ExpectedBit solamente garantizamos que el resultado de 5 sea el mismo resultado que SumCalculation.

215
00:19:14,000 --> 00:19:20,000
Después si en el futuro cambia porque alguien le puso un más 2, este test no va a fallar.

216
00:19:20,000 --> 00:19:23,000
Va a fallar solamente el test de SumCalculation.

217
00:19:23,000 --> 00:19:25,000
¿Qué es un poco lo que queremos?

218
00:19:26,000 --> 00:19:33,000
Porque si cambia la forma en calcular algo, no queremos que nos fallen todos los test donde eso se usa.

219
00:19:33,000 --> 00:19:38,000
Queremos que nos fallen solamente los test específicos de la cosa que cambió.

220
00:19:38,000 --> 00:19:45,000
Porque si no empieza a fallar todo y es muy difícil encontrar dónde estaba el problema de todos los lugares donde se usaba eso.

221
00:19:45,000 --> 00:19:54,000
Entonces eso es una forma muy simple de separar si se quiere los problemas y hacer test específicos por cada una de las cositas que queremos tener.

222
00:19:54,000 --> 00:19:56,000
¿Qué queremos testear?

223
00:19:56,000 --> 00:20:01,000
Si quisiéramos hacer por ejemplo esto pero sin moquear SumCalculations.

224
00:20:01,000 --> 00:20:08,000
Sería más un test de integración o un test funcional donde se valida el flujo completo.

225
00:20:08,000 --> 00:20:09,000
Pero no es un test unitario.

226
00:20:09,000 --> 00:20:16,000
Para hacer un test unitario se valida solamente el código de cada una de las funciones.

227
00:20:17,000 --> 00:20:27,000
Otra cosa interesante de PyTest que nos ayuda a esto de escribir código orinto y no estar repitiendo muchas veces lo mismo.

228
00:20:27,000 --> 00:20:29,000
Es el parametraizo.

229
00:20:29,000 --> 00:20:32,000
Pongamos un ejemplo similar a lo que estábamos viendo.

230
00:20:32,000 --> 00:20:38,000
Tenemos la función SumCalculation que hace una operación, en este caso suma más b.

231
00:20:38,000 --> 00:20:41,000
Y queremos probarlo en distintos escenarios.

232
00:20:41,000 --> 00:20:44,000
Por ejemplo, ¿qué pasa si le paso dos números cualquiera?

233
00:20:44,000 --> 00:20:46,000
¿Qué pasa si le paso dos números iguales?

234
00:20:46,000 --> 00:20:49,000
¿Falla? No falla. Tiene algún comportamiento raro.

235
00:20:49,000 --> 00:20:52,000
¿Qué pasa si le paso un número negativo?

236
00:20:53,000 --> 00:20:56,000
Son muchos escenarios de lo que queremos probar realmente.

237
00:20:56,000 --> 00:21:02,000
Pero lo que no está bueno es tener que escribir un test nuevo por cada uno de los escenarios que queremos validar.

238
00:21:02,000 --> 00:21:05,000
Para estos casos existe el parametraizo.

239
00:21:06,000 --> 00:21:16,000
Donde fíjense cómo es la sintaxis, pero le pasamos como parámetro los valores que queremos diferir entre un escenario y otro.

240
00:21:16,000 --> 00:21:23,000
Entonces, los valores que queremos diferir son el parámetro a, el parámetro b y los resultados de esperados.

241
00:21:25,000 --> 00:21:34,000
Y le pasamos una lista con tuplas de cada parámetro de los escenarios que queremos validar.

242
00:21:35,000 --> 00:21:40,000
Entonces, el primer escenario, bueno, lo que vimos antes, uno, dos y tres.

243
00:21:40,000 --> 00:21:43,000
El segundo con dos números iguales, con un número negativo.

244
00:21:43,000 --> 00:21:46,000
Y así podemos poner todos los escenarios que se nos ocurran.

245
00:21:46,000 --> 00:21:51,000
Y de una forma muy simple, estamos parametrizando nuestro test.

246
00:21:52,000 --> 00:21:58,000
Fíjense que ahora el test recibe como parámetros justamente lo que definimos arriba.

247
00:21:58,000 --> 00:22:03,000
Y realiza los cálculos con los parámetros en vez de los números arqueodados.

248
00:22:05,000 --> 00:22:19,000
Y una vez que corremos los test, si le pasamos el verbose que es este "-vever", van a ver que es muy lindo esto porque nos dice en cada uno de los escenarios si pasó o no pasó.

249
00:22:19,000 --> 00:22:29,000
Si falla, por ejemplo, en los números negativos porque no sabe manejar números negativos, vamos a ver concretamente dónde falla.

250
00:22:29,000 --> 00:22:41,000
Bueno, una cosita extra que por ahí es muy útil y que de hecho usé acá, pero no sé si alguno de ustedes se dio cuenta.

251
00:22:41,000 --> 00:22:47,000
Tenemos una forma de filtrar que test correr. ¿Por qué?

252
00:22:47,000 --> 00:22:55,000
Y porque muchas veces tenemos un montón de test, muchos son lentos, otros son rápidos, pero queremos ejecutarlos muchas veces.

253
00:22:55,000 --> 00:22:59,000
¿Por qué? Y porque como dije antes, tener test nos da paz.

254
00:22:59,000 --> 00:23:09,000
Entonces correr muchas veces los test nos ayuda a tener confianza en que lo que estamos trabajando y las cosas que estamos haciendo no están rompiendo nada.

255
00:23:09,000 --> 00:23:13,000
O si están rompiendo, por lo menos ir viendo qué cosas están rompiendo y sentirnos seguros con eso.

256
00:23:13,000 --> 00:23:22,000
Entonces correr test rápido es una ventaja muy buena de p-test.

257
00:23:22,000 --> 00:23:36,000
Y justamente correr muchas veces, perdón acá me perdí un toque, correr muchas veces los test nos hace sentir seguros por esto porque estamos viendo todo el tiempo qué es lo que va cambiando, qué es lo que se rompe, qué es lo que no.

258
00:23:36,000 --> 00:23:50,000
Si tenemos muchos test y test muy pesados, queremos una forma de correr solamente los test rápidos o correr solamente los test de la cosa que estamos probando o correr solamente un grupito de test los que nos interesan.

259
00:23:50,000 --> 00:23:53,000
Porque si corremos todos, capaz que es un montón de tiempo.

260
00:23:53,000 --> 00:23:58,000
Entonces, ¿cómo hacemos esto? Una de las formas es con marcas.

261
00:23:58,000 --> 00:24:02,000
P-test tiene también esta otra feature que se llama Marks.

262
00:24:03,000 --> 00:24:07,000
Que funciona de esta manera, funciona también como un decorador.

263
00:24:07,000 --> 00:24:12,000
P-test.mark.el nombre de lo que ustedes quieran marcar.

264
00:24:12,000 --> 00:24:21,000
En este caso mi marca se va a llamar Slow, pero pueden marcarlo con el nombre que quieran, pueden marcarlo RapidTest o lo que ustedes quieran.

265
00:24:21,000 --> 00:24:24,000
Si este nombre del final lo ponen ustedes.

266
00:24:25,000 --> 00:24:26,000
Entonces, eso.

267
00:24:26,000 --> 00:24:36,000
Marcamos un test con una marca y después podemos con este parámetro, "-m", y la marca, correr solamente ese conjunto de test.

268
00:24:36,000 --> 00:24:38,000
Todos los que tengan esa marca.

269
00:24:38,000 --> 00:24:45,000
O al contrario, podemos decirle "-m", no Slow, entonces me iba a correr todos los test que en teoría son más rápidos.

270
00:24:45,000 --> 00:24:51,000
Otra forma de filtrar los test es con el parámetro "-k".

271
00:24:51,000 --> 00:24:59,000
P-test "-k", y algo, una palabra, nos va a buscar todos los test que contengan esa palabra.

272
00:24:59,000 --> 00:25:04,000
Ya sea en su nombre o en su módulo o de alguna forma dentro de ese escenario.

273
00:25:04,000 --> 00:25:07,000
Entonces si están haciendo una feature muy específica de algo puntual.

274
00:25:08,000 --> 00:25:15,000
Pueden con este parámetro correr solamente los test que tengan relación con eso, que están probando.

275
00:25:15,000 --> 00:25:23,000
Y esto se puede anidar, podrían hacer "-k", not func, "-m", Slow y no se haría hacer todas las combinaciones que quieran.

276
00:25:23,000 --> 00:25:26,000
Para correr específicamente los test que quieren correr.

277
00:25:28,000 --> 00:25:32,000
Y bueno, eso fue básicamente todo lo que les quería mostrar sobre Pytest.

278
00:25:32,000 --> 00:25:39,000
Pero no quería irme sin dejarle algunos tips para cuando se pongan a escribir sus test unitarios.

279
00:25:39,000 --> 00:25:46,000
El primer tip tiene que ver un poco con lo que decía recién, escribir test es lo mismo que escribir código.

280
00:25:46,000 --> 00:25:49,000
Entonces siempre de la forma más clara y simple posible.

281
00:25:49,000 --> 00:25:54,000
Siempre poniéndole docstrings o los comentarios que sean necesarios.

282
00:25:54,000 --> 00:25:58,000
Poniendo nombres de variables que tengan significado.

283
00:25:58,000 --> 00:26:03,000
Todo lo que ustedes hacen para escribir código con buen estilo.

284
00:26:03,000 --> 00:26:05,000
Háganlo también en los test.

285
00:26:05,000 --> 00:26:08,000
Porque es muy lindo leer test bien escritos.

286
00:26:10,000 --> 00:26:13,000
Todos los test que son lentos o que son de integración o que son exhaustivos.

287
00:26:13,000 --> 00:26:16,000
Está bueno marcarlos para lo que les decía recién.

288
00:26:16,000 --> 00:26:22,000
Para no correrlo siempre, para tenerlos bien identificados y correrlo solamente cuando sea necesario.

289
00:26:24,000 --> 00:26:27,000
No testear frameworks, no testear librerías.

290
00:26:27,000 --> 00:26:31,000
Esto que quiere decir, si uso una librería que ya me resuelve un problema.

291
00:26:31,000 --> 00:26:36,000
No hagamos test que usen esa librería y que valían el resultado.

292
00:26:36,000 --> 00:26:42,000
Por ejemplo, si uso Django, no voy a escribir un test que si yo llamo a Django con estos parámetros.

293
00:26:42,000 --> 00:26:45,000
El SQL que me genera Django va a ser de tal forma.

294
00:26:45,000 --> 00:26:47,000
Eso ya lo hace Django y ya lo hace bien.

295
00:26:47,000 --> 00:26:49,000
Confiamos en que lo hace bien.

296
00:26:49,000 --> 00:26:57,000
Entonces, eso. No estemos testeando, no estemos intentando validar comportamientos que no son comportamientos que escribimos nosotros.

297
00:26:57,000 --> 00:26:59,000
Sino que son comportamientos de la librería.

298
00:27:01,000 --> 00:27:04,000
Y esto se relaciona mucho con este otro punto.

299
00:27:04,000 --> 00:27:08,000
Siempre moquear. Moquear todo lo que no es parte de lo que queremos testear.

300
00:27:08,000 --> 00:27:11,000
Si queremos testear solamente la función que hace el diccionario.

301
00:27:11,000 --> 00:27:15,000
Todas las funciones que estén adentro, lo ideal sería moquearlas.

302
00:27:16,000 --> 00:27:18,000
Si es que estamos hablando de test unitarios.

303
00:27:18,000 --> 00:27:23,000
Como les decía antes, podemos tener test de integración donde probemos que todo funcione de la mejor forma.

304
00:27:23,000 --> 00:27:33,000
Pero todo lo que no sea parte de la lógica que queremos testear, mejor moquearlo y hacer sí test específicos para cada una de las cosas que moqueamos.

305
00:27:33,000 --> 00:27:38,000
De esta forma, cuando hay un problema, valíamos dónde está el problema.

306
00:27:38,000 --> 00:27:47,000
Y último, pero no menos importante, validar un único comportamiento por test.

307
00:27:47,000 --> 00:27:57,000
Si ustedes tienen, por ejemplo, una función que hace muchas cosas, porque no sé, actualiza un estado, después va y busca un valor en la base de datos y lo cambia por otro.

308
00:27:57,000 --> 00:27:59,000
Y después devuelve una respuesta específica.

309
00:27:59,000 --> 00:28:04,000
Y hace muchas cosas que alteran el proyecto de alguna forma.

310
00:28:04,000 --> 00:28:07,000
Si quieren validarlas todas, está muy bien.

311
00:28:07,000 --> 00:28:11,000
Pero escriban test distintos para cada una de las cosas que quieren validar.

312
00:28:11,000 --> 00:28:13,000
Esto por varias razones.

313
00:28:13,000 --> 00:28:26,000
Pero una de las principales es, si llega a fallar alguno de estos comportamientos y escriben un solo test que tenga todos los asserts juntos, falla el primer assert y el código deja de correr.

314
00:28:26,000 --> 00:28:39,000
Y luego se pierde en ese insight de qué hubiera pasado si esto funcionaba, los otros cheques fallaban o no fallaban, estaba todo roto, estaba rota solamente esta parte, etc.

315
00:28:39,000 --> 00:28:42,000
Eso se puede validar si hacen test separados.

316
00:28:42,000 --> 00:28:49,000
Les permite visualizar qué es lo que hubiera pasado con cada uno de los comportamientos.

317
00:28:49,000 --> 00:28:52,000
Y bueno, eso fue todo lo que tenía para mostrarles.

318
00:28:52,000 --> 00:28:56,000
Ahí en este QR está el link de las slides, por si les sirve.

319
00:28:56,000 --> 00:29:01,000
Y nada más. Si tienen alguna pregunta, estoy para eso.

320
00:29:09,000 --> 00:29:12,000
Tenemos espacio para dos minutos para preguntas.

321
00:29:12,000 --> 00:29:18,000
Cualquier pregunta que no quepa podemos, claro, si está dentro de tu posibilidad, responderla afuera.

322
00:29:22,000 --> 00:29:24,000
Hay una pregunta allá al fondo.

323
00:29:28,000 --> 00:29:37,000
Hola. A mí me gustaría saber si podés explicar un poquito más lo de AutoSpec True que mencionaste que estaba interesante y no sé cómo funciona.

324
00:29:37,000 --> 00:29:40,000
Buenísima, buenísima la pregunta.

325
00:29:40,000 --> 00:29:47,000
Vos sabés que pensé, digo, voy a poner unas slides más por si alguien pregunta esto y después me obligue y no las agregué.

326
00:29:47,000 --> 00:29:49,000
Pero está muy buena la pregunta.

327
00:29:49,000 --> 00:29:51,000
Bueno, bueno, bueno.

328
00:29:51,000 --> 00:29:57,000
La pregunta es, ¿cómo se puede ver que el código de AutoSpec True es un código de AutoSpec?

329
00:29:57,000 --> 00:30:01,000
La gracia es validar la interfaz de lo que estamos moqueando.

330
00:30:01,000 --> 00:30:07,000
Entonces, por ejemplo, someCalculation que recibe los parámetros 1 y 2.

331
00:30:07,000 --> 00:30:08,000
¿Cierto?

332
00:30:08,000 --> 00:30:17,000
Si nosotros, si nosotros por alguna razón en el código de makeAddict lo llamamos, acá, vuelvo acá.

333
00:30:17,000 --> 00:30:19,000
Por ejemplo, vamos a ver más.

334
00:30:19,000 --> 00:30:25,000
Si si no le pasamos ese AutoSpec True, el test nos va a decir que funciona.

335
00:30:25,000 --> 00:30:31,000
¿Por qué? Porque en este caso, mocker.patch está haciendo un magicMock.

336
00:30:31,000 --> 00:30:39,000
Para los que no conocen, un magicMock es un objeto de Python que sabe hacer lo que ustedes le pidan, lo que sea.

337
00:30:39,000 --> 00:30:42,000
Entonces, si lo llamas con 50 parámetros, algo te responde.

338
00:30:43,000 --> 00:30:47,000
Pero si le pasas, ¿cómo querés que se comporte ese magicMock?

339
00:30:47,000 --> 00:30:49,000
Respeta ese comportamiento.

340
00:30:49,000 --> 00:30:56,000
Entonces, si no le pasamos el AutoSpec True, va a ser este magicMock así como pelado, como viene por default.

341
00:30:56,000 --> 00:30:58,000
Entonces, le pasas 50 parámetros y funciona.

342
00:30:58,000 --> 00:31:00,000
Le pasas 1 y también funciona.

343
00:31:00,000 --> 00:31:03,000
Y no le importa porque él sabe funcionar siempre.

344
00:31:03,000 --> 00:31:09,000
Pero si le pasas AutoSpec True, se fija cuál es la interfaz de esa cosa que estás queriendo moquear.

345
00:31:09,000 --> 00:31:13,000
Entonces, en este caso, se fija cómo es la interfaz de SumCalculation.

346
00:31:13,000 --> 00:31:17,000
Y SumCalculation, como vemos acá, recibe 2 parámetros, ahí ve.

347
00:31:17,000 --> 00:31:25,000
Entonces, si en nuestro test lo llamamos con más parámetros o con menos parámetros o con cualquier cosa distinta, va a fallar.

348
00:31:25,000 --> 00:31:33,000
Para funciones, y está buenísimo hacer esto porque, como les decía, las cosas cambian con el tiempo.

349
00:31:33,000 --> 00:31:39,000
Y esta función que ve y recibe 2 parámetros, es muy probable que el día de mañana reciba más.

350
00:31:39,000 --> 00:31:42,000
Y que reciba más de forma obligatoria.

351
00:31:42,000 --> 00:31:49,000
Si nosotros no le ponemos el AutoSpec True, no nos vamos a enterar que falla justamente esa integración en todos los lugares donde se usa.

352
00:31:49,000 --> 00:31:53,000
No sé si responde. Buenísimo.

353
00:31:54,000 --> 00:32:02,000
Lamentablemente no tenemos más tiempo aquí dentro del salón, pero ella está disponible para cualquier otra pregunta.

354
00:32:02,000 --> 00:32:07,000
Y hasta durante la PyCon. Un segundo, parece que hay un anuncio.

355
00:32:09,000 --> 00:32:15,000
Un pequeño anuncio que recuerden que mañana, después de la última charla, estaremos aquí.

356
00:32:15,000 --> 00:32:21,000
Queremos tomar una foto de grupo de todas las personas hispanohablantes que estuvieron aquí participando de las PyCon charlas.

357
00:32:21,000 --> 00:32:28,000
Así que, si quieren participar de esta foto y ver de toda la comunidad que estuvo apoyando aquí en la PyCon US a las PyCon charlas,

358
00:32:28,000 --> 00:32:33,000
mañana, después de la última charla, estaremos aquí para esa foto.

359
00:32:39,000 --> 00:32:42,000
Muchísimas gracias a todos. Gracias, Traves.

