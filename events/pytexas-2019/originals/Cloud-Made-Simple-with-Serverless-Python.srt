1
00:00:00,000 --> 00:00:02,280
Here is Belinda Venom.

2
00:00:02,280 --> 00:00:04,760
She's going to tell us about Cloud Made Simple

3
00:00:04,760 --> 00:00:05,840
with Serverless Python.

4
00:00:05,840 --> 00:00:07,340
Let's give her a round of applause.

5
00:00:07,340 --> 00:00:07,840
Woo!

6
00:00:07,840 --> 00:00:08,340
Thank you.

7
00:00:08,340 --> 00:00:08,840
Thank you.

8
00:00:13,320 --> 00:00:14,080
Thanks.

9
00:00:14,080 --> 00:00:15,760
Can you guys hear me?

10
00:00:15,760 --> 00:00:16,640
OK, perfect.

11
00:00:16,640 --> 00:00:18,800
So my name is Belinda Venom.

12
00:00:18,800 --> 00:00:23,000
I'm a developer advocate and software developer at IBM.

13
00:00:23,000 --> 00:00:27,400
Right now, my current focus is on both Cloud and Serverless.

14
00:00:27,400 --> 00:00:30,920
Prior to this role, I was a software developer

15
00:00:30,920 --> 00:00:33,520
on the IBM Cloud Functions project, which

16
00:00:33,520 --> 00:00:35,720
is based on top of Apache Open.

17
00:00:35,720 --> 00:00:37,360
Oh, it's kind of coming in.

18
00:00:37,360 --> 00:00:39,760
Based on top of Apache OpenLisk.

19
00:00:39,760 --> 00:00:43,960
So who here has heard of Serverless?

20
00:00:43,960 --> 00:00:45,960
OK, cool, less people.

21
00:00:45,960 --> 00:00:50,320
Is anyone using Serverless in their projects?

22
00:00:50,320 --> 00:00:51,360
OK, so less people.

23
00:00:51,360 --> 00:00:54,480
Anyone like projects in production with Serverless?

24
00:00:54,480 --> 00:00:55,960
OK, so same people.

25
00:00:55,960 --> 00:00:57,720
Awesome.

26
00:00:57,720 --> 00:00:59,180
Today, we're going to talk about some

27
00:00:59,180 --> 00:01:00,960
of the benefits of Serverless.

28
00:01:00,960 --> 00:01:04,600
And then we'll also check out a real life use case.

29
00:01:04,600 --> 00:01:06,640
And then I'll show you guys a quick demo

30
00:01:06,640 --> 00:01:10,760
of running some Python code on a Serverless platform.

31
00:01:10,760 --> 00:01:12,340
OK, cool.

32
00:01:12,340 --> 00:01:15,040
So let's say I've been working on a project,

33
00:01:15,040 --> 00:01:17,920
and I'm ready to play my code out to the cloud.

34
00:01:17,920 --> 00:01:20,800
In the past, me or someone else in my company

35
00:01:20,800 --> 00:01:22,880
might have needed to purchase bare metal servers

36
00:01:22,880 --> 00:01:25,120
to run my application on.

37
00:01:25,120 --> 00:01:27,760
You have to manage the security updates for the servers,

38
00:01:27,760 --> 00:01:29,160
install all the required software,

39
00:01:29,160 --> 00:01:30,800
and keep the hardware up to date.

40
00:01:30,800 --> 00:01:33,160
Then virtual machines came into the picture, right?

41
00:01:33,160 --> 00:01:36,160
We were able to let someone else, like Amazon or Rackspace,

42
00:01:36,160 --> 00:01:37,960
start to manage those machines for us,

43
00:01:37,960 --> 00:01:39,440
and we just get a virtual machine

44
00:01:39,440 --> 00:01:41,920
to run our application on.

45
00:01:41,920 --> 00:01:44,280
You'd still have to manage the operating system

46
00:01:44,280 --> 00:01:46,760
and the software dependencies of your application,

47
00:01:46,760 --> 00:01:48,760
but you didn't need to physically own or house

48
00:01:48,760 --> 00:01:51,040
those servers anymore.

49
00:01:51,040 --> 00:01:54,400
Even more recently, we've had containers enter the scene

50
00:01:54,400 --> 00:01:57,000
where we're only managing the application code

51
00:01:57,000 --> 00:01:58,240
and its dependencies.

52
00:01:58,240 --> 00:02:01,000
We package everything up into a container.

53
00:02:01,000 --> 00:02:03,880
We give that container to the platform to be run.

54
00:02:03,880 --> 00:02:06,120
So that made things a lot easier,

55
00:02:06,120 --> 00:02:09,240
but we're still managing some of the infrastructure there.

56
00:02:09,240 --> 00:02:10,920
We need to manage our own runtime

57
00:02:10,920 --> 00:02:13,240
and our own application dependencies.

58
00:02:13,240 --> 00:02:15,480
Building a container to run your application on

59
00:02:15,480 --> 00:02:17,120
is still a somewhat manual process

60
00:02:17,120 --> 00:02:18,920
that could still be abstracted away.

61
00:02:20,000 --> 00:02:21,840
So software developers really need to focus

62
00:02:21,840 --> 00:02:23,160
on that core business logic

63
00:02:23,160 --> 00:02:25,560
and not get distracted by infrastructure management

64
00:02:25,560 --> 00:02:26,800
or configuration.

65
00:02:26,800 --> 00:02:29,960
And these abstractions are ultimately what serverless

66
00:02:29,960 --> 00:02:33,000
or functions as a service offerings are promising you.

67
00:02:33,000 --> 00:02:34,800
So the execution environment for the code

68
00:02:34,800 --> 00:02:36,600
is provided for me as a developer,

69
00:02:36,600 --> 00:02:39,080
and my code can just be run in response to events

70
00:02:39,080 --> 00:02:41,760
or in response to actions that I care about.

71
00:02:41,760 --> 00:02:44,360
So I should note, I'm positing this as an evolution,

72
00:02:44,360 --> 00:02:47,120
but all these models are still available today,

73
00:02:47,120 --> 00:02:49,520
and they might even still be the right choice,

74
00:02:49,520 --> 00:02:51,080
depending on what problem you're trying to solve

75
00:02:51,080 --> 00:02:52,920
or what your requirements are.

76
00:02:52,920 --> 00:02:54,440
So you'll notice on the x-axis,

77
00:02:54,440 --> 00:02:58,960
it says decreasing concern over your stack implementation,

78
00:02:58,960 --> 00:03:01,480
but it's also decreasing control.

79
00:03:01,480 --> 00:03:03,000
So if there's a security vulnerability

80
00:03:03,000 --> 00:03:05,720
or an environment update that you need to make,

81
00:03:05,720 --> 00:03:07,600
you have to wait for the platform provider

82
00:03:07,600 --> 00:03:10,240
to make that required environment update.

83
00:03:10,240 --> 00:03:12,240
So if you need that additional control,

84
00:03:12,240 --> 00:03:15,200
one of the others might still be the right option for you.

85
00:03:17,600 --> 00:03:19,480
I'm gonna get this over.

86
00:03:19,480 --> 00:03:21,240
So I think this is a really,

87
00:03:21,240 --> 00:03:23,120
just another nice way to visualize

88
00:03:23,120 --> 00:03:25,040
the increasing levels of abstraction.

89
00:03:25,040 --> 00:03:28,480
So as we're moving through each of the deployment models,

90
00:03:28,480 --> 00:03:29,760
we're seeing less and less

91
00:03:29,760 --> 00:03:31,800
that the end user's responsible for.

92
00:03:31,800 --> 00:03:34,160
So on the far left, we have on-prem,

93
00:03:34,160 --> 00:03:35,360
where you have your own machines

94
00:03:35,360 --> 00:03:36,840
and you're managing everything,

95
00:03:36,840 --> 00:03:38,720
and then we go through infrastructure as a service,

96
00:03:38,720 --> 00:03:39,720
platform as a service,

97
00:03:39,720 --> 00:03:41,800
and then ultimately functions as a service,

98
00:03:41,800 --> 00:03:44,340
where you literally only write, manage,

99
00:03:44,340 --> 00:03:45,640
and deal with functions.

100
00:03:51,600 --> 00:03:53,600
So these changing deployment models

101
00:03:53,600 --> 00:03:55,360
have also affected how we write

102
00:03:55,360 --> 00:03:57,640
and think about our application.

103
00:03:57,640 --> 00:04:00,800
We used to write code as these big monolithic applications.

104
00:04:00,800 --> 00:04:03,120
The entire application gets deployed as one unit,

105
00:04:03,120 --> 00:04:05,480
and introducing any new code changes

106
00:04:05,480 --> 00:04:07,880
means a completely new deployment of the full application,

107
00:04:07,880 --> 00:04:10,600
even if you're only changing one or two lines.

108
00:04:10,600 --> 00:04:14,280
So from there, we moved more to this microservices paradigm.

109
00:04:14,280 --> 00:04:16,320
We started to break that monolithic application

110
00:04:16,320 --> 00:04:18,600
into various services

111
00:04:18,600 --> 00:04:21,800
that are communicating with each other over RESTful APIs.

112
00:04:21,800 --> 00:04:24,520
In a store application, for example,

113
00:04:24,520 --> 00:04:25,920
you might have a microservice

114
00:04:25,920 --> 00:04:28,520
that manages the accounts for your users,

115
00:04:28,520 --> 00:04:29,940
one for placing orders,

116
00:04:29,940 --> 00:04:31,640
and one for maybe managing interactions

117
00:04:31,640 --> 00:04:33,040
with your shipping company.

118
00:04:33,960 --> 00:04:36,440
So you could deploy each of those microservices

119
00:04:36,440 --> 00:04:39,560
either as an application on a pad solution,

120
00:04:39,560 --> 00:04:41,600
like a platform as a service solution,

121
00:04:41,600 --> 00:04:43,680
or maybe you deploy each one of those microservices

122
00:04:43,680 --> 00:04:45,520
into their own containers.

123
00:04:45,520 --> 00:04:47,600
And then finally, as we've moved more towards

124
00:04:48,000 --> 00:04:50,200
the service model, there's been further decoupling

125
00:04:50,200 --> 00:04:52,440
and shrinking of the size of the unit of code.

126
00:04:52,440 --> 00:04:54,880
So instead of creating microservices,

127
00:04:54,880 --> 00:04:56,720
we can literally just write functions

128
00:04:56,720 --> 00:04:58,440
that we wanna deploy to the cloud.

129
00:04:58,440 --> 00:05:00,080
And each of those functions have the goal

130
00:05:00,080 --> 00:05:03,080
of doing one thing and doing that one thing really well,

131
00:05:03,080 --> 00:05:06,280
perhaps in reaction to a particular event.

132
00:05:09,100 --> 00:05:11,440
So as we said, Serverless promises

133
00:05:11,440 --> 00:05:14,320
that you can just spend your time writing business logic

134
00:05:14,320 --> 00:05:16,720
that has a direct positive impact to your users

135
00:05:16,720 --> 00:05:20,240
and not focus on that configuration or management events.

136
00:05:20,240 --> 00:05:21,360
Even though it's called Serverless,

137
00:05:21,360 --> 00:05:23,200
yes, there are servers,

138
00:05:23,200 --> 00:05:24,800
but the idea is you don't have to see them

139
00:05:24,800 --> 00:05:26,240
or deal with them.

140
00:05:26,240 --> 00:05:28,320
So from a developer's perspective,

141
00:05:28,320 --> 00:05:29,800
the functions as a service platform

142
00:05:29,800 --> 00:05:33,120
is gonna provide a runtime and an execution environment

143
00:05:33,120 --> 00:05:34,400
for the code that they're writing.

144
00:05:34,400 --> 00:05:35,680
So you just write the code,

145
00:05:35,680 --> 00:05:38,080
and then the Serverless platform runs it for you

146
00:05:38,080 --> 00:05:41,840
in the cloud on demand and within milliseconds.

147
00:05:41,840 --> 00:05:44,260
And this may be actually abstracted away from you,

148
00:05:44,260 --> 00:05:45,760
so you typically won't see it,

149
00:05:45,760 --> 00:05:47,640
but usually what's happening under the covers

150
00:05:47,640 --> 00:05:50,600
is that the code is ultimately being run on a container

151
00:05:50,600 --> 00:05:53,120
in the cloud provider's environment.

152
00:05:56,320 --> 00:05:58,320
So one of the goals of Serverless

153
00:05:58,320 --> 00:06:01,320
is to provide developers with scalability out of the box.

154
00:06:01,320 --> 00:06:04,320
So let's say that you have a set of APIs,

155
00:06:04,320 --> 00:06:07,520
and you've represented each of those API endpoints

156
00:06:07,520 --> 00:06:08,960
as different functions.

157
00:06:10,360 --> 00:06:12,600
Maybe suddenly your app gets featured on Reddit,

158
00:06:12,600 --> 00:06:14,400
you have millions of requests from your UI

159
00:06:14,400 --> 00:06:17,320
to these backend API endpoints.

160
00:06:17,320 --> 00:06:18,600
The only thing that's gonna happen

161
00:06:18,600 --> 00:06:21,980
is that the platform will start up multiple instances

162
00:06:21,980 --> 00:06:23,360
of the backend API code

163
00:06:23,360 --> 00:06:26,160
to process those requests in parallel.

164
00:06:26,160 --> 00:06:28,800
And it kinda gives you that horizontal scaling for free

165
00:06:28,800 --> 00:06:31,000
without any additional programming

166
00:06:31,000 --> 00:06:32,600
or server management from you.

167
00:06:35,480 --> 00:06:37,960
So we talked about your code scaling out

168
00:06:37,960 --> 00:06:40,720
or up to end instances when it's required,

169
00:06:40,720 --> 00:06:42,480
but it also scales back down to zero

170
00:06:42,480 --> 00:06:44,440
when it's not being used.

171
00:06:44,440 --> 00:06:47,680
So what that means from an app developer's perspective

172
00:06:47,680 --> 00:06:49,600
is that you're not paying for the time

173
00:06:49,600 --> 00:06:51,480
that your code is not being run.

174
00:06:51,480 --> 00:06:53,200
So you're only charged for the amount of time

175
00:06:53,200 --> 00:06:56,120
that your code is actively running or doing some work.

176
00:06:56,120 --> 00:06:58,600
So you're no longer paying for that idle time.

177
00:06:58,600 --> 00:07:02,640
You have to do the testing for your particular scenario,

178
00:07:02,640 --> 00:07:05,200
but this can actually mean really big cost savings

179
00:07:05,200 --> 00:07:08,480
compared to having a server up 100% of the time.

180
00:07:08,480 --> 00:07:10,680
So it really just depends on the project,

181
00:07:10,680 --> 00:07:11,640
it depends on the workload,

182
00:07:11,640 --> 00:07:13,880
but it can be really good cost savings.

183
00:07:17,520 --> 00:07:20,280
Other promises, most serverless solutions provide support

184
00:07:20,280 --> 00:07:22,920
for some kind of event-driven scenario.

185
00:07:22,920 --> 00:07:25,960
So this is literally anything where an event happens

186
00:07:25,960 --> 00:07:28,660
and you wanna react to that by some code.

187
00:07:28,660 --> 00:07:31,280
Some examples, like maybe you have a new user

188
00:07:31,280 --> 00:07:33,720
who signs up to your app,

189
00:07:33,720 --> 00:07:36,080
and that results in their information being stored

190
00:07:36,080 --> 00:07:37,520
in your customer's database,

191
00:07:37,520 --> 00:07:39,280
and then you wanna execute some logic

192
00:07:39,280 --> 00:07:41,880
in response to that new database item.

193
00:07:41,880 --> 00:07:43,760
So maybe send them a welcome email

194
00:07:43,760 --> 00:07:46,240
or do some processing of their input data.

195
00:07:47,160 --> 00:07:49,960
You could have like a user uploads an image to the app,

196
00:07:49,960 --> 00:07:51,640
maybe you wanna generate a thumbnail

197
00:07:51,640 --> 00:07:55,400
as soon as that image is stored in your object store.

198
00:07:55,400 --> 00:07:56,880
And you can do other things,

199
00:07:56,880 --> 00:07:59,160
sentiment analysis on text that a user has input,

200
00:07:59,160 --> 00:08:02,120
literally anything you just want your code

201
00:08:02,120 --> 00:08:04,780
to react to a particular event.

202
00:08:04,780 --> 00:08:07,600
So typically, serverless platforms are gonna provide

203
00:08:07,600 --> 00:08:10,000
that infrastructure for you to easily react

204
00:08:10,000 --> 00:08:11,800
to those events with your code.

205
00:08:15,400 --> 00:08:18,520
So many of the cloud platforms offer

206
00:08:18,520 --> 00:08:20,480
a number of different services you can integrate

207
00:08:20,480 --> 00:08:21,920
with your applications.

208
00:08:21,920 --> 00:08:24,280
So these are things like artificial intelligence,

209
00:08:24,280 --> 00:08:27,920
IoT platforms, object storage, or databases.

210
00:08:27,920 --> 00:08:30,000
So think of some of the things you can do

211
00:08:30,000 --> 00:08:32,920
if you connect up with, like I'm writing them,

212
00:08:32,920 --> 00:08:37,560
so the Watson APIs, or maybe the Alexa APIs from Amazon.

213
00:08:38,480 --> 00:08:40,680
You're using those in conjunction with your application.

214
00:08:40,680 --> 00:08:42,400
Most of the serverless solutions provided

215
00:08:42,400 --> 00:08:45,240
by the various cloud providers really wanna make

216
00:08:45,240 --> 00:08:47,000
that connection very seamless.

217
00:08:47,000 --> 00:08:48,960
Like they're really incentivized for you to go off

218
00:08:48,960 --> 00:08:50,920
and use their other services, right?

219
00:08:50,920 --> 00:08:52,880
So if you're using their platform,

220
00:08:52,880 --> 00:08:54,880
they wanna make it super easy for you to connect up

221
00:08:54,880 --> 00:08:56,460
with their various services.

222
00:08:56,460 --> 00:08:59,880
So I think as you're looking at maybe moving some workloads

223
00:08:59,880 --> 00:09:01,760
over to serverless, definitely look into

224
00:09:01,760 --> 00:09:03,840
what integrations are provided.

225
00:09:04,680 --> 00:09:06,280
See what other services you can easily

226
00:09:06,280 --> 00:09:09,000
and seamlessly connect up to and react to.

227
00:09:12,280 --> 00:09:15,480
So ultimately, all of these promises are trying

228
00:09:15,480 --> 00:09:17,480
to achieve this overarching goal

229
00:09:17,480 --> 00:09:19,240
of decreased time to market.

230
00:09:19,240 --> 00:09:21,600
And they're all attempting to help developers focus

231
00:09:21,600 --> 00:09:24,520
on just business value and their value to the users

232
00:09:24,520 --> 00:09:27,520
and not on infrastructure or configuration.

233
00:09:27,520 --> 00:09:30,860
I really like this quote from serverless.com.

234
00:09:30,860 --> 00:09:35,480
It says, serverless abstracts away the most menial parts

235
00:09:35,480 --> 00:09:38,640
of building an application, leaving developers free

236
00:09:38,640 --> 00:09:40,680
to actually spend their days coding.

237
00:09:40,680 --> 00:09:43,440
So I think that's kind of the dream of serverless

238
00:09:43,440 --> 00:09:45,200
that people are hoping to realize.

239
00:09:47,760 --> 00:09:50,700
So there's a few use cases that are emerging

240
00:09:50,700 --> 00:09:53,560
as really a nice fit for the serverless space.

241
00:09:54,760 --> 00:09:57,240
First one is web application backends.

242
00:09:57,240 --> 00:09:59,960
So you have a front end and it's making some calls

243
00:09:59,960 --> 00:10:02,000
to some backend APIs.

244
00:10:02,000 --> 00:10:05,000
Each of those endpoints for your APIs can be functions

245
00:10:05,000 --> 00:10:07,440
that are created in a serverless platform.

246
00:10:07,440 --> 00:10:09,760
A mobile backend super similar

247
00:10:09,760 --> 00:10:11,320
to the web application use case,

248
00:10:11,320 --> 00:10:13,880
except the front end is mobile.

249
00:10:13,880 --> 00:10:16,120
Internet of things, so just because a lot

250
00:10:16,120 --> 00:10:18,180
of the serverless platforms can help you connect up

251
00:10:18,180 --> 00:10:21,840
with some kind of IoT platform on the provider's cloud.

252
00:10:23,240 --> 00:10:26,480
Scheduled tasks, so let's say you maybe have some code

253
00:10:26,480 --> 00:10:29,840
that you wanna run once a week or maybe once a month.

254
00:10:29,840 --> 00:10:32,920
You can set up a chronological trigger for that code

255
00:10:32,920 --> 00:10:35,480
to be spun up on maybe Wednesdays to run.

256
00:10:35,480 --> 00:10:38,480
And then after it finishes, it spins back down.

257
00:10:38,480 --> 00:10:40,560
You're no longer being charged for those resources

258
00:10:40,560 --> 00:10:42,000
that are being used.

259
00:10:42,000 --> 00:10:44,520
So you don't have to have the server up all week

260
00:10:44,520 --> 00:10:48,120
just to run that code once a week.

261
00:10:49,400 --> 00:10:52,360
Conversational scenarios, so this is things

262
00:10:52,360 --> 00:10:55,240
like chat clients where you maybe wanna do

263
00:10:55,240 --> 00:10:57,880
some additional processing on the chats

264
00:10:57,880 --> 00:10:58,720
that are coming through.

265
00:10:58,720 --> 00:11:00,400
So like maybe translating the text

266
00:11:00,400 --> 00:11:01,960
or filtering out bad words

267
00:11:01,960 --> 00:11:05,600
or doing some other processing on that text.

268
00:11:05,600 --> 00:11:07,400
And then finally, data processing.

269
00:11:07,400 --> 00:11:10,040
So this is literally anything where you get that new item

270
00:11:10,040 --> 00:11:12,200
in your data store and you wanna react to that

271
00:11:12,200 --> 00:11:14,160
with some kind of processing.

272
00:11:14,160 --> 00:11:17,880
So this can be things like normalizing audio inputs,

273
00:11:17,880 --> 00:11:21,840
image resizing, address verification, anything like that.

274
00:11:22,780 --> 00:11:25,160
So today, I wanted to quickly check out

275
00:11:25,160 --> 00:11:29,480
a real life use case on a mobile backend architecture

276
00:11:29,480 --> 00:11:31,520
so you can kind of start to get an idea

277
00:11:31,560 --> 00:11:34,520
for how you might architect your serverless apps.

278
00:11:36,760 --> 00:11:38,400
So the application I'm gonna talk about

279
00:11:38,400 --> 00:11:40,680
is called Weather Gods.

280
00:11:40,680 --> 00:11:42,480
It's this kind of cool, creative way

281
00:11:42,480 --> 00:11:44,800
for people to interact with the weather.

282
00:11:44,800 --> 00:11:48,520
I think it's like 2.99 on the app store.

283
00:11:48,520 --> 00:11:51,520
And they have this kind of creative way

284
00:11:51,520 --> 00:11:52,360
to interact with the weather.

285
00:11:52,360 --> 00:11:55,080
So the weather is represented as various gods.

286
00:11:55,080 --> 00:11:57,520
So there's like a fire god for heat,

287
00:11:57,520 --> 00:11:59,980
there's an ice god for winter weather,

288
00:11:59,980 --> 00:12:01,940
water god for rain and precipitation, et cetera.

289
00:12:01,940 --> 00:12:03,900
I think there's like six gods.

290
00:12:03,900 --> 00:12:06,260
Maybe I can't keep up with them all.

291
00:12:06,260 --> 00:12:09,500
But users can click through the various weather events

292
00:12:09,500 --> 00:12:12,740
or they can subscribe to specific notifications.

293
00:12:12,740 --> 00:12:16,740
So I actually used to live here in Austin.

294
00:12:16,740 --> 00:12:19,180
So when I was living here, I think it's pretty unlikely

295
00:12:19,180 --> 00:12:23,180
that I would subscribe to notifications for high UV

296
00:12:23,180 --> 00:12:24,800
since that's basically all the time.

297
00:12:24,800 --> 00:12:26,700
It was always high here.

298
00:12:26,700 --> 00:12:28,540
But downtown where I lived,

299
00:12:28,540 --> 00:12:30,580
there would sometimes be flooding issues

300
00:12:30,580 --> 00:12:34,620
or sometimes there would be like hail here.

301
00:12:34,620 --> 00:12:35,980
So I'd probably go ahead and subscribe

302
00:12:35,980 --> 00:12:40,060
to like water god notifications or ice god notifications.

303
00:12:40,060 --> 00:12:42,000
That's kind of how the app works.

304
00:12:42,900 --> 00:12:46,460
This is the architecture for how they did their backend.

305
00:12:46,460 --> 00:12:47,980
Obviously they have a mobile front end

306
00:12:47,980 --> 00:12:49,420
that interacts with this backend,

307
00:12:49,420 --> 00:12:51,020
which isn't pictured there.

308
00:12:51,020 --> 00:12:53,260
Oh no, actually this is over on the right.

309
00:12:53,260 --> 00:12:55,780
So each of the little green functions

310
00:12:55,780 --> 00:12:58,660
are the functions that they created.

311
00:12:58,660 --> 00:13:00,980
I'll kind of quickly walk you guys through this

312
00:13:00,980 --> 00:13:03,220
and then we'll take a step back

313
00:13:03,220 --> 00:13:05,260
to talk about why they chose serverless.

314
00:13:06,140 --> 00:13:07,980
So the first thing that happens

315
00:13:07,980 --> 00:13:10,300
is they have this chronological trigger

316
00:13:10,300 --> 00:13:13,740
that's gonna query a subset of their users

317
00:13:13,740 --> 00:13:16,840
which are stored in a Couch NoSQL DB.

318
00:13:16,840 --> 00:13:18,540
And then the group scanner action

319
00:13:18,540 --> 00:13:21,900
is gonna determine the locations and weather conditions

320
00:13:21,900 --> 00:13:24,300
that those particular users are interested in.

321
00:13:25,940 --> 00:13:28,460
Then the next action is just a weather checker

322
00:13:28,460 --> 00:13:30,100
and that makes a call out

323
00:13:30,100 --> 00:13:32,900
to the weather channel data service,

324
00:13:32,900 --> 00:13:37,300
parses and handles the data that it gets back,

325
00:13:37,300 --> 00:13:40,540
gets it into the right format for their next action

326
00:13:40,540 --> 00:13:43,980
and goes ahead and writes that into the weather database.

327
00:13:43,980 --> 00:13:46,860
And then as weather gets updated into the database,

328
00:13:46,860 --> 00:13:50,180
that will trigger a scanner for each user

329
00:13:50,180 --> 00:13:53,060
that's interested in that particular type of data.

330
00:13:53,060 --> 00:13:56,660
So let's say a user's interested in snow in New York

331
00:13:56,660 --> 00:13:58,220
and rain in Austin,

332
00:13:58,220 --> 00:14:00,260
only those two scanners are invoked

333
00:14:00,260 --> 00:14:01,860
for that particular user.

334
00:14:01,860 --> 00:14:03,620
The scanners are run in parallel

335
00:14:03,620 --> 00:14:05,940
so that gives them some performance benefits

336
00:14:05,940 --> 00:14:09,080
and then of course they're also able to scale up

337
00:14:09,080 --> 00:14:10,900
and back down independently.

338
00:14:11,780 --> 00:14:15,460
And then once the scanner finds interesting data

339
00:14:15,460 --> 00:14:18,120
for the user, it'll send a notification

340
00:14:18,120 --> 00:14:20,100
using the push notification service.

341
00:14:23,840 --> 00:14:25,780
So what about this architecture makes it

342
00:14:25,780 --> 00:14:27,820
a really nice fit for serverless?

343
00:14:27,820 --> 00:14:30,220
There's a few different points I wanna highlight.

344
00:14:31,220 --> 00:14:32,700
Integrated platform services,

345
00:14:32,700 --> 00:14:34,940
so they were able to really easily consume

346
00:14:34,940 --> 00:14:37,020
some services from their cloud platform.

347
00:14:37,020 --> 00:14:39,020
In this case, a notification service,

348
00:14:39,020 --> 00:14:42,380
a database as a service and the weather company data API.

349
00:14:42,380 --> 00:14:43,740
So those are all pieces of their app

350
00:14:43,740 --> 00:14:44,820
but they don't have to wait,

351
00:14:44,820 --> 00:14:47,680
they're just consuming some services.

352
00:14:47,680 --> 00:14:49,740
They were also able to regularly schedule their code

353
00:14:49,740 --> 00:14:52,740
to run in reaction to a trigger every three minutes.

354
00:14:53,940 --> 00:14:57,660
A bunch of their code was running in reaction to events.

355
00:14:57,660 --> 00:14:59,340
So they want to run weather checks

356
00:14:59,340 --> 00:15:01,980
when a new user location is updated,

357
00:15:01,980 --> 00:15:04,700
they wanted to react to new users in their database

358
00:15:04,700 --> 00:15:06,620
and of course whenever there's a new weather item

359
00:15:06,620 --> 00:15:10,660
of interest, they wanna react to that as well.

360
00:15:10,660 --> 00:15:13,960
And then finally they had the really nice scanner section

361
00:15:13,960 --> 00:15:16,620
where the code could be executed in parallel

362
00:15:16,620 --> 00:15:18,400
and independently.

363
00:15:18,400 --> 00:15:21,520
So if a ton of their users are only interested in rain,

364
00:15:21,520 --> 00:15:23,640
then that rain scanner code can be scaled up

365
00:15:23,640 --> 00:15:25,880
independently of the other events.

366
00:15:25,880 --> 00:15:28,400
Alternatively, let's say no one's interested

367
00:15:28,400 --> 00:15:29,960
in a particular weather event,

368
00:15:29,960 --> 00:15:31,960
that code's not being called

369
00:15:31,960 --> 00:15:34,820
as ultimately they're not being charged for it.

370
00:15:34,820 --> 00:15:37,160
So finding those elements of your application

371
00:15:37,160 --> 00:15:39,840
where you can really benefit from running in parallel

372
00:15:39,840 --> 00:15:43,320
and scaling out independently can make a good use case

373
00:15:43,320 --> 00:15:45,820
for serverless for that particular piece.

374
00:15:46,820 --> 00:15:49,300
And then the last thing I wanted to highlight

375
00:15:49,300 --> 00:15:51,100
about weather gods in particular

376
00:15:51,100 --> 00:15:52,900
is that they didn't actually start out

377
00:15:52,900 --> 00:15:55,540
as a fully serverless backend like this.

378
00:15:56,540 --> 00:15:58,340
They already had their item and they realized,

379
00:15:58,340 --> 00:16:01,460
okay, certain pieces of this would actually benefit

380
00:16:01,460 --> 00:16:04,260
from being run on a serverless platform

381
00:16:04,260 --> 00:16:06,660
and so they kind of transitioned those elements over

382
00:16:06,660 --> 00:16:09,340
piece by piece as it made sense for them.

383
00:16:11,780 --> 00:16:15,260
So let's say you're ready to write your next serverless app,

384
00:16:15,260 --> 00:16:16,500
how do you get started?

385
00:16:18,340 --> 00:16:20,500
So you have some options.

386
00:16:20,500 --> 00:16:22,580
These are some of the major players in this space

387
00:16:22,580 --> 00:16:24,580
and listed them in alphabetical order.

388
00:16:24,580 --> 00:16:27,900
So the first one is Azure Functions from Microsoft.

389
00:16:27,900 --> 00:16:31,540
They have a Python runtime, but it's currently in preview.

390
00:16:31,540 --> 00:16:34,780
So it hasn't fully become general availability yet,

391
00:16:34,780 --> 00:16:37,740
but I would assume that because it's in preview,

392
00:16:37,740 --> 00:16:40,180
they're heading in that direction.

393
00:16:40,180 --> 00:16:43,420
Lambda from Amazon supports Python out of the box.

394
00:16:44,420 --> 00:16:45,740
Apache OpenWhisk.

395
00:16:45,740 --> 00:16:49,740
So this is an open source Apache incubator project

396
00:16:49,740 --> 00:16:51,300
and this would be really nice

397
00:16:51,300 --> 00:16:53,060
maybe if you need something open source

398
00:16:53,060 --> 00:16:55,660
or you want to host and manage your own instance

399
00:16:55,660 --> 00:16:58,900
of a serverless platform for the rest of your company.

400
00:16:58,900 --> 00:17:02,060
IBM Cloud Functions is based on OpenWhisk

401
00:17:02,060 --> 00:17:05,820
and it's basically just managed and hosted

402
00:17:05,820 --> 00:17:07,740
OpenWhisk on IBM Cloud.

403
00:17:07,740 --> 00:17:10,020
And it also supports Python out of the box

404
00:17:10,020 --> 00:17:11,620
and this is the one that we'll check out

405
00:17:11,620 --> 00:17:14,140
in a demo in a couple of minutes.

406
00:17:14,140 --> 00:17:17,060
And then finally, I know a little less about it,

407
00:17:17,060 --> 00:17:17,980
but I think it would be interesting

408
00:17:17,980 --> 00:17:20,340
to check out Python Anywhere.

409
00:17:20,340 --> 00:17:22,460
So I did a few minutes just kind of checking it out

410
00:17:22,460 --> 00:17:23,300
and playing with it.

411
00:17:23,300 --> 00:17:24,860
It seems like it's a little more focused

412
00:17:24,860 --> 00:17:27,000
on web hosting and education use cases,

413
00:17:27,000 --> 00:17:28,460
but I think it's just kind of a good one

414
00:17:28,460 --> 00:17:29,760
to highlight and check out.

415
00:17:32,660 --> 00:17:34,380
So let's take a quick peek

416
00:17:34,380 --> 00:17:36,500
at what a function might look like.

417
00:17:36,500 --> 00:17:39,740
You can see a really simple example up here.

418
00:17:39,740 --> 00:17:40,700
It should look familiar.

419
00:17:40,700 --> 00:17:42,020
It looks like Python code.

420
00:17:42,020 --> 00:17:44,860
So it's a straightforward hello world function

421
00:17:44,860 --> 00:17:46,660
and it's just gonna check and see

422
00:17:46,660 --> 00:17:49,660
if it got name passed in as a parameter.

423
00:17:49,660 --> 00:17:52,060
If not, it'll return hello stranger.

424
00:17:52,060 --> 00:17:53,500
Otherwise, it's gonna return hello

425
00:17:53,500 --> 00:17:55,860
with the name that was passed in.

426
00:17:55,860 --> 00:17:58,500
So for OpenWhisk and IBM Cloud Functions,

427
00:17:58,500 --> 00:18:01,540
the expected input and output is JSON.

428
00:18:01,540 --> 00:18:04,940
So you can tie your various functions together with JSON.

429
00:18:04,940 --> 00:18:08,580
So let's say you have three functions in a sequence.

430
00:18:08,620 --> 00:18:10,820
The first one outputs some JSON.

431
00:18:10,820 --> 00:18:13,020
That'll be the input for the next one.

432
00:18:13,020 --> 00:18:14,060
That'll output some JSON,

433
00:18:14,060 --> 00:18:15,460
which will be the input for the next one.

434
00:18:15,460 --> 00:18:17,860
So that's how you kind of tie them together.

435
00:18:17,860 --> 00:18:20,380
And then the expected entry point

436
00:18:20,380 --> 00:18:22,300
is just a function named main.

437
00:18:22,300 --> 00:18:25,820
So you can have other functions defined in the file,

438
00:18:25,820 --> 00:18:28,140
but main is the expected entry point.

439
00:18:30,580 --> 00:18:34,060
So we'll see kind of a quick live demo of this in action.

440
00:18:34,060 --> 00:18:36,300
Like I said, I'll be using IBM Cloud Functions,

441
00:18:36,300 --> 00:18:38,420
which is managed OpenWhisk.

442
00:18:38,420 --> 00:18:40,740
You can really take these and apply it

443
00:18:40,740 --> 00:18:42,400
to any serverless platform you want.

444
00:18:42,400 --> 00:18:44,380
So it should look and feel very similar

445
00:18:44,380 --> 00:18:47,260
to a lot of the other serverless platforms.

446
00:18:47,260 --> 00:18:50,460
So for our example, we'll say we have this image.

447
00:18:50,460 --> 00:18:52,460
It's a really cute puppy image.

448
00:18:52,460 --> 00:18:54,460
And we'll say that it's getting uploaded

449
00:18:54,460 --> 00:18:57,340
to our cloud object storage or database

450
00:18:57,340 --> 00:18:59,540
from a mobile app or UI.

451
00:18:59,540 --> 00:19:01,260
And we wanna react to this uploaded image

452
00:19:01,260 --> 00:19:03,220
by running some code.

453
00:19:03,220 --> 00:19:06,260
So in our case, maybe we wanna do some image analysis.

454
00:19:06,260 --> 00:19:08,500
So what's actually in the image?

455
00:19:08,500 --> 00:19:11,140
So if we upload this really cute puppy picture,

456
00:19:11,140 --> 00:19:13,780
we wanna see some output like Bernie's mountain dog

457
00:19:13,780 --> 00:19:15,180
or dog or animal.

458
00:19:17,620 --> 00:19:19,220
So this is an architecture diagram

459
00:19:19,220 --> 00:19:22,020
for how we might create something like this.

460
00:19:22,020 --> 00:19:23,900
When there's a new image URL that's uploaded

461
00:19:23,900 --> 00:19:28,140
into the database, that should trigger an action to get run.

462
00:19:28,140 --> 00:19:29,580
In this case, I divided that action

463
00:19:29,580 --> 00:19:31,680
into two separate functions.

464
00:19:31,680 --> 00:19:34,920
So one function is responsible for reading the changes

465
00:19:34,920 --> 00:19:36,800
that occurred in the database.

466
00:19:36,800 --> 00:19:39,340
That's the read changes from db action.

467
00:19:39,340 --> 00:19:43,000
And then that action will parse the changes,

468
00:19:43,000 --> 00:19:45,980
output the URL to a new image in the database,

469
00:19:47,860 --> 00:19:51,560
and then hand that URL off to the get tags action.

470
00:19:51,560 --> 00:19:54,600
So then the get tags action will actually make a call out

471
00:19:54,600 --> 00:19:56,960
to a visual recognition service,

472
00:19:56,960 --> 00:19:58,460
do some parsing of the return value,

473
00:19:58,460 --> 00:20:02,280
and hopefully output what it believes is in our image.

474
00:20:02,280 --> 00:20:04,180
So this is a really simple use case,

475
00:20:04,180 --> 00:20:06,860
but you could definitely continue building on this, right?

476
00:20:06,860 --> 00:20:10,480
You could save tags back into the database.

477
00:20:10,480 --> 00:20:12,800
You could add an action for compressing

478
00:20:12,800 --> 00:20:14,320
a really large image if you use

479
00:20:14,320 --> 00:20:16,020
or upload something too large.

480
00:20:16,980 --> 00:20:20,280
You could do things like handling video uploads

481
00:20:20,280 --> 00:20:23,720
by creating another function that breaks apart the video

482
00:20:23,720 --> 00:20:26,760
into multiple frames, and then running the get tags

483
00:20:26,760 --> 00:20:29,640
on each frame, and that would be able to scale up

484
00:20:29,640 --> 00:20:30,880
kind of independently.

485
00:20:31,880 --> 00:20:35,820
Each of my functions gets scaling out of the box,

486
00:20:35,820 --> 00:20:38,420
so I don't have to do anything special.

487
00:20:42,060 --> 00:20:43,660
So let's check this out.

488
00:20:43,660 --> 00:20:46,640
This is gonna be live, so fingers crossed.

489
00:20:50,420 --> 00:20:53,620
So this is just our get tags action

490
00:20:53,620 --> 00:20:55,060
that I talked about earlier.

491
00:20:55,060 --> 00:20:56,660
Should look super familiar,

492
00:20:56,660 --> 00:20:59,960
just some Python code that we have.

493
00:20:59,980 --> 00:21:02,020
And I'm gonna kinda walk through a couple pieces of it.

494
00:21:02,020 --> 00:21:03,940
So the first thing that's happening

495
00:21:03,940 --> 00:21:07,380
is we're gonna pull in this Visual Recognition SDK.

496
00:21:07,380 --> 00:21:08,740
So what that should imply to you

497
00:21:08,740 --> 00:21:11,100
is that Visual Recognition SDK

498
00:21:11,100 --> 00:21:12,900
is provided as a part of the runtime,

499
00:21:12,900 --> 00:21:15,960
so it's just already there in the runtime.

500
00:21:15,960 --> 00:21:18,560
And then we're gonna do a couple of things.

501
00:21:18,560 --> 00:21:23,020
I need to instantiate that with an API key

502
00:21:23,020 --> 00:21:24,760
and a version number.

503
00:21:24,760 --> 00:21:27,380
The API key will actually pull in

504
00:21:27,380 --> 00:21:29,500
from parameters for this action,

505
00:21:29,500 --> 00:21:32,760
so we should be able to pass in parameters into our action.

506
00:21:34,120 --> 00:21:37,600
In this particular case, that API key doesn't change,

507
00:21:37,600 --> 00:21:40,540
so I can actually store it as a stored parameter

508
00:21:40,540 --> 00:21:41,920
for this particular action.

509
00:21:41,920 --> 00:21:43,720
So if we click on parameters,

510
00:21:43,720 --> 00:21:46,440
you see, okay, I've got this API key that's stored in here

511
00:21:46,440 --> 00:21:50,160
and it'll just be safe for that action.

512
00:21:50,160 --> 00:21:52,640
I'll make sure I revoke that right after this.

513
00:21:54,240 --> 00:21:57,960
And then the next thing is

514
00:21:57,980 --> 00:22:00,060
that we'll wanna pass in an image URL,

515
00:22:00,060 --> 00:22:03,300
so that's the image that we wanna get the tags for.

516
00:22:03,300 --> 00:22:06,060
And then finally, we'll make a call out to that

517
00:22:06,060 --> 00:22:08,840
visualrecognition.classify right here.

518
00:22:08,840 --> 00:22:11,060
And then we'll just do a little bit of parsing

519
00:22:11,060 --> 00:22:12,900
the return data, because it has some info in there

520
00:22:12,900 --> 00:22:14,260
that we don't care about,

521
00:22:14,260 --> 00:22:16,540
and then we'll print out the tags.

522
00:22:17,580 --> 00:22:19,700
So let's try that out.

523
00:22:19,700 --> 00:22:24,100
This is our little puppy picture, so it's cute.

524
00:22:24,100 --> 00:22:25,900
And if we do change input,

525
00:22:25,900 --> 00:22:27,880
we can go in here and make sure

526
00:22:29,080 --> 00:22:30,440
we have that image in there, and it is,

527
00:22:30,440 --> 00:22:31,360
so we can click apply.

528
00:22:31,360 --> 00:22:33,840
So we're passing this in as a parameter.

529
00:22:33,840 --> 00:22:38,520
And then if we click invoke, we should hopefully see, yes.

530
00:22:38,520 --> 00:22:40,080
So we see some tags back.

531
00:22:40,080 --> 00:22:43,840
So it says puppy, dog, laboratory retriever dog,

532
00:22:43,840 --> 00:22:45,440
retriever dog, golden retriever dog,

533
00:22:45,440 --> 00:22:46,800
so just some different tags

534
00:22:46,800 --> 00:22:48,860
of what the visual recognition service thinks

535
00:22:48,860 --> 00:22:50,040
is in that image.

536
00:22:50,920 --> 00:22:53,440
But that's not all we want it to do.

537
00:22:53,440 --> 00:22:55,980
We actually said we want it to react to the image

538
00:22:55,980 --> 00:22:59,860
when there's a new image stored in the database, right?

539
00:23:00,780 --> 00:23:03,540
So let's see how we set that up.

540
00:23:03,540 --> 00:23:07,180
This is inside of a sequence,

541
00:23:07,180 --> 00:23:09,220
and that sequence contains two actions.

542
00:23:09,220 --> 00:23:11,660
So there's the read from database action,

543
00:23:11,660 --> 00:23:13,460
and then there's the get tags action.

544
00:23:14,380 --> 00:23:19,380
And so the sequence gets kicked off by a trigger.

545
00:23:19,380 --> 00:23:20,620
So if we go back and connect to triggers,

546
00:23:20,620 --> 00:23:23,180
we can see, okay, there's this cloud image trigger.

547
00:23:23,800 --> 00:23:26,640
So anytime a new item gets added to the cloud database,

548
00:23:26,640 --> 00:23:28,560
then that trigger will be fired.

549
00:23:28,560 --> 00:23:30,400
So let's try that out really quick.

550
00:23:30,400 --> 00:23:32,620
So I'll grab this image,

551
00:23:32,620 --> 00:23:34,480
and then I already have cloud open.

552
00:23:35,880 --> 00:23:38,080
Oh, it wants me to log in again.

553
00:23:42,160 --> 00:23:44,720
So you can see I already have a database created

554
00:23:44,720 --> 00:23:46,520
called my image URLs.

555
00:23:46,520 --> 00:23:48,320
I can create a new document in here.

556
00:23:48,320 --> 00:23:52,080
So I'm just gonna create image URL,

557
00:23:52,140 --> 00:23:54,700
and I'm trying to fly because I have five minutes left.

558
00:23:54,700 --> 00:23:57,700
And then I'll just click create document.

559
00:23:57,700 --> 00:23:59,580
And then what that's gonna do hopefully

560
00:23:59,580 --> 00:24:01,460
is cause my trigger to fire,

561
00:24:01,460 --> 00:24:04,640
which will then kick off that sequence.

562
00:24:04,640 --> 00:24:07,500
The first action was to read from the cloud database

563
00:24:07,500 --> 00:24:08,780
whatever changes happen,

564
00:24:08,780 --> 00:24:10,860
and then the second action was to get the tags.

565
00:24:10,860 --> 00:24:13,060
So if we go over here,

566
00:24:13,060 --> 00:24:16,900
and then go over to the little monitor tab,

567
00:24:16,900 --> 00:24:19,100
hopefully we should see that it was called.

568
00:24:22,780 --> 00:24:25,660
Yeah, and so at 11 o'clock,

569
00:24:25,660 --> 00:24:28,220
we can see, I don't know how to make this bigger,

570
00:24:28,220 --> 00:24:33,220
but we can see that the trigger was fired at 11.

571
00:24:33,260 --> 00:24:35,540
There was a sequence that was called,

572
00:24:35,540 --> 00:24:37,300
and then the read action,

573
00:24:37,300 --> 00:24:39,220
and then they get tags action.

574
00:24:39,220 --> 00:24:42,340
And each action has an activation ID associated with it.

575
00:24:42,340 --> 00:24:44,460
So if we click that activation ID,

576
00:24:45,380 --> 00:24:47,940
we should be able to see the results in there.

577
00:24:47,940 --> 00:24:50,060
So we have the logs, just the printing out,

578
00:24:50,060 --> 00:24:52,440
and then of course the various tags.

579
00:24:54,280 --> 00:24:55,120
That's just a little bit,

580
00:24:55,120 --> 00:24:56,960
and actually, yay, that worked, live demo.

581
00:24:58,240 --> 00:24:59,280
I always get nervous.

582
00:25:01,520 --> 00:25:02,720
Oh, let me stop mirroring.

583
00:25:14,680 --> 00:25:16,160
Okay, perfect.

584
00:25:16,160 --> 00:25:17,720
So I don't have too much time left,

585
00:25:17,720 --> 00:25:19,500
but I did wanna quickly highlight,

586
00:25:21,000 --> 00:25:21,840
I wanted to highlight

587
00:25:21,840 --> 00:25:24,400
one of the Python-specific libraries that's out there.

588
00:25:24,400 --> 00:25:26,400
It's called Pyren.

589
00:25:26,400 --> 00:25:31,400
So what it does, it has this goal of making a really easy

590
00:25:31,680 --> 00:25:34,000
push-to-cloud experience for Python developers.

591
00:25:34,000 --> 00:25:38,480
So maybe if you have a super parallel workload,

592
00:25:39,600 --> 00:25:41,240
and a parallel workload is something

593
00:25:41,240 --> 00:25:43,120
where you have little or no effort

594
00:25:43,120 --> 00:25:44,960
that's needed to separate the problem

595
00:25:44,960 --> 00:25:47,880
into these number of parallel tasks.

596
00:25:47,880 --> 00:25:52,240
So common examples might be like 3D video rendering,

597
00:25:52,240 --> 00:25:56,560
handled by GPU, where you want to run some code

598
00:25:56,560 --> 00:25:58,600
for each frame, or maybe for each pixel

599
00:25:58,600 --> 00:26:00,040
if you're doing ray tracing,

600
00:26:00,040 --> 00:26:01,160
and those can all be handled

601
00:26:01,160 --> 00:26:03,960
without any interdependency between them.

602
00:26:04,980 --> 00:26:06,360
So Pyren is this library

603
00:26:06,360 --> 00:26:09,160
where you can take your Python workloads,

604
00:26:09,160 --> 00:26:11,180
scale it out into multiple functions

605
00:26:11,180 --> 00:26:13,120
to be run on a serverless platform.

606
00:26:13,520 --> 00:26:16,320
So really their goal, like I said,

607
00:26:16,320 --> 00:26:18,680
is to simplify that push-to-cloud experience,

608
00:26:18,680 --> 00:26:19,880
and you can run your algorithm

609
00:26:19,880 --> 00:26:21,520
against a cluster of machines

610
00:26:21,520 --> 00:26:23,920
without needing to figure out how do I set that up,

611
00:26:23,920 --> 00:26:25,760
or how do I have those machines talk to each other,

612
00:26:25,760 --> 00:26:27,480
how do I get the results back.

613
00:26:30,520 --> 00:26:33,440
Pyren was originally built for Amazon Lambda,

614
00:26:33,440 --> 00:26:35,520
and it's also available for IBM Cloud Functions,

615
00:26:35,520 --> 00:26:40,520
so go check out this article to learn a little bit more.

616
00:26:40,800 --> 00:26:42,840
It talks about using Pyren for scenarios

617
00:26:43,520 --> 00:26:45,360
where you have a lot of data processing to do.

618
00:26:45,360 --> 00:26:47,120
And the two examples they talk about

619
00:26:47,120 --> 00:26:50,280
were the really large data sets like solar flares,

620
00:26:50,280 --> 00:26:52,360
which can help predict storms

621
00:26:52,360 --> 00:26:55,040
that can hamper power or satellite operations,

622
00:26:55,040 --> 00:26:56,960
and then they also talked about

623
00:26:56,960 --> 00:26:59,040
just the sheer volume of data

624
00:26:59,040 --> 00:27:01,480
when looking at how neurons combine

625
00:27:01,480 --> 00:27:04,440
to create behaviors or disease or cognition,

626
00:27:04,440 --> 00:27:08,160
and their big goal is to really easily give access

627
00:27:08,160 --> 00:27:11,040
to parallel computing to data scientists and others.

628
00:27:12,000 --> 00:27:14,080
There's another article you can check out.

629
00:27:14,080 --> 00:27:15,960
Like I said, it's built for Amazon Lambda

630
00:27:15,960 --> 00:27:19,040
and has recently been ported to IBM Cloud Functions.

631
00:27:19,040 --> 00:27:22,200
So this article is about using Pyren

632
00:27:22,200 --> 00:27:24,880
for running stock market predictions

633
00:27:24,880 --> 00:27:27,280
through the money car loan method.

634
00:27:27,280 --> 00:27:28,960
So it uses Pyren to scale out

635
00:27:28,960 --> 00:27:30,320
and then combine the results

636
00:27:30,320 --> 00:27:33,080
from those simultaneously running predictions.

637
00:27:36,120 --> 00:27:39,080
So that's all I had, just a couple of quick notes.

638
00:27:39,080 --> 00:27:42,400
You can go check out IBM Cloud Functions.

639
00:27:42,400 --> 00:27:44,840
The first link, and then the last link

640
00:27:44,840 --> 00:27:48,440
is for the Apache OpenList project.

641
00:27:48,440 --> 00:27:51,000
So if you're looking for a new open source project

642
00:27:51,000 --> 00:27:53,560
to be a contributor on, it's a really fun one.

643
00:27:53,560 --> 00:27:55,600
The community is really nice.

644
00:27:55,600 --> 00:27:56,800
So that's all.

645
00:27:56,800 --> 00:27:57,640
Thank you so much.

646
00:27:57,880 --> 00:27:58,720
Thank you.

647
00:27:58,720 --> 00:27:59,560
Thank you.

