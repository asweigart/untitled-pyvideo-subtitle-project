1
00:00:00,000 --> 00:00:03,000
Our next talk is going to be Michael Lynch.

2
00:00:03,000 --> 00:00:07,000
He's going to give us a great talk about why good developers write bad tests.

3
00:00:07,000 --> 00:00:09,000
Let's give him a round of applause.

4
00:00:15,000 --> 00:00:18,000
Hello, everyone. Welcome. Thank you for coming.

5
00:00:18,000 --> 00:00:22,000
My name is Michael Lynch, and this talk is called Why Good Developers Write Bad Tests.

6
00:00:24,000 --> 00:00:27,000
So there's the answer. My whole talk is just these two bullet points.

7
00:00:28,000 --> 00:00:31,000
So for the next 30 minutes, we can take a nap or something.

8
00:00:31,000 --> 00:00:34,000
Now, you probably need some more convincing.

9
00:00:34,000 --> 00:00:38,000
So all of you in this room are good developers because you're here at Pi Texas.

10
00:00:38,000 --> 00:00:40,000
You're expanding your skills.

11
00:00:40,000 --> 00:00:45,000
You're willing to hear a talk from a new speaker who right off the bat accuses you of writing bad tests.

12
00:00:45,000 --> 00:00:51,000
So a problem that a lot of us have is that we learn a lot of these good practices in production code.

13
00:00:51,000 --> 00:00:55,000
Like, we learn to refactor our code to eliminate redundancy.

14
00:00:55,000 --> 00:00:58,000
We learn to write these small, tightly-scoped functions.

15
00:00:58,000 --> 00:01:02,000
And so we've been told they're good practices.

16
00:01:02,000 --> 00:01:05,000
And in fact, we're told that they're the best practices.

17
00:01:05,000 --> 00:01:11,000
And so when it comes time to write tests, we don't really question them because why would you question the best practices?

18
00:01:11,000 --> 00:01:13,000
We just keep using them.

19
00:01:13,000 --> 00:01:19,000
But in a lot of cases, applying these best practices from production code actually leads to worse test code.

20
00:01:19,000 --> 00:01:24,000
And throughout this talk, I want to give you a few examples of how that can happen.

21
00:01:25,000 --> 00:01:31,000
So before we get any further, just to clarify in semantics, I'm going to be talking mostly about unit tests.

22
00:01:31,000 --> 00:01:35,000
A lot of these techniques will apply to various kinds of testing.

23
00:01:35,000 --> 00:01:39,000
They apply best to unit tests, but they apply to others in general.

24
00:01:39,000 --> 00:01:42,000
We're going to keep talking about unit tests just to keep things concrete.

25
00:01:42,000 --> 00:01:47,000
And so unit tests, as Andy talked about yesterday, they're tests at the smallest level of granularity.

26
00:01:47,000 --> 00:01:51,000
So you're testing that a particular function is correct.

27
00:01:51,000 --> 00:01:56,000
So if we had a function called Fahrenheit to Celsius, here's a simple unit test.

28
00:01:56,000 --> 00:02:02,000
You'd pass it 212 degrees Fahrenheit, and we expect that the answer is 100 degrees Celsius.

29
00:02:02,000 --> 00:02:08,000
And so if this is ever not true, it means that something drastic has happened in the world of standard measurements

30
00:02:08,000 --> 00:02:12,000
or more likely you broke your code and you need to fix it.

31
00:02:12,000 --> 00:02:20,000
And so here's an example of an anti-pattern I see a lot with people who are really good at writing code

32
00:02:20,000 --> 00:02:23,000
but not so experienced at writing test code.

33
00:02:23,000 --> 00:02:27,000
So we're just going to walk through it. We're testing this class called account manager.

34
00:02:27,000 --> 00:02:31,000
We're calling self.accountManager.getScore for the user Joe123.

35
00:02:31,000 --> 00:02:35,000
We get the initial score, and we make sure the initial score is 150.

36
00:02:35,000 --> 00:02:37,000
So there's two big problems with this right off the bat.

37
00:02:37,000 --> 00:02:40,000
So first is, where did this Joe123 account come from?

38
00:02:40,000 --> 00:02:44,000
Why does account manager have Joe123? Is this just hard-coded?

39
00:02:44,000 --> 00:02:47,000
Every single account manager has a Joe123?

40
00:02:47,000 --> 00:02:52,000
And then similarly, why is Joe123 score 150? Where is that coming from?

41
00:02:52,000 --> 00:02:56,000
And so a lot of times when I see a test like this, the developer says, oh, the answer's in the setup.

42
00:02:56,000 --> 00:03:00,000
And so if you scroll up to the setup, and if you're not familiar,

43
00:03:00,000 --> 00:03:05,000
setup is the method that the unit test framework calls automatically before every test.

44
00:03:05,000 --> 00:03:08,000
So our setup, we're creating this mock database.

45
00:03:08,000 --> 00:03:15,000
It's got a row with Joe123 with a score of 150, and it assigns that to the account manager.

46
00:03:15,000 --> 00:03:19,000
And so the developer might say, okay, so all the answers are in the setup.

47
00:03:19,000 --> 00:03:24,000
And so this is a good test because everything you need is in the setup and in the test function itself.

48
00:03:24,000 --> 00:03:30,000
So I think this is actually a bad test. And throughout this talk, I'm going to explain why.

49
00:03:30,000 --> 00:03:34,000
So to understand, test code isn't like other code.

50
00:03:34,000 --> 00:03:39,000
So when we think about production code, it's too complex to read all at once.

51
00:03:40,000 --> 00:03:48,000
So if every application was 10 lines of code, we wouldn't need things like functions or classes or modules.

52
00:03:48,000 --> 00:03:51,000
You could just write those 10 lines and read them top to bottom.

53
00:03:51,000 --> 00:03:55,000
We invent all of these techniques and these things like functions and classes

54
00:03:55,000 --> 00:04:00,000
to break large bodies code into small consumable chunks.

55
00:04:00,000 --> 00:04:02,000
And so good production code is well factored.

56
00:04:02,000 --> 00:04:09,000
It allows us to think about these very complex pieces of code in small, narrowly scoped pieces.

57
00:04:09,000 --> 00:04:11,000
And so the components are in logical chunks.

58
00:04:11,000 --> 00:04:17,000
We break things into layers of abstraction where we can understand each thing in its own layer.

59
00:04:17,000 --> 00:04:19,000
Test code is very different.

60
00:04:19,000 --> 00:04:24,000
Test code, if you think about a unit test function, it basically is its own tiny application.

61
00:04:24,000 --> 00:04:29,000
It's very simple. It usually just starts up, calls one function, exits.

62
00:04:29,000 --> 00:04:31,000
But that's its own application.

63
00:04:31,000 --> 00:04:35,000
And so in the case of test code, it is simple enough to read top to bottom.

64
00:04:35,000 --> 00:04:39,000
Most unit tests, you could write them in just 10 lines of code.

65
00:04:39,000 --> 00:04:44,000
And so you don't need these things like classes and functions to break up the complexity.

66
00:04:44,000 --> 00:04:49,000
The other thing that's different about tests is that developers often read tests in isolation.

67
00:04:49,000 --> 00:04:57,000
It's not often that if you read a production function, if you read a member of a class, a method,

68
00:04:57,000 --> 00:05:00,000
often you have to read other parts of that class to understand it.

69
00:05:00,000 --> 00:05:02,000
You have to read the member variables.

70
00:05:02,000 --> 00:05:05,000
You have to read the other functions that it calls.

71
00:05:05,000 --> 00:05:11,000
If you have a unit test that fails, often reading that unit test and understanding that single function

72
00:05:11,000 --> 00:05:13,000
is enough to understand why it failed.

73
00:05:13,000 --> 00:05:18,000
You generally don't have to read other functions in that test suite to understand what went wrong.

74
00:05:18,000 --> 00:05:21,000
And lastly, tests must be correct by inspection.

75
00:05:21,000 --> 00:05:26,000
We have confidence that our production code is correct because we have tests that exercise it.

76
00:05:26,000 --> 00:05:31,000
You generally don't have tests for your tests because you would just end up in this infinite regression

77
00:05:31,000 --> 00:05:34,000
where you're writing tests for everything else that you're writing.

78
00:05:34,000 --> 00:05:39,000
And so tests, the last line of defense is the fact that you can read it and reason about it.

79
00:05:39,000 --> 00:05:42,000
And so good test code maximizes obviousness.

80
00:05:42,000 --> 00:05:47,000
It makes it so that you can quickly jump into a unit test if it fails

81
00:05:47,000 --> 00:05:51,000
and understand quickly what it's asserting and why it's failing currently.

82
00:05:51,000 --> 00:05:53,000
And it should minimize cognitive load.

83
00:05:53,000 --> 00:05:57,000
The more complex you make your unit test functions, the harder it is for developers to reason about it,

84
00:05:57,000 --> 00:06:02,000
the easier it is for them to overlook bugs that are in the test function.

85
00:06:02,000 --> 00:06:06,000
So I don't know if this comes up, sort of.

86
00:06:06,000 --> 00:06:08,000
So I took this in my basement.

87
00:06:08,000 --> 00:06:13,000
I've got a radon remediation system in my house that sucks air from below the floor of my basement

88
00:06:13,000 --> 00:06:21,000
out above the roof of my house to make sure I don't die of radon poisoning.

89
00:06:21,000 --> 00:06:26,000
And so it's got a very interesting unit test in that it's got a glass tube that's filled with liquid

90
00:06:26,000 --> 00:06:31,000
and the tube is connected by a straw into the vacuum tube.

91
00:06:31,000 --> 00:06:38,000
And so I know that the vacuum tube is creating suction because it's sucking the liquid up to this four mark there.

92
00:06:38,000 --> 00:06:43,000
And so this is a very interesting unit test for the physical world because it's very hard for,

93
00:06:43,000 --> 00:06:45,000
it's very obvious when that fails.

94
00:06:45,000 --> 00:06:51,000
If it's not reading four, if I, for example, pull out the straw so that it's not getting suction,

95
00:06:51,000 --> 00:06:55,000
the water recedes to the zero level.

96
00:06:55,000 --> 00:06:57,000
And so it's very hard for there to be a false negative here.

97
00:06:57,000 --> 00:07:03,000
It's very hard for the level to read four and there not to be suction.

98
00:07:03,000 --> 00:07:05,000
So this is a very good unit test in that it's very clear.

99
00:07:05,000 --> 00:07:09,000
It's very hard for something to go wrong and for me not to see it.

100
00:07:09,000 --> 00:07:11,000
And so we see this a lot in the physical world.

101
00:07:11,000 --> 00:07:14,000
If you think about something, if you've ever done hobby electronics,

102
00:07:14,000 --> 00:07:17,000
you probably recognize the image in the center as a multimeter.

103
00:07:17,000 --> 00:07:18,000
And so it's a very simple tool.

104
00:07:18,000 --> 00:07:22,000
It's just got these two probes and it lets you diagnose what's wrong with a circuit board,

105
00:07:22,000 --> 00:07:24,000
which is often very complex.

106
00:07:24,000 --> 00:07:27,000
There's also like, if you look at a weather vane, it's a very simple tool

107
00:07:27,000 --> 00:07:30,000
and that it shows you which way the wind is blowing.

108
00:07:30,000 --> 00:07:32,000
It just points in the direction that the wind is blowing.

109
00:07:32,000 --> 00:07:37,000
And so the thing about the multimeter is it's a layer simpler than the thing it's testing.

110
00:07:37,000 --> 00:07:39,000
And so this is a good thing to keep in mind with unit tests as well

111
00:07:39,000 --> 00:07:42,000
because unit tests need to be correct by inspection,

112
00:07:42,000 --> 00:07:46,000
so they often need to be at least one level simpler than the thing they're testing.

113
00:07:46,000 --> 00:07:51,000
And with a weather vane as well, if you see a test fail,

114
00:07:51,000 --> 00:07:55,000
you don't want to worry about whether the problem is in the test itself.

115
00:07:55,000 --> 00:07:58,000
You want to think that should be as small a possibility as possible.

116
00:07:58,000 --> 00:08:01,000
And so a weather vane, if it's pointing north,

117
00:08:01,000 --> 00:08:04,000
you have a pretty high confidence that the wind is blowing north.

118
00:08:04,000 --> 00:08:09,000
It's very unusual for a weather vane to point north when the wind is blowing east.

119
00:08:09,000 --> 00:08:11,000
And so you can think about that in your unit tests.

120
00:08:11,000 --> 00:08:13,000
You want to apply those same principles.

121
00:08:13,000 --> 00:08:16,000
And so one thing that's very helpful when you're writing unit tests

122
00:08:16,000 --> 00:08:19,000
is to think about if another developer comes along when this test fails,

123
00:08:19,000 --> 00:08:21,000
can they diagnose what the problem is?

124
00:08:21,000 --> 00:08:24,000
And so going back to this unit test we had before,

125
00:08:24,000 --> 00:08:27,000
it's very hard for another developer to understand what's wrong here

126
00:08:27,000 --> 00:08:30,000
because they don't have information about Joe 123, where that's coming from,

127
00:08:30,000 --> 00:08:33,000
or why the score is 150.

128
00:08:33,000 --> 00:08:36,000
And so we can solve that by inlining the setup method.

129
00:08:36,000 --> 00:08:39,000
I showed you before there was a separate setup method.

130
00:08:39,000 --> 00:08:43,000
And if we just take the body of that setup and put it right in the test function,

131
00:08:43,000 --> 00:08:46,000
that solves the problem because now we have everything we need to know

132
00:08:46,000 --> 00:08:48,000
right in the test function.

133
00:08:48,000 --> 00:08:51,000
The reader doesn't have to scroll up and down in your unit test file

134
00:08:51,000 --> 00:08:54,000
to understand what's going on.

135
00:08:54,000 --> 00:08:58,000
And so the other benefit of this is a common pattern in unit testing

136
00:08:58,000 --> 00:09:01,000
is this structure of arrange, act, assert.

137
00:09:01,000 --> 00:09:04,000
So arrange is where you set up your preconditions.

138
00:09:04,000 --> 00:09:06,000
Act is where you act on the object under test.

139
00:09:06,000 --> 00:09:08,000
In this case it's the account manager.

140
00:09:08,000 --> 00:09:11,000
And assert is where you assert that the post conditions are correct.

141
00:09:11,000 --> 00:09:14,000
And so if you inline your setup in this way,

142
00:09:14,000 --> 00:09:19,000
you achieve this structure that a lot of people will recognize quickly

143
00:09:19,000 --> 00:09:22,000
and it makes it easier for them to understand your tests.

144
00:09:22,000 --> 00:09:25,000
So the reader should understand your test without reading any other code.

145
00:09:25,000 --> 00:09:28,000
Everything should be right there in the test function

146
00:09:28,000 --> 00:09:31,000
where they can see it without a lot of scrolling.

147
00:09:31,000 --> 00:09:33,000
So next I want to talk about DRY.

148
00:09:33,000 --> 00:09:35,000
We talked about this yesterday.

149
00:09:35,000 --> 00:09:37,000
So DRY is don't repeat yourself.

150
00:09:37,000 --> 00:09:40,000
And so we've generally learned this in production code

151
00:09:40,000 --> 00:09:42,000
and it's a good idea in production code.

152
00:09:42,000 --> 00:09:44,000
So here's an example of some production code

153
00:09:44,000 --> 00:09:49,000
where I'm showing you some calls to a SQLite database.

154
00:09:49,000 --> 00:09:51,000
And so if a lot of us in this room saw this code,

155
00:09:51,000 --> 00:09:54,000
we'd say, okay, a lot of this code is redundant.

156
00:09:54,000 --> 00:09:57,000
So almost every line in both these functions are repeated.

157
00:09:57,000 --> 00:10:01,000
The only thing that's different is this one segment of a string.

158
00:10:01,000 --> 00:10:04,000
And so for a lot of us, a refactoring like this looks pretty good.

159
00:10:04,000 --> 00:10:08,000
We'd say, okay, we're abstracting away all the things that are repeated.

160
00:10:08,000 --> 00:10:12,000
And so get user names and get user IDs are now just different

161
00:10:12,000 --> 00:10:14,000
by the only thing that's different about them.

162
00:10:14,000 --> 00:10:17,000
And so a lot of us looking at this is like if this is production code,

163
00:10:17,000 --> 00:10:19,000
we're saying, okay, yeah, I like this refactoring.

164
00:10:19,000 --> 00:10:22,000
It's fewer lines of code, fewer, like less redundancy.

165
00:10:22,000 --> 00:10:24,000
So this is great.

166
00:10:24,000 --> 00:10:29,000
And so in the unit test I showed you before where I inlined the setup,

167
00:10:29,000 --> 00:10:31,000
some of you are maybe thinking ahead and saying,

168
00:10:31,000 --> 00:10:33,000
okay, that's fine for that one function.

169
00:10:33,000 --> 00:10:36,000
What if you got another function like test increased score?

170
00:10:36,000 --> 00:10:40,000
Now you've got these three statements that are exactly the same.

171
00:10:40,000 --> 00:10:44,000
And so that's a big problem because we know we don't like redundancy.

172
00:10:44,000 --> 00:10:48,000
And so here the thing to keep in mind is that

173
00:10:48,000 --> 00:10:51,000
eliminating redundancy is not a goal in itself.

174
00:10:51,000 --> 00:10:54,000
You eliminate redundancy because it serves some other goal.

175
00:10:54,000 --> 00:10:58,000
And so the goal you want to keep in mind is simplicity and obviousness.

176
00:10:58,000 --> 00:11:02,000
And I think those two are the most important things in unit testing.

177
00:11:02,000 --> 00:11:05,000
And so in this case, you're making tradeoffs either way.

178
00:11:05,000 --> 00:11:08,000
So if you do refactor this into a setup,

179
00:11:08,000 --> 00:11:12,000
so sure you're eliminating redundancy, but you're also increasing complexity.

180
00:11:12,000 --> 00:11:16,000
Now you're making it so that the reader has to jump around your test file

181
00:11:16,000 --> 00:11:18,000
in order to understand the test.

182
00:11:18,000 --> 00:11:20,000
And so you're kind of making a tradeoff either way.

183
00:11:20,000 --> 00:11:25,000
So in my opinion, just inlining it, it's three statements.

184
00:11:25,000 --> 00:11:28,000
It's not a big deal to inline these three statements.

185
00:11:28,000 --> 00:11:30,000
You add seven lines.

186
00:11:30,000 --> 00:11:33,000
It's going to vary for everybody how many lines you're comfortable repeating.

187
00:11:33,000 --> 00:11:37,000
But for me, just these three lines, I feel like it gives you a lot of simplicity.

188
00:11:37,000 --> 00:11:40,000
And for unit tests, I think that's more important.

189
00:11:40,000 --> 00:11:44,000
So I think accept redundancy if it supports simplicity.

190
00:11:44,000 --> 00:11:47,000
And so maybe you'll indulge me that last thing.

191
00:11:47,000 --> 00:11:49,000
You'll say, okay, three statements. I don't mind doing that.

192
00:11:49,000 --> 00:11:54,000
But what about when you've got an object that's really complicated to instantiate?

193
00:11:54,000 --> 00:11:57,000
So imagine this account manager class.

194
00:11:57,000 --> 00:12:00,000
Instead of just taking this one parameter, it takes three.

195
00:12:00,000 --> 00:12:02,000
And they're hard to instantiate too.

196
00:12:02,000 --> 00:12:05,000
So you've got these, I think it's like 15 lines of code.

197
00:12:05,000 --> 00:12:09,000
And so you're probably saying, I'm not going to copy paste these 15 lines of code

198
00:12:09,000 --> 00:12:11,000
into every single one of my tests. That's crazy.

199
00:12:11,000 --> 00:12:13,000
And so I agree. That would be crazy.

200
00:12:13,000 --> 00:12:16,000
Because at 15 lines, it's taking up so much of your test function

201
00:12:16,000 --> 00:12:19,000
that it obscures what you're actually trying to test.

202
00:12:19,000 --> 00:12:23,000
If a reader comes and tries to understand what behavior you're trying to assert,

203
00:12:23,000 --> 00:12:25,000
they kind of get lost in all the setup.

204
00:12:25,000 --> 00:12:30,000
And so your initial instinct might be to refactor this into helper methods.

205
00:12:30,000 --> 00:12:33,000
But first you should take a look at the interface you're using.

206
00:12:33,000 --> 00:12:37,000
So in this case, so the first parameter is this user database object.

207
00:12:37,000 --> 00:12:38,000
Okay, that sounds fine.

208
00:12:38,000 --> 00:12:41,000
It's an account manager that manages users.

209
00:12:41,000 --> 00:12:43,000
So sure, it can take a user database.

210
00:12:43,000 --> 00:12:47,000
Then the next thing where it gets kind of weird is it's taking a privilege database

211
00:12:47,000 --> 00:12:49,000
that's wrapped by this privilege manager object.

212
00:12:49,000 --> 00:12:52,000
So already there's a red flag that it's taking these two objects

213
00:12:52,000 --> 00:12:55,000
that are at different layers of abstraction.

214
00:12:55,000 --> 00:12:57,000
And lastly, it takes this URL downloader.

215
00:12:57,000 --> 00:13:02,000
And so that's very logically different from the two previous parameters.

216
00:13:02,000 --> 00:13:07,000
And so I see this case a lot where the class interface has evolved over time

217
00:13:07,000 --> 00:13:09,000
where the parameters don't really make sense anymore

218
00:13:09,000 --> 00:13:12,000
and it becomes this thing that's very hard to instantiate.

219
00:13:12,000 --> 00:13:16,000
And so the problem is if it's difficult to instantiate in your tests,

220
00:13:16,000 --> 00:13:19,000
it's also going to be difficult to instantiate in production.

221
00:13:19,000 --> 00:13:23,000
And so if you're tempted to write a helper method here,

222
00:13:23,000 --> 00:13:26,000
you can refactor your production class,

223
00:13:26,000 --> 00:13:31,000
and in so doing you'll improve your tests and you'll improve your production code.

224
00:13:31,000 --> 00:13:35,000
And so, yeah, so improving your production code simplifies your tests.

225
00:13:35,000 --> 00:13:38,000
So when you find yourself tempted to write a helper method

226
00:13:38,000 --> 00:13:40,000
to make your tests easier to write,

227
00:13:40,000 --> 00:13:45,000
think first about if you can refactor your production code to make everything easier.

228
00:13:45,000 --> 00:13:48,000
So sometimes you just, you have no other choice.

229
00:13:48,000 --> 00:13:49,000
You have to write a helper method.

230
00:13:49,000 --> 00:13:52,000
Sometimes you just don't have the luxury of refactoring the production class

231
00:13:52,000 --> 00:13:54,000
because maybe it's used in 200 places.

232
00:13:54,000 --> 00:13:56,000
So if you do have to write helper methods,

233
00:13:56,000 --> 00:14:00,000
you have to make sure you don't commit the cardinal sin of test helper methods,

234
00:14:00,000 --> 00:14:03,000
which is to bury critical values in your test helper.

235
00:14:03,000 --> 00:14:05,000
And so when I say critical value,

236
00:14:05,000 --> 00:14:07,000
I mean any value that the reader needs to know

237
00:14:07,000 --> 00:14:09,000
in order to understand why your test is correct.

238
00:14:09,000 --> 00:14:11,000
And so I'll give you an example.

239
00:14:11,000 --> 00:14:13,000
So this is similar to the test I showed you before.

240
00:14:13,000 --> 00:14:15,000
So here's our test method.

241
00:14:15,000 --> 00:14:16,000
We've got account manager,

242
00:14:16,000 --> 00:14:20,000
and then we call this self-add-dummy-count helper method.

243
00:14:20,000 --> 00:14:25,000
And then we do adjust score and assert equal that the score is 175.

244
00:14:25,000 --> 00:14:28,000
And so here we see the same problem that I've been showing you

245
00:14:28,000 --> 00:14:29,000
where there's hidden information.

246
00:14:29,000 --> 00:14:33,000
We don't know why the final score is 175

247
00:14:33,000 --> 00:14:36,000
because it assumes that there's this user Joe123,

248
00:14:36,000 --> 00:14:38,000
and it assumes their score was 150.

249
00:14:38,000 --> 00:14:41,000
And so the helper method, it buried these critical values.

250
00:14:41,000 --> 00:14:44,000
We needed to know these values in order to understand

251
00:14:44,000 --> 00:14:46,000
why test increase score was correct.

252
00:14:46,000 --> 00:14:50,000
It also commits a slightly less severe sin,

253
00:14:50,000 --> 00:14:54,000
but there's this call to account manager.add-account.

254
00:14:54,000 --> 00:14:56,000
So you also want to avoid this.

255
00:14:56,000 --> 00:14:59,000
It's burying interactions with, in this case,

256
00:14:59,000 --> 00:15:01,000
account manager is the object under test.

257
00:15:01,000 --> 00:15:04,000
And so as much as possible, you want to keep all interactions

258
00:15:04,000 --> 00:15:07,000
with the object under test in the test method itself.

259
00:15:07,000 --> 00:15:10,000
It makes it much harder for the reader to understand

260
00:15:10,000 --> 00:15:12,000
what you're doing to the object you're testing

261
00:15:12,000 --> 00:15:14,000
if you're sprinkling interactions with it

262
00:15:14,000 --> 00:15:16,000
throughout different functions.

263
00:15:16,000 --> 00:15:21,000
So you can rewrite this, and you can still use the helper method

264
00:15:21,000 --> 00:15:25,000
if you just respect this law of not burying critical values.

265
00:15:25,000 --> 00:15:27,000
So this is the same code.

266
00:15:27,000 --> 00:15:29,000
We've rewritten it so that we're still

267
00:15:29,000 --> 00:15:33,000
eliminating some boilerplate in this make-dummy-account method.

268
00:15:33,000 --> 00:15:36,000
But you can see that all the information we need is right there.

269
00:15:36,000 --> 00:15:38,000
We see Joe123 is created.

270
00:15:38,000 --> 00:15:40,000
We see that they start with a score of 150.

271
00:15:40,000 --> 00:15:43,000
And so it's very intuitive for the reader to follow this.

272
00:15:43,000 --> 00:15:46,000
We've got 150 plus 25 is 175.

273
00:15:46,000 --> 00:15:48,000
So that all makes sense.

274
00:15:48,000 --> 00:15:51,000
And so I basically don't have to show you the helper method,

275
00:15:51,000 --> 00:15:53,000
but I can.

276
00:15:53,000 --> 00:15:56,000
But you see all it's doing is eliminating some of the dummy work

277
00:15:56,000 --> 00:16:00,000
of presumably these parameters to account are required values.

278
00:16:00,000 --> 00:16:04,000
And so the helper method is just eliminating some of this stuff

279
00:16:04,000 --> 00:16:06,000
that's not relevant to your test.

280
00:16:06,000 --> 00:16:09,000
So don't bury critical information in your test helper methods.

281
00:16:09,000 --> 00:16:11,000
You want to keep all the information that the reader needs

282
00:16:11,000 --> 00:16:13,000
in the test itself.

283
00:16:13,000 --> 00:16:15,000
So now I want to talk about naming.

284
00:16:15,000 --> 00:16:17,000
So if you were writing some production code

285
00:16:17,000 --> 00:16:21,000
and you had the choice between these two function names,

286
00:16:21,000 --> 00:16:25,000
so user exists and their account is in good standing with all bills paid,

287
00:16:25,000 --> 00:16:27,000
or is account active?

288
00:16:27,000 --> 00:16:30,000
So a lot of people in this room would probably choose the second one,

289
00:16:30,000 --> 00:16:33,000
because the first one is very precise,

290
00:16:33,000 --> 00:16:38,000
but you don't want to burden your team with this super long function name.

291
00:16:38,000 --> 00:16:40,000
If this were a Java conference,

292
00:16:40,000 --> 00:16:42,000
I think everybody in the audience would be saying,

293
00:16:42,000 --> 00:16:44,000
well, both those names are far too short.

294
00:16:44,000 --> 00:16:50,000
But it's Pi Texas, so we value conciseness.

295
00:16:50,000 --> 00:16:53,000
And so there's a difference in tests.

296
00:16:53,000 --> 00:16:55,000
In production, you don't want to force your teammates

297
00:16:55,000 --> 00:16:59,000
to have to constantly write this super long function name.

298
00:16:59,000 --> 00:17:02,000
But in tests, you never write calls to test functions.

299
00:17:02,000 --> 00:17:06,000
You get out a function name exactly once when you define the test,

300
00:17:06,000 --> 00:17:09,000
because the test framework itself is what calls the test function.

301
00:17:09,000 --> 00:17:13,000
And so because of that, conciseness still matters,

302
00:17:13,000 --> 00:17:18,000
but you can err more on the side of being more precise and being more verbose.

303
00:17:18,000 --> 00:17:22,000
So here's an example of a unit test.

304
00:17:22,000 --> 00:17:25,000
Imagine you're editing this class called Tokenizer,

305
00:17:25,000 --> 00:17:27,000
and you're editing it, and then you run the unit test,

306
00:17:27,000 --> 00:17:30,000
and you see this test fails, and it says,

307
00:17:30,000 --> 00:17:33,000
test nest token failed with empty string is not known.

308
00:17:33,000 --> 00:17:36,000
So if you were the person editing Tokenizer,

309
00:17:36,000 --> 00:17:38,000
you probably wouldn't know why this test failed.

310
00:17:38,000 --> 00:17:41,000
And this is a very common naming pattern I see

311
00:17:41,000 --> 00:17:46,000
where people will just prefix test with the function that they're calling in the test.

312
00:17:46,000 --> 00:17:49,000
And so the problem here is you're forcing the developer

313
00:17:49,000 --> 00:17:53,000
to go read the test implementation to understand why this test failed.

314
00:17:53,000 --> 00:17:58,000
And so if you just go crazy with test function naming,

315
00:17:58,000 --> 00:18:00,000
you can give a lot more information.

316
00:18:00,000 --> 00:18:03,000
So if you were modifying this class and you see the test fails,

317
00:18:03,000 --> 00:18:07,000
is test nest token returns none when stream is empty,

318
00:18:07,000 --> 00:18:09,000
that's very clear.

319
00:18:09,000 --> 00:18:14,000
It's clear that you modified this behavior where the test expected

320
00:18:14,000 --> 00:18:18,000
that when the stream parameter is empty, then next token returns none,

321
00:18:18,000 --> 00:18:20,000
and somehow you broke that.

322
00:18:20,000 --> 00:18:23,000
But you can fix that without ever having to go read the test implementation.

323
00:18:23,000 --> 00:18:26,000
And so that should be a goal of your test naming.

324
00:18:26,000 --> 00:18:29,000
Your test should be named so well that people can diagnose failures

325
00:18:29,000 --> 00:18:32,000
just by reading the name of the test that failed.

326
00:18:32,000 --> 00:18:34,000
And so lastly, I want to talk about magic numbers.

327
00:18:34,000 --> 00:18:38,000
So if you're not familiar, a magic number is a numeric value or string

328
00:18:38,000 --> 00:18:41,000
that appears in code without information about what it represents.

329
00:18:41,000 --> 00:18:43,000
So here's an example of a magic number.

330
00:18:43,000 --> 00:18:47,000
So we're calling this function calculate pay, and we're passing it a value of 80.

331
00:18:47,000 --> 00:18:51,000
And so we don't really know what this 80 represents,

332
00:18:51,000 --> 00:18:54,000
and so we as a developer community have basically all decided

333
00:18:54,000 --> 00:18:58,000
that magic numbers are evil and so we vanquish them whenever we see them.

334
00:18:58,000 --> 00:19:02,000
And so a rewrite of that would be we use named constants.

335
00:19:02,000 --> 00:19:06,000
So we have a named constant called hours per week and weeks per pay period.

336
00:19:06,000 --> 00:19:10,000
And so anybody reading this code can understand where this 80 is coming from.

337
00:19:10,000 --> 00:19:13,000
They don't have to guess about why the number is 80.

338
00:19:13,000 --> 00:19:17,000
And so we're so used to this in production code that we've brought this practice

339
00:19:17,000 --> 00:19:19,000
with us to test code.

340
00:19:19,000 --> 00:19:23,000
And so if you're somebody who hates magic numbers, this test looks correct to you.

341
00:19:23,000 --> 00:19:26,000
So we're not using any magic numbers. We're using named constants.

342
00:19:26,000 --> 00:19:31,000
And so this is a good test in that we're not using any magic numbers.

343
00:19:31,000 --> 00:19:36,000
And so if you're somebody who's very devoted to getting rid of magic numbers,

344
00:19:36,000 --> 00:19:40,000
the next slide might be kind of shocking to you, so brace yourself.

345
00:19:40,000 --> 00:19:44,000
So this is the same test with magic numbers, and it's a lot more readable.

346
00:19:44,000 --> 00:19:48,000
You can just trace it very easily, 72, 80, like that.

347
00:19:48,000 --> 00:19:51,000
It's very intuitive. It's half the lines of code.

348
00:19:51,000 --> 00:19:57,000
And so I think in test code, we're used to this idea of eliminating magic numbers,

349
00:19:57,000 --> 00:20:00,000
but magic numbers are actually fine in test code.

350
00:20:00,000 --> 00:20:09,000
And the other issue that was kind of hidden in the example with named constants is this line.

351
00:20:09,000 --> 00:20:15,000
So we're calculating expected billable hours by adding together starting hours and hours increase.

352
00:20:16,000 --> 00:20:23,000
And so the problem with this is I said earlier that we want to minimize the level of logic in our test code.

353
00:20:23,000 --> 00:20:25,000
We want to make it as obvious as possible.

354
00:20:25,000 --> 00:20:29,000
And so here it's very simple logic, but it's nevertheless logic.

355
00:20:29,000 --> 00:20:35,000
And the problem is that in our production code, there's almost certainly a line that's almost exactly like this.

356
00:20:35,000 --> 00:20:40,000
And I see this a lot. People will take a complex calculation from production code

357
00:20:40,000 --> 00:20:43,000
and basically just copy paste the exact same thing into their tests.

358
00:20:43,000 --> 00:20:46,000
And so the problem is if there's an error in that calculation,

359
00:20:46,000 --> 00:20:52,000
you don't know it because you're using the exact same calculation in both your production code and your test code.

360
00:20:52,000 --> 00:20:56,000
And so if you just embrace magic numbers in your test, you can avoid this.

361
00:20:56,000 --> 00:21:03,000
And so a lot of the reasons that we have to always use named constants don't really apply in tests.

362
00:21:03,000 --> 00:21:07,000
So prefer magic numbers to named constants in test code.

363
00:21:07,000 --> 00:21:10,000
So in summary, you want to keep the reader in your test function.

364
00:21:10,000 --> 00:21:16,000
You want to make sure they're not jumping all around your test file to understand why the test function is correct.

365
00:21:16,000 --> 00:21:19,000
Eliminating redundancy isn't a goal in itself.

366
00:21:19,000 --> 00:21:23,000
You want to accept redundancy if it makes the tests more obvious and simpler.

367
00:21:23,000 --> 00:21:26,000
And if you're tempted to write helper methods,

368
00:21:26,000 --> 00:21:32,000
you should first think about whether you can refactor your production code to eliminate the need for helper methods.

369
00:21:32,000 --> 00:21:35,000
You want to avoid burying critical information in your test helpers.

370
00:21:35,000 --> 00:21:41,000
You want to make it so that the reader can stay in your test function without having to look outside for this critical information.

371
00:21:41,000 --> 00:21:45,000
Go crazy with long test names because you never have to call your test functions.

372
00:21:45,000 --> 00:21:48,000
And embrace magic numbers. They're your friends.

373
00:21:48,000 --> 00:21:51,000
They're not as evil as they are in production code.

374
00:21:51,000 --> 00:21:56,000
And so that's all. Thanks to Pi Texas for having me and all the volunteers.

375
00:21:56,000 --> 00:21:59,000
This was originally a blog post. So if you want to read this as a blog,

376
00:21:59,000 --> 00:22:02,000
you can just Google good developers, bad tests.

377
00:22:02,000 --> 00:22:07,000
And if you want to tweet it to everybody and say it's the best blog post you've ever read, that's totally fine.

378
00:22:07,000 --> 00:22:10,000
I don't mind. I'm on Twitter. I'm at Deliberate Coder.

379
00:22:10,000 --> 00:22:14,000
There's my email. If you want to read these slides, they're mtlinch.page.link.

380
00:22:14,000 --> 00:22:17,000
GDBT, good developer, bad test.

381
00:22:17,000 --> 00:22:19,000
And do we have time for questions?

382
00:22:19,000 --> 00:22:21,000
So we've got some time for questions.

383
00:22:21,000 --> 00:22:25,000
Does anybody have any questions or want to yell at me for besmirching DIY?

384
00:22:25,000 --> 00:22:40,000
So the question is, how did I decide that magic numbers are okay in tests?

385
00:22:40,000 --> 00:22:47,000
Yeah, good question. So in production code, we usually have this problem of

386
00:22:47,000 --> 00:22:54,000
we want to avoid magic numbers in production code because usually the number we choose are not arbitrary.

387
00:22:54,000 --> 00:22:57,000
They're usually related to something else in the production code.

388
00:22:57,000 --> 00:23:03,000
And so it's necessary. Named constants eliminate that problem of if it's related to some other number,

389
00:23:03,000 --> 00:23:06,000
the named constant kind of enforces that relationship.

390
00:23:06,000 --> 00:23:08,000
Whereas in tests, that doesn't really apply.

391
00:23:08,000 --> 00:23:13,000
Usually it's not related to something else. It's not going to be related to something else in your tests.

392
00:23:13,000 --> 00:23:22,000
And the other thing is that in tests, like in production code, you want to show that the number isn't arbitrary.

393
00:23:22,000 --> 00:23:28,000
And in tests, the number often is arbitrary. You're just choosing a number that meets a number or a value.

394
00:23:28,000 --> 00:23:33,000
So like you might want to choose a negative number to make sure that your function handles negative numbers.

395
00:23:33,000 --> 00:23:37,000
And so it could be like negative five or it could be negative ten.

396
00:23:37,000 --> 00:23:40,000
It doesn't really matter. You're just choosing something that's negative.

397
00:23:40,000 --> 00:23:48,000
And so it should be the test name itself that tells the reader what's special about the magic numbers that you're choosing.

398
00:23:48,000 --> 00:23:50,000
But thank you. That was a good question.

399
00:23:50,000 --> 00:23:52,000
Question over there.

400
00:23:52,000 --> 00:24:02,000
Would you recommend, because I know you can write test classes and then that can hold your functions that are in test cases called.

401
00:24:02,000 --> 00:24:11,000
So would you say it's okay to write your functions in that test class and then call them in the test cases?

402
00:24:11,000 --> 00:24:17,000
Yeah, I mean, I personally use the unit tests module in Python.

403
00:24:17,000 --> 00:24:20,000
So I write all my unit tests in classes.

404
00:24:20,000 --> 00:24:27,000
And so I think classes can be a good way of when the test fails, you also see the class name.

405
00:24:27,000 --> 00:24:31,000
And so that can be a helpful way of giving context to the reader.

406
00:24:31,000 --> 00:24:36,000
So I think these aren't hard and fast rules. They're not like never write test offers.

407
00:24:36,000 --> 00:24:43,000
But I think the the idea I want to get across is that you should be thinking about like what's going to help the reader to understand why the test fails?

408
00:24:43,000 --> 00:24:46,000
What's going to what's going to make it obvious to the reader?

409
00:24:46,000 --> 00:24:59,000
So using using a test class, if it if it makes it easier for the reader to understand quickly what the test does and why it's failing, I'd say use whatever tool you can get the question.

410
00:25:00,000 --> 00:25:03,000
Hey, I really like to talk.

411
00:25:03,000 --> 00:25:04,000
Thank you.

412
00:25:04,000 --> 00:25:08,000
I did have one question to clarify on the redundancy point.

413
00:25:08,000 --> 00:25:09,000
Sure.

414
00:25:09,000 --> 00:25:13,000
Would you prefer redundancy versus focus?

415
00:25:13,000 --> 00:25:17,000
Would you prefer if your account manager was the thing that was failing?

416
00:25:17,000 --> 00:25:24,000
Then you got a bunch of tests all of a sudden where you copy and pasted that code instead of in the setup.

417
00:25:24,000 --> 00:25:26,000
Now you've got a bunch of tests.

418
00:25:26,000 --> 00:25:31,000
You prefer to see that everywhere account manager was copied and pasted.

419
00:25:31,000 --> 00:25:35,000
Those are all failing as opposed to one test showing.

420
00:25:35,000 --> 00:25:37,000
I guess I understand the question.

421
00:25:37,000 --> 00:25:40,000
If you've got a setup, then they would all fail anyway.

422
00:25:40,000 --> 00:25:41,000
Right.

423
00:25:41,000 --> 00:25:44,000
Well, it would.

424
00:25:44,000 --> 00:25:46,000
I can't remember exactly the difference.

425
00:25:46,000 --> 00:25:50,000
It's a failure versus errors.

426
00:25:50,000 --> 00:25:52,000
OK.

427
00:25:52,000 --> 00:25:55,000
Yeah, I mean, I guess I understand what you're saying.

428
00:25:55,000 --> 00:26:03,000
So if you have some something where like you're breaking all of your tests and you could maybe avoid that if you were better factored.

429
00:26:03,000 --> 00:26:07,000
Yeah, I mean, for me, I feel like that's fine.

430
00:26:07,000 --> 00:26:12,000
Like if you if you do something that does break all of your tests, then all of your tests should break because.

431
00:26:12,000 --> 00:26:13,000
Yeah.

432
00:26:13,000 --> 00:26:15,000
So I mean, but I think that's a matter of opinion.

433
00:26:15,000 --> 00:26:17,000
It's kind of kind of debate.

434
00:26:17,000 --> 00:26:21,000
Depend on what your team thinks and how you feel about the code.

435
00:26:21,000 --> 00:26:23,000
So any other questions?

436
00:26:23,000 --> 00:26:25,000
Oh, question up here.

437
00:26:25,000 --> 00:26:26,000
Surprise.

438
00:26:26,000 --> 00:26:28,000
Nobody's yelled at me about the D.R.Y.

439
00:26:28,000 --> 00:26:33,000
Yeah.

440
00:26:33,000 --> 00:26:39,000
So we know that.

441
00:26:39,000 --> 00:26:46,000
So when you say that you have to have useful information in the test.

442
00:26:46,000 --> 00:26:52,000
Do you are separating that from a sensitive information versus useful information?

443
00:26:52,000 --> 00:26:59,000
We want most of it to be the functions because of the encapsulation.

444
00:26:59,000 --> 00:27:04,000
So I think the.

445
00:27:04,000 --> 00:27:11,000
I think this kind of goes back to what I said in the beginning, where I think unit tests are small enough that you don't.

446
00:27:11,000 --> 00:27:17,000
We use encapsulation in production code because there's there's too much code to understand if you just read it top to bottom.

447
00:27:17,000 --> 00:27:23,000
I think often in unit tests, you can't it's there's there's small enough logic that you could just read it top to bottom.

448
00:27:23,000 --> 00:27:26,000
So you're making a trade off.

449
00:27:26,000 --> 00:27:33,000
So if you use encapsulation to refactor out some of the redundancy, you're eliminating redundancy, but you're you're now increasing complexity.

450
00:27:33,000 --> 00:27:37,000
So you're forcing the reader to go outside your test function to understand what's happening.

451
00:27:37,000 --> 00:27:42,000
And so, you know, there's there's no one rule that's going to answer it in all cases.

452
00:27:42,000 --> 00:27:45,000
I think we're engineers. And so part of that is making trade offs.

453
00:27:45,000 --> 00:27:51,000
I think people are too used to eliminating redundancy, so they just do it without thinking about it.

454
00:27:51,000 --> 00:27:56,000
But I think often it's better to just have the simplicity of of having redundant code.

455
00:27:56,000 --> 00:28:00,000
But it appears in every test function so that the reader can just read it top to bottom.

456
00:28:00,000 --> 00:28:02,000
So.

457
00:28:02,000 --> 00:28:04,000
Out of time or more questions?

458
00:28:04,000 --> 00:28:06,000
We have a little more time.

459
00:28:10,000 --> 00:28:12,000
Yeah, I like to talk.

460
00:28:12,000 --> 00:28:14,000
I was going to make a comment back to the drive.

461
00:28:14,000 --> 00:28:16,000
Sure.

462
00:28:16,000 --> 00:28:43,000
So to me, that's still like I, I can appreciate the explicitness of it.

463
00:28:43,000 --> 00:28:47,000
But I think you still pay a penalty in forcing the reader to to jump around.

464
00:28:47,000 --> 00:28:53,000
I think I think there's tremendous value in letting the reader just read a test function from top to bottom without having to read it.

465
00:28:53,000 --> 00:28:54,000
Another fixture.

466
00:28:54,000 --> 00:28:59,000
And I mean, sometimes it's fine if there's not critical information in the test picture, if it's just all information.

467
00:28:59,000 --> 00:29:04,000
I just think it takes for, let's say, 20 times.

468
00:29:04,000 --> 00:29:06,000
Yeah, I mean, it depends.

469
00:29:06,000 --> 00:29:09,000
Yeah, it depends on what your preferences are.

470
00:29:09,000 --> 00:29:12,000
And one more question.

471
00:29:12,000 --> 00:29:15,000
I need to bring heresy into this conference.

472
00:29:15,000 --> 00:29:20,000
But the GoLang community says a little bit of copying is better than a little bit of dependency.

473
00:29:20,000 --> 00:29:23,000
I think that's the thing we're talking about.

474
00:29:23,000 --> 00:29:32,000
If you break something in the class under test and not all of your tests break, you only need to change those tests that did break.

475
00:29:32,000 --> 00:29:36,000
And it's more explicit when you get to the pull request point of like, these are the exact things that I wrote.

476
00:29:36,000 --> 00:29:46,000
If what you break is in the set up, you effectively effectively broke all the tests, you effectively changed all the tests without that actually being necessary.

477
00:29:46,000 --> 00:29:51,000
So I'd like the breaking the dependency by getting rid of the set up.

478
00:29:51,000 --> 00:29:54,000
OK.

479
00:29:54,000 --> 00:29:57,000
All right. Any other questions?

480
00:29:57,000 --> 00:29:59,000
All right. Let's give them a round of applause.

481
00:30:06,000 --> 00:30:08,000
Thank you.

