1
00:00:00,000 --> 00:00:09,880
Hello everyone, I'm Wayne Wharton and this is Great Snake Variation Programming with

2
00:00:09,880 --> 00:00:10,880
Python Chess.

3
00:00:10,880 --> 00:00:16,280
To start out, I just want to say how excited and great I am to be here with all of you

4
00:00:16,280 --> 00:00:17,280
at PyTexas.

5
00:00:17,280 --> 00:00:22,280
It's been a long time since I got to go to an in-person conference, it's been a long

6
00:00:22,280 --> 00:00:27,280
time since I got to speak at an in-person conference, but I was at the 2019 PyTexas,

7
00:00:27,760 --> 00:00:32,760
had a great time, and so I'm really happy after all of this to be back here with you.

8
00:00:32,760 --> 00:00:37,760
And so you might all be wondering why this talk, Chess at a Python conference.

9
00:00:37,760 --> 00:00:43,760
I promise you there's something here, and the main blame I would say falls on the Queen's

10
00:00:43,760 --> 00:00:44,760
Gambit.

11
00:00:44,760 --> 00:00:49,760
I don't know if anyone else watched, I was definitely one of those people who binge-watched

12
00:00:49,760 --> 00:00:54,760
this during the pandemic and got very into online chess.

13
00:00:55,240 --> 00:00:57,240
Now, I had played chess before as a kid.

14
00:00:57,240 --> 00:01:01,240
Yes, that's me as a kid before the gray hair set in.

15
00:01:01,240 --> 00:01:04,240
And I had done pretty well playing chess as a kid.

16
00:01:04,240 --> 00:01:09,240
This is actually a picture of chess trophies that I asked my mom to send me for this presentation.

17
00:01:09,240 --> 00:01:18,240
But most importantly, I learned how to beat my dad at chess using this book, which is

18
00:01:18,240 --> 00:01:20,240
actually a great book.

19
00:01:20,720 --> 00:01:21,720
I did play chess.

20
00:01:21,720 --> 00:01:22,720
Highly recommend it.

21
00:01:22,720 --> 00:01:25,720
I did finally accomplish that.

22
00:01:25,720 --> 00:01:30,720
So I knew something about chess, but after about fifth grade, I had other interests,

23
00:01:30,720 --> 00:01:32,720
and I didn't really play chess.

24
00:01:32,720 --> 00:01:37,720
Much after that, I didn't really play seriously for about 16 years until the Queen's Gambit

25
00:01:37,720 --> 00:01:43,720
came, and the pandemic hit, and all of a sudden I decided to dive back in.

26
00:01:43,720 --> 00:01:48,720
So I created an account on Leechess, which is a free and open source tool, a free and

27
00:01:49,200 --> 00:01:50,200
open source chess server.

28
00:01:50,200 --> 00:01:53,200
It's a great thing if you want to play online with other people.

29
00:01:53,200 --> 00:01:55,200
And I dove right in.

30
00:01:55,200 --> 00:01:58,200
And when I say that, I really dove in.

31
00:01:58,200 --> 00:02:00,200
So here's a little bit of stats.

32
00:02:00,200 --> 00:02:07,200
So I started in November 2020, and that is at least the graph until July of 2021.

33
00:02:07,200 --> 00:02:11,200
I played almost 1,700 Blitz games online.

34
00:02:11,200 --> 00:02:16,200
And unfortunately, Leechess also tells you how much time you've spent on it, and mine

35
00:02:16,680 --> 00:02:23,680
came out to over 19 days, which I did the math for this talk, is about an average of

36
00:02:23,680 --> 00:02:28,680
30 minutes per day, every day since November 2020.

37
00:02:28,680 --> 00:02:35,680
I can say sometimes it is more than that, and very often more than that.

38
00:02:35,680 --> 00:02:38,680
So I really got back into playing chess.

39
00:02:38,680 --> 00:02:40,680
I loved playing chess online.

40
00:02:41,160 --> 00:02:46,160
Eventually I also got back into playing in-person chess at tournaments, which led to me having

41
00:02:46,160 --> 00:02:52,160
this very hilarious reading graph where on this side you can see was the single rated

42
00:02:52,160 --> 00:02:57,160
tournament I ever played as a kid, and I was rated 914 in 2004.

43
00:02:57,160 --> 00:03:02,160
Then you can see a 16-year gap where I played no chess.

44
00:03:02,160 --> 00:03:07,160
But the way they render it, for some reason, it has me steadily getting better at chess

45
00:03:07,640 --> 00:03:10,640
over that time, despite playing no chess.

46
00:03:10,640 --> 00:03:16,640
And then here is where I started playing chess in person, and basically after 1,700 Blitz

47
00:03:16,640 --> 00:03:21,640
games online, I was able to make very rapid progress once I finally returned to playing

48
00:03:21,640 --> 00:03:23,640
in person.

49
00:03:23,640 --> 00:03:29,640
Eventually I started asking myself, can programming help me in training for chess, and it helped

50
00:03:29,640 --> 00:03:31,640
me analyze my games.

51
00:03:32,120 --> 00:03:38,120
So by day I am a machine learning engineer, and so when I was approaching this problem

52
00:03:38,120 --> 00:03:40,120
I thought, well I have a lot of data.

53
00:03:40,120 --> 00:03:45,120
I have almost 1,700 games on LeeChess, which is the account I told you about.

54
00:03:45,120 --> 00:03:51,120
I have over 2,700 games on my chess.com account, which I did not mention until now.

55
00:03:51,120 --> 00:03:56,120
So that's a lot of chess games, which in this case means a lot of data to analyze and maybe

56
00:03:56,120 --> 00:03:58,120
some interesting things that I can learn.

57
00:03:58,600 --> 00:04:04,600
And I was already inspired by some software tools that existed that I found useful.

58
00:04:04,600 --> 00:04:08,600
One of them was this thing called Opening Tree.

59
00:04:08,600 --> 00:04:13,600
So this will load your games from a given website and allow you to interactively explore

60
00:04:13,600 --> 00:04:17,600
different openings that you've played, ways your opponents have responded.

61
00:04:17,600 --> 00:04:22,600
It's a very useful tool, but I found that it couldn't always answer all the questions

62
00:04:22,600 --> 00:04:23,600
that I had.

63
00:04:24,080 --> 00:04:30,080
I wanted to go further, and so I decided how can I write a program that does things like this?

64
00:04:33,080 --> 00:04:39,080
So I opened up PyPI, or as our keynote speaker called it, the magic shopping list of Python,

65
00:04:39,080 --> 00:04:45,080
and thankfully I found what I was looking for, which was Python Chess, a chess library

66
00:04:45,080 --> 00:04:49,080
for Python, which was exactly what I wanted.

67
00:04:49,080 --> 00:04:52,080
And that is how this story started.

68
00:04:52,560 --> 00:04:56,560
To give you an idea of how this talk is going to go, to start off I'm going to do a brief

69
00:04:56,560 --> 00:04:58,560
history of chess and programming.

70
00:04:58,560 --> 00:05:05,560
Then I'm going to dive into the API and usage of this library that I found and came to love

71
00:05:05,560 --> 00:05:06,560
called Python Chess.

72
00:05:06,560 --> 00:05:10,560
And finally I'm going to go into a little bit about the applications of Python Chess,

73
00:05:10,560 --> 00:05:14,560
how I used it, some interesting ways I've seen other people use it.

74
00:05:14,560 --> 00:05:20,560
And I do want to underline after all this that I think my main idea for this talk is

75
00:05:21,040 --> 00:05:25,040
not to teach you something about chess, because some of you might be interested in chess and

76
00:05:25,040 --> 00:05:28,040
some of you might not care, and this is a Python conference.

77
00:05:28,040 --> 00:05:33,040
So what I really want you to take away in the end is that chess is just one interesting

78
00:05:33,040 --> 00:05:38,040
problem, it's one interesting domain where we can apply Python, we can apply programming

79
00:05:38,040 --> 00:05:44,040
principles, and that can teach us something even if you don't really care about knights

80
00:05:44,040 --> 00:05:47,040
and rooks and haunts.

81
00:05:47,520 --> 00:05:50,520
And to start off, that's why I want to give you a little bit of a brief history of chess

82
00:05:50,520 --> 00:05:54,520
and programming, because I think there is a lot of background to say that chess as a

83
00:05:54,520 --> 00:05:59,520
problem can teach us something about programming more generally.

84
00:05:59,520 --> 00:06:06,520
It started off maybe not so well with this contraption in 1770, which was supposedly

85
00:06:06,520 --> 00:06:11,520
a robot that could play chess by itself.

86
00:06:11,520 --> 00:06:15,520
People at the time didn't know that there was actually someone sitting inside of it

87
00:06:16,000 --> 00:06:21,000
manipulating this robot, and it made a grand tour of Europe and many places and defeated

88
00:06:21,000 --> 00:06:26,000
some great chess players, and people didn't necessarily catch on.

89
00:06:26,000 --> 00:06:33,000
And this does actually live on with some legacy in our current tech environment as the name

90
00:06:33,000 --> 00:06:39,000
of, it also lives on as the name of an Amazon service, Amazon mechanical chart, which you

91
00:06:39,000 --> 00:06:40,000
can use.

92
00:06:40,000 --> 00:06:45,000
So a second figure in the history of computer science and programming who got into chess

93
00:06:45,480 --> 00:06:48,480
was Alan Turing.

94
00:06:51,480 --> 00:06:52,480
I'll keep going.

95
00:06:52,480 --> 00:07:00,480
And in 1948, he wrote what is one of the first computer chess programs called Turochamp.

96
00:07:00,480 --> 00:07:03,480
Co-wrote it, there was another person.

97
00:07:03,480 --> 00:07:09,480
And the problem for Alan Turing was at the time there were no computers that could execute

98
00:07:09,480 --> 00:07:12,480
the complexity of this program that he designed.

99
00:07:12,960 --> 00:07:19,960
And so the only way that he could play it was to actually execute the algorithm on paper.

100
00:07:19,960 --> 00:07:25,960
And so there's one reported game of him playing as the algorithm against a human where he's

101
00:07:25,960 --> 00:07:28,960
actually writing out the calculations on paper.

102
00:07:28,960 --> 00:07:32,960
It took about 30 minutes per move, which is not very efficient or probably very fun if

103
00:07:32,960 --> 00:07:34,960
you're the human on the other side.

104
00:07:34,960 --> 00:07:39,960
So he was maybe a little ahead of his time with this program.

105
00:07:40,440 --> 00:07:45,440
Another big figure in computer science called Shannon was known to have a great interest

106
00:07:45,440 --> 00:07:46,440
in computer chess.

107
00:07:46,440 --> 00:07:51,440
He wrote a very influential paper on it and later designed a machine, a robot that could

108
00:07:51,440 --> 00:07:53,440
play chess.

109
00:07:53,440 --> 00:07:57,440
Due to the technical limitations of the time, this machine you see here, it can only handle

110
00:07:57,440 --> 00:08:03,440
positions of up to six pieces due to the computational complexity, but still was quite an accomplishment.

111
00:08:03,440 --> 00:08:08,440
And he has a quote from this paper that I really liked as I was putting this talk together.

112
00:08:10,440 --> 00:08:14,440
He was talking about the problem of chess programming.

113
00:08:14,440 --> 00:08:20,440
He said, perhaps it's not of practical importance, but he basically thought by tackling this

114
00:08:20,440 --> 00:08:25,440
problem of programming chess, maybe we can make some headway toward larger problems.

115
00:08:25,440 --> 00:08:30,440
And he had in mind big AI problems of translation and other things.

116
00:08:30,440 --> 00:08:35,440
But I think that this is a really fascinating idea that by learning something about this

117
00:08:35,920 --> 00:08:40,920
domain, by tackling this, we can go on to learn maybe bigger, better things.

118
00:08:42,920 --> 00:08:47,920
So another big figure in computer science, Ken Thompson, who created Unix later in his

119
00:08:47,920 --> 00:08:50,920
career, would co-create a language called Go.

120
00:08:50,920 --> 00:08:57,920
In the 70s, he was working at Bell Labs and he came up with the software for this contraption

121
00:08:57,920 --> 00:09:00,920
called Bell in 1972.

122
00:09:01,400 --> 00:09:08,400
And this is one of the early champions of computer software championships at the time.

123
00:09:08,400 --> 00:09:15,400
And finally, I don't think I could complete my historical review of chess and programming

124
00:09:15,400 --> 00:09:22,400
without mentioning this big event in 1997 when IBM built this machine called Deep Blue

125
00:09:22,400 --> 00:09:27,400
and it finally defeated Garry Kasparov, who at the time was the world chess champion.

126
00:09:27,880 --> 00:09:32,880
This was the first time that a machine had defeated the human champion of chess.

127
00:09:32,880 --> 00:09:37,880
So this was kind of a big turning point in chess and programming and technology.

128
00:09:37,880 --> 00:09:44,880
So that's a little bit of an idea of the history of how chess has influenced programming and

129
00:09:44,880 --> 00:09:51,880
drawn the interest of some people who went on to do or were doing great things in general

130
00:09:51,880 --> 00:09:53,880
programming and computer science.

131
00:09:54,360 --> 00:09:56,360
So right out of the way, we'll get into this library.

132
00:09:56,360 --> 00:10:01,360
How can you do things with chess using Python?

133
00:10:01,360 --> 00:10:08,360
I mentioned that there's some program principles that you can learn by looking at this library

134
00:10:08,360 --> 00:10:11,360
and I want to mention a few of them in particular.

135
00:10:11,360 --> 00:10:20,360
So data parsing, object-oriented programming, very important, data structures and algorithms,

136
00:10:20,840 --> 00:10:23,840
pattern patterns, and finally communication protocols.

137
00:10:23,840 --> 00:10:29,840
I'm going to go through examples of how you can see all these things in the Python Chess

138
00:10:29,840 --> 00:10:36,840
Library and basically how you can learn to use it by looking at these different principles.

139
00:10:42,840 --> 00:10:47,840
So if you've done data parsing in Python before, you've probably used Pandas and you know that

140
00:10:48,320 --> 00:10:53,320
it provides a nice API for taking a structured data set, for example a CSP, you can read

141
00:10:53,320 --> 00:10:59,320
it in and you can get it as a data frame which then has a nice API to allow you to further

142
00:10:59,320 --> 00:11:03,320
manipulate the data, do any of the calculations that you want to do.

143
00:11:05,320 --> 00:11:07,320
Chess has a similar thing.

144
00:11:07,320 --> 00:11:11,320
It has structured data in this form which is called PGN.

145
00:11:11,800 --> 00:11:18,800
That was a standard that was put together way back in the day in 1994 as a portable

146
00:11:18,800 --> 00:11:22,800
protocol for sharing chess games and it lives on until today.

147
00:11:22,800 --> 00:11:28,800
This is the main format in which chess games are represented for processing and similar

148
00:11:28,800 --> 00:11:34,800
to how Pandas has the ability to read a CSV, the Python Chess Library allows you to read

149
00:11:34,800 --> 00:11:36,800
in a PGN file.

150
00:11:37,280 --> 00:11:43,280
So here you can see if you have a PGN you can read it in and you get a game object and

151
00:11:43,280 --> 00:11:45,280
that is going to allow you to do further analysis.

152
00:11:45,280 --> 00:11:50,280
So the next question might be what is the game object and that leads us into the next

153
00:11:50,280 --> 00:11:58,280
topic which is object oriented programming and some of you may have once been subjected

154
00:11:58,280 --> 00:12:03,280
to programming interviews that make you do these kinds of problems.

155
00:12:03,760 --> 00:12:10,760
Maybe you had to influence chess in the stress of a 30 minute interview or maybe some other

156
00:12:10,760 --> 00:12:12,760
kind of object oriented game.

157
00:12:12,760 --> 00:12:17,760
So in this case chess can be thought of as several classes.

158
00:12:17,760 --> 00:12:22,760
So an important one is piece, obviously move, board and game.

159
00:12:22,760 --> 00:12:27,760
These are all different classes with different functionalities that can help us represent

160
00:12:27,760 --> 00:12:29,760
chess as a whole.

161
00:12:29,760 --> 00:12:31,760
So I'm going to go through these classes.

162
00:12:32,240 --> 00:12:36,240
Some of them are fairly simple, some of them are fairly complex and explain basically their

163
00:12:36,240 --> 00:12:42,240
APIs in the Python Chess Library and some of the interesting methods.

164
00:12:42,240 --> 00:12:44,240
So a piece is fairly simple.

165
00:12:44,240 --> 00:12:47,240
A piece just has a piece type and a color.

166
00:12:47,240 --> 00:12:53,240
It's essentially a data class that is holding these two things and representing them.

167
00:12:53,240 --> 00:12:56,240
A move is similarly fairly simple.

168
00:12:56,720 --> 00:13:01,720
A piece just has the square you're moving from, the square you're moving to and then

169
00:13:01,720 --> 00:13:03,720
the piece you might be promoting to.

170
00:13:03,720 --> 00:13:07,720
That's in the case of moving a pawn, you can turn a pawn into a queen sometimes so you

171
00:13:07,720 --> 00:13:09,720
want to keep track of that.

172
00:13:09,720 --> 00:13:14,720
And here it's referring to squares and in this library squares are also represented

173
00:13:14,720 --> 00:13:15,720
fairly simply.

174
00:13:15,720 --> 00:13:21,720
The square type is just an integer type and all of the 64 squares on a standard chess

175
00:13:21,720 --> 00:13:24,720
board are just assigned to unique integers.

176
00:13:25,200 --> 00:13:28,200
So they can be referred to 0 to 63.

177
00:13:30,200 --> 00:13:31,200
So then we get to board.

178
00:13:31,200 --> 00:13:36,200
And board is definitely the most complex class in the whole library and you'll usually see

179
00:13:36,200 --> 00:13:38,200
that in chess programming.

180
00:13:38,200 --> 00:13:41,200
Most of the functionality will be represented on the board.

181
00:13:41,200 --> 00:13:46,200
And some of the things that it allows you to do is move generation, calculation of whether

182
00:13:46,200 --> 00:13:52,200
or not the particular position has completed the game, a bunch of stuff is packed into

183
00:13:52,680 --> 00:13:57,680
board and I looked at it in the library, the board class has over 2300 lines of Python

184
00:13:57,680 --> 00:14:00,680
so it's a whopper, it's a huge class.

185
00:14:00,680 --> 00:14:03,680
There's probably something you could say about that but that would probably be a whole

186
00:14:03,680 --> 00:14:05,680
other talk.

187
00:14:05,680 --> 00:14:07,680
But most of the functionality lives in this class.

188
00:14:07,680 --> 00:14:11,680
There are a lot of interesting methods and I just picked out a few that I thought were

189
00:14:11,680 --> 00:14:15,680
useful or interesting properties and methods of board.

190
00:14:16,160 --> 00:14:25,160
So some of the simple ones, you can check whose turn is it, you can check what move

191
00:14:25,160 --> 00:14:30,160
you're on, which full move number is what we think of as move, so one, white will move,

192
00:14:30,160 --> 00:14:35,160
black will move, two, white will move, black will move again, and so on.

193
00:14:35,160 --> 00:14:38,160
So these things are represented on the board class.

194
00:14:38,160 --> 00:14:45,160
This one is outcome and this actually represents a huge percentage of that 2300 lines because

195
00:14:45,640 --> 00:14:50,640
calculating whether a chess game is over is actually extremely complex.

196
00:14:50,640 --> 00:14:55,640
Obviously most people know about checkmate, stalemate, but there's all sorts of rules

197
00:14:55,640 --> 00:15:00,640
of three-fold repetition, so if you reach the same position three times, someone can

198
00:15:00,640 --> 00:15:05,640
claim a draw and calculating that actually is pretty complex, you have to go back through

199
00:15:05,640 --> 00:15:08,640
all the positions and see if it's been repeated.

200
00:15:09,120 --> 00:15:15,120
So this is a real big part of the complexity of programming a chess representation is getting

201
00:15:15,120 --> 00:15:20,120
this right and knowing whether the game is over and how it finished.

202
00:15:20,120 --> 00:15:25,120
And these are some of the ones I picked out that I think are just funny or interesting.

203
00:15:25,120 --> 00:15:28,120
There's checkers, which does not do what you think it does.

204
00:15:28,120 --> 00:15:31,120
I really thought this was an implementation where you could just call this and all of

205
00:15:31,120 --> 00:15:34,120
a sudden you're playing checkers, not chess.

206
00:15:34,120 --> 00:15:35,120
That's not what it is.

207
00:15:35,600 --> 00:15:40,600
It's just finding all the pieces that are currently putting your king in check, which

208
00:15:40,600 --> 00:15:42,600
is kind of an interesting problem.

209
00:15:42,600 --> 00:15:47,600
And then the other one I thought was kind of cool was is irreversible so you can pass

210
00:15:47,600 --> 00:15:52,600
in a move and it'll tell you if that's the kind of move that you can't undo.

211
00:15:52,600 --> 00:15:57,600
So in the case of normal chess, moving your pawns forward, you can't undo that because

212
00:15:57,600 --> 00:15:58,600
they don't move backward.

213
00:15:58,600 --> 00:16:02,600
There's some things around if you move your king, you won't be able to castle.

214
00:16:03,080 --> 00:16:08,080
So this is another interesting one where there's a lot of domain-specific logic in there to

215
00:16:08,080 --> 00:16:12,080
say, okay, is this a move that someone's going to be able to take back or not?

216
00:16:15,080 --> 00:16:17,080
So I mentioned data structures and algorithms.

217
00:16:17,080 --> 00:16:22,080
And when we look into the classes that are used to implement the chess functionality

218
00:16:22,080 --> 00:16:27,080
in this library, we can see the use of some common data structures and algorithms.

219
00:16:27,560 --> 00:16:32,560
So for example, the moves that are made are represented as a stack, and the board class

220
00:16:32,560 --> 00:16:38,560
provides common methods, pop, peek, push, and you can also clear the stack.

221
00:16:38,560 --> 00:16:43,560
And if you look into the implementation of one of these methods, it's also interesting

222
00:16:43,560 --> 00:16:46,560
because it's actually holding two stacks on the class.

223
00:16:46,560 --> 00:16:47,560
There's a stack of moves.

224
00:16:47,560 --> 00:16:52,560
And then if you look at the implementation, there's also an internal stack of the board

225
00:16:53,040 --> 00:16:58,040
representation after that move so that in processing, you can know not only the moves

226
00:16:58,040 --> 00:17:03,040
that were made, but you can also go back through and see the resulting positions.

227
00:17:07,040 --> 00:17:11,040
And the game class is actually a tree of moves.

228
00:17:11,040 --> 00:17:17,040
So there's a game node, and they can point to various other game nodes, and that's how

229
00:17:17,520 --> 00:17:22,520
you represent a game, which is a very flexible model and useful because when you think of

230
00:17:22,520 --> 00:17:28,520
a game, you might think just a set of moves and then why isn't it a list or a linked list

231
00:17:28,520 --> 00:17:29,520
or something.

232
00:17:29,520 --> 00:17:34,520
But in chess games, people often want to add variations.

233
00:17:34,520 --> 00:17:39,520
So then one move maybe could be followed by another move, but then there's a variation

234
00:17:39,520 --> 00:17:40,520
that someone wants to consider.

235
00:17:40,520 --> 00:17:42,520
And so that's how you get this tree structure.

236
00:17:43,000 --> 00:17:46,000
Off of each move, there could be several possibilities.

237
00:17:46,000 --> 00:17:49,000
So the game is represented as a tree of nodes.

238
00:17:49,000 --> 00:17:54,000
And this is the basic of a game node.

239
00:17:54,000 --> 00:18:00,000
It has a pointer up to its parent and then a list of variations, which in the general

240
00:18:00,000 --> 00:18:02,000
tree structure would be the children.

241
00:18:02,000 --> 00:18:06,000
And there are also some interesting methods on this that allow you to reverse the tree

242
00:18:06,000 --> 00:18:07,000
in different ways.

243
00:18:07,000 --> 00:18:12,000
So game would give you the overall game, which means going all the way back up to the root

244
00:18:12,480 --> 00:18:14,480
end, which is kind of the reverse.

245
00:18:14,480 --> 00:18:19,480
So it's going to follow all the way to the end of the tree down the main line.

246
00:18:19,480 --> 00:18:24,480
And in that case, this means that it's going to take the first child of each node.

247
00:18:24,480 --> 00:18:30,480
And the main line method also gives you an interval of all the nodes basically between

248
00:18:30,480 --> 00:18:32,480
this node and the end.

249
00:18:32,480 --> 00:18:38,480
So those are just some methods that are useful in traversing this particular tree, the game

250
00:18:38,480 --> 00:18:40,480
tree, in a useful way.

251
00:18:42,480 --> 00:18:45,480
And another thing I mentioned was design patterns.

252
00:18:45,480 --> 00:18:48,480
There's going to be a whole lot of talk about this later.

253
00:18:48,480 --> 00:18:52,480
But there is a design pattern in this library that I thought was pretty cool.

254
00:18:52,480 --> 00:18:53,480
It's the visitor pattern.

255
00:18:53,480 --> 00:18:58,480
So the visitor pattern is basically a way to specify a function that you want to run

256
00:18:58,480 --> 00:19:04,480
on each element of a data structure, but you don't want to add that to the class.

257
00:19:04,960 --> 00:19:11,960
So in this case, we have our game nodes, but maybe we don't want to have to modify game

258
00:19:11,960 --> 00:19:16,960
node for every operation we might want to do on the node.

259
00:19:16,960 --> 00:19:18,960
In this case, there's a visitor class.

260
00:19:18,960 --> 00:19:23,960
And what the visitor class allows you to do is specify for each node I want to run a particular

261
00:19:23,960 --> 00:19:24,960
function.

262
00:19:24,960 --> 00:19:29,960
And there's one simple example that's built into the library, and this is like string

263
00:19:29,960 --> 00:19:30,960
exporter.

264
00:19:31,440 --> 00:19:33,440
So this is the visitor.

265
00:19:33,440 --> 00:19:38,440
The visit move method is basically a method that's called on every move in the tree.

266
00:19:38,440 --> 00:19:43,440
And in this case, it's basically just for each move creating a string representation

267
00:19:43,440 --> 00:19:49,440
of that and appending that on to basically a running string that it's keeping.

268
00:19:53,440 --> 00:19:58,440
Another I found this very interesting is the use of standard communication protocols, which

269
00:19:58,920 --> 00:20:02,920
in general programming, I would say it's very useful if you've ever had to collect metrics.

270
00:20:02,920 --> 00:20:07,920
You might have used statsd, which allows you to basically collect metrics and send them

271
00:20:07,920 --> 00:20:12,920
on to Datadog or any other collector in a very standardized way.

272
00:20:12,920 --> 00:20:17,920
One that's come up in my own work very recently is this library called case-serve, which provides

273
00:20:17,920 --> 00:20:23,920
a standard interface for getting model predictions, regardless of the underlying implementation

274
00:20:23,920 --> 00:20:24,920
of the model.

275
00:20:25,400 --> 00:20:27,400
These are like a couple of standard protocols.

276
00:20:27,400 --> 00:20:32,400
I think in programming, we can agree that this is like a super important thing, and

277
00:20:32,400 --> 00:20:34,400
in chess it's no different.

278
00:20:34,400 --> 00:20:39,400
So in the chess world, there's a con protocol for communicating with chess engines, which

279
00:20:39,400 --> 00:20:44,400
means that if you want to write a program that talks to an engine, you don't have to

280
00:20:44,400 --> 00:20:47,400
write a different program for engine A or engine B.

281
00:20:47,400 --> 00:20:52,400
Someone came up with a standard protocol, and it turns out it's very Unix-y, which

282
00:20:52,880 --> 00:20:57,880
is kind of funny, but all the communication goes over standard in and standard out in

283
00:20:57,880 --> 00:21:01,880
a text, and that's kind of the protocol.

284
00:21:01,880 --> 00:21:05,880
It's called UCI, and it's a fairly complex spec.

285
00:21:05,880 --> 00:21:06,880
This is like one example.

286
00:21:06,880 --> 00:21:09,880
This is the go command, and this is used to actually run the engine.

287
00:21:09,880 --> 00:21:13,880
There's a lot of different options, a lot of parameters, and you can imagine that if

288
00:21:13,880 --> 00:21:18,880
you had to implement a client for this, that might get very cumbersome, and you probably

289
00:21:19,360 --> 00:21:25,360
wouldn't want to do it if you're just playing around and want to run a chess engine.

290
00:21:25,360 --> 00:21:31,360
The cool thing is Python chess also has an interface for interacting with any chess engine

291
00:21:31,360 --> 00:21:37,360
over this standard UCI protocol, so this snippet is an example of basically starting out with

292
00:21:39,360 --> 00:21:44,360
Stockfish, which is a commonly used engine, and then allowing it to play a game of chess

293
00:21:44,840 --> 00:21:49,840
against itself, giving it a limit of 100 milliseconds per move.

294
00:21:49,840 --> 00:21:54,840
I shall also mention that Stockfish is also a free-note resource software, which is super

295
00:21:54,840 --> 00:21:55,840
cool.

296
00:21:55,840 --> 00:22:01,840
It's a super, super powerful chess engine, and I wanted to go back to this kind of historical

297
00:22:01,840 --> 00:22:06,840
point, which is in 1997, when Deep Blue beat Garry Kasparov.

298
00:22:06,840 --> 00:22:11,840
This was a huge historical moment requiring years and years of effort by a huge team of

299
00:22:11,840 --> 00:22:12,840
people.

300
00:22:13,320 --> 00:22:19,320
I just think it's really cool that in 2022, through open-source software, you can now

301
00:22:19,320 --> 00:22:25,320
access an engine that's way more powerful than Deep Blue on your laptop using these

302
00:22:25,320 --> 00:22:28,320
open-source tools, so Python, Python Chess, and Stockfish.

303
00:22:28,320 --> 00:22:33,320
I think that's a really cool thing, and kind of shows the power of technology and how much

304
00:22:33,320 --> 00:22:36,320
it's grown.

305
00:22:36,320 --> 00:22:41,320
This is the class that is in the Python Chess library that provides you access to an engine,

306
00:22:41,800 --> 00:22:42,800
and it has two main methods.

307
00:22:42,800 --> 00:22:45,800
It has play and analyze, which do slightly different things.

308
00:22:45,800 --> 00:22:48,800
Play is basically going to play the board that you pass it.

309
00:22:48,800 --> 00:22:55,800
Analyze is slightly more flexible, so you can ask for multiple moves, and it'll basically

310
00:22:55,800 --> 00:22:59,800
just return a dictionary of information.

311
00:22:59,800 --> 00:23:05,800
After going through the internals of the library, the API, how to use it, I wanted to end by

312
00:23:05,800 --> 00:23:09,800
going through two applications of what you might want to do with this library.

313
00:23:10,280 --> 00:23:15,280
I will say this is the more like chessy part of the talk, but I hope that it'll also be

314
00:23:15,280 --> 00:23:17,280
interesting to everyone.

315
00:23:19,280 --> 00:23:25,280
We'll start with an application that I wrote myself, and it has to do with opening training.

316
00:23:25,280 --> 00:23:28,280
Basically, in chess, there's a concept of an opening book.

317
00:23:28,280 --> 00:23:35,280
It's basically, if my opponent plays X, I'm going to play Y to any various depth.

318
00:23:35,280 --> 00:23:39,280
You always play E4 as your first move, things like that.

319
00:23:39,760 --> 00:23:46,760
As an example, this is a representation of one, don't tell anyone my opponent's.

320
00:23:46,760 --> 00:23:50,760
This is like the beginning of my opening book, so I might always play B3 as white.

321
00:23:50,760 --> 00:23:52,760
This has various responses.

322
00:23:52,760 --> 00:23:54,760
They can make various responses I would make back.

323
00:23:54,760 --> 00:23:59,760
It's basically this tree of moves that shows what I would play in a given position, starting

324
00:23:59,760 --> 00:24:01,760
from move one.

325
00:24:01,760 --> 00:24:07,760
As you play more games, as I play more games, the questions I want to ask myself are, how

326
00:24:08,240 --> 00:24:13,240
far am I making it in before I end up out of the book, as they say.

327
00:24:13,240 --> 00:24:16,240
You're having to play on your own with no preparation.

328
00:24:16,240 --> 00:24:19,240
When I reach those positions, am I the one messing it up?

329
00:24:19,240 --> 00:24:24,240
Am I forgetting the moves I should have studied, or is my opponent playing something unexpected?

330
00:24:24,240 --> 00:24:27,240
Maybe, what does the engine think about that?

331
00:24:27,240 --> 00:24:30,240
Am I getting out of book because my opponent is playing terrible moves?

332
00:24:30,240 --> 00:24:34,240
Then maybe I don't need to study those moves because they're obviously bad.

333
00:24:34,240 --> 00:24:36,240
These are a bunch of the questions I had.

334
00:24:36,720 --> 00:24:42,720
Like I said, I had a lot of data to work with in my games, so I wanted to do some analysis.

335
00:24:42,720 --> 00:24:47,720
I ended up with an implementation that basically uses two classes of visitors.

336
00:24:47,720 --> 00:24:51,720
It uses the base visitor from Pipe Out Chess.

337
00:24:51,720 --> 00:24:55,720
This one is a fairly simple implementation.

338
00:24:55,720 --> 00:24:59,720
Basically, on each move, it's getting two things and it's storing them.

339
00:24:59,720 --> 00:25:04,720
It's getting the fen, which is a representation of the position, a unique representation of

340
00:25:05,200 --> 00:25:10,200
the position, and then the move that was made in that position.

341
00:25:10,200 --> 00:25:16,200
This is basically going over my whole opening book and saying, at each position, what move

342
00:25:16,200 --> 00:25:17,200
can be made?

343
00:25:17,200 --> 00:25:23,200
Those moves are represented as a set because in some positions, usually you'd want to have

344
00:25:23,200 --> 00:25:28,200
only one move in each position for your opening book, but obviously your opponent could play

345
00:25:28,200 --> 00:25:30,200
many different moves.

346
00:25:30,680 --> 00:25:35,680
This visitor will go through my whole opening book, which is represented as a PGN and collects

347
00:25:35,680 --> 00:25:36,680
those things.

348
00:25:36,680 --> 00:25:42,680
Once he collects all those things, this is kind of the representation I get, which is

349
00:25:42,680 --> 00:25:43,680
what I wanted.

350
00:25:43,680 --> 00:25:48,680
It's a dictionary that maps keys that are positions to a set of moves.

351
00:25:48,680 --> 00:25:51,680
This is the same example I showed before.

352
00:25:51,680 --> 00:25:56,680
At the start, I will always play B3, hence there's only one move in the set.

353
00:25:56,680 --> 00:25:59,680
The position after that is my opponent's move.

354
00:26:00,160 --> 00:26:05,160
Many of those are in my opening book, so that's the second set you see there and so on through

355
00:26:05,160 --> 00:26:08,160
all the positions that I have represented.

356
00:26:08,160 --> 00:26:15,160
Once I have that, I create another visitor that basically will go over a set of games

357
00:26:15,160 --> 00:26:20,160
and determine at what point in the game did I reach a position that's not in that dictionary.

358
00:26:20,160 --> 00:26:26,160
I've collected from my opening book all the positions that I, in theory, should have studied

359
00:26:26,160 --> 00:26:28,160
and learned what to play here.

360
00:26:28,640 --> 00:26:37,640
Now I go through all my games and then I take the fan, which is the position and the move

361
00:26:37,640 --> 00:26:45,640
and say, if this position is in this dictionary I just created, is the move in the set of

362
00:26:45,640 --> 00:26:47,640
moves or is it not?

363
00:26:47,640 --> 00:26:54,640
If it's not, then I add it to this list basically of divergences and over a series of games

364
00:26:55,120 --> 00:26:58,120
you can collect many of these divergences.

365
00:26:58,120 --> 00:27:03,120
Once I run this visitor on a set of games, you would end up with something like this,

366
00:27:03,120 --> 00:27:10,120
which is a list of metadata about places where I ended up outside of my opening preparation.

367
00:27:10,120 --> 00:27:17,120
For the first one you can see was my fault, so I played as white and on the third move

368
00:27:17,120 --> 00:27:18,120
I played D4.

369
00:27:18,120 --> 00:27:24,120
In my preparation, I was supposed to have learned to play D2, but then the second example

370
00:27:24,600 --> 00:27:29,600
I see is where my opponent diverged, so they played a move that I never expected.

371
00:27:29,600 --> 00:27:32,600
Maybe that's something you want to go study.

372
00:27:32,600 --> 00:27:38,600
Once you create a bunch of these for, say, 1700 blitz games, you can start to aggregate

373
00:27:38,600 --> 00:27:39,600
them.

374
00:27:39,600 --> 00:27:44,600
You can start to get a sense of how far on average you are in the game, how often am

375
00:27:44,600 --> 00:27:48,600
I the one messing up versus my opponent, things like that.

376
00:27:48,600 --> 00:27:53,600
This is pretty useful if you're working on learning a chess opening and you want to figure

377
00:27:54,080 --> 00:27:59,080
out how are you doing and actually trying to learn that and remember the moves you're

378
00:27:59,080 --> 00:28:00,080
supposed to play.

379
00:28:00,080 --> 00:28:05,080
I have a second application, which I think is very interesting, and it's the application

380
00:28:05,080 --> 00:28:12,080
of chess puzzle generation, which before all these tools, software tools, it was pretty

381
00:28:13,080 --> 00:28:14,080
hard.

382
00:28:14,080 --> 00:28:19,080
You had to do a main move, you had to review a game, you had to say, okay, is this an interesting

383
00:28:19,560 --> 00:28:20,560
game?

384
00:28:20,560 --> 00:28:27,560
By some metric, and then you had to go through and say, okay, did the people play this correctly

385
00:28:27,560 --> 00:28:32,560
and kind of find a puzzle through a very manual inspection.

386
00:28:32,560 --> 00:28:39,560
But it turns out the criteria for a puzzle can be generalized, and for a chess puzzle,

387
00:28:40,560 --> 00:28:45,560
you want to basically find a position where one side's chances shift very dramatically.

388
00:28:46,040 --> 00:28:49,040
Usually someone has made a mistake and now someone can take advantage.

389
00:28:49,040 --> 00:28:54,040
In order to take advantage, that player has to play a series of moves where they only

390
00:28:54,040 --> 00:28:59,040
have one move to play, because otherwise, if there's a lot of moves, you can't really

391
00:28:59,040 --> 00:29:00,040
solve the puzzle.

392
00:29:00,040 --> 00:29:03,040
There might be like five solutions and then it's really not that interesting.

393
00:29:03,040 --> 00:29:08,040
After that series of moves, you have to have a measurable outcome, so that might need to

394
00:29:08,040 --> 00:29:12,040
checkmate Stanley or the game of material.

395
00:29:12,520 --> 00:29:17,520
This is an example of a chess puzzle that I just looked at this morning.

396
00:29:17,520 --> 00:29:22,520
I'm a little on time, so I'll run through it quickly, but basically, I won't explain

397
00:29:22,520 --> 00:29:27,520
all the chess logic, but black here can take the rook, which is what I did.

398
00:29:27,520 --> 00:29:32,520
Now white has to take back the rook, because otherwise they'll be down rook.

399
00:29:32,520 --> 00:29:33,520
They have no choice.

400
00:29:33,520 --> 00:29:38,520
But that means black can play the knight, which executes a classic tactic, and then

401
00:29:38,520 --> 00:29:39,520
there's a fork.

402
00:29:40,000 --> 00:29:44,000
In this position, the rook now can't protect from bishop.

403
00:29:44,000 --> 00:29:47,000
The rook has to go somewhere else or be captured by the knight.

404
00:29:47,000 --> 00:29:51,000
Now the knight captures the bishop and black is up a piece.

405
00:29:51,000 --> 00:29:53,000
This is an example of a puzzle.

406
00:29:53,000 --> 00:29:58,000
In this series of moves, there's really only one move for black and one move for white

407
00:29:58,000 --> 00:30:02,000
in order to arrive at this result.

408
00:30:02,000 --> 00:30:09,000
There's a really cool open source tool called Chess Puzzle Maker that basically puts these

409
00:30:09,480 --> 00:30:16,480
criteria into an algorithm that's expressed in Python, and it uses Python Chess.

410
00:30:16,480 --> 00:30:19,480
How is it using Python Chess to find these puzzles?

411
00:30:22,480 --> 00:30:25,480
There's really two functionalities that I wanted to look at.

412
00:30:25,480 --> 00:30:30,480
This is how it finds puzzles, and I basically just wanted to show that here it's using the

413
00:30:30,480 --> 00:30:35,480
game, it's traversing the game tree, it's using some of the methods that I mentioned

414
00:30:35,960 --> 00:30:39,960
that are important in the Python Chess API to basically go through the game and examine

415
00:30:39,960 --> 00:30:40,960
the positions.

416
00:30:40,960 --> 00:30:47,960
It's also using the engine protocol to communicate with Stockfish in order to evaluate the positions

417
00:30:47,960 --> 00:30:49,960
and get the best moves.

418
00:30:52,960 --> 00:30:57,960
To wrap it up, I think Python Chess is a super cool library.

419
00:30:57,960 --> 00:31:04,960
I hope that you learned something, maybe not only about chess, but about Python and programming.

420
00:31:05,440 --> 00:31:10,440
And as my final slide, I wanted to show a simple program.

421
00:31:10,440 --> 00:31:13,440
So this is using Python Chess to play just two moves.

422
00:31:13,440 --> 00:31:16,440
This is an opening C4, G6.

423
00:31:16,440 --> 00:31:20,440
This is known as the Great Snake Variation, and I just thought it was a nice way to show

424
00:31:20,440 --> 00:31:23,440
that Python and chess can go well together.

425
00:31:23,440 --> 00:31:24,440
Thank you.

426
00:31:24,440 --> 00:31:27,440
My Twitter is where you can find me.

427
00:31:27,440 --> 00:31:30,440
If you want to find me on chess, there's my account.

428
00:31:30,440 --> 00:31:31,440
You can send me a challenge.

429
00:31:31,440 --> 00:31:32,440
Thank you all.

