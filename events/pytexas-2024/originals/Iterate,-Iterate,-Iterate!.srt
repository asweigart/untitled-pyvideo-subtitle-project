1
00:00:00,000 --> 00:00:08,000
My name is Moshe Zadka. My website is... Thank you. My website is

2
00:00:08,000 --> 00:00:11,280
CobraDism.com where you can find every way of reaching out to me known to

3
00:00:11,280 --> 00:00:14,880
humankind. I work for Anthropic and I definitely do not speak for my employer.

4
00:00:14,880 --> 00:00:20,840
And today I want to talk to you a little bit about iteration. So let's talk about

5
00:00:20,840 --> 00:00:25,440
what's gonna be on the agenda. I'm gonna talk about what iteration is in Python

6
00:00:25,440 --> 00:00:28,880
because that's kind of nuanced and subtle. I'm gonna talk about how to do

7
00:00:28,880 --> 00:00:34,240
that. We're gonna talk about how not to do it. So that'll be fun. And then I'll talk

8
00:00:34,240 --> 00:00:38,800
about like you know why you should use it and like where. So okay let's get

9
00:00:38,800 --> 00:00:44,440
started because we have a lot of stuff to cover. So I'm sure many of you have

10
00:00:44,440 --> 00:00:47,440
heard the word iterable. You know what? Let me start with a question. How many

11
00:00:47,440 --> 00:00:51,320
of you have done iteration in Python? Use the for loop comprehension or call the

12
00:00:51,320 --> 00:00:56,240
list constructor? How many of you feel like you really understand how

13
00:00:56,280 --> 00:01:04,760
it works internally? Great. So that's what I expected. Cool. So iterable. An iterable

14
00:01:04,760 --> 00:01:10,560
is a protocol that has one method in it which is __iter__ and it returns an

15
00:01:10,560 --> 00:01:15,720
iterator. I should have started with an iterator, right? Well kind of hard

16
00:01:15,720 --> 00:01:19,840
because iterator is something that inherits from iterable, right? So it also

17
00:01:19,840 --> 00:01:24,840
has a __iter__ method but it also has a __next__ method that

18
00:01:24,880 --> 00:01:30,440
raises StopIteration. Now there's one extra kind of twist to that which is

19
00:01:30,440 --> 00:01:35,280
obviously does a __iter__ method because it inherits from iterable but

20
00:01:35,280 --> 00:01:41,840
__iter__ on an iterator returns self. So that's pretty cool because it means

21
00:01:41,840 --> 00:01:47,600
it's always safe to call iter and that's a good segue to my next bit. We never

22
00:01:47,600 --> 00:01:51,800
call Dunder functions in Python directly. We always call them through an operator

23
00:01:52,680 --> 00:01:56,960
and in this case through these two things. So if you want to call the Dunder

24
00:01:56,960 --> 00:02:01,280
method you call iter and if you want to call __next__ you call next. That also

25
00:02:01,280 --> 00:02:04,760
works correctly with like C types and things that don't technically have the

26
00:02:04,760 --> 00:02:10,920
Dunder method. So basically that's how iteration works from the inside in

27
00:02:10,920 --> 00:02:17,800
Python. So let's write something iterable, right? We know what we need to do. What we

28
00:02:17,800 --> 00:02:25,280
do is put a __iter__ method on it and return an iterator. Well, luckily we have

29
00:02:25,280 --> 00:02:29,560
something that returns iterators really efficiently, right? So we snuff iter from

30
00:02:29,560 --> 00:02:33,280
Python and that's an iterable thing, right? Like I have implemented an

31
00:02:33,280 --> 00:02:38,160
iterable class. Great. Now let's implement an iterator.

32
00:02:38,160 --> 00:02:43,800
Oops, sorry. Before we implement an iterator, here's how we use it, right? So we call

33
00:02:43,800 --> 00:02:48,960
iter on it. That's called the __iter__ method. That's an iterator and then we

34
00:02:48,960 --> 00:02:53,120
just call next on it and we get, you know, one and ten, right? So that works, right?

35
00:02:53,120 --> 00:02:59,560
That's like, you know, the basics of iteration. That is the iter method. Okay.

36
00:02:59,560 --> 00:03:04,640
So now let's see if we want to write an iterator, right? I'm kind of cheating and

37
00:03:04,640 --> 00:03:08,480
I'm not implementing the __iter__ method because it won't fit on the slide.

38
00:03:08,480 --> 00:03:13,640
But I'm putting two things and whenever I call next I just grab the next thing

39
00:03:13,640 --> 00:03:19,240
and pop it out of the list. But you notice that when I, if you remember like

40
00:03:19,240 --> 00:03:24,360
when I talked about the protocols, when this ends it has to raise a stop

41
00:03:24,360 --> 00:03:28,080
iteration error. This will stop an index error so I have to translate the

42
00:03:28,080 --> 00:03:33,600
exception and now it's a proper iterator. Well, how do I know that? Because I did

43
00:03:33,600 --> 00:03:38,440
this, right? So I build the iterator. You notice that I didn't have to call

44
00:03:38,440 --> 00:03:43,520
iter because it's already an iterator. I called next. I called next. It gave me the

45
00:03:43,520 --> 00:03:50,060
numbers. But, ha-ha, what happens when I call next again? Well, it raises stop

46
00:03:50,060 --> 00:03:53,680
iteration. That's great, right? So that means we've implemented the iterators

47
00:03:53,680 --> 00:03:57,960
properly. And you will notice that like implementing an iterator was kind of

48
00:03:57,960 --> 00:04:01,200
annoying and weird and I had to do weird stuff for that and we'll get back to

49
00:04:01,200 --> 00:04:08,080
that in a few minutes. But first, like, you know, I called next an iter manually

50
00:04:08,080 --> 00:04:12,840
here and like you probably have never done that or maybe done it like, you know,

51
00:04:12,880 --> 00:04:17,080
half a dozen times in your life. Probably most of the time you're going to call

52
00:04:17,080 --> 00:04:21,960
for. So, okay, for for I basically also need to implement under iter and I'm

53
00:04:21,960 --> 00:04:26,240
also going to add a lot of prints. Why am I adding the prints? Because I want you

54
00:04:26,240 --> 00:04:34,920
to see how for works. So you see I have a print from before, a print and after

55
00:04:34,920 --> 00:04:40,440
the for. And notice that for already swallowed the StopIterationException

56
00:04:40,440 --> 00:04:45,840
that we raised. It's a reason exception. There is no try catch here. That

57
00:04:45,840 --> 00:04:50,760
exception got swallowed. That exception is what signals for to be done. So it's a

58
00:04:50,760 --> 00:04:53,640
very critical exception to remember and remember to kind of raise the right

59
00:04:53,640 --> 00:04:58,440
exception. But then you see that like, you know, every time it calls next

60
00:04:58,440 --> 00:05:01,960
internally, right, you know that because it prints out from the next and then it

61
00:05:01,960 --> 00:05:05,640
actually gets a value and prints out from the for. So this is a good way to

62
00:05:05,680 --> 00:05:11,520
kind of get visibility into like actually how for works from the inside. So if you

63
00:05:11,520 --> 00:05:15,080
remember in the poll in the beginning, I mentioned that, like, you know, if you

64
00:05:15,080 --> 00:05:18,840
have iterated in Python, you might have used one of three ways, which is to use

65
00:05:18,840 --> 00:05:24,400
for loops, list comprehensions and remember the third thing. Use the least

66
00:05:24,400 --> 00:05:31,760
constructor. So the least construction is an iterator, right? It will iterate over

67
00:05:31,760 --> 00:05:36,320
your stuff and put it into a list. You can see that, right? It does all the

68
00:05:36,320 --> 00:05:40,760
iteration before. It swallowed the stop. Look, I do not have an explicit try

69
00:05:40,760 --> 00:05:45,840
accept here. But if you remember, I do raise an exception. So it called all of

70
00:05:45,840 --> 00:05:51,000
these things. It swallowed the exception. It gave me the list, right? So that's

71
00:05:51,000 --> 00:05:54,960
another way to iterate. And that's important because you often don't think

72
00:05:54,960 --> 00:06:00,720
of it as iterating, right? And this calls arbitrary code. Arbitrary, right? I did

73
00:06:00,720 --> 00:06:04,280
print, right? I could have, like, you know, connected to the internet, you know,

74
00:06:04,280 --> 00:06:07,960
for the same price, right? So it's really important to remember that the least

75
00:06:07,960 --> 00:06:14,920
thing can call, like, arbitrary code. Okay. So I'm sure that if you've heard of,

76
00:06:14,920 --> 00:06:19,880
like, iterators, someone, like, threw away the word generator. So what's the

77
00:06:19,880 --> 00:06:23,560
connection between an iterator and a generator? That's very nuanced. An iterator

78
00:06:23,560 --> 00:06:27,080
is a protocol. It says what you're supposed to do. What you're supposed to

79
00:06:27,240 --> 00:06:30,840
do is you're supposed to have __next__. They're supposed to obey certain

80
00:06:30,840 --> 00:06:36,360
constraints. But you remember that I wrote an iterator myself, right? And it

81
00:06:36,360 --> 00:06:40,640
barely fit on a slide. It was the simplest iterator you can imagine. And it

82
00:06:40,640 --> 00:06:43,680
was annoying to write, right? I had to, like, you know, put state and I had to,

83
00:06:43,680 --> 00:06:47,960
like, you know, put a pop and remember where I am. And it's kind of annoying. If

84
00:06:47,960 --> 00:06:50,520
you ever want to write an iterator yourself, you probably want an easier way

85
00:06:50,560 --> 00:07:01,240
to do it. Luckily, so Python has generators. Generators are a facility, a

86
00:07:01,240 --> 00:07:08,600
language construct that will let you implement iterators much more easily. So

87
00:07:08,600 --> 00:07:14,320
why is it so easy to implement iterators with generators? So, you know, basically

88
00:07:14,320 --> 00:07:18,760
this is very equivalent to, like, the previous one, right? You know, we turn

89
00:07:18,800 --> 00:07:23,600
the same things, one and ten. And it also does a bunch of prints for more or less

90
00:07:23,600 --> 00:07:27,320
the same reason that we did prints before, so that you can see the prints when

91
00:07:27,320 --> 00:07:31,200
they come out. So, well, we all remember how to iterate through that, right?

92
00:07:31,200 --> 00:07:35,800
Because I did a few slides ago. So let's iterate, right? Like same thing I write

93
00:07:35,800 --> 00:07:40,520
before and after. And you'll see, like, you know, it's the same flow, right? And

94
00:07:40,520 --> 00:07:46,120
when it gets to the end, again, remember four only stops when it sees a stop

95
00:07:46,120 --> 00:07:50,760
iteration exception, which means there's a hidden throw or, like, a raise at the

96
00:07:50,760 --> 00:07:57,800
end that raised a stop iteration and then four swallowed it and returned. So in

97
00:07:57,800 --> 00:08:02,680
this case, both the raise and the try and accept are invisible for different

98
00:08:02,680 --> 00:08:07,960
reasons. The generator has a hidden raise and the for loop has a hidden try

99
00:08:07,960 --> 00:08:13,080
accept, so you don't see any of them. But it's important to remember that earlier

100
00:08:13,080 --> 00:08:17,120
on, before I used any of these, like, you know, nice language constructs, they had

101
00:08:17,120 --> 00:08:20,760
try and accept and raise, and that was explicit. This is the same thing, but

102
00:08:20,760 --> 00:08:29,160
they're invisible. Okay, so yield form is really, really nice in generators

103
00:08:29,160 --> 00:08:35,680
because it is the equivalent of calling a function from another function, right?

104
00:08:35,680 --> 00:08:42,480
Except nuance, yield form, the input of that does not have to be a generator. In

105
00:08:42,960 --> 00:08:47,920
fact, it does not have to be an iterator. It only needs to be an iterable, right?

106
00:08:47,920 --> 00:08:51,800
That's important. Remember, iterable is something that you can call iter on it to

107
00:08:51,800 --> 00:08:57,800
get an iterator. Every iterator is an iterable because if you call iter on

108
00:08:57,800 --> 00:09:01,800
iterator, you get itself. Every generator is an iterator because we saw that

109
00:09:01,800 --> 00:09:07,560
earlier. So often, right, especially if you have, like, a recursive generator, you

110
00:09:07,560 --> 00:09:11,280
know, then it will call itself. And if you have a recursion, usually that's the

111
00:09:11,280 --> 00:09:16,000
form it will take, a yield form. But the yield form can do anything, right? You can

112
00:09:16,000 --> 00:09:20,440
yield from one comma two, and that will be fine, right? Because it's a tuple and

113
00:09:20,440 --> 00:09:26,240
tuple, blah, blah, blah. So it's kind of weird, but you can do that. Anyway, so you

114
00:09:26,240 --> 00:09:31,680
see, I do a list of that, right? It prints begin, middle, end. Those come from the

115
00:09:31,680 --> 00:09:35,480
yield form. I probably should have added another print before the hundred, but you

116
00:09:35,480 --> 00:09:43,120
see, the result is 110, 100. Right? So this is pretty cool. So now we get, like, a sense

117
00:09:43,120 --> 00:09:46,880
of, like, why generators are so useful. Because, again, imagine implementing this

118
00:09:46,880 --> 00:09:53,160
logic yourself in a class with, like, a dunder iter on the next method. It would

119
00:09:53,160 --> 00:09:57,040
be a lot of code, lots of annoying code, you have to remember. Am I still doing the

120
00:09:57,040 --> 00:10:01,240
yield form, so I need to continue that? Or am I done? Like, you know, you'd have to

121
00:10:01,240 --> 00:10:04,560
have, like, very complicated state. You basically be implementing kind of a

122
00:10:04,960 --> 00:10:10,320
mini interpreter. This way, you get to use the Python interpreter, sort of, you

123
00:10:10,320 --> 00:10:17,680
know, implement your own mini interpreter. So remember I said list is a way of

124
00:10:17,680 --> 00:10:22,520
iterating? So I was not lying, but I was not being completely truthful. Every

125
00:10:22,520 --> 00:10:26,760
single sequence constructor is a way of iterator, right? So list is a sequence

126
00:10:26,760 --> 00:10:32,000
constructor. It constructs lists, which are a sequence. Double-ended queue, also a

127
00:10:32,000 --> 00:10:36,760
sequence constructor. You can make a double-ended queue with a length of zero.

128
00:10:38,080 --> 00:10:41,240
But still, when you call the constructor, it will consume your iterator. And that's

129
00:10:41,560 --> 00:10:44,360
occasionally very useful. Sometimes you want to kind of eat up the iterator

130
00:10:44,360 --> 00:10:48,920
without taking any extra space, maybe because you want the side effects, right?

131
00:10:48,960 --> 00:10:53,160
For example, in here, the side effects are printing, right? So it prints, but it

132
00:10:53,160 --> 00:10:58,840
takes zero space. Again, kind of an esoteric use case, but it's important to

133
00:10:58,880 --> 00:11:03,600
hold this use case in mind, because there are very similar use cases to that that

134
00:11:03,600 --> 00:11:06,840
will be important, and it's important to remember that these two have like almost

135
00:11:06,840 --> 00:11:10,720
nothing to do with each other. Okay, so any sequence constructor is a way of

136
00:11:10,720 --> 00:11:16,680
explicitly iterating to the end of your iterator or any iterable, because it will

137
00:11:16,680 --> 00:11:21,200
implicitly convert it to iterator. And as I said, every generator is an iterator.

138
00:11:21,640 --> 00:11:25,440
I think it's important to repeat that because people will often kind of use these

139
00:11:25,440 --> 00:11:28,280
things informally and say this is a way to consume everything from a generator.

140
00:11:28,280 --> 00:11:31,680
No, this is a way to consume everything from an iterable. A generator is an

141
00:11:31,680 --> 00:11:39,040
iterator is an iterable. So like I said, like you can convert an iterable to

142
00:11:39,040 --> 00:11:43,840
iterator, but what what other ways can you take an iterable and convert it to

143
00:11:43,840 --> 00:11:49,400
iterator? So there's a lot of fun functions in Python. The signature is

144
00:11:49,680 --> 00:11:57,040
take iterable, maybe take several intervals and return an iterator. It does

145
00:11:57,040 --> 00:12:00,440
not promise you that it will return a generator, but usually you don't care

146
00:12:00,440 --> 00:12:02,760
about the implementation. It does promise you that it will return an

147
00:12:02,760 --> 00:12:07,360
iterator. And that's very useful. It will be on demand, right? So it doesn't take

148
00:12:07,360 --> 00:12:11,880
any extra space. And so why do I mention that like there's a lot of functions like

149
00:12:11,880 --> 00:12:17,080
that? So I'm going to go fairly quickly to the function because of a gazillion of

150
00:12:17,080 --> 00:12:23,200
them. And if I went to like all of them to take most of the talk, I have a lot of

151
00:12:23,200 --> 00:12:26,560
other stuff to get through. So there's like, you know, lots more details in the

152
00:12:26,560 --> 00:12:30,960
handouts later. But I'll kind of cover like some of my favorites. So there's

153
00:12:30,960 --> 00:12:36,040
enumerate, which give you indices, which is a good alternative whenever you see

154
00:12:36,280 --> 00:12:44,840
someone doing form I of range len, enumerate, better. Map, really useful,

155
00:12:45,160 --> 00:12:49,400
right? And again, always returns an iterator. It doesn't do all the things in

156
00:12:49,400 --> 00:12:53,560
the beginning. It does things on demand. Let's see one arbitrary functions on

157
00:12:53,560 --> 00:12:59,840
your iterables, which might be an iterator. So for example, or you can use

158
00:12:59,840 --> 00:13:04,280
filter. It's kind of nuanced with filter and especially with partial because

159
00:13:04,280 --> 00:13:09,440
partial has the order. So greater or equal to five means five greater or

160
00:13:09,440 --> 00:13:12,600
equal to the thing, which means it will give you all the things that are less

161
00:13:12,600 --> 00:13:20,400
than five. In this case, one and three, it skips the 10. Zip takes a few

162
00:13:20,400 --> 00:13:27,160
iterable and gives you an iterator of the tuples. Again, very useful when you

163
00:13:27,160 --> 00:13:30,480
need to kind of combine. And remember, these two can be completely different

164
00:13:30,480 --> 00:13:34,000
generators, which means each of them might have a different flow and zip kind

165
00:13:34,000 --> 00:13:40,040
of coordinates them. Super useful in many use cases. And then if you're like,

166
00:13:40,040 --> 00:13:44,240
if you don't find exactly the right stuff you need, we have arbitrary generator

167
00:13:44,240 --> 00:13:47,680
expressions, right? So if you can think it, you can code it, right? Like if you

168
00:13:47,680 --> 00:13:53,240
can think of a way to combine several iterables into an iterator, you can do

169
00:13:53,240 --> 00:14:00,080
that this way and just do it in line, right? So that's very useful. Now

170
00:14:00,080 --> 00:14:05,280
sometimes, like I covered the language and the built-in, there's a

171
00:14:05,280 --> 00:14:10,160
useful module that's called itertools in the standard library having functions

172
00:14:10,160 --> 00:14:14,320
like, so it's a standard library module and basically has like, you know, even more

173
00:14:14,320 --> 00:14:19,440
advanced iterator algebra. So it has chain, which will combine iterators one

174
00:14:19,440 --> 00:14:22,760
after the other. Extremely useful, especially if you want like a little

175
00:14:22,760 --> 00:14:27,400
prefix before you do the real stuff to kind of, you know, warm up something. You

176
00:14:27,400 --> 00:14:30,640
can have islice, which is a really, really good way to deal with infinite

177
00:14:30,640 --> 00:14:34,320
iterators. As you saw earlier, I can do infinite iterators just by not ever

178
00:14:34,320 --> 00:14:39,560
raising a stop iteration. This way, you can kind of like limit the potential

179
00:14:39,560 --> 00:14:45,760
size. You have count, which is an infinite iterator, which just count from

180
00:14:45,760 --> 00:14:50,280
zero to infinity. Very useful, especially if you zip it up with something.

181
00:14:53,040 --> 00:14:58,320
And if those are not enough, there is a library in PyPI where they took all the

182
00:14:58,320 --> 00:15:02,080
suggestions from itertools documentation of like what cool stuff you

183
00:15:02,080 --> 00:15:05,080
can do and just did it so that you don't have to like, you know, copy and paste

184
00:15:05,080 --> 00:15:10,400
from the documentation to your code. So basically like a lot of like really

185
00:15:10,400 --> 00:15:14,360
useful stuff like chunked, which will give you chunks. Very useful if you want

186
00:15:14,360 --> 00:15:18,080
to batch process something, especially if it comes in via stream infinite.

187
00:15:20,400 --> 00:15:24,600
You can distribute, which is the opposite, right? So again, if you kind of

188
00:15:24,600 --> 00:15:27,760
want to give something to like, you know, several threads or several kind of

189
00:15:27,760 --> 00:15:31,640
async flows or stuff like that, you can kind of distribute like that.

190
00:15:32,480 --> 00:15:36,360
There's peekable, which is very useful when you want to kind of look into the

191
00:15:36,360 --> 00:15:41,760
future. You know, so I want to stop one before I get to three, right?

192
00:15:41,760 --> 00:15:46,600
So like zero, one, but I want to get, no, not do the two, right?

193
00:15:46,600 --> 00:15:49,320
Like as soon as three is closed, I want to stop, right?

194
00:15:49,320 --> 00:15:51,280
Again, there's some use cases where this is useful.

195
00:15:51,840 --> 00:15:54,760
Pickable is like super useful and you don't have to sync, right?

196
00:15:54,760 --> 00:15:58,240
You just pick and use, otherwise you use the iterator as is, right?

197
00:15:58,240 --> 00:15:59,480
So this is amazing. I love it.

198
00:15:59,760 --> 00:16:03,920
And this is windowed, which I really like for like doing ranges, right?

199
00:16:03,920 --> 00:16:07,640
So if you have like timestamps and you want to know the differences between

200
00:16:07,640 --> 00:16:10,640
the timestamps, like, you know, for example, like, you know, for like

201
00:16:10,640 --> 00:16:14,640
something like meantime between failures or stuff like that, that's basically

202
00:16:14,640 --> 00:16:16,240
all the code you need for that kind of stuff.

203
00:16:19,280 --> 00:16:20,840
So here are a few gotchas, right?

204
00:16:20,840 --> 00:16:24,480
Like so far I was like, you know, super enthusiastic about the iterators, right?

205
00:16:24,480 --> 00:16:27,240
And I was like, you know, here's like, you know, all the things that are really

206
00:16:27,240 --> 00:16:30,320
useful, but they are like weirdly mutable.

207
00:16:30,320 --> 00:16:34,800
And I kind of mentioned that because you'd often see iterators kind of mentioned

208
00:16:34,800 --> 00:16:37,120
right next to like functional programming, right?

209
00:16:37,120 --> 00:16:39,000
Because you saw the code I wrote before, right?

210
00:16:39,000 --> 00:16:42,240
Like, you know, I had map and filter and kind of like very abstract flows.

211
00:16:44,080 --> 00:16:46,600
That don't really kind of like, you know, mutate everything and everything

212
00:16:46,600 --> 00:16:49,280
kind of flows, so it looks very nice and functional.

213
00:16:49,560 --> 00:16:52,120
You remember that like at the end point, it's not functional.

214
00:16:52,120 --> 00:16:53,360
It's like the opposite of functional.

215
00:16:53,360 --> 00:16:55,280
It's like super stateful, right?

216
00:16:55,280 --> 00:16:57,200
And this is like the example of how stateful it is.

217
00:16:57,640 --> 00:17:01,280
Once you consume an iterator, it has been consumed.

218
00:17:01,800 --> 00:17:03,800
If you try to consume it again, you'll get zero.

219
00:17:04,040 --> 00:17:06,080
This is a source of many subtle bugs.

220
00:17:06,600 --> 00:17:09,360
If you see a subtle bug like that, that means you did that.

221
00:17:10,040 --> 00:17:11,200
How do you avoid this bug?

222
00:17:12,400 --> 00:17:13,120
There's two ways.

223
00:17:14,560 --> 00:17:17,040
One, make sure you pass in the sequence.

224
00:17:17,040 --> 00:17:20,920
This would require you to refactor code from being iterator focused to like

225
00:17:20,920 --> 00:17:23,320
passing in a sequence that might be a lot of refactoring.

226
00:17:24,320 --> 00:17:26,880
So, you know, a lot of code, but pretty efficient.

227
00:17:28,360 --> 00:17:33,680
The other way fixes it at like the point of consumption.

228
00:17:34,200 --> 00:17:39,400
So you don't have to refactor, but in return, you have to kind of freeze

229
00:17:39,960 --> 00:17:45,800
the free the iterator, which can be very heavyweight in memory and time wise.

230
00:17:45,800 --> 00:17:46,000
Right.

231
00:17:46,000 --> 00:17:49,040
At this point, have to do all the computation to freeze it.

232
00:17:50,040 --> 00:17:53,920
There's like more sophisticated solutions if you use more-iterator tools.

233
00:17:54,440 --> 00:17:55,600
But that's probably enough.

234
00:17:55,920 --> 00:17:59,000
But like, I want you to kind of just be mindful of the bug and mindful that

235
00:17:59,000 --> 00:18:02,200
there are ways to fix it as long as you think very, very carefully.

236
00:18:04,760 --> 00:18:05,120
Cool.

237
00:18:05,840 --> 00:18:09,080
And then my favorite bug, this is like everybody's favorite bugs.

238
00:18:09,400 --> 00:18:14,400
If you have a dictionary and you have an iterator on it and you try to

239
00:18:14,400 --> 00:18:18,880
use the iterator after you have mutated the dictionary, it will do this.

240
00:18:19,920 --> 00:18:23,080
Uh, this will be the sign that you are in a sad place.

241
00:18:23,240 --> 00:18:24,640
There are ways to solve it.

242
00:18:25,240 --> 00:18:29,480
I don't really have time to delve into all of them, but like potentially using

243
00:18:29,480 --> 00:18:34,240
like, um, immutable data structures instead of dictionaries is a good

244
00:18:34,240 --> 00:18:39,080
way of solving that, uh, it is important to like, no, no, the shape of the bug.

245
00:18:39,400 --> 00:18:41,520
This is kind of the, the abstract shape.

246
00:18:41,880 --> 00:18:46,120
Usually that's not like the, um, pure form of like how it would look.

247
00:18:46,120 --> 00:18:48,160
Usually there'll be a for loop somewhere in the middle.

248
00:18:48,440 --> 00:18:52,320
Like I said, four is a much more popular way of doing iteration.

249
00:18:52,520 --> 00:18:56,120
So usually this will come in a for loop where in like one of the sub sub

250
00:18:56,120 --> 00:18:58,880
branches, you call a functions that modify the dictionary.

251
00:18:58,880 --> 00:19:02,960
That's like, you know, like usually how this bug looks, but this is

252
00:19:02,960 --> 00:19:04,440
kind of like the back condensed.

253
00:19:04,480 --> 00:19:05,600
So I want you to see that.

254
00:19:05,600 --> 00:19:08,600
And remember that like, whenever you see that it's basically this

255
00:19:08,600 --> 00:19:10,880
except spread probably of course, like five files.

256
00:19:11,160 --> 00:19:14,480
So now you have to track it down, but at least now you have kind of a, a

257
00:19:14,480 --> 00:19:17,120
thread, a memory hint to kind of, you know, know what to look for.

258
00:19:18,760 --> 00:19:23,480
And, oh my God, this is my favorite bucket because, uh, this happened at

259
00:19:23,480 --> 00:19:26,680
the worst time, what do I mean by it happened at the worst time?

260
00:19:26,840 --> 00:19:29,480
Let's say that you have kind of complicated code and there's some issues.

261
00:19:30,040 --> 00:19:30,280
Okay.

262
00:19:30,280 --> 00:19:32,600
Well, let me kind of reduce like, you know, some variables.

263
00:19:32,600 --> 00:19:35,880
I'll comment out some of the complicated flows so I can concentrate

264
00:19:35,880 --> 00:19:37,000
on like what's really happening.

265
00:19:37,800 --> 00:19:38,680
So you know what?

266
00:19:38,720 --> 00:19:38,800
Okay.

267
00:19:38,800 --> 00:19:42,200
I have this function, it yields hello, and then does a print and then it

268
00:19:42,200 --> 00:19:45,200
yields goodbye and potentially it's like being used in a very complicated

269
00:19:46,000 --> 00:19:46,760
unit test.

270
00:19:47,240 --> 00:19:52,080
Um, and like the hello just causes a lot of printouts and like some

271
00:19:52,080 --> 00:19:53,200
trying to figure out what's going on.

272
00:19:53,200 --> 00:19:54,840
So I'm like, okay, let's call it out the hello.

273
00:19:54,840 --> 00:19:56,040
I don't actually need it right now.

274
00:19:56,240 --> 00:19:56,760
That's fine.

275
00:19:57,520 --> 00:20:01,520
I call it out the hello and I want the unit test and there's still

276
00:20:01,520 --> 00:20:02,600
a lot of printouts, right?

277
00:20:02,600 --> 00:20:03,680
There's still kind of a lot of junk.

278
00:20:03,680 --> 00:20:04,640
And I'm like, you know what?

279
00:20:04,680 --> 00:20:07,040
I actually don't need anything from this function for like, you

280
00:20:07,040 --> 00:20:08,360
know, debugging my specific bug.

281
00:20:08,400 --> 00:20:10,720
I can call it out the goodbye too, cause I don't need it.

282
00:20:10,720 --> 00:20:18,560
Those of you who have experienced it know what's going to happen after

283
00:20:18,560 --> 00:20:22,240
I call it out to the last field, this is no longer a generator.

284
00:20:23,240 --> 00:20:24,120
Now it's a function.

285
00:20:24,800 --> 00:20:27,760
Now when I call it, it does stuff.

286
00:20:27,920 --> 00:20:29,600
When you call a generator, it doesn't do anything, right?

287
00:20:29,600 --> 00:20:31,920
It returns an iterator that will do stuff when you iterate through it.

288
00:20:32,240 --> 00:20:36,080
You'll see that I, and now I get the printout of going and the return value

289
00:20:36,080 --> 00:20:39,640
is none, so if I try to iterate through it, it'll just fail.

290
00:20:40,480 --> 00:20:46,480
The last yield you comment out stops it from being a generator.

291
00:20:47,080 --> 00:20:48,960
That is something you will encounter often.

292
00:20:48,960 --> 00:20:52,080
If you kind of do this kind of debugging by kind of commenting out flows that

293
00:20:52,080 --> 00:20:54,520
you don't care about to kind of focus on the flow that you do.

294
00:20:55,760 --> 00:20:56,600
There is a trick.

295
00:20:57,400 --> 00:20:58,200
This is a trick.

296
00:20:59,280 --> 00:21:01,560
I do if false yield, right?

297
00:21:01,560 --> 00:21:03,040
Cause like for Python, that's enough.

298
00:21:03,080 --> 00:21:04,560
I don't care if it's true.

299
00:21:04,760 --> 00:21:07,440
It just gives it as a yield somewhere in the function for you.

300
00:21:07,440 --> 00:21:08,360
That's also great.

301
00:21:08,880 --> 00:21:13,200
And luckily, because it yields a none, that will also trigger the type checker.

302
00:21:13,480 --> 00:21:17,240
So if you forget to undo it before you check in, you'll remember.

303
00:21:17,880 --> 00:21:19,760
So a very neat trick.

304
00:21:20,120 --> 00:21:24,240
And when you run into that, that might be the difference between you being

305
00:21:24,240 --> 00:21:26,400
very sad and you not being very sad.

306
00:21:26,440 --> 00:21:27,760
So I like showing that.

307
00:21:29,840 --> 00:21:30,280
Cool.

308
00:21:30,360 --> 00:21:34,000
So let me kind of, I think I'm very close to the end.

309
00:21:34,280 --> 00:21:37,720
So I want to go over like, you know, what I talked and like where I want you to

310
00:21:37,720 --> 00:21:38,400
take it from here.

311
00:21:38,840 --> 00:21:40,840
So we covered iterators and generators.

312
00:21:41,880 --> 00:21:44,800
Interactors are a very useful interface in Python, right?

313
00:21:44,800 --> 00:21:47,840
Like you saw that like, there's like a lot of stuff that focuses on this

314
00:21:47,840 --> 00:21:49,360
interface between different flows.

315
00:21:49,680 --> 00:21:54,320
It's a good way to express some sort of something that kind of, you know, gives

316
00:21:54,320 --> 00:22:00,560
you one value after the next kind of in a, in a reasonable way implementing

317
00:22:00,560 --> 00:22:04,920
in used to be annoying, but with generators, implementing them is very nice.

318
00:22:04,960 --> 00:22:09,120
So if you use generators, you can easily implement iterators and you get a good

319
00:22:09,120 --> 00:22:11,160
way to use that interface.

320
00:22:13,120 --> 00:22:18,160
You have basically a whole algebra that focuses on just in time stuff, right?

321
00:22:18,400 --> 00:22:22,800
You take stuff that you wrote that is just in time and you combine it, you

322
00:22:22,800 --> 00:22:26,640
know, with stuff like zip and map and chunked and windowed and you still

323
00:22:26,640 --> 00:22:28,200
everything is just in time, right?

324
00:22:28,240 --> 00:22:33,360
As long as you just call these functions, nothing happens and they only respond to

325
00:22:33,360 --> 00:22:38,880
like being iterated on top of and say, if you islice it, it will be like, you

326
00:22:38,880 --> 00:22:41,960
know, kind of limited amount of time.

327
00:22:42,360 --> 00:22:42,640
Right?

328
00:22:42,640 --> 00:22:46,720
So, so like, like everything here is like very just in time, which is very useful.

329
00:22:46,720 --> 00:22:46,880
Right?

330
00:22:46,880 --> 00:22:50,600
You write, get to write your abstract code and the implementation just in time.

331
00:22:50,960 --> 00:22:52,360
That can also be confusing.

332
00:22:53,160 --> 00:22:53,520
Right?

333
00:22:53,720 --> 00:22:58,440
And that's based on functions that that's kind of actually like, uh, more

334
00:22:58,440 --> 00:22:58,960
on us than that.

335
00:22:59,160 --> 00:23:01,480
They accept intervals and return it to us.

336
00:23:02,200 --> 00:23:02,480
Right.

337
00:23:03,000 --> 00:23:06,000
Um, and the composable tools, right?

338
00:23:06,000 --> 00:23:11,840
You can use map of a zip of an ice slice of account of like, you know, and

339
00:23:11,840 --> 00:23:12,920
like do all of these things.

340
00:23:12,920 --> 00:23:13,120
Right?

341
00:23:13,120 --> 00:23:17,040
So, um, basically all these tools are like super, super composable.

342
00:23:19,400 --> 00:23:23,920
Uh, and luckily because it's like such a useful interface, it's a huge ecosystem,

343
00:23:24,280 --> 00:23:29,520
which means if you want to do something with iterators, your first instinct should

344
00:23:29,520 --> 00:23:34,400
probably be not reach for like, you know, kind of a really complicated, um,

345
00:23:34,480 --> 00:23:35,600
generator expression.

346
00:23:35,600 --> 00:23:38,160
Your first instinct should be to do some research.

347
00:23:38,920 --> 00:23:41,080
Someone has probably solved this before.

348
00:23:41,400 --> 00:23:41,640
Right?

349
00:23:41,640 --> 00:23:45,360
If you're starting to like implement something like windowed or chunked,

350
00:23:45,600 --> 00:23:48,480
well, like these things are like very twiddly to, to implement.

351
00:23:49,040 --> 00:23:50,000
You don't need, right?

352
00:23:50,000 --> 00:23:53,560
And those are just for me more into tools as tons of ecosystem outside of that.

353
00:23:54,760 --> 00:23:54,840
Right.

354
00:23:54,840 --> 00:23:56,600
Consume that ecosystem, right?

355
00:23:56,600 --> 00:23:57,880
You're probably already used to that.

356
00:23:57,880 --> 00:24:01,040
You probably already have a lot of stuff people install, you know, after you use

357
00:24:01,040 --> 00:24:06,640
it, consume it and okay, that's very confusing.

358
00:24:06,680 --> 00:24:11,760
Um, and finally, if you don't find something that is exactly what you need, um,

359
00:24:11,760 --> 00:24:15,080
you know, you might have stumbled upon one of the missing parts.

360
00:24:15,520 --> 00:24:17,240
So definitely contribute back.

361
00:24:19,880 --> 00:24:21,240
Let's see what question they have.

362
00:24:21,240 --> 00:24:25,080
Um, have you implemented the customer iterator that is already in production?

363
00:24:25,400 --> 00:24:28,920
I'm curious to know the use case and your thoughts of it or tool.

364
00:24:29,120 --> 00:24:32,000
So itertools and the stdlib is absolutely amazing.

365
00:24:32,640 --> 00:24:35,040
Have I implemented an iterator that is in production?

366
00:24:35,160 --> 00:24:39,720
Uh, quite probably, like I, I don't really think about it, but I'm pretty sure that

367
00:24:39,880 --> 00:24:43,640
like, I wrote some code that works like that, uh, probably like, you know, like

368
00:24:43,640 --> 00:24:46,360
part of my data analysis involved, like an iterator that does that.

369
00:24:46,680 --> 00:24:50,240
So yes, I can think of like a specific code that works like that.

370
00:24:50,240 --> 00:24:53,560
I can think of like a specific example, but it's because I do it so much that

371
00:24:53,560 --> 00:24:57,000
like, you know, it just like, I don't even think of it as kind of a separate activity.

372
00:24:57,520 --> 00:25:00,920
Um, I also got a question of whether I'm swapping is hiring.

373
00:25:01,200 --> 00:25:05,040
The answer is yes, we are hiring, uh, um, catch me later.

374
00:25:05,040 --> 00:25:07,200
And I'm happy to give you my email address.

375
00:25:07,680 --> 00:25:09,680
Uh, what's my favorite iterator?

376
00:25:10,320 --> 00:25:10,960
Wow.

377
00:25:11,240 --> 00:25:16,960
Uh, I would say I have like a special weakness for windowed, right?

378
00:25:17,040 --> 00:25:21,040
Like, you know, like, like it makes like implementing stuff, like, like rolling

379
00:25:21,040 --> 00:25:25,400
average, just like almost mindless, right?

380
00:25:25,400 --> 00:25:28,200
And like, you know, implementing these things are like, you know, typically hard.

381
00:25:28,200 --> 00:25:30,760
I'm used to like, you know, cause there's so much work to kind of implement these

382
00:25:30,760 --> 00:25:35,880
things now implementing a rolling average is basically just map of windows or like,

383
00:25:35,880 --> 00:25:38,600
you know, map some of windows and like, you know, then like, you know, map the

384
00:25:38,600 --> 00:25:39,760
division and that's it, right?

385
00:25:39,760 --> 00:25:41,680
Like, you know, I can implement it in like two lines of code.

386
00:25:41,680 --> 00:25:45,040
So windowed is just like magical and I love it so much.

387
00:25:45,720 --> 00:25:50,040
Um, how would you approach delving into these tools to learn them deeply?

388
00:25:50,320 --> 00:25:52,000
Just to read code and reach for those tools.

389
00:25:52,240 --> 00:25:54,400
Um, I would not say even read code, right?

390
00:25:54,400 --> 00:25:59,080
Like when you have to write code, think, you know, is this a natural, like, like

391
00:25:59,120 --> 00:26:04,000
if you see yourself iterating on something and you see a lot of code inside the

392
00:26:04,000 --> 00:26:08,640
for loop, that's your signal to think maybe there's a good abstraction I can do.

393
00:26:08,920 --> 00:26:11,800
And one of the reasons I like this good abstract, these abstractions,

394
00:26:12,040 --> 00:26:14,440
they're extremely testable, right?

395
00:26:14,440 --> 00:26:18,040
If you test every bit of it, then you barely have to test a combination.

396
00:26:18,080 --> 00:26:22,080
So, um, if you see a lot of code on their for loop, that's your kind of sign to

397
00:26:22,080 --> 00:26:25,560
like, say, should I look into like, you know, implementing it with the iterators?

398
00:26:26,120 --> 00:26:31,560
Um, isn't using a lib just for chunks encourage the J?

399
00:26:31,640 --> 00:26:34,120
Well, so more-itertools is not just for chunks.

400
00:26:34,120 --> 00:26:38,120
It has a lot of use stuff, like, you know, window chunked and I didn't even cover

401
00:26:38,120 --> 00:26:43,680
half of it because like, you know, uh, there's tons, um, I basically reached

402
00:26:43,680 --> 00:26:48,400
for more-itertools like the alternative is basically like, you'll end up implementing

403
00:26:48,400 --> 00:26:51,600
it yourself, probably worse and probably with more bugs.

404
00:26:51,640 --> 00:26:53,000
I do not think it's left bad.

405
00:26:53,440 --> 00:26:56,240
Uh, chunks is actually like not that trivial to implement.

406
00:26:56,520 --> 00:27:00,320
If remember all the annoying edge cases, like what happens if you could, you know,

407
00:27:00,560 --> 00:27:04,520
if the stuff you have is not, you know, directly divisible by the chunk size

408
00:27:04,520 --> 00:27:09,200
and stuff like that, so I would say, yeah, um, cool.

409
00:27:09,200 --> 00:27:11,080
I think, uh, that is all the question.

410
00:27:11,080 --> 00:27:12,520
And I'm also out of time.

411
00:27:12,520 --> 00:27:12,880
Am I?

412
00:27:13,520 --> 00:27:14,080
Okay, cool.

413
00:27:14,120 --> 00:27:15,160
So, uh, thank you.

