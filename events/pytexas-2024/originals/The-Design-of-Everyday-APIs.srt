1
00:00:00,000 --> 00:00:05,520
All right, okay, you can hear me okay?

2
00:00:05,520 --> 00:00:06,520
Cool.

3
00:00:06,520 --> 00:00:07,520
Good morning.

4
00:00:07,520 --> 00:00:12,920
I am super excited to be here because, yes, you've been asking me for so long.

5
00:00:12,920 --> 00:00:20,520
I feel so very honored, but you've been pestering me because I'm just so happy to be here.

6
00:00:20,520 --> 00:00:25,280
I love regional conferences so much, and I didn't know that Pi Texas was the oldest regional

7
00:00:25,280 --> 00:00:26,280
conference.

8
00:00:26,760 --> 00:00:31,960
Yeah, so I'm just excited to be here and to meet you all.

9
00:00:31,960 --> 00:00:39,400
So I don't say technical keynotes that often, but when I do, I thoroughly enjoy them.

10
00:00:39,400 --> 00:00:46,480
I'm not sure if this meets the bar of keynote level, but I really like this talk, and I

11
00:00:46,480 --> 00:00:47,480
hope you do too.

12
00:00:47,480 --> 00:00:52,680
I even learned Blender to make this cool slide.

13
00:00:52,680 --> 00:00:55,080
So yes, hi, my name is Len Root.

14
00:00:55,080 --> 00:00:58,320
I'm roguelike everywhere except for GitHub.

15
00:00:58,320 --> 00:00:59,320
I'm econchic.

16
00:00:59,320 --> 00:01:00,320
I'm GitHub.

17
00:01:00,320 --> 00:01:01,320
I don't know what happened there.

18
00:01:01,320 --> 00:01:05,440
Yeah, you can find me in Macedonia on Twitter, on Instagram, wherever.

19
00:01:05,440 --> 00:01:11,120
Yeah, and I am a staff engineer at Spotify, and I'm based in New York.

20
00:01:11,120 --> 00:01:18,400
I've been at Spotify for over 10 years now, and most recently I've been working on infrastructure

21
00:01:18,400 --> 00:01:22,560
for ML, experimentation, and governance.

22
00:01:22,560 --> 00:01:26,800
I also actually teach at Columbia, which is rather a new gig.

23
00:01:26,800 --> 00:01:28,360
You might also know me from Pi Ladies.

24
00:01:28,360 --> 00:01:32,800
I am the chair of the Global Council of Pi Ladies, and if you want stickers, you can

25
00:01:32,800 --> 00:01:35,920
come find me for stickers later.

26
00:01:35,920 --> 00:01:42,920
And yeah, as a heads up, I'm not doing a live Q&A session, but I'm just honestly too nervous

27
00:01:42,920 --> 00:01:47,400
to be up here and actually hear questions, even if you are loud enough.

28
00:01:47,400 --> 00:01:50,120
I just can't physically hear people when I'm up here.

29
00:01:50,360 --> 00:01:52,240
I'm super nervous in these lights.

30
00:01:52,240 --> 00:01:57,920
But I'm more than happy to chat afterwards, and for a bit true of folks, I will hop on

31
00:01:57,920 --> 00:02:00,280
Discord later and answer anything.

32
00:02:00,280 --> 00:02:03,840
But yeah, let's jump to it.

33
00:02:03,840 --> 00:02:08,200
About 10 years ago, I bought an electric kettle.

34
00:02:08,200 --> 00:02:12,160
It had this plug, and it blew my mind.

35
00:02:12,160 --> 00:02:17,560
I found myself asking, you know, why don't all plugs have a stand like this?

36
00:02:18,080 --> 00:02:20,720
It's probably because of patents.

37
00:02:20,720 --> 00:02:26,680
But not only does it make it easy to unplug, like you don't have to like, you know, wiggle

38
00:02:26,680 --> 00:02:30,200
around, try and get leverage, maybe like electrocute yourself.

39
00:02:30,200 --> 00:02:35,360
But it's also very easy and obvious to me how to use it.

40
00:02:35,360 --> 00:02:39,120
It allows for easy grabbing and pulling, right?

41
00:02:39,120 --> 00:02:44,960
So the simplicity and the thoughtfulness of this design, this made me think, what else

42
00:02:45,000 --> 00:02:47,000
am I unknowingly struggling with?

43
00:02:49,320 --> 00:02:54,320
This found me to this book, The Design of Everyday Things by Dot Norton, which you might

44
00:02:54,320 --> 00:02:57,720
notice is the inspiration for my talks, Titan.

45
00:02:57,720 --> 00:02:59,960
And it's got this nice coffee pot.

46
00:02:59,960 --> 00:03:02,680
It's dubbed the coffee pot for masochists.

47
00:03:07,120 --> 00:03:13,600
And the penance of this book is how design serves as the communication between object

48
00:03:13,600 --> 00:03:18,400
and user, and how to optimize that communication for a better experience.

49
00:03:20,320 --> 00:03:25,920
So Don Norman writes, design is concerned with how things work, how they are controlled

50
00:03:25,920 --> 00:03:30,360
and the nature of the interaction between people and technology.

51
00:03:31,920 --> 00:03:38,800
The range of things is not limited to physical objects like the Bremer plug that I'm so

52
00:03:38,880 --> 00:03:41,440
familiar with, or the masochistic coffee pot.

53
00:03:42,960 --> 00:03:48,960
It includes artificial creation as well, like software and digital interfaces, or the

54
00:03:48,960 --> 00:03:52,600
layout of a conference room, organizational structures, whatever.

55
00:03:53,560 --> 00:03:56,160
So what then makes design good?

56
00:03:57,800 --> 00:04:03,520
Don says, Tim, the most important characteristics of good design are discoverability and

57
00:04:03,520 --> 00:04:04,400
understanding.

58
00:04:05,080 --> 00:04:11,320
So breaking this down further, discoverability is described as, am I able to figure out

59
00:04:11,320 --> 00:04:14,720
what actions are possible and where and how to perform them?

60
00:04:16,800 --> 00:04:20,760
So the author lays out five key elements of discoverability.

61
00:04:21,720 --> 00:04:23,600
The first one is affordances.

62
00:04:24,560 --> 00:04:27,720
So affordances determine what actions are possible.

63
00:04:28,240 --> 00:04:34,560
What's, it's what a user can do with an object based on their capabilities.

64
00:04:36,920 --> 00:04:43,040
Affordances aren't a physical property, it's the relation between the user and the

65
00:04:43,040 --> 00:04:48,280
object. So a door affords opening if you can reach the handle.

66
00:04:48,760 --> 00:04:53,200
So for a toddler, a door doesn't afford opening if they can't reach it.

67
00:04:54,040 --> 00:04:58,120
So building on top of affordances, the second element is signifiers.

68
00:04:58,800 --> 00:05:04,280
A signifier is some sort of perceivable cue about the affordance.

69
00:05:04,840 --> 00:05:09,000
Signifiers communicate where the action should place.

70
00:05:10,280 --> 00:05:16,800
The term signifier exists in this context to make a clear distinction between the

71
00:05:16,800 --> 00:05:21,280
signal and a flowless might provide to a person, which is entirely in the visual

72
00:05:21,960 --> 00:05:27,760
perceptible part of an affordance, and the actual affordance itself.

73
00:05:28,240 --> 00:05:32,560
So they are like similar as their latest sounds, some sort of like physical

74
00:05:32,640 --> 00:05:39,640
indicator. So for example, a flat panel or like a bar on a door would signify

75
00:05:39,640 --> 00:05:41,480
that you need to push the door open.

76
00:05:45,080 --> 00:05:47,960
The third key element of discoverability is constraints.

77
00:05:48,680 --> 00:05:53,400
Constraints are limitations or restrictions, and they give us clues that

78
00:05:53,400 --> 00:05:57,760
allow us to determine coercive action by limiting the possible actions available

79
00:05:57,760 --> 00:06:03,320
to us. There are a few types of constraints that could be physical, like

80
00:06:03,400 --> 00:06:08,920
a mailbox slot that only allows letters and suit packages to be dropped in.

81
00:06:10,520 --> 00:06:16,840
Or it might be logical, like where the last case of the pizzer might go in to

82
00:06:16,840 --> 00:06:18,280
only the last space left.

83
00:06:19,560 --> 00:06:25,560
And then there's also like cultural and semantic constraints, like a red roadside

84
00:06:25,560 --> 00:06:26,920
typically means stop.

85
00:06:30,120 --> 00:06:31,560
The source is mappings.

86
00:06:32,480 --> 00:06:36,360
A mapping is the relationship between control and election.

87
00:06:37,200 --> 00:06:41,360
So when a mapping uses spatial correspondence between the layout of the

88
00:06:41,360 --> 00:06:46,800
controls and the device being controlled, it's easy to determine how to use them.

89
00:06:47,640 --> 00:06:52,920
So a good example of a good mapping would be where you'd have like two lights

90
00:06:53,200 --> 00:06:57,160
and two light switches, and then like the left light switch would control the

91
00:06:57,160 --> 00:07:00,320
left light and the right light switch would control the right light.

92
00:07:01,560 --> 00:07:04,840
I have a couple of bad mappings in my own apartment that I should try and fix,

93
00:07:04,840 --> 00:07:07,480
but it's really annoying when they're not mapped correctly.

94
00:07:09,800 --> 00:07:14,040
The final key element is feedback, where the results of an action is

95
00:07:14,040 --> 00:07:15,760
communicated back to the user.

96
00:07:16,840 --> 00:07:21,840
So feedback should communicate clear, unambiguous information back to the

97
00:07:21,840 --> 00:07:23,640
user in order to be effective.

98
00:07:24,640 --> 00:07:26,600
Immediate feedback is ideal.

99
00:07:27,080 --> 00:07:30,560
Delayed feedback can be disconcerting and lead to a feeling of

100
00:07:30,560 --> 00:07:32,560
user abandonment or failure.

101
00:07:34,320 --> 00:07:37,800
And then there's a delicate balance between the amount of feedback.

102
00:07:38,520 --> 00:07:42,360
Too much feedback can be annoying and irritating to the users or, you know,

103
00:07:42,360 --> 00:07:44,760
too much to even like want to read through it all.

104
00:07:45,360 --> 00:07:51,520
Too little feedback could be useless and as good as no feedback at all.

105
00:07:52,640 --> 00:07:55,720
And then feedback also needs to be prioritized.

106
00:07:55,760 --> 00:07:59,920
So you have important messages and alerts versus like unimportant messages.

107
00:08:02,440 --> 00:08:05,840
And so these are the five key elements of destabilizing.

108
00:08:05,840 --> 00:08:09,320
We have affordances, signifiers, constraints, mapping, and feedback.

109
00:08:10,200 --> 00:08:13,960
And then build up to the second part of good design.

110
00:08:14,840 --> 00:08:15,640
Understanding.

111
00:08:16,520 --> 00:08:21,840
So understandably, it means is it possible or easy for users to figure

112
00:08:21,840 --> 00:08:23,680
out how the product can be used?

113
00:08:26,080 --> 00:08:29,720
So understanding is developed by swan-naming a conceptual or

114
00:08:29,720 --> 00:08:32,440
at-time model of how something works.

115
00:08:33,040 --> 00:08:36,480
A conceptual model is just a collection of explanations,

116
00:08:36,520 --> 00:08:37,920
often pretty simplified.

117
00:08:39,400 --> 00:08:43,640
And so the user builds their own conceptual model of how a system or

118
00:08:43,680 --> 00:08:49,000
product works and the designer designs the system or product using

119
00:08:49,040 --> 00:08:50,400
their own conceptual model.

120
00:08:52,560 --> 00:08:57,600
The designer expects the user's conceptual model to be identical to

121
00:08:57,600 --> 00:09:03,240
their own, but it can't because they cannot communicate directly with the user.

122
00:09:03,480 --> 00:09:07,440
So the burden of communication is with the system and its design.

123
00:09:08,440 --> 00:09:13,560
So good conceptual models are the key to understandable, enjoyable products.

124
00:09:14,200 --> 00:09:17,840
And good communication is the key to good conceptual models.

125
00:09:18,960 --> 00:09:23,120
And then that communication comes from those key aspects of discoverability.

126
00:09:23,400 --> 00:09:26,800
The affordances, signifiers, constraints, mappings, and feedback.

127
00:09:28,880 --> 00:09:33,240
And so maybe you can start to see how these ideas, essentially human-centered

128
00:09:33,680 --> 00:09:39,840
design, can start to apply to software, to designing a library for others to use.

129
00:09:41,120 --> 00:09:44,640
My first instinct when thinking about this is to think about libraries that

130
00:09:44,640 --> 00:09:47,520
I've worked with, maybe that are not so fun to use.

131
00:09:48,440 --> 00:09:52,800
I'm not going to name and shame any Python libraries here, but there's

132
00:09:52,800 --> 00:09:56,120
one non-Python library that I do load.

133
00:09:57,040 --> 00:09:58,320
It is ffmpeg.

134
00:09:59,160 --> 00:10:03,560
If you don't know, it's a well-known tool that is designed for processing

135
00:10:03,560 --> 00:10:09,960
audio and video, so the screen recording is just me running, like, let us punch.

136
00:10:10,080 --> 00:10:11,720
So just with some documentation.

137
00:10:12,880 --> 00:10:18,600
And so whenever I use ffmpeg, the way for me to figure out how to do something,

138
00:10:18,800 --> 00:10:22,640
seemingly simple, like creating a looping gif from a video, I end up

139
00:10:22,640 --> 00:10:27,160
meaning to go copy commands from Stack Overflow, because I'm solving

140
00:10:27,200 --> 00:10:30,440
because I'm sorry, the documentation sucks.

141
00:10:31,720 --> 00:10:35,240
It's so powerful and I know that I can do many things with it.

142
00:10:35,560 --> 00:10:40,040
And I will continue to reach for it just on its ubiquity and its performance,

143
00:10:40,320 --> 00:10:44,320
but there will always be this reaction.

144
00:10:46,320 --> 00:10:50,840
So this made me think, if I am an engineer who develops tools and

145
00:10:50,840 --> 00:10:55,280
infrastructure for other engineers, how many masochistic keypots

146
00:10:55,280 --> 00:10:56,800
have I unknowingly shipped?

147
00:10:57,160 --> 00:11:00,800
How many size have I caused?

148
00:11:03,680 --> 00:11:08,640
So there are much, much better people to give talks on this,

149
00:11:08,760 --> 00:11:10,960
better ideas and theories.

150
00:11:11,440 --> 00:11:15,600
So I'm not an authority on API design, but for me, it is a missing

151
00:11:15,600 --> 00:11:20,320
connection between a theory of good design and the actual implementation.

152
00:11:21,400 --> 00:11:23,520
So this brings me to my talk.

153
00:11:23,760 --> 00:11:28,360
I'm not sure if anyone else has seen my previous talks, but I have a habit

154
00:11:28,360 --> 00:11:34,240
of writing talks for myself, particularly ones that I really wish I saw years ago.

155
00:11:35,000 --> 00:11:40,560
So this talk is mainly for Kathleen that tries to take key elements of good

156
00:11:40,560 --> 00:11:43,560
design and apply them to a real world example.

157
00:11:45,640 --> 00:11:48,800
So I was aiming to condense this into a through-tennis or through-chain

158
00:11:48,800 --> 00:11:52,320
principles that make it really fun to work with API.

159
00:11:54,040 --> 00:11:55,440
So first I'm going to set the stage.

160
00:11:55,680 --> 00:11:59,280
In a previous talk of mine, I went through building what's called

161
00:11:59,280 --> 00:12:02,800
like a KS monkey system, and it uses a Pub-Sub queue.

162
00:12:02,800 --> 00:12:04,920
I kind of want to stick with that theme.

163
00:12:05,480 --> 00:12:10,640
And so let's like design a library that works with a Pub-Sub queue-like service.

164
00:12:11,000 --> 00:12:13,760
I'm just going to call it a KS queue, because why not?

165
00:12:14,160 --> 00:12:15,200
And it has nothing to do with this car.

166
00:12:15,200 --> 00:12:15,880
I just like it.

167
00:12:17,760 --> 00:12:18,000
All right.

168
00:12:18,000 --> 00:12:19,640
So let's look at some code.

169
00:12:20,640 --> 00:12:24,600
So first we have this class that defines a message object.

170
00:12:25,040 --> 00:12:29,840
And all it does is contain data to be passed to and from a KS queue.

171
00:12:31,680 --> 00:12:36,560
And we have a second class, a client that essentially publishes to and

172
00:12:36,560 --> 00:12:40,520
consumes messages from our Pub-Sub KS queue.

173
00:12:41,720 --> 00:12:43,240
And so this is our starting library.

174
00:12:44,160 --> 00:12:48,040
Perhaps you are already thinking of some things that you want to change,

175
00:12:48,320 --> 00:12:50,840
which is great, but just, just don't type.

176
00:12:52,800 --> 00:12:57,640
Which in order to develop a little bit of empathy for my future users, I want

177
00:12:57,640 --> 00:13:02,400
to write a little bit of user code that interacts with this library.

178
00:13:03,320 --> 00:13:10,960
So on the user side, I have a Pub-Sub queue client, and then I try and create

179
00:13:10,960 --> 00:13:15,200
a topic, create a subscription as well, and then catching if they already

180
00:13:15,200 --> 00:13:16,840
exist and continuing on.

181
00:13:17,680 --> 00:13:20,680
And then we start interacting with our client.

182
00:13:21,040 --> 00:13:26,000
We have a silly week that publishes five messages to a grass Pub-Sub queue.

183
00:13:26,920 --> 00:13:30,560
And then a while true to consume those messages.

184
00:13:31,120 --> 00:13:32,200
We print the message.

185
00:13:32,200 --> 00:13:34,240
Maybe it's, you know, swept over a debugger.

186
00:13:34,840 --> 00:13:38,160
And then we do some sort of processing on the message data.

187
00:13:38,680 --> 00:13:42,080
And then we acknowledge the message from the queue when we're done processing.

188
00:13:42,920 --> 00:13:46,960
And then finally, maybe the client has some network connections that we need

189
00:13:46,960 --> 00:13:49,760
to clean up and close or some methods to flush.

190
00:13:51,000 --> 00:13:52,120
So this is what we have.

191
00:13:52,160 --> 00:13:56,320
So let's improve this for the user and start iterating on our library.

192
00:13:57,400 --> 00:13:59,840
We'll start with my first of three principles.

193
00:14:00,800 --> 00:14:06,960
An API should be intuitive and note that I mean intuitive for the user, not

194
00:14:06,960 --> 00:14:09,240
for you, the equipment or maintainer.

195
00:14:10,200 --> 00:14:13,800
So with an intuitive API, a user can be easy.

196
00:14:14,520 --> 00:14:17,680
They don't have to think too hard about how it works.

197
00:14:18,840 --> 00:14:22,280
They need to remember complicated details because their intuition

198
00:14:22,280 --> 00:14:23,880
correctly explains it to them.

199
00:14:25,960 --> 00:14:29,240
They don't have to spend a lot of time learning new parts of the API

200
00:14:29,240 --> 00:14:30,840
because they all work pretty similarly.

201
00:14:31,880 --> 00:14:37,360
And so an intuitive API builds on the user's pre-existing conceptions.

202
00:14:37,360 --> 00:14:41,360
And tries not to do anything surprising, nothing that unnecessarily works

203
00:14:41,520 --> 00:14:44,200
against any logical or domain constraints.

204
00:14:45,400 --> 00:14:49,400
And so with that, I have three changes that I want to make to RKS queue

205
00:14:49,400 --> 00:14:52,640
to improve the intuitiveness of the API.

206
00:14:55,400 --> 00:14:59,080
So we're going to start with some loan manuals and naming the methods

207
00:14:59,080 --> 00:15:04,240
in our client class using the domain's nomenclature, like publish a message,

208
00:15:04,240 --> 00:15:07,480
cloud a message from a queue, acknowledging a message is complete,

209
00:15:07,680 --> 00:15:09,440
and drain a queue of messages.

210
00:15:11,120 --> 00:15:17,040
So right now we have add message, get message, art message, die, clear

211
00:15:17,040 --> 00:15:23,080
message queue, and so we're going to need to publish, cloud, direct, and drain.

212
00:15:24,640 --> 00:15:29,200
Now I also dropped the noun from the method layers since I found them

213
00:15:29,200 --> 00:15:32,280
a little redundant because I didn't want them to be in the same

214
00:15:32,280 --> 00:15:36,320
since I found them a little redundant, particularly because in my layer,

215
00:15:36,520 --> 00:15:40,200
the noun that we're operating on is in the function signature already.

216
00:15:40,200 --> 00:15:41,280
It's the message.

217
00:15:42,440 --> 00:15:46,720
And then now look, I have room on my slide to indent four spaces in the two.

218
00:15:49,840 --> 00:15:52,760
So why are we doing this?

219
00:15:52,800 --> 00:15:56,320
So this plays into the mappings element of discoverability.

220
00:15:56,800 --> 00:16:00,440
Naming your functions, something similar to the domain that they're supposed

221
00:16:00,440 --> 00:16:05,360
to work in can help result in immediate understanding of what your API is supposed to do.

222
00:16:08,520 --> 00:16:14,840
So the next suggestion kind of steps back a tiny bit to think about appropriate

223
00:16:14,840 --> 00:16:19,960
abstraction levels, so clumsy naming hints at clumsy abstractions within

224
00:16:19,960 --> 00:16:21,520
the slides, kind of a little clumsy.

225
00:16:23,680 --> 00:16:27,280
If you recall, our PubSub client, we have a few Q&As and events.

226
00:16:28,280 --> 00:16:31,400
We have create topic, create subscription, and click as client.

227
00:16:32,000 --> 00:16:36,160
But this point seems to manage all in one object.

228
00:16:36,720 --> 00:16:41,360
From the user's point of view, what if we want to just consume messages and not publish them?

229
00:16:41,360 --> 00:16:45,240
Do I have to create a topic for some reason, or will there be

230
00:16:45,800 --> 00:16:48,920
connections managed by the client sound unnecessary?

231
00:16:49,920 --> 00:16:55,600
So let's not add any unnecessary confusion to the user and break up those client into two.

232
00:16:56,560 --> 00:17:01,080
So one that works with just publishing and one that works with just subscribing.

233
00:17:01,720 --> 00:17:04,840
So this allows us to clean up the method names a little bit as well.

234
00:17:06,200 --> 00:17:09,960
And then this creates natural constraints on what the user can do.

235
00:17:10,320 --> 00:17:15,680
If the user must create a topic, then they have to instantiate a PubClient.

236
00:17:16,040 --> 00:17:20,880
And that will lead to only those actions provided with the PubClient's methods.

237
00:17:21,320 --> 00:17:26,480
However, our clients also create some unnecessary constraints on our users.

238
00:17:27,120 --> 00:17:29,040
So that brings me to microchange.

239
00:17:30,560 --> 00:17:32,760
Let's make sure our API has symmetry.

240
00:17:34,920 --> 00:17:38,880
So we allow the user to create a topic or create a subscription.

241
00:17:39,600 --> 00:17:43,520
Well, what does the user do if they want to change an existing topic or

242
00:17:43,520 --> 00:17:44,960
subscription or even delete one?

243
00:17:46,400 --> 00:17:48,640
So let's not limit them unnecessarily.

244
00:17:48,640 --> 00:17:53,320
Let's not limit them unnecessarily and provide symmetry with our methods.

245
00:17:54,680 --> 00:17:59,280
So just having a create method without its logical symmetric pair or tripling or

246
00:17:59,280 --> 00:18:02,840
whatever, gives a misleading center file to the user.

247
00:18:04,200 --> 00:18:09,840
It can be certain that users have worked with other APIs that provide both a create

248
00:18:10,000 --> 00:18:15,000
and a delete method, a set and a get method and upload and a download method.

249
00:18:15,360 --> 00:18:20,760
And so it would be counter-intuitive to either not provide such functionality,

250
00:18:21,360 --> 00:18:25,880
or to provide that functionality, but not file convention and symmetric naming.

251
00:18:29,040 --> 00:18:32,000
So some of these changes may seem a bit contrived.

252
00:18:32,040 --> 00:18:36,040
It was really hard to come up with a super succinct example that is also

253
00:18:36,040 --> 00:18:39,640
relatable, but hopefully the message is starting to come across here.

254
00:18:40,360 --> 00:18:45,240
And some of these changes later on in the talk could very well apply with being

255
00:18:45,240 --> 00:18:49,880
intuitive, and I'm sure the changes I'm addressing here may apply.

256
00:18:51,080 --> 00:18:55,960
And again, I'm not really an expert here, but anyways, let's move on to the next

257
00:18:55,960 --> 00:18:59,040
unit. An API should be flexible.

258
00:18:59,800 --> 00:19:01,480
And again, I mean flexible for the user.

259
00:19:01,800 --> 00:19:05,160
It's a whole other talk about writing flexible APIs for a maintainable

260
00:19:05,240 --> 00:19:10,360
country. So basically a flexible API lets you do what you want.

261
00:19:11,600 --> 00:19:16,880
In my point of view, a flexible API lets users to get started quickly with the

262
00:19:16,880 --> 00:19:22,520
more basic use cases, and then it allows the user to adjust as they need to solve

263
00:19:22,520 --> 00:19:24,120
more and more complex problems.

264
00:19:25,200 --> 00:19:30,080
So flexibility comes down to the question of how many problems can users solve

265
00:19:30,360 --> 00:19:31,680
once they learn the API?

266
00:19:32,640 --> 00:19:37,120
So for this time, I have four changes I want to make to a chaos queue.

267
00:19:38,560 --> 00:19:42,560
The first is to provide same defaults to the most common use cases.

268
00:19:43,840 --> 00:19:49,520
So recall that we have some methods to work with publishing and consuming

269
00:19:49,520 --> 00:19:55,360
messages. The main resource these methods are working with is the message.

270
00:19:56,360 --> 00:20:01,440
The timeout and the retry arguments aren't required to the core functionality

271
00:20:01,440 --> 00:20:04,080
of publishing or acknowledging a message.

272
00:20:05,360 --> 00:20:09,520
And then I often find myself as a user to not know what a good number of seconds

273
00:20:09,520 --> 00:20:13,040
a timeout should be or how many retries I should be making.

274
00:20:14,320 --> 00:20:19,920
And so as the API designer, I should make optional behavior as optional keywords

275
00:20:21,040 --> 00:20:26,160
with some defaults. So maybe 30 seconds is the most common timeout value, or maybe

276
00:20:26,400 --> 00:20:29,280
it comes from the default of the server side.

277
00:20:30,000 --> 00:20:34,240
And then maybe having a zero as a default for retries makes sense too.

278
00:20:35,520 --> 00:20:40,640
So by moving a lot of optional settings into keyword arguments, it allows the user

279
00:20:40,640 --> 00:20:42,960
to focus on just what is required of them.

280
00:20:44,640 --> 00:20:48,960
This change also goes a bit beyond the flexibility of an API.

281
00:20:50,000 --> 00:20:55,760
By forcing users to use keyword arguments and providing same defects,

282
00:20:55,760 --> 00:21:00,240
we limit the number of and the order of positional arguments that the user

283
00:21:00,240 --> 00:21:05,520
has to remember. So for instance, both timeout and retries are integers.

284
00:21:06,240 --> 00:21:11,120
If they were positional arguments like before, the user could easily inverse them

285
00:21:11,120 --> 00:21:14,640
when calling a method, and then that would safely pass type checkers.

286
00:21:17,920 --> 00:21:22,400
We also have more optional keyword arguments in our methods, like request ID and

287
00:21:22,400 --> 00:21:28,480
publicity rebel with a bunch more of them. If you have many, many arguments, positional

288
00:21:28,480 --> 00:21:33,280
or keyword, you might want to step back a little bit because it might be providing

289
00:21:33,280 --> 00:21:38,880
another hint at clumsy code. It might be unnecessarily exposing some

290
00:21:38,880 --> 00:21:44,480
complexity. So with slide pants and a lot of arguments, if folks can't understand

291
00:21:44,480 --> 00:21:47,760
type annotations, maybe you need to rethink and refactor.

292
00:21:47,760 --> 00:21:56,560
So for the sake of my slides being readable, I'm rolling all of these keyword arguments

293
00:21:56,560 --> 00:22:01,760
into star quarks, but don't do this at home, particularly for your public API.

294
00:22:04,400 --> 00:22:10,320
For libraries with automatic generation, instead of finding a list of arguments

295
00:22:10,320 --> 00:22:15,760
and their meaning in the documentation, users will absolutely see no information

296
00:22:15,760 --> 00:22:22,480
about some keyword arguments. And then if the library does not have automatic

297
00:22:22,480 --> 00:22:28,720
generation or any documentation at all, which is a shame on you, but then the user

298
00:22:28,720 --> 00:22:33,680
can actually just simply look at a function signature. You must dive into the code,

299
00:22:33,680 --> 00:22:36,240
but they still have to try and understand what these quarks are.

300
00:22:37,520 --> 00:22:40,560
So again, these quarks are just to make my slides readable.

301
00:22:41,520 --> 00:22:46,960
Anyways, moving on. The next change I want to make is to increase flexibility of our

302
00:22:46,960 --> 00:22:54,160
APIs to minimize the user's need to repeat themselves. So we saw in the user's code a

303
00:22:54,160 --> 00:23:02,800
loop for publishing each message. So in the PEM client, our published message has one

304
00:23:02,960 --> 00:23:11,200
positional argument for message. To minimize forcing the user to repeatably publish each

305
00:23:11,200 --> 00:23:16,800
message, we can accept multiple message arguments in the function signature by collecting them into

306
00:23:16,800 --> 00:23:25,280
star args. And then we can do the repetitive work for them. So hopefully you're writing some

307
00:23:25,760 --> 00:23:32,960
code as you are building your API. So you can look for common patterns in the user code that

308
00:23:32,960 --> 00:23:40,400
you could minimize away, like loops and repetition. Then as I said earlier, the

309
00:23:40,400 --> 00:23:46,000
tenet of flexibility is, again, from the user's point of view. Providing flexibility to any user

310
00:23:46,000 --> 00:23:50,160
requires you to be predictable and to be precise in what you do for them.

311
00:23:51,120 --> 00:23:58,400
So part of building that conceptual model, the understanding for the user is defining constraints

312
00:23:58,400 --> 00:24:05,760
and feedback. So we provide flexibility in what we accept as input. There needs to be a clear

313
00:24:05,760 --> 00:24:11,920
constraint in what we do time. We shouldn't make the user figure out what object type that they

314
00:24:11,920 --> 00:24:18,800
get back from a method of ours. So we'll call our subscription client by returning a consumed

315
00:24:18,800 --> 00:24:26,480
message when we call it. Or it returns none. So this doesn't seem too predictable or too precise.

316
00:24:27,360 --> 00:24:32,640
So the user has to check if they got a message out or if they are dealing with none.

317
00:24:33,840 --> 00:24:41,200
So now what's the use case here? It's when there are no more messages in the queue to consume.

318
00:24:42,160 --> 00:24:48,160
Now, if they look at preexisting APIs like the Python queue library, it raises an error when

319
00:24:48,160 --> 00:24:54,320
the queue is empty. That seems pretty easy to do. So let's update our function signature to

320
00:24:54,320 --> 00:25:00,320
only return a message object and then raise if there are no more messages in the subscription queue.

321
00:25:01,280 --> 00:25:07,520
So this goes back to what Don Norb was saying about feedback, that it should

322
00:25:09,280 --> 00:25:15,200
create third, ambiguous information back to the user and for it to be effective.

323
00:25:15,200 --> 00:25:22,160
So this last change of flexibility is kind of supporting the user's being lazy. Basically,

324
00:25:22,160 --> 00:25:29,200
not force users to provide data that you can generate yourself. So recall our message object.

325
00:25:29,200 --> 00:25:37,760
It has an ID, it has some data, and a public timestamp of some sort. Now, when creating a message,

326
00:25:37,760 --> 00:25:42,560
there's no need for users to supply their own unique ID. They probably shouldn't even be.

327
00:25:43,360 --> 00:25:49,840
Or even to timestamp it when it's published. We can do that ourselves. We probably would not

328
00:25:49,840 --> 00:25:55,600
have a timestamp. Generally, at the time the message is in student sheet, probably when it's

329
00:25:55,600 --> 00:26:03,200
actually published, coming up with real examples is kind of hard. But now, let's say we have a bit

330
00:26:03,200 --> 00:26:09,440
of user understanding. So often, a user might want to print or log the message for debugging

331
00:26:09,600 --> 00:26:14,640
purposes. And for them, we should provide a method to make it easy to just print out the instance.

332
00:26:15,440 --> 00:26:20,160
So now the user doesn't need to worry about printing necessary attributes on the message,

333
00:26:21,040 --> 00:26:27,760
but just the message itself. So this is just one approach at redefining our message object

334
00:26:27,760 --> 00:26:33,920
to help out the user. We could also use data classes. This removes some boilerplate for us.

335
00:26:34,880 --> 00:26:41,280
It does get a little clumsy with setting defaults in our case with post in it. And yeah, the code

336
00:26:41,280 --> 00:26:47,840
kind of goes off the slide a little bit, but it's still nice. A third option would be just

337
00:26:47,840 --> 00:26:52,160
the third byte I could just adders. This actually allows me to go back to the force space and

338
00:26:52,160 --> 00:26:58,960
location. But also, if I needed adders, it would provide me the flexibility and constraints for my

339
00:26:59,200 --> 00:27:08,960
users. Since not only does it give me a clean way to set dynamic defaults, it also has validation

340
00:27:08,960 --> 00:27:15,680
and convertives and even the ability to abuse in it more so if I need it. Now, I'm not a paid

341
00:27:15,680 --> 00:27:24,160
shill for adders. I'm just a happy user of it. So if your API is not flexible, you'll find yourself

342
00:27:24,160 --> 00:27:30,960
saying, I'm sorry, I know our API should be able to do that, but for reasons that you don't care

343
00:27:30,960 --> 00:27:38,240
and that are within our control, we can't. So if the API is not flexible, users will eventually

344
00:27:38,240 --> 00:27:45,040
ditch the library and go to something else that does solve the problems. And so for my last tenet,

345
00:27:46,160 --> 00:27:52,720
an API should be simple. The complexity of an API can be measured by the cognitive load it requires

346
00:27:52,720 --> 00:27:58,560
to actually use it. Complexity hurts our understanding. So we've already made some

347
00:27:58,560 --> 00:28:04,320
changes to reduce the cognitive load of our API, like consistent and appropriate method naming,

348
00:28:04,320 --> 00:28:08,880
learning the number of propositional arguments in our function signatures, and minimizing the

349
00:28:08,880 --> 00:28:13,760
amount of verification that the user has to do. But we can make a few more changes to make it

350
00:28:13,760 --> 00:28:22,400
more simple. So the first change is to provide composable functions. APIs that follow the

351
00:28:22,400 --> 00:28:30,080
mathematical closure property tend to be simple as well as flexible. So loosely, an API plans that

352
00:28:30,080 --> 00:28:36,240
closure property when every operation returns a data type that can be set into another operation.

353
00:28:36,800 --> 00:28:44,080
This means that different operations in your API should be composed with each other. For example,

354
00:28:44,080 --> 00:28:48,400
in Python, we're able to chain a bunch of string methods together since the output of many string

355
00:28:48,400 --> 00:28:55,680
methods is another string. So the closure property makes it easier to combine multiple operations to

356
00:28:55,680 --> 00:29:01,360
get the desired result. Maybe users don't do it that often, but following this, we're able to

357
00:29:02,320 --> 00:29:08,160
allow users to not have to remember different function signatures operating on the same object.

358
00:29:10,400 --> 00:29:16,320
So looking at our subscription client, we have ternethics that operate on the message that they

359
00:29:16,320 --> 00:29:22,400
act. And it's pretty reasonable to think that once you pull a message from the chaos queue,

360
00:29:22,400 --> 00:29:27,440
you'll want to acknowledge it. Otherwise, it'll just get redeliberated after some time,

361
00:29:27,440 --> 00:29:33,920
and then you have unnecessary duplicate work. So there is no reason for us to be restrictive in

362
00:29:33,920 --> 00:29:40,000
our function signature for acting and requiring a string, but adds to the cognitive load for the

363
00:29:40,000 --> 00:29:45,040
user. They basically have to remember that they must give an ID of the message and can't actually

364
00:29:45,040 --> 00:29:51,040
pass in the object that they've been working with. So let's change that to the message object,

365
00:29:51,040 --> 00:30:03,920
and we can figure out how to get the ID of the message. And so now it's simpler for a

366
00:30:03,920 --> 00:30:10,640
user to pull a message from the subscription and then act it. So while we're at it, let's also

367
00:30:10,640 --> 00:30:15,120
accept the ability for users to give us multiple messages if they wish to batch up their

368
00:30:15,120 --> 00:30:20,560
acknowledgments. It certainly adds to the symmetry of our method signatures and

369
00:30:20,560 --> 00:30:27,360
also removes unnecessary loops in the user code. Now, while we're on the topic of loops,

370
00:30:27,360 --> 00:30:33,520
the next change I want to make aligns our API with some Python idioms, making it more Pythonic.

371
00:30:34,800 --> 00:30:40,560
Now, leveraging language idioms also leans into what a programming language affords.

372
00:30:41,280 --> 00:30:46,880
Different programming languages allow you to or afford you different approaches to solve the

373
00:30:46,880 --> 00:30:52,400
kinds of problems that we solve. So like supporting deflection and introspection,

374
00:30:52,400 --> 00:30:57,840
or supporting default values for the function parameters, or how they're defined.

375
00:31:00,000 --> 00:31:05,920
So looking at our subscription client again, the user has to call pull to get a single message,

376
00:31:06,560 --> 00:31:10,720
and then you might recall that in our users, part of it is a wild true loop.

377
00:31:12,080 --> 00:31:17,440
So let's make that easier for the user and provide an iter method that returns an iter.

378
00:31:18,880 --> 00:31:23,680
So providing an iter is helpful for cases like this where the user is consuming a stream of

379
00:31:23,680 --> 00:31:30,240
events or data. It's also helpful when users might need to page through results like a search query

380
00:31:30,240 --> 00:31:36,880
with hundreds or thousands of items. This iter method also happens to simplify the

381
00:31:36,880 --> 00:31:40,880
user's code even more. The iterable just stops when there are no more messages.

382
00:31:41,520 --> 00:31:47,360
The user can now remove a try and accept around for different dequeues around the consuming code.

383
00:31:50,080 --> 00:31:56,560
So in continuing on leveraging the language idioms, you might remember that both clients

384
00:31:56,560 --> 00:32:00,160
have a Cliffhills method, managing any connections and buffers underneath the home.

385
00:32:01,120 --> 00:32:05,200
So this forces the user to remember to clean up after themselves,

386
00:32:05,200 --> 00:32:10,960
adding to the complexity and cognitive load. You might see where this is going. Let's make

387
00:32:10,960 --> 00:32:15,840
use of a context management and provide an easy way for users to not have to remember

388
00:32:15,840 --> 00:32:22,960
any finalization or cleanup behavior. And then there is a third adjustment that we can make

389
00:32:23,040 --> 00:32:29,840
to align with existing idioms and habits. We have two methods in a pub and sub client

390
00:32:30,640 --> 00:32:38,320
that the user would have to put a try and accept on because it blizzes if the topic or

391
00:32:38,320 --> 00:32:45,280
subscription already exists. So let's follow the convention of other APIs like os.migdur

392
00:32:45,280 --> 00:32:51,280
or even SQLs create terrible. And allow the user to not care if something exists already

393
00:32:51,280 --> 00:32:57,520
and make sure that and just make sure that it does exist. So we'll add an exist okay

394
00:32:57,520 --> 00:33:04,880
keyword that'd be aborium. And we'll default it to false, since it might not do what the user

395
00:33:04,880 --> 00:33:13,280
expects. So we kind of force them to opt into it. Now, so the last change, we can also think of

396
00:33:13,280 --> 00:33:19,520
simplicity as, is it convenient to get started? How much do I have to learn to start being able

397
00:33:19,520 --> 00:33:27,520
to use this library? What do I have to do right now to get it working? If an API is not convenient,

398
00:33:27,520 --> 00:33:32,560
if it takes many steps to get started or I have to page through a lot of documentation in order

399
00:33:32,560 --> 00:33:39,760
to get a very basic understanding, then the choice adoption will suffer. So provide your user with

400
00:33:39,760 --> 00:33:46,320
convenience. And you can do this by treating your readme like you would a newspaper. So given the

401
00:33:46,320 --> 00:33:52,560
most important details first, like above the fold, and then if users want to learn more,

402
00:33:52,560 --> 00:33:56,720
they can turn the page or they can read the rest of the readme document or other docs.

403
00:33:57,520 --> 00:34:04,560
And so when I'm looking at a readme, I want three things above the fold. How do I get your library?

404
00:34:04,560 --> 00:34:07,600
Do I need any system level or non-Python dependencies?

405
00:34:09,120 --> 00:34:13,120
What are one or two examples that I can copy and paste immediately to try this out?

406
00:34:14,080 --> 00:34:20,160
And as a side note, potentially reconsider if your examples are using the repend or having

407
00:34:20,160 --> 00:34:27,600
the bash prompt. It makes it annoying to copy and paste those particular examples. Maybe that's just

408
00:34:27,600 --> 00:34:34,640
a pet peeve of mine. And then say, where can I go to get more information? So give me those three

409
00:34:34,640 --> 00:34:41,520
things at the top and then I'm good to go with getting started with your API. So creating a

410
00:34:41,520 --> 00:34:47,600
simple API is all about reducing cognitive load on the user, reducing what the user has

411
00:34:47,600 --> 00:34:54,640
to keep in their head while working with your API. All right. That was a lot. I'm going to

412
00:34:54,640 --> 00:35:00,960
rewind and review a little bit. So we started here with a very simple API for a library that

413
00:35:00,960 --> 00:35:07,840
contains only two classes. As we moved on, we built our code into three classes and now this

414
00:35:07,840 --> 00:35:14,800
slide is unreadable on purpose. And that's okay because we started with a lot of user code, 29

415
00:35:14,800 --> 00:35:20,080
lines to be exact and the data down to 13 lines. Now the code can actually fit on the slide and be

416
00:35:20,080 --> 00:35:25,760
readable. This should be the goal and not necessarily the number of lines of code words

417
00:35:25,760 --> 00:35:30,800
that can be on the slide, but it's about user empathy when designing a delightful API.

418
00:35:31,360 --> 00:35:38,320
And so to recap, is your API intuitive for the user? Is it flexible for the use cases? Is it

419
00:35:38,320 --> 00:35:44,160
simple enough to essentially learn once? So you have to keep in mind that your software will

420
00:35:44,160 --> 00:35:51,520
become a part of a larger system. Your only choice is whether it will be a well-behaved part of a

421
00:35:52,480 --> 00:35:59,680
larger system. The how can be a little elusive. So hopefully this example progression

422
00:36:00,400 --> 00:36:08,320
in improving a dummy API was helpful. It's a lot. All right. I understand. So if you only

423
00:36:08,320 --> 00:36:14,480
remember one thing from this talk, besides my awesome cheeky synthwave theme, is to remember

424
00:36:14,480 --> 00:36:22,320
this. If all else fails, standardize. So Don Varnon leaves us with a good catch-all.

425
00:36:22,320 --> 00:36:27,840
When no other solution appears possible, then design everything the same way so people only

426
00:36:27,840 --> 00:36:32,720
have to learn once. All right. So that was all I had.

