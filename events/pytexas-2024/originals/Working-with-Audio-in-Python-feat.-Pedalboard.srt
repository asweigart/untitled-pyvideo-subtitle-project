1
00:00:00,000 --> 00:00:08,880
All right. Thank you, PyTexas. My name is Peter Sobot, and I'm here to talk to you today about

2
00:00:08,880 --> 00:00:13,840
working with audio in Python. So first off, who am I and why am I up here talking to you?

3
00:00:13,840 --> 00:00:17,240
Well, I'm a staff machine learning engineer, and I work at Spotify in what's called their

4
00:00:17,240 --> 00:00:22,000
audio intelligence lab. That's a machine learning research team that uses machine learning to

5
00:00:22,000 --> 00:00:26,220
try and build systems that understand music and understand audio. We use a lot of Python

6
00:00:26,220 --> 00:00:29,820
day-to-day, which is why I'm here talking about Python, and we also build a lot of stuff that

7
00:00:29,820 --> 00:00:33,620
ends up in the Spotify app itself. So if you're a user, thank you. You've probably seen our work.

8
00:00:33,620 --> 00:00:38,980
If you're curious about other stuff we do, though, we publish APIs such as this one that

9
00:00:38,980 --> 00:00:43,140
allows you to find out the tempo and the key and the beats and all sorts of stuff like that about

10
00:00:43,140 --> 00:00:47,540
every song that you might hear on Spotify. But we also publish machine learning models. We publish

11
00:00:47,540 --> 00:00:52,900
open source software like this called Basic Pitch. Basic Pitch here is an automatic transcription

12
00:00:52,900 --> 00:00:57,620
model. So you can put music or an audio signal in, and you can get notes out the other end. So it'll

13
00:00:57,620 --> 00:01:02,180
tell you which notes were played in a specific piece of music. Super cool, totally open source,

14
00:01:02,180 --> 00:01:06,500
totally free to use, runs in the browser, runs in Python, wherever you want. Find that on GitHub.

15
00:01:06,500 --> 00:01:13,220
But also, and more related to Python for today, we build audio software like this. This is Petalboard.

16
00:01:13,220 --> 00:01:17,180
You can find this on GitHub. It's a Python library for working with audio, and we'll be touching on

17
00:01:17,180 --> 00:01:22,500
this later on in the talk. But first off, this is Pi Texas, not Audio Texas. So I'm going to set

18
00:01:22,500 --> 00:01:27,500
some kind of ground rules to start with. I'll talk about how digital audio works to begin with.

19
00:01:27,500 --> 00:01:31,940
Then once I've done that, I'll talk about how to read and edit audio in Python, how you can use

20
00:01:31,940 --> 00:01:36,300
audio in your own Python code. Then I'll talk about different problems you might run into working

21
00:01:36,300 --> 00:01:41,020
with audio in Python, gotchas or, you know, issues that you won't find out until it's four in the

22
00:01:41,020 --> 00:01:45,220
morning and you just got paged. And then I'll finally talk about how to make your audio code

23
00:01:45,220 --> 00:01:49,940
simpler by using Petalboard, that library I just talked about. So let's start at the very top. I'm

24
00:01:49,940 --> 00:01:53,420
going to assume that you know nothing about audio whatsoever, and we'll talk about how digital audio

25
00:01:53,420 --> 00:01:58,020
works to begin with. Audio is really just a recording of sound, and sound is what you're hearing

26
00:01:58,020 --> 00:02:03,540
right now, I hope. And so to get that sound from the air around us into a computer, we're going to

27
00:02:03,540 --> 00:02:07,220
have to measure it in some way. So I'm going to put a two-dimensional graph on the screen here,

28
00:02:07,220 --> 00:02:11,740
and along the x-axis, we'll have time in seconds, and on the y-axis, we'll have pressure in the air.

29
00:02:11,740 --> 00:02:15,580
The pressure can move back and forth. You can have no pressure. You get a pressure coming towards

30
00:02:15,580 --> 00:02:19,020
you or going away from you. It doesn't matter too much. But I'm going to play a sound here,

31
00:02:19,020 --> 00:02:29,980
and we'll see how the pressure changes on this graph. Cool. So we just measured a whole bunch of

32
00:02:29,980 --> 00:02:33,580
points on this graph here. Each of them doesn't really have much meaning on its own. We can't

33
00:02:33,580 --> 00:02:38,220
tell what's going on without looking them all together. But what we can do is measure both where

34
00:02:38,220 --> 00:02:43,260
they are on the x position and on the y position. On the x position here, we can see that we measured

35
00:02:43,260 --> 00:02:48,540
one point roughly every 0.4 seconds or so. If I take the reciprocal of that, that gives us a rate

36
00:02:48,700 --> 00:02:53,340
of 2.5 points per second, and we can call that our sample rate. That's going to be super important

37
00:02:53,340 --> 00:02:57,100
later on. This is how we can tell how fast these points came in, and if we want to play them back

38
00:02:57,100 --> 00:03:01,580
through a speaker again, we need to know that number. Also, you might notice that these are

39
00:03:01,580 --> 00:03:06,380
spaced evenly around some middle point, and that's actually the silence point or the zero point on

40
00:03:06,380 --> 00:03:10,540
this graph. And that's because, like I mentioned before, pressure can come towards you or move away

41
00:03:10,540 --> 00:03:14,780
from you. And so maximum loudness or maximum pressure is actually at the top and bottom of

42
00:03:14,780 --> 00:03:18,860
this graph, and that's how we can read this. And then we can just measure each of these points.

43
00:03:18,860 --> 00:03:24,060
So on the left here, this point is maybe 60% amplitude or 60% of the maximum in the positive

44
00:03:24,060 --> 00:03:30,940
direction, so we could give it 0.60 there. And this point here is negative, sorry, 90% amplitude in

45
00:03:30,940 --> 00:03:36,220
the negative direction, so we'd give it a value of negative 0.90. So I could join all these points

46
00:03:36,220 --> 00:03:40,140
together and try to reconstruct that original sound that we just heard of that saxophone,

47
00:03:40,140 --> 00:03:44,380
but you might notice there's not really that much detail here. We can't tell much from these

48
00:03:44,380 --> 00:03:48,540
10 or 12 points, and that's because we didn't sample often enough. So let's try sampling the

49
00:03:48,540 --> 00:03:53,020
signal again, recording it again off the microphone, but this time I'm going to sample at a rate of

50
00:03:53,980 --> 00:03:59,820
44,100 points per second, or 44,000 kilohertz, or sorry, 44.1 kilohertz, and that's actually the

51
00:03:59,820 --> 00:04:03,100
rate that most digital audio systems use today. And let's see what the difference looks like.

52
00:04:09,660 --> 00:04:12,620
So we've got a lot more data there, and we can already tell that visually because there's so

53
00:04:12,620 --> 00:04:18,060
much more detail in this waveform here. I can zoom in, and we can go from kind of the grand scale

54
00:04:18,060 --> 00:04:22,540
where we see multiple seconds at once all the way down to the millisecond range, and at this range

55
00:04:22,540 --> 00:04:26,380
we're actually going to be able to see the individual waveform, or sorry, the individual

56
00:04:26,380 --> 00:04:29,980
waves that make up the waveform here. If we were to measure the distance between these peaks,

57
00:04:29,980 --> 00:04:33,340
that would actually give us the pitch or the frequency, but I don't want to stop there. I

58
00:04:33,340 --> 00:04:37,740
want to keep going even further down to see exactly what the computer saw. And so we're

59
00:04:37,740 --> 00:04:42,140
going to go down to the microsecond level between each of these points here. We're actually looking

60
00:04:42,220 --> 00:04:47,180
at only 22 microseconds of time, which is a very, very, very small amount. And what the computer did

61
00:04:47,180 --> 00:04:52,700
here is that it measured the amplitude, or it measured the pressure at each of these 22 microsecond

62
00:04:52,700 --> 00:04:58,460
samples here. And so if we take just those numbers, well, that's really the secret. That's digital

63
00:04:58,460 --> 00:05:03,740
audio. That's all there is to it. Digital audio is just streams of numbers, plus also that sample

64
00:05:03,740 --> 00:05:09,100
rate I mentioned earlier. So we've got some digital audio. We recorded this off a microphone.

65
00:05:09,100 --> 00:05:13,500
Technically, this is part of a saxophone clip. That's great. What can we do with it? Well,

66
00:05:13,500 --> 00:05:18,620
we could save these numbers on disk, and we could save them as regular uncompressed floating point

67
00:05:18,620 --> 00:05:22,860
information if we wanted to. We could use NumPy and Python to save these if we wanted to, and that'd

68
00:05:22,860 --> 00:05:27,660
be great. But that would cost us a lot of data. That would be about 21 megabytes per minute of

69
00:05:27,660 --> 00:05:31,980
audio, which doesn't sound like a huge amount if you have a laptop that has a lot of storage on it.

70
00:05:31,980 --> 00:05:36,140
But if we're talking about streaming music to your phone, 21 megabytes per minute is a lot.

71
00:05:36,780 --> 00:05:41,660
So instead, back in the 1990s, some extremely smart people came up with compression algorithms,

72
00:05:41,660 --> 00:05:46,940
and you might have heard of some of these before. Things like MP3 and AUG Vorbis and AAC and so on.

73
00:05:46,940 --> 00:05:51,100
And these compression algorithms throw away part of the signal. So instead of storing every single

74
00:05:51,100 --> 00:05:55,740
number in its full resolution, we're instead storing a compressed version of that. That is

75
00:05:55,740 --> 00:05:59,980
a little bit less high fidelity. It throws away stuff that our ears can't hear super well. But

76
00:05:59,980 --> 00:06:03,980
it gets our data rate down to less than one megabyte per minute in many cases. So that's how

77
00:06:03,980 --> 00:06:07,740
most audio is stored nowadays, and if we want to read that, we're going to have to use some

78
00:06:07,740 --> 00:06:13,340
sort of tool or some sort of library to decompress the audio for us. So let's start writing some

79
00:06:13,340 --> 00:06:17,900
Python. This is where I start to bring in actually Petalboard, which is the library I mentioned

80
00:06:17,900 --> 00:06:24,300
earlier. So let's at the very top do import audio file. Now, I don't want to talk too much

81
00:06:24,300 --> 00:06:27,660
about what Petalboard does just yet, but here we're just going to pull in a class that can

82
00:06:27,660 --> 00:06:32,540
read the audio off of the disk and decode it for us. So if you've ever opened a file in Python,

83
00:06:32,540 --> 00:06:37,580
you're probably aware of using a with statement and the open constructor or the open function.

84
00:06:37,580 --> 00:06:40,700
And here we're going to do the same thing, only we're going to use audio file instead.

85
00:06:40,700 --> 00:06:46,300
So I can say with audio file, myfavoritesong.mp3 has F, and I've just opened a file pointer that

86
00:06:46,300 --> 00:06:50,540
points into this file. Now, F has a couple properties on it that you won't find in a regular

87
00:06:50,540 --> 00:06:54,300
open file. For instance, you can find out the sample rate, which we talked about before,

88
00:06:54,300 --> 00:06:59,900
and see that this audio is recorded at 44,100 samples per second. We can also find the number

89
00:06:59,900 --> 00:07:03,500
of channels that are available in the audio file. In this case, it's a two-channel audio file. It's

90
00:07:03,500 --> 00:07:08,700
in stereo, and that's because we have two ears. Usually we record in stereo. And just like a

91
00:07:08,700 --> 00:07:13,420
regular open file, we can do F.read on this file. And here we're going to ask for three samples,

92
00:07:13,420 --> 00:07:17,980
rather than three characters or three bytes, and we end up getting a multidimensional array back.

93
00:07:17,980 --> 00:07:21,660
Now, if you're not familiar with multidimensional arrays, that's totally okay. They just look like

94
00:07:21,660 --> 00:07:26,460
this. You can think of them like lists of lists of numbers. And the only property that's important

95
00:07:26,460 --> 00:07:29,580
is that the inner lists all have to be the same shape or the same length.

96
00:07:30,380 --> 00:07:34,620
So here, because we have two channels, we have a multidimensional array of two dimensions.

97
00:07:34,620 --> 00:07:37,980
The first is the number of channels, and that's two. And the second is the number of samples,

98
00:07:37,980 --> 00:07:42,380
and that's three. So here we have the left channel up top and the right channel at the bottom.

99
00:07:42,380 --> 00:07:46,380
So we'll touch up on this again in a second. If it doesn't make sense yet, don't worry about that.

100
00:07:47,740 --> 00:07:52,380
Okay. So let's try to do some more complex slicing and reading of the audio here.

101
00:07:53,260 --> 00:07:57,420
Let's start by opening up the file again, and then we'll read the entire thing in. Instead of

102
00:07:57,420 --> 00:08:01,340
just reading three samples, we'll read all of the samples in the entire file. And again,

103
00:08:01,340 --> 00:08:05,740
we end up with a multidimensional array. The first dimension is the number of channels, which is two,

104
00:08:05,740 --> 00:08:10,460
and the second is the number of samples, which here is 1.3 million, which sounds like a lot,

105
00:08:10,460 --> 00:08:13,900
but if you divide that by the sample rate, that's really only 30 seconds worth of audio.

106
00:08:13,900 --> 00:08:19,180
So it's not that much. Then we can use standard Python array slicing tricks here. We could do

107
00:08:19,180 --> 00:08:22,940
audio at zero to give us the left channel and audio at one to give us the right channel.

108
00:08:23,580 --> 00:08:27,580
We can also do multidimensional array slicing like this. So we can pass an empty slice for

109
00:08:27,580 --> 00:08:32,060
the first dimension and then pass up to 100 samples for the second dimension, and that'll

110
00:08:32,060 --> 00:08:36,220
just chop the audio down to only 100 samples in both the left and right channels. And we're

111
00:08:36,220 --> 00:08:40,140
just dealing with NumPy arrays here. So if you're familiar with those, everything transfers to this.

112
00:08:41,340 --> 00:08:46,140
We can also work in units of seconds instead. So we can say audio in both channels up into

113
00:08:46,140 --> 00:08:50,460
10 seconds by multiplying 10 by F dot sample rate, and we get a buffer that just contains the first

114
00:08:50,460 --> 00:08:55,260
10 seconds. Standard Python slicing tricks apply, so we can do negative F dot sample rate times 10

115
00:08:55,260 --> 00:09:00,140
and so on, and everything just works as you'd expect. But just like a regular open file,

116
00:09:00,140 --> 00:09:03,420
why would you read the whole thing in if you only want part of it? Well, you can also deal

117
00:09:03,420 --> 00:09:07,580
with that here too. You can do F dot seek to move around the file pointer in the file,

118
00:09:07,580 --> 00:09:10,860
and then you can do F dot read just to read a certain section that you care about,

119
00:09:10,860 --> 00:09:13,820
and Petal Board will just avoid decoding the audio that you don't need.

120
00:09:14,460 --> 00:09:18,860
So that's how we can open these files and read from them and play around with the data inside.

121
00:09:18,860 --> 00:09:22,220
But now let's change how they sound. I'm going to delete all of this,

122
00:09:23,660 --> 00:09:27,580
and then we're going to try to add an effect to some of this audio. So here,

123
00:09:27,580 --> 00:09:31,020
still dealing with my favorite song, dot IP3, we'll read the whole thing. I'm just going to

124
00:09:31,020 --> 00:09:34,300
take one of the channels, so I'll just take the first channel, doesn't really matter which one it

125
00:09:34,300 --> 00:09:39,420
is, and let's add an echo effect or a delay effect to this audio. I'll define some parameters up

126
00:09:39,420 --> 00:09:44,780
front first. So we'll say delay in seconds is equal to 0.2. We'll add a delay here of one

127
00:09:44,780 --> 00:09:50,140
fifth of a second. And we'll also convert that from seconds into samples because we're indexing

128
00:09:50,140 --> 00:09:53,820
this array in units of samples rather than seconds. So this just makes it easier for us

129
00:09:53,820 --> 00:09:59,100
to do our math here. Then we'll set a volume parameter. This is how loud we want our echo

130
00:09:59,100 --> 00:10:04,380
to be. It'll be 75% of the original volume of the signal. Then we're going to loop through

131
00:10:04,380 --> 00:10:08,700
each of the samples here. So for every sample in our original array, we're going to do a little bit

132
00:10:08,700 --> 00:10:13,420
of calculation. I can explain this really quickly. We're just going to take the sample value at the

133
00:10:13,420 --> 00:10:18,700
current index, multiply it by the volume that we want, and then add it to the signal in the future

134
00:10:19,260 --> 00:10:23,340
moved forward by delayed samples. And if that doesn't make sense, that's okay because we're

135
00:10:23,340 --> 00:10:27,340
dealing with audio code, which means we can listen to it to find out if we did the audio

136
00:10:27,340 --> 00:10:32,220
code correctly or not. So here's two samples. The one on the left has not been run through our code,

137
00:10:32,220 --> 00:10:34,540
and the one on the right has. So let's take a listen to these.

138
00:10:38,620 --> 00:10:41,100
So that's before we run our code, and then here's after.

139
00:10:45,260 --> 00:10:48,940
You can hear that, right? That's definitely an echo effect. We've just added this kind of

140
00:10:48,940 --> 00:10:53,580
almost musical galloping kind of effect, and all we had to do was add the signal to itself here

141
00:10:53,580 --> 00:10:58,460
with these six lines of Python code. So it's not too complicated to add these effects,

142
00:10:58,460 --> 00:11:01,980
but let's try a different style of effect. Instead of a rhythmic effect, let's change

143
00:11:01,980 --> 00:11:05,900
the character of the sound itself. And in this case, I'm going to use a totally different sample

144
00:11:05,900 --> 00:11:10,540
as an example. Let's load up cool guitar dot wave here. I'm going to read just the left channel as

145
00:11:10,540 --> 00:11:15,580
well, and then let's set some other parameters here. Let's set a parameter called gain to 200.

146
00:11:15,580 --> 00:11:19,980
This will be some distortion that we want to add to the signal. Then let's set volume to 10%.

147
00:11:20,780 --> 00:11:23,980
This is just going to make sure that we don't blow out the speakers in this auditorium

148
00:11:23,980 --> 00:11:28,620
because distortion will make things a little bit louder. Then for every single sample in the

149
00:11:28,620 --> 00:11:33,260
audio file, we're going to apply a mathematical function here. This happens to be math dot tan

150
00:11:33,260 --> 00:11:37,260
H or the hyperbolic tangent function, but that doesn't matter too much. If you don't know what

151
00:11:37,260 --> 00:11:42,460
that means, I don't really either. That's fine. All I know that this does is it'll make the sound

152
00:11:42,460 --> 00:11:45,420
much more distorted. And so let's listen to a before and after here as well.

153
00:11:45,420 --> 00:12:00,460
So hopefully you could hear the difference there. What we did was really just multiply this signal

154
00:12:00,460 --> 00:12:05,660
by the distortion factor, put it into a function, and then reduce its volume. And that added a lot

155
00:12:05,660 --> 00:12:09,740
more aggression, a lot more overdrive to the signal. And all we had to do was write these five lines of

156
00:12:09,740 --> 00:12:14,700
Python code. Okay. So we've seen how to open audio files, how to edit them, how to manipulate

157
00:12:14,700 --> 00:12:18,300
them in Python. That's all pretty simple. But let's talk about some problems that you might

158
00:12:18,300 --> 00:12:22,220
run into when working with audio in your Python code. These are probably only going to bite you

159
00:12:22,220 --> 00:12:25,100
once your code has already been deployed and once you think everything is going well.

160
00:12:26,220 --> 00:12:32,060
So let's write a very quick five line application that can open up an audio file and make it louder

161
00:12:32,060 --> 00:12:37,820
and then save it back to disk again. So let's start by opening up my favorite song on IP3 again.

162
00:12:37,820 --> 00:12:41,660
And let's read the entire thing into memory here with audio equals f dot read, f dot frames.

163
00:12:42,540 --> 00:12:46,940
Then once that's done, we'll multiply every sample by two to make every sample louder,

164
00:12:46,940 --> 00:12:51,420
and the whole thing will come out sounding much more loud. That's it. And then we'll save back

165
00:12:51,420 --> 00:12:55,740
to disk again by opening up audio file again. We'll pass W as the second parameter, just like

166
00:12:55,740 --> 00:12:59,980
you would with a regular open call in Python. We'll pass in the sample rate, and then we'll do

167
00:12:59,980 --> 00:13:04,940
O dot write louder audio. Side note, this will encode in MP3 for us. So if you want to do MP3

168
00:13:04,940 --> 00:13:09,980
encoding in Python, those two lines will do that for you, no problem. And then you deploy this code

169
00:13:09,980 --> 00:13:14,300
and you send this to your users, and everybody uses it, and they're happy, and that's all great.

170
00:13:14,300 --> 00:13:19,340
But this code will probably crash eventually if you accept any user input or deal with audio files

171
00:13:19,340 --> 00:13:24,540
that you don't control or anything like that. And that's for one very simple reason. It's that MP3

172
00:13:24,540 --> 00:13:29,100
is a good compression codec. So are many other compression codecs. And if my favorite song on

173
00:13:29,100 --> 00:13:33,100
IP3 here is two hours long, then as soon as you're reading the entire thing, you're going to have to

174
00:13:33,100 --> 00:13:38,460
decompress that audio. And in this case, a two hour input clip is going to require 2.3 gigabytes

175
00:13:38,460 --> 00:13:42,620
worth of memory. And you would have no idea because all you're doing is opening the file and

176
00:13:42,620 --> 00:13:47,180
reading it in. So instead, we can write much more robust code by avoiding the need to read

177
00:13:47,180 --> 00:13:51,500
the whole thing into memory. And let's try doing that here. We can do that in only two extra lines

178
00:13:51,500 --> 00:13:56,220
of code. So I'll start by defining a chunk size. We're going to process the audio in chunks here

179
00:13:56,220 --> 00:14:00,620
because there's no need really to read the whole thing in at once. We'll open our input file,

180
00:14:00,620 --> 00:14:04,380
then we'll open our output file and keep them both open at the same time. So now we're able

181
00:14:04,380 --> 00:14:09,500
to read from the input, do some processing, and write to the output. Then as long as we have more

182
00:14:09,500 --> 00:14:15,260
input to read, so while f.tel is less than f.frames, we're going to read one chunk of the file,

183
00:14:15,260 --> 00:14:18,940
we're going to make it louder, and then we're going to write that to the output file. So this

184
00:14:18,940 --> 00:14:23,420
is seven lines of code instead of five lines. Those two extra lines, I mean, that's a penalty

185
00:14:23,420 --> 00:14:27,900
we're going to have to pay here. But the benefit is that we're never going to use more than four

186
00:14:27,900 --> 00:14:32,060
megabytes of memory. And that's because we're only ever reading in one chunk of audio at a time.

187
00:14:32,060 --> 00:14:36,620
So my favorite song could be a full collection of symphonies that's 12 hours long,

188
00:14:36,620 --> 00:14:41,500
and this code would process it just fine. So my takeaway for you here is you should always,

189
00:14:41,500 --> 00:14:47,580
always, always think of audio data as a stream. Audio is a stream. It's a representation of sound,

190
00:14:47,580 --> 00:14:52,540
and sound goes on over time, and time continues indefinitely. So you should always make sure that

191
00:14:52,540 --> 00:14:57,900
your audio code can handle any size of input. Okay. So that's a memory problem you might run

192
00:14:57,900 --> 00:15:01,260
into. Let's talk about a different problem, though. Let's talk about a performance problem.

193
00:15:02,060 --> 00:15:06,220
Here's that example that we used earlier to add distortion to a guitar signal. This sounded just

194
00:15:06,220 --> 00:15:11,020
fine. It actually ran pretty quickly. Everything went well. But let's time part of this code.

195
00:15:11,020 --> 00:15:14,860
In fact, let's time this hot loop here, where we're going through every single sample of the

196
00:15:14,860 --> 00:15:20,220
audio file and applying map.10h. If I time this on my MacBook here, we see that it takes eight

197
00:15:20,220 --> 00:15:25,420
seconds per minute of audio to process this audio. That's 7.5 times faster than just playing the

198
00:15:25,420 --> 00:15:30,780
audio in the first place. Or what we would say is it's 7.5 times real time. And that's great.

199
00:15:30,780 --> 00:15:34,540
Faster than real time is still really good. But if I were to rewrite this using something

200
00:15:34,540 --> 00:15:40,220
like NumPy, let's say, we'd find that NumPy performs a little bit better. And just writing

201
00:15:40,220 --> 00:15:46,140
it like this, almost the same exact code, this runs in 23 milliseconds per minute of audio.

202
00:15:46,140 --> 00:15:51,900
So let's do the math on that. We find that it's 338 times faster to use NumPy here instead of

203
00:15:51,900 --> 00:15:56,460
for loops. Which should be no surprise to anybody who's dealt with Python for a while. It turns out

204
00:15:56,460 --> 00:16:00,860
that Python code is very, very slow if you're doing repeated numeric operations like this.

205
00:16:00,860 --> 00:16:04,380
Of course. Because every line of Python you run has to invoke the interpreter,

206
00:16:04,380 --> 00:16:07,660
has to do a whole bunch of overhead that you don't really need if you're just doing the same

207
00:16:07,660 --> 00:16:12,780
operation on audio samples or doing math like this. So what I want you to take away from this

208
00:16:12,780 --> 00:16:18,140
is that for pure audio code, Python is slow. If you ever find yourself iterating sample by sample

209
00:16:18,140 --> 00:16:21,980
or operating on every individual data point here, you're probably doing something that's

210
00:16:21,980 --> 00:16:25,740
not going to scale and that will become a bottleneck in your code. Instead, you should

211
00:16:25,740 --> 00:16:29,420
find a way to outsource that computation to another library. Either something like NumPy

212
00:16:29,420 --> 00:16:35,100
that's very efficient or something much more specific built for audio like this one right here

213
00:16:35,100 --> 00:16:39,740
called pedal board which I happen to maintain and which does a lot of this stuff for us.

214
00:16:39,740 --> 00:16:43,980
So let's take a look at how this can simplify your audio code. Now a quick aside, though,

215
00:16:43,980 --> 00:16:47,740
if you're wondering why this is called pedal board, do we have any guitar players in the room?

216
00:16:47,740 --> 00:16:53,820
I see one. Okay. There's a lot of guitarists here. Do any of you guitarists have pedal boards?

217
00:16:53,820 --> 00:16:58,300
Yes? Okay. Good. A lot of people enthusiastic. Great. So for those who are not guitarists,

218
00:16:58,300 --> 00:17:03,020
let me show you what I'm talking about here. Pedal boards are tools used by guitarists to

219
00:17:03,020 --> 00:17:07,900
change how their guitar can sound. Each one of these little boxes here is a different effect pedal

220
00:17:07,900 --> 00:17:11,980
and these get chained together so you can say I want some distortion. I'm going to click on this

221
00:17:11,980 --> 00:17:16,540
with my foot. I want some chorus. I'm going to click on this with my foot. And you chain those

222
00:17:16,540 --> 00:17:20,620
together in different ways. And pedal board here is actually a library that was built originally

223
00:17:20,620 --> 00:17:24,700
to add audio effects to your audio. And so we called it pedal board. And it was a nice little

224
00:17:24,700 --> 00:17:29,660
metaphor. But let's take a look at what that looks like in Python code instead. So let's add an

225
00:17:29,660 --> 00:17:33,980
effect here using pedal board. Let's read in cool guitar.wav again. Even though I just told

226
00:17:33,980 --> 00:17:37,260
you in the last section never to read the whole file in, well, I'm going to do it because this is

227
00:17:37,260 --> 00:17:42,620
a demo. And here let's do from pedal board import reverb. Now reverb is an effect that makes your

228
00:17:42,620 --> 00:17:46,300
audio sound like it was played in a larger space. You're kind of hearing some reverb right now in

229
00:17:46,300 --> 00:17:51,740
this room. But you'll hear even more in just a second. So I can do reverb equals capital R

230
00:17:51,740 --> 00:17:56,860
reverb here to create a new instance of this class. I'll set the room size to 75%. And then

231
00:17:56,860 --> 00:18:01,420
I'll pass this audio into the reverb plugin by just calling it like a function. So reverb,

232
00:18:01,420 --> 00:18:04,940
pass in audio, pass in the sample rate. And now I've just applied the reverb effect.

233
00:18:05,500 --> 00:18:08,780
So let's listen again to a before and an after here. Here's the before.

234
00:18:09,340 --> 00:18:14,780
And here's after that effect.

235
00:18:20,460 --> 00:18:24,140
Hopefully you can hear that. That's definitely a different sound. It sounds like we played that

236
00:18:24,140 --> 00:18:29,020
same clip in a big boomy cavern. And all we needed to do there was really apply three lines

237
00:18:29,020 --> 00:18:33,580
of Python code. But it doesn't really stop there. It's rare that you want to apply a single effect

238
00:18:33,580 --> 00:18:36,940
to your audio. It's much more common that you need to apply multiple effects or you want to

239
00:18:36,940 --> 00:18:40,540
chain them together in some way just like those pedal boards I talked about earlier.

240
00:18:40,540 --> 00:18:45,820
So pedal board has a facility for that, excuse me. And all we need to do there is create a

241
00:18:45,820 --> 00:18:50,540
pedal board object and pass multiple plugins into it. So we'll start by adding a distortion plugin

242
00:18:50,540 --> 00:18:53,660
which is actually doing the same thing under the hood that we wrote in Python earlier.

243
00:18:54,380 --> 00:18:58,300
We can then add a delay plugin which does the same thing as we wrote in Python earlier.

244
00:18:58,300 --> 00:19:01,020
And then we'll add a reverb plugin which we just heard on the last slide.

245
00:19:01,820 --> 00:19:05,260
So with these three in order here, we're now able to apply the effect,

246
00:19:06,540 --> 00:19:10,860
all three of these effects to the same audio all in one fell swoop. And all we need to do

247
00:19:10,860 --> 00:19:15,100
is apply that to the audio by calling it like a function. And so we do that. And again,

248
00:19:15,100 --> 00:19:19,100
let's listen to the before and after. So here's the clean signal going into this function.

249
00:19:26,140 --> 00:19:30,060
And now with distortion and delay and reverb applied with these five lines of Python code.

250
00:19:31,020 --> 00:19:42,620
So that's definitely a very noticeable effect. It's a very musical effect. It has this huge

251
00:19:42,620 --> 00:19:46,940
wash of sound. And all we had to do was import these effects from pedal board and call them on

252
00:19:46,940 --> 00:19:52,460
the audio data that we read in from that file. So very simple to do. But it doesn't stop there.

253
00:19:53,020 --> 00:19:56,700
If you've ever dealt with audio software on your laptop or online or anything like that,

254
00:19:56,700 --> 00:19:59,900
you've probably noticed that there's this vibrant community out there. All these people

255
00:19:59,900 --> 00:20:04,220
that are building what are called plugins or VSTs or audio units that you can import into your

256
00:20:04,220 --> 00:20:08,220
software to change your sound or to create new sounds. And pedal board actually supports

257
00:20:08,220 --> 00:20:12,380
using all of those too. So let's load a third party plugin here that was not written in Python

258
00:20:12,380 --> 00:20:16,860
at all. I'll do from pedal board import load plugin. We're going to open up that clean guitar

259
00:20:16,860 --> 00:20:21,260
dot wave again. And then I'm going to load one of those plugins. I'll do plugin equals

260
00:20:21,260 --> 00:20:27,260
load plugin. This happens to be an open source guitar pedal emulation plugin. You can find this

261
00:20:27,260 --> 00:20:31,500
on GitHub. It's really, really nice. But it's also something that was designed to run in a

262
00:20:31,500 --> 00:20:36,860
digital audio workstation. It's not designed to run in the Python environment here. So it's

263
00:20:36,860 --> 00:20:42,140
got a UI. I can even do plugin dot show editor here and a window will pop up. And I'm able to

264
00:20:42,140 --> 00:20:46,700
use my mouse to go and click on each of these knobs and turn them around and set the parameters

265
00:20:46,700 --> 00:20:50,860
how I like them. But if I don't want to do that, that's okay. I can also set the values for each

266
00:20:50,860 --> 00:20:55,020
of those parameters in Python code itself. So here I can print out the value that already exists

267
00:20:55,580 --> 00:21:00,540
for plugin dot gain. I can set it to some new value. And I can also just pass audio into the

268
00:21:00,540 --> 00:21:05,020
plugin like I did before. So I do plugin, call it like a function. Send in the audio and send in

269
00:21:05,020 --> 00:21:09,900
the sample rate. And it's applied to the audio. So let's take a listen one more time to before

270
00:21:09,900 --> 00:21:14,380
and after for this plugin. And just to remind you, I didn't write any Python code here for this

271
00:21:14,380 --> 00:21:18,140
plugin. This is someone else's native code, probably written in C++ that I just downloaded

272
00:21:18,140 --> 00:21:26,940
from the internet and imported here with load plugin. So that's the clean signal. And then once

273
00:21:26,940 --> 00:21:36,060
we put it through the plugin, that actually sounds pretty good. And again, no DSP code had to be

274
00:21:36,060 --> 00:21:41,420
written in Python. This is someone else's code, which is great. Okay. One more thing I want to

275
00:21:41,420 --> 00:21:46,140
show off. In the past year, there's been a lot of improvements in Petalboard for doing things that

276
00:21:46,140 --> 00:21:50,780
are not just audio effects. For instance, now we can host instrument effects or instrument VSDs

277
00:21:50,780 --> 00:21:55,820
and instrument plugins. For those who know audio software, that's a very, very different paradigm.

278
00:21:55,820 --> 00:22:00,540
We're not just changing the audio. We're instead creating new audio by passing in MIDI notes and

279
00:22:00,540 --> 00:22:04,860
telling the computer what to play at what time. So let's see that in less than 10 lines of code

280
00:22:04,860 --> 00:22:09,740
here. Let's load a plugin here called magical 8-bit plug, which is an 8-bit synthesizer plugin

281
00:22:09,740 --> 00:22:14,940
that emulates the sounds of old Nintendo video games from the 80s. And I've just loaded that

282
00:22:14,940 --> 00:22:19,900
instrument. I can open its window again here by using show editor. And we can see, yes, that is

283
00:22:19,900 --> 00:22:24,780
a different plugin there. Then instead of passing audio in, I'm going to have to pass in a list of

284
00:22:24,780 --> 00:22:30,460
notes or messages. So here I'll do notes equals this list of MIDI notes. These correspond with C,

285
00:22:30,460 --> 00:22:37,340
E, G, B, you know, musical notes. And I'll change those into MIDI messages here. So I'll send on and

286
00:22:37,340 --> 00:22:40,940
off messages for each of those notes to say here's when you should start playing this note and here's

287
00:22:40,940 --> 00:22:45,820
when you should stop playing this note. Then I'll open up an audio file to write to and I'll render

288
00:22:45,820 --> 00:22:49,420
those notes by just passing them in like a function to the instrument and passing the output of that

289
00:22:49,420 --> 00:23:02,380
into F dot write. And here's what that sounds like. So we just invoked a third-party plugin. We didn't

290
00:23:02,380 --> 00:23:05,820
write any of that rendering code ourselves. And that was less than 10 lines of Python.

291
00:23:06,780 --> 00:23:11,580
Okay. So I've got about one minute left. So I'm going to spend that last minute on a bonus round

292
00:23:11,580 --> 00:23:15,580
here. Some advanced pedal board topics for anybody who is curious about audio or deals with it day

293
00:23:15,580 --> 00:23:19,260
to day. Some really cool things that you can do in pedal board that you might not have expected

294
00:23:19,260 --> 00:23:24,140
or might not have thought about. So so far in this talk, we've been opening audio files by using the

295
00:23:24,140 --> 00:23:28,700
audio file constructor here or the audio file function. And that's great. But it's very common

296
00:23:28,700 --> 00:23:32,860
for you to need to open an audio file and then read it in at a different sample rate than it was

297
00:23:32,860 --> 00:23:38,460
saved as. So instead of maybe 44,000 or sorry, 44 kilohertz, you might need to add 22 kilohertz

298
00:23:38,460 --> 00:23:43,020
or something like that. Well, pedal board lets you do that by just adding a little addition on

299
00:23:43,020 --> 00:23:47,180
the end of the call here. You can do dot resample two and it will give you a file pointer that

300
00:23:47,180 --> 00:23:51,420
behaves as if the file was saved with a different sample rate altogether. This is super useful. We

301
00:23:51,420 --> 00:23:55,260
use this all the time at Spotify. Extremely performant and extremely useful in production

302
00:23:55,260 --> 00:24:00,540
situations. On top of that, though, let's say you want to take some audio and time stretch it. You

303
00:24:00,540 --> 00:24:05,020
want to change how long it is or how fast or slow it is without changing its pitch or vice versa.

304
00:24:05,020 --> 00:24:08,460
You want to change its pitch, but you don't want to change how fast it's playing back. Well,

305
00:24:08,460 --> 00:24:12,220
all you need to do is from pedal board import time stretch, call this function with your audio,

306
00:24:12,220 --> 00:24:16,540
set the appropriate parameters, and you get the results there. Huge shout out to Chris Canham,

307
00:24:16,540 --> 00:24:20,220
a breakfast key for implementing the rubber band time stretcher that we use here. It sounds great.

308
00:24:21,020 --> 00:24:25,180
And one last thing, all of the functions you've seen so far have been talking to files on disk,

309
00:24:25,180 --> 00:24:29,340
but you can also pass in file-like objects here. So you can render to a bytes IO buffer,

310
00:24:29,340 --> 00:24:33,020
you can render to a network stream. Doesn't matter. It's all available right there in your

311
00:24:33,020 --> 00:24:37,580
audio file constructor. So I barely scratched the surface here. You can find it a lot more on

312
00:24:37,580 --> 00:24:42,620
GitHub at github.com slash Spotify slash pedal board. And I also have five minutes for questions,

313
00:24:42,620 --> 00:24:46,220
so please feel free to use the Slido to submit some questions and find me after the talk to

314
00:24:46,220 --> 00:24:49,580
grab some stickers of this cool pedal board logo. Thank you so much by Dexis.

315
00:24:49,820 --> 00:25:03,260
Awesome. Thank you, Peter. I'm intrigued. I'm not a guitar player, not a musician, but now

316
00:25:03,260 --> 00:25:07,820
I'm inspired. I've got a stack of questions, so let's walk through some of these while they're

317
00:25:07,820 --> 00:25:13,740
getting set up for the next talk. First question, can pedal board work on live audio like a real

318
00:25:13,740 --> 00:25:18,220
pedal board would? That's a very good question. So we got this question so much that I actually

319
00:25:18,220 --> 00:25:22,700
put together a new feature in pedal board that does allow you to use it on live audio,

320
00:25:22,700 --> 00:25:27,580
actually just for a demo last year. It is now merged in and you can use it with some restrictions.

321
00:25:27,580 --> 00:25:31,260
Look for the audio stream class online in the documentation if you want to use that.

322
00:25:31,260 --> 00:25:35,740
That's awesome. We're going to unplug you here. Okay. And if you want to grab the hand mic or

323
00:25:35,740 --> 00:25:45,420
pull that one out. Okay. So next question. Any reason, let me think about this. Is there any

324
00:25:45,420 --> 00:25:50,620
reason for a stream not to just always use a chunk size of one? That's a great question. So

325
00:25:50,620 --> 00:25:54,220
you could use a chunk size of one if you're processing audio like this. At that point,

326
00:25:54,220 --> 00:25:59,180
the overhead of reading each chunk starts to dominate the runtime. So a larger chunk size

327
00:25:59,180 --> 00:26:04,220
will allow you to be a bit faster, but it'll use more memory. So there's always a sweet spot in

328
00:26:04,220 --> 00:26:09,020
there between processing speed and memory use. Where do you find that sweet spot? Does it depend

329
00:26:09,020 --> 00:26:12,940
on sample rate, I guess? It depends on the sample rate, depends on the machine that you're using.

330
00:26:12,940 --> 00:26:17,260
If you've got lots and lots of memory like on the server, you'd choose tens of megabytes maybe

331
00:26:17,260 --> 00:26:21,260
for your buffer. If you're working in an embedded environment, maybe something much smaller than that.

332
00:26:21,260 --> 00:26:27,500
Gotcha. Makes sense. Next, why choose Pedalboard over like a traditional DAW like Audacity or

333
00:26:27,500 --> 00:26:33,100
Bandcamp? Yeah. Traditional DAWs are really great tools and they're very good at allowing you to

334
00:26:33,100 --> 00:26:38,780
work with audio visually. Pedalboard is much more scriptable and much more easy to get integrated

335
00:26:38,780 --> 00:26:44,780
into your own software. Okay, cool. Do you want to talk for a minute about the API design process

336
00:26:44,780 --> 00:26:49,900
for the package? And did it start as open source or did that come out later? Great question. So

337
00:26:49,900 --> 00:26:53,900
I'll tackle the second part first. Pedalboard was not open source to start with. It came from

338
00:26:53,900 --> 00:26:58,060
internal needs that we had at Spotify. And then we realized, oh, we built a tool here that many

339
00:26:58,060 --> 00:27:02,220
people could use and we kept adding more and more to it. But for the API design process,

340
00:27:03,180 --> 00:27:09,980
I really came up with a lot of ideas from what you saw in Lin Root's talk earlier about how to

341
00:27:09,980 --> 00:27:14,860
lean on familiarity when designing an API. So it tries to be as Pythonic as possible. And the idea

342
00:27:14,860 --> 00:27:18,780
is that if you know Python, all you need to do is swap out a couple of functions and everything

343
00:27:18,780 --> 00:27:23,020
behaves like you would expect. Yeah. I love the structure of opening it as a file and treating

344
00:27:23,020 --> 00:27:28,300
it like that normal file context. That's pretty smooth. You showed down sampling. Is it possible

345
00:27:28,300 --> 00:27:33,900
to upsample? It is also possible to upsample. If you do upsample, there's no additional detail

346
00:27:33,900 --> 00:27:39,260
that will be added to the sound, though. Fair enough. Last one that I think, Josh,

347
00:27:39,260 --> 00:27:49,820
were you about ready? Does it use FFmpeg internally? I like FFmpeg, actually. But it

348
00:27:49,820 --> 00:27:54,060
does not use FFmpeg at all internally. It's all completely compiled code. There are no external

349
00:27:54,060 --> 00:27:59,820
dependencies. You just pip install it and it works. Fair enough. You good? All right. Once

350
00:27:59,820 --> 00:28:02,220
again, thank you, Peter. Thank you.

